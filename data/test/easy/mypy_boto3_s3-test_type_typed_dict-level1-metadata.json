{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_type_typed_dict",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/type_annotations/test_type_typed_dict.py",
  "test_code": "from mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypedDictAttribute, TypeTypedDict\n\n\nclass TestTypedDictAttribute:\n    result: TypedDictAttribute\n\n    def setup_method(self) -> None:\n        self.result = TypedDictAttribute(\"test\", Type.DictStrAny, required=True)\n\n    def test_init(self) -> None:\n        assert self.result.name == \"test\"\n        assert self.result.is_required()\n\n    def test_render(self) -> None:\n        assert self.result.render() == '\"test\": Dict[str, Any]'\n\n    def test_mark_as_required(self) -> None:\n        self.result.required = False\n        assert not self.result.is_required()\n        self.result.mark_as_required()\n        assert self.result.is_required()\n\n\nclass TestTypeTypedDict:\n    result: TypeTypedDict\n\n    def setup_method(self) -> None:\n        self.result = TypeTypedDict(\n            \"MyDict\",\n            [\n                TypedDictAttribute(\"required\", Type.bool, required=True),\n                TypedDictAttribute(\"optional\", Type.str, required=False),\n            ],\n            \"documentation\",\n        )\n\n    def test_init(self) -> None:\n        assert self.result.name == \"MyDict\"\n        assert len(self.result.children) == 2\n        assert self.result.docstring == \"documentation\"\n\n    def test_render(self) -> None:\n        result = self.result.copy()\n        assert result.render() == \"MyDict\"\n        result.stringify()\n        assert result.render() == '\"MyDict\"'\n\n    def test_render_definition(self) -> None:\n        result = self.result.copy()\n        assert result.render_definition() == (\n            \"class MyDict(TypedDict):\\n    required: bool\\n    optional: NotRequired[str]\\n\"\n        )\n\n        typed_dict = TypeTypedDict(\n            \"MyDict\",\n            [\n                TypedDictAttribute(\"required\", Type.str, required=True),\n                TypedDictAttribute(\"Type\", Type.str, required=False),\n            ],\n        )\n        typed_dict.is_safe_as_class = False\n        assert (\n            typed_dict.render_definition()\n            == 'MyDict = TypedDict(\"MyDict\", {\"required\": str, \"Type\": NotRequired[str], })'\n        )\n\n    def test_get_import_records(self) -> None:\n        import_records = sorted(self.result.get_import_records())\n        assert len(import_records) == 1\n        assert import_records[0].render() == \"from .type_defs import MyDict\"\n\n    def test_get_types(self) -> None:\n        assert set(self.result.iterate_types()) == {self.result}\n\n    def test_add_attribute(self) -> None:\n        self.result.add_attribute(\"third\", Type.int, required=False)\n        assert len(self.result.children) == 3\n\n    def test_is_dict(self) -> None:\n        assert self.result.is_dict()\n\n    def test_has_optional(self) -> None:\n        assert self.result.has_optional()\n        assert not TypeTypedDict(\n            \"MyDict\",\n            [TypedDictAttribute(\"required\", Type.bool, required=True)],\n        ).has_optional()\n        assert TypeTypedDict(\n            \"MyDict\",\n            [TypedDictAttribute(\"optional\", Type.str, required=False)],\n        ).has_optional()\n        assert not TypeTypedDict(\"MyDict\", []).has_optional()\n\n    def test_has_required(self) -> None:\n        assert self.result.has_required()\n        assert TypeTypedDict(\n            \"MyDict\",\n            [TypedDictAttribute(\"required\", Type.bool, required=True)],\n        ).has_required()\n        assert not TypeTypedDict(\n            \"MyDict\",\n            [TypedDictAttribute(\"optional\", Type.str, required=False)],\n        ).has_required()\n        assert not TypeTypedDict(\"MyDict\", []).has_required()\n\n    def test_get_required(self) -> None:\n        assert len(self.result.get_required()) == 1\n        assert self.result.get_required()[0].name == \"required\"\n\n    def test_get_optional(self) -> None:\n        assert len(self.result.get_optional()) == 1\n        assert self.result.get_optional()[0].name == \"optional\"\n\n    def test_copy(self) -> None:\n        assert self.result.copy().name == self.result.name\n\n    def test_is_same(self) -> None:\n        assert self.result.is_same(\n            TypeTypedDict(\n                \"MyDict\",\n                [\n                    TypedDictAttribute(\"required\", Type.bool, required=True),\n                    TypedDictAttribute(\"optional\", Type.str, required=False),\n                ],\n            ),\n        )\n        assert not self.result.is_same(\n            TypeTypedDict(\n                \"MyDict\",\n                [\n                    TypedDictAttribute(\"required\", Type.bool, required=True),\n                    TypedDictAttribute(\"optional\", Type.float, required=False),\n                ],\n            ),\n        )\n\n    def test_get_children_types(self) -> None:\n        assert self.result.get_children_types() == {\n            Type.str,\n            # Type.NotRequired,\n            Type.bool,\n        }\n\n    def test_get_children_literals(self) -> None:\n        clone = self.result.copy()\n        assert len(clone.get_children_literals()) == 0\n        clone.add_attribute(\"literal\", TypeLiteral(\"test\", [\"asd\"]), required=True)\n        assert len(clone.get_children_literals()) == 1\n        assert len(clone.get_children_literals([\"other\"])) == 1\n        assert len(clone.get_children_literals([clone.name])) == 0\n\n    def test_stringify(self) -> None:\n        result = self.result.copy()\n        assert not result.is_stringified()\n        result.stringify()\n        assert result.is_stringified()\n\n    def test_replace_self_references(self) -> None:\n        typed_dict = TypeTypedDict(\n            \"MyDict\",\n            [\n                TypedDictAttribute(\"required\", Type.str, required=True),\n            ],\n        )\n        typed_dict.is_safe_as_class = False\n        typed_dict.add_attribute(\"self_one\", typed_dict, required=True)\n        typed_dict.add_attribute(\"Type\", typed_dict, required=False)\n        assert typed_dict.replace_self_references(Type.DictStrAny)\n        assert typed_dict.render_definition() == (\n            'MyDict = TypedDict(\"MyDict\",'\n            ' {\"required\": str, \"self_one\": Dict[str, Any],'\n            ' \"Type\": NotRequired[Dict[str, Any]], })'\n        )\n        assert not self.result.replace_self_references(Type.DictStrAny)\n",
  "GT_file_code": {
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": "\"\"\"\nWrapper for `typing/typing_extensions.TypedDict` type annotations.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypedDictAttribute:\n    \"\"\"\n    TypedDict attribute wrapper.\n\n    Arguments:\n        name -- Attribute name.\n        type_annotation -- Attribute type annotation.\n        required -- Whether the attribute has to be set.\n    \"\"\"\n\n    def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        self.name = name\n        self.required = required\n        self.type_annotation = type_annotation\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name, required and type annotation.\n        \"\"\"\n        return hash((self.name, self.required, self.type_annotation.get_sort_key()))\n\n    def get_type_annotation(self) -> FakeAnnotation:\n        \"\"\"\n        Get wrapped for non-required type annotation or raw type annotation.\n        \"\"\"\n        if self.is_required():\n            return self.type_annotation\n\n        return TypeSubscript(Type.NotRequired, [self.type_annotation])\n\n    def render(self) -> str:\n        \"\"\"\n        Render attribute to use in function-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'\"{self.name}\": {self.get_type_annotation().render()}'\n\n    def render_attribute(self) -> str:\n        \"\"\"\n        Render attribute to use in class-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f\"{self.name}: {self.get_type_annotation().render()}\"\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Itera over type annotations.\n        \"\"\"\n        yield from self.type_annotation.iterate_types()\n\n    def is_required(self) -> bool:\n        \"\"\"\n        Whether argument is required.\n        \"\"\"\n        return self.required\n\n    def mark_as_required(self) -> None:\n        \"\"\"\n        Mark attribute as required.\n        \"\"\"\n        self.required = True\n\n\nclass TypeTypedDict(TypeParent, TypeDefSortable):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.TypedDict` type annotations.\n\n    Arguments:\n        name -- Type name.\n        children -- Typed dict attributes.\n        docstring -- Docstring for render.\n        stringify -- Convert type annotation to string to avoid circular deps.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        children: Iterable[TypedDictAttribute] = (),\n        docstring: str = \"\",\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.name = name\n        self.children = list(children)\n        self.docstring = docstring\n        self._stringify = stringify\n        self.is_safe_as_class = True\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether TypedDict usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render TypedDict usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort Typed Dicts by name.\n        \"\"\"\n        return self.name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name and children.\n        \"\"\"\n        return hash((self.name, *self.children))\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.is_stringified():\n            return f'\"{self.name}\"'\n\n        return self.name\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        template = (\n            Path(\"common/typed_dict_class.py.jinja2\")\n            if self.is_safe_as_class\n            else Path(\"common/typed_dict.py.jinja2\")\n        )\n        return render_jinja2_template(template, {\"type_def\": self})\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using TypedDict.\n        \"\"\"\n        result = Type.TypedDict.get_import_records()\n        for child in self.iterate_children():\n            result.update(child.get_type_annotation().get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"\n        Add new attribute to a dictionary.\n\n        Arguments:\n            name -- Argument name.\n            type_annotation -- Argument type annotation.\n            required -- Whether argument has to be set.\n        \"\"\"\n        self.children.append(TypedDictAttribute(name, type_annotation, required=required))\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return True\n\n    def has_optional(self) -> bool:\n        \"\"\"\n        Whether TypedDict has optional keys.\n        \"\"\"\n        return any(not child.is_required() for child in self.children)\n\n    def has_required(self) -> bool:\n        \"\"\"\n        Whether TypedDict has required keys.\n        \"\"\"\n        return any(child.is_required() for child in self.children)\n\n    def get_required(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of required attributes.\n        \"\"\"\n        return tuple(child for child in self.children if child.is_required())\n\n    def get_optional(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of optional attributes.\n        \"\"\"\n        return tuple(child for child in self.children if not child.is_required())\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            self.name,\n            list(self.children),\n            docstring=self.docstring,\n            stringify=self.is_stringified(),\n        )\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check whether typed dict attributes are the same as `other`.\n        \"\"\"\n        return hash(self) == hash(other)\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        for child in self.children:\n            yield child.type_annotation\n\n    def get_children_literals(self, processed: Iterable[str] = ()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def iterate_children(self) -> Iterator[TypedDictAttribute]:\n        \"\"\"\n        Iterate over children from required to optional.\n        \"\"\"\n        yield from self.get_required()\n        yield from self.get_optional()\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [\n            child.type_annotation\n            for child in self.children\n            if child.type_annotation.get_local_types()\n        ]\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return True\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        children_types = [i.type_annotation for i in self.children]\n        if child not in children_types:\n            raise TypeAnnotationError(f\"Child not found: {child}\")\n\n        indices = [i for i, x in enumerate(children_types) if x == child]\n        for index in indices:\n            self.children[index].type_annotation = new_child\n\n        return self\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n",
    "mypy_boto3_builder/type_annotations/type_parent.py": "\"\"\"\nProtocol for types with children.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\n\n\nclass TypeParent(FakeAnnotation, ABC):\n    \"\"\"\n    Protocol for types with children.\n    \"\"\"\n\n    @abstractmethod\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children type annotations.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        ...\n\n    def find_type_annotation_parents(\n        self,\n        type_annotation: FakeAnnotation,\n        skip: Iterable[FakeAnnotation] = (),\n    ) -> \"set[TypeParent]\":\n        \"\"\"\n        Check recursively if child is present in type def.\n        \"\"\"\n        result: set[TypeParent] = set()\n        for child_type in self.iterate_children_type_annotations():\n            if child_type == type_annotation:\n                result.add(self)\n            if not isinstance(child_type, TypeParent):\n                continue\n\n            if child_type in skip:\n                continue\n\n            parents = child_type.find_type_annotation_parents(\n                type_annotation,\n                skip={*skip, child_type},\n            )\n            result.update(parents)\n\n        return result\n\n    def replace_self_references(self, replacement: FakeAnnotation) -> \"set[TypeParent]\":\n        \"\"\"\n        Replace self references with a new type annotation to avoid recursion.\n        \"\"\"\n        \"\"\"\n        Replace self references with a new type annotation to avoid recursion.\n        \"\"\"\n        parents = self.find_type_annotation_parents(self)\n        for parent in parents:\n            parent.replace_child(self, replacement)\n        return parents\n\n    def get_sortable_children(self) -> list[TypeDefSortable]:\n        \"\"\"\n        Extract required TypeDefSortable list from attributes.\n        \"\"\"\n        result: list[TypeDefSortable] = []\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if not isinstance(type_annotation, TypeDefSortable):\n                continue\n            result.append(type_annotation)\n\n        return result\n",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def __init__(self, name: str, children: Iterable[str]) -> None:\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError(\"Literal should have children\")\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.inline:\n            children = \", \".join([repr(i) for i in sorted(self.children)])\n            return f\"Literal[{children}]\"\n\n        return self.name\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation(\"Literal\").get_import_records()\n\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation(\"Literal\").get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError(\"Use add_literal_child function.\")\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path(\"common/literal.py.jinja2\"), {\"literal\": self})\n",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        min_version: tuple[int, ...] | None = None,\n        fallback: Self | None = None,\n    ) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f\"ImportRecord {self} has no name\")\n\n        if self.alias:\n            return f\"{self.name} as {self.alias}\"\n\n        return self.name\n\n    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f\"from {self.source} import {self.render_name()}\"\n        if self.alias:\n            return f\"import {self.source} as {self.alias}\"\n\n        return f\"import {self.source}\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash(\n            (\n                self.source,\n                self.name,\n                self.alias,\n                self.min_version,\n                self.fallback,\n            ),\n        )\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n\n        if self.source != other.source:\n            return self.source > other.source\n\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
      "TypedDictAttribute.__init__": {
        "code": "    def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"Initializes a `TypedDictAttribute` instance, which represents an attribute in a TypedDict with a specific type annotation and optional requirement status.\n\nParameters:\n- `name` (str): The name of the attribute.\n- `type_annotation` (FakeAnnotation): The type annotation associated with the attribute, which specifies the expected data type.\n- `required` (bool): Indicates whether the attribute is mandatory in the TypedDict.\n\nThis constructor does not return any value and creates an instance that holds the attribute name, its type annotation, and whether it is required. The `type_annotation` parameter must be an instance of `FakeAnnotation`, which is used throughout the code to define various types and supports rendering and iteration.\"\"\"\n        self.name = name\n        self.required = required\n        self.type_annotation = type_annotation",
        "docstring": "Initializes a `TypedDictAttribute` instance, which represents an attribute in a TypedDict with a specific type annotation and optional requirement status.\n\nParameters:\n- `name` (str): The name of the attribute.\n- `type_annotation` (FakeAnnotation): The type annotation associated with the attribute, which specifies the expected data type.\n- `required` (bool): Indicates whether the attribute is mandatory in the TypedDict.\n\nThis constructor does not return any value and creates an instance that holds the attribute name, its type annotation, and whether it is required. The `type_annotation` parameter must be an instance of `FakeAnnotation`, which is used throughout the code to define various types and supports rendering and iteration.",
        "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:",
        "type": "Method",
        "class_signature": "class TypedDictAttribute:"
      },
      "TypedDictAttribute.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the attribute of a `TypedDictAttribute` to a string format suitable for function-based TypedDict definitions.\n\nThis method constructs a string representation of the attribute in the format `\"<name>\": <type_annotation>`, where `<name>` is the name of the attribute and `<type_annotation>` is derived from the result of the `get_type_annotation().render()` method. The `get_type_annotation()` function determines the appropriate type annotation, which could be either a raw type or a wrapped type if the attribute is optional.\n\nReturns:\n    str: A formatted string containing the attribute definition, ready for inclusion in a TypedDict.\n\nDependencies:\n    - `self.name`: The name of the attribute as a string.\n    - `self.get_type_annotation()`: A method that returns the appropriate type annotation (an instance of `FakeAnnotation`) used to render the type in the output string.\"\"\"\n        '\\n        Render attribute to use in function-based TypedDict definition.\\n\\n        Returns:\\n            A string with argument definition.\\n        '\n        return f'\"{self.name}\": {self.get_type_annotation().render()}'",
        "docstring": "Render the attribute of a `TypedDictAttribute` to a string format suitable for function-based TypedDict definitions.\n\nThis method constructs a string representation of the attribute in the format `\"<name>\": <type_annotation>`, where `<name>` is the name of the attribute and `<type_annotation>` is derived from the result of the `get_type_annotation().render()` method. The `get_type_annotation()` function determines the appropriate type annotation, which could be either a raw type or a wrapped type if the attribute is optional.\n\nReturns:\n    str: A formatted string containing the attribute definition, ready for inclusion in a TypedDict.\n\nDependencies:\n    - `self.name`: The name of the attribute as a string.\n    - `self.get_type_annotation()`: A method that returns the appropriate type annotation (an instance of `FakeAnnotation`) used to render the type in the output string.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypedDictAttribute:"
      },
      "TypedDictAttribute.is_required": {
        "code": "    def is_required(self) -> bool:\n        \"\"\"Determine if the attribute wrapped by the `TypedDictAttribute` instance is required. This method checks the `required` attribute of the instance, which is set during initialization. If `True`, it indicates that the attribute must be included in a `TypedDict`, while `False` denotes that the attribute is optional. The `required` attribute directly controls the expected structure of the `TypedDict` instances that utilize this attribute.\"\"\"\n        '\\n        Whether argument is required.\\n        '\n        return self.required",
        "docstring": "Determine if the attribute wrapped by the `TypedDictAttribute` instance is required. This method checks the `required` attribute of the instance, which is set during initialization. If `True`, it indicates that the attribute must be included in a `TypedDict`, while `False` denotes that the attribute is optional. The `required` attribute directly controls the expected structure of the `TypedDict` instances that utilize this attribute.",
        "signature": "def is_required(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypedDictAttribute:"
      },
      "TypedDictAttribute.mark_as_required": {
        "code": "    def mark_as_required(self) -> None:\n        \"\"\"Mark the attribute as required in the TypedDictAttribute.\n\nThis method sets the `required` attribute of the TypedDictAttribute instance to `True`, indicating that this attribute must be present when using the TypedDict. The `required` attribute is a boolean that influences how the TypedDict is rendered and validated.\n\nParameters:\n    None\n\nReturns:\n    None\n\nSide Effects:\n    This method modifies the internal state of the TypedDictAttribute instance by changing the value of the `required` attribute from `False` to `True`, if it was not already set.\"\"\"\n        '\\n        Mark attribute as required.\\n        '\n        self.required = True",
        "docstring": "Mark the attribute as required in the TypedDictAttribute.\n\nThis method sets the `required` attribute of the TypedDictAttribute instance to `True`, indicating that this attribute must be present when using the TypedDict. The `required` attribute is a boolean that influences how the TypedDict is rendered and validated.\n\nParameters:\n    None\n\nReturns:\n    None\n\nSide Effects:\n    This method modifies the internal state of the TypedDictAttribute instance by changing the value of the `required` attribute from `False` to `True`, if it was not already set.",
        "signature": "def mark_as_required(self) -> None:",
        "type": "Method",
        "class_signature": "class TypedDictAttribute:"
      },
      "TypeTypedDict.__init__": {
        "code": "    def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:\n        \"\"\"Initialize a TypeTypedDict instance, representing a TypedDict type annotation.\n\nParameters:\n- name (str): The name of the TypedDict type.\n- children (Iterable[TypedDictAttribute], optional): A collection of TypedDictAttribute instances defining the attributes of the TypedDict. Defaults to an empty iterable.\n- docstring (str, optional): A docstring for the TypedDict, providing documentation. Defaults to an empty string.\n- stringify (bool, optional): A flag indicating whether to render the TypedDict as a string. Defaults to False.\n\nAttributes:\n- self.name: Stores the name of the TypedDict.\n- self.children: A list of TypedDictAttribute instances.\n- self.docstring: Stores the provided docstring.\n- self._stringify: Indicates if the TypedDict should be represented as a string.\n- self.is_safe_as_class: A boolean flag set to True, suggesting that the TypedDict can be safely used as a class.\n\nThis constructor sets up an instance for further manipulation, allowing the addition of attributes and rendering for type annotations in type definitions.\"\"\"\n        self.name = name\n        self.children = list(children)\n        self.docstring = docstring\n        self._stringify = stringify\n        self.is_safe_as_class = True",
        "docstring": "Initialize a TypeTypedDict instance, representing a TypedDict type annotation.\n\nParameters:\n- name (str): The name of the TypedDict type.\n- children (Iterable[TypedDictAttribute], optional): A collection of TypedDictAttribute instances defining the attributes of the TypedDict. Defaults to an empty iterable.\n- docstring (str, optional): A docstring for the TypedDict, providing documentation. Defaults to an empty string.\n- stringify (bool, optional): A flag indicating whether to render the TypedDict as a string. Defaults to False.\n\nAttributes:\n- self.name: Stores the name of the TypedDict.\n- self.children: A list of TypedDictAttribute instances.\n- self.docstring: Stores the provided docstring.\n- self._stringify: Indicates if the TypedDict should be represented as a string.\n- self.is_safe_as_class: A boolean flag set to True, suggesting that the TypedDict can be safely used as a class.\n\nThis constructor sets up an instance for further manipulation, allowing the addition of attributes and rendering for type annotations in type definitions.",
        "signature": "def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.is_stringified": {
        "code": "    def is_stringified(self) -> bool:\n        \"\"\"Check if the TypedDict usage should be rendered as a string.\n\nThis method returns the value of the `_stringify` attribute, which indicates whether the TypedDict's representation should be output as a string rather than as its standard type form. This functionality is essential for controlling the rendering format, especially in scenarios requiring serialized representations.\n\nReturns:\n    bool: `True` if the TypedDict should be rendered as a string, otherwise `False`.\"\"\"\n        '\\n        Whether TypedDict usage should be rendered as a string.\\n        '\n        return self._stringify",
        "docstring": "Check if the TypedDict usage should be rendered as a string.\n\nThis method returns the value of the `_stringify` attribute, which indicates whether the TypedDict's representation should be output as a string rather than as its standard type form. This functionality is essential for controlling the rendering format, especially in scenarios requiring serialized representations.\n\nReturns:\n    bool: `True` if the TypedDict should be rendered as a string, otherwise `False`.",
        "signature": "def is_stringified(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.stringify": {
        "code": "    def stringify(self) -> None:\n        \"\"\"Mark the TypedDict as stringified, indicating that its usage should be rendered as a string in type annotations. This method modifies the internal state of the TypeTypedDict instance by setting the `_stringify` attribute to `True`. This attribute controls how the TypedDict is rendered in the `render` method, allowing it to be presented as a string rather than a type. No parameters are required, and the method does not return any value.\"\"\"\n        '\\n        Render TypedDict usage as a string.\\n        '\n        self._stringify = True",
        "docstring": "Mark the TypedDict as stringified, indicating that its usage should be rendered as a string in type annotations. This method modifies the internal state of the TypeTypedDict instance by setting the `_stringify` attribute to `True`. This attribute controls how the TypedDict is rendered in the `render` method, allowing it to be presented as a string rather than a type. No parameters are required, and the method does not return any value.",
        "signature": "def stringify(self) -> None:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value for a `TypeTypedDict` instance.\n\nThe hash is computed using the `name` attribute and the `children` attributes. This allows `TypeTypedDict` objects to be used in sets and as keys in dictionaries, enabling efficient membership tests and lookups. The `children` are expected to be instances of `TypedDictAttribute`, which also implement the `__hash__` method.\n\nReturns:\n    int: The computed hash value for the instance.\n\nDependencies:\n    - `self.name`: A string representing the type name of the `TypedDict`.\n    - `self.children`: A list of `TypedDictAttribute` instances, which are included in the hash calculation.\"\"\"\n        '\\n        Calculate hash value based on name and children.\\n        '\n        return hash((self.name, *self.children))",
        "docstring": "Calculate the hash value for a `TypeTypedDict` instance.\n\nThe hash is computed using the `name` attribute and the `children` attributes. This allows `TypeTypedDict` objects to be used in sets and as keys in dictionaries, enabling efficient membership tests and lookups. The `children` are expected to be instances of `TypedDictAttribute`, which also implement the `__hash__` method.\n\nReturns:\n    int: The computed hash value for the instance.\n\nDependencies:\n    - `self.name`: A string representing the type name of the `TypedDict`.\n    - `self.children`: A list of `TypedDictAttribute` instances, which are included in the hash calculation.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the type annotation of the `TypeTypedDict` instance to produce a valid Python code representation for local usage. \n\nThe method checks if the `TypedDict` should be rendered as a string by calling the `is_stringified()` method. If it returns `True`, the method returns the type name enclosed in quotes (e.g., '\"type_name\"'). If not, it returns the type name directly.\n\nReturns:\n    A string representing the type annotation, either as a quoted string or as the type name itself.\n\nDependencies:\n    - `self.name`: The name of the typed dictionary, used when rendering the output.\n    - `is_stringified()`: Method that determines the rendering format based on the state of the `TypeTypedDict` instance.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        if self.is_stringified():\n            return f'\"{self.name}\"'\n        return self.name",
        "docstring": "Render the type annotation of the `TypeTypedDict` instance to produce a valid Python code representation for local usage. \n\nThe method checks if the `TypedDict` should be rendered as a string by calling the `is_stringified()` method. If it returns `True`, the method returns the type name enclosed in quotes (e.g., '\"type_name\"'). If not, it returns the type name directly.\n\nReturns:\n    A string representing the type annotation, either as a quoted string or as the type name itself.\n\nDependencies:\n    - `self.name`: The name of the typed dictionary, used when rendering the output.\n    - `is_stringified()`: Method that determines the rendering format based on the state of the `TypeTypedDict` instance.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.render_definition": {
        "code": "    def render_definition(self) -> str:\n        \"\"\"Render the type annotation definition for the TypedDict.\n\nThis method generates a string representation of the type definition based on a Jinja2 template, selecting between two templates depending on the `is_safe_as_class` attribute. The `template` variable holds the path to the appropriate template file, either `common/typed_dict_class.py.jinja2` or `common/typed_dict.py.jinja2`. The rendered output incorporates the current instance of the `TypeTypedDict`, facilitating the creation of type definitions in a Pythonic format.\n\nReturns:\n    A string containing the complete type annotation definition for the TypedDict.\n\nDependencies:\n    - The method uses `render_jinja2_template`, which is expected to accept a template path and a context dictionary to generate the final output.\"\"\"\n        '\\n        Render type annotation definition.\\n        '\n        template = Path('common/typed_dict_class.py.jinja2') if self.is_safe_as_class else Path('common/typed_dict.py.jinja2')\n        return render_jinja2_template(template, {'type_def': self})",
        "docstring": "Render the type annotation definition for the TypedDict.\n\nThis method generates a string representation of the type definition based on a Jinja2 template, selecting between two templates depending on the `is_safe_as_class` attribute. The `template` variable holds the path to the appropriate template file, either `common/typed_dict_class.py.jinja2` or `common/typed_dict.py.jinja2`. The rendered output incorporates the current instance of the `TypeTypedDict`, facilitating the creation of type definitions in a Pythonic format.\n\nReturns:\n    A string containing the complete type annotation definition for the TypedDict.\n\nDependencies:\n    - The method uses `render_jinja2_template`, which is expected to accept a template path and a context dictionary to generate the final output.",
        "signature": "def render_definition(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.add_attribute": {
        "code": "    def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"Add a new attribute to the TypedDict.\n\nThis method appends a new TypedDictAttribute to the internal list of children,\nrepresenting an attribute of the TypedDict. The attribute includes a name,\ntype annotation, and a flag indicating if it is required.\n\nParameters:\n    name (str): The name of the attribute being added to the TypedDict.\n    type_annotation (FakeAnnotation): The type annotation for the attribute,\n        which describes the expected type of the attribute value.\n    required (bool): A flag indicating whether this attribute must be set\n        when creating an instance of the TypedDict.\n\nThis method interacts with the TypedDictAttribute class to manage individual\nattributes of the TypedDict, allowing for the flexible creation of type-safe\ndictionaries within the context of type definitions.\"\"\"\n        '\\n        Add new attribute to a dictionary.\\n\\n        Arguments:\\n            name -- Argument name.\\n            type_annotation -- Argument type annotation.\\n            required -- Whether argument has to be set.\\n        '\n        self.children.append(TypedDictAttribute(name, type_annotation, required=required))",
        "docstring": "Add a new attribute to the TypedDict.\n\nThis method appends a new TypedDictAttribute to the internal list of children,\nrepresenting an attribute of the TypedDict. The attribute includes a name,\ntype annotation, and a flag indicating if it is required.\n\nParameters:\n    name (str): The name of the attribute being added to the TypedDict.\n    type_annotation (FakeAnnotation): The type annotation for the attribute,\n        which describes the expected type of the attribute value.\n    required (bool): A flag indicating whether this attribute must be set\n        when creating an instance of the TypedDict.\n\nThis method interacts with the TypedDictAttribute class to manage individual\nattributes of the TypedDict, allowing for the flexible creation of type-safe\ndictionaries within the context of type definitions.",
        "signature": "def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.is_dict": {
        "code": "    def is_dict(self) -> bool:\n        \"\"\"Check if the type annotation represented by `TypeTypedDict` is a dictionary, specifically whether it is a `Dict` or a `TypedDict`. This method serves to confirm the nature of the type annotation encapsulated by instances of `TypeTypedDict`, facilitating type checks and ensuring proper handling of dict-like structures in type annotations. There are no input parameters. The method returns a boolean value, `True`, indicating that the annotation is always treated as a type of dictionary. This method does not depend on any external constants or variables.\"\"\"\n        '\\n        Whether type annotation is `Dict` or `TypedDict`.\\n        '\n        return True",
        "docstring": "Check if the type annotation represented by `TypeTypedDict` is a dictionary, specifically whether it is a `Dict` or a `TypedDict`. This method serves to confirm the nature of the type annotation encapsulated by instances of `TypeTypedDict`, facilitating type checks and ensuring proper handling of dict-like structures in type annotations. There are no input parameters. The method returns a boolean value, `True`, indicating that the annotation is always treated as a type of dictionary. This method does not depend on any external constants or variables.",
        "signature": "def is_dict(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.has_optional": {
        "code": "    def has_optional(self) -> bool:\n        \"\"\"Determine if the TypedDict contains any optional keys.\n\nThis method checks the attributes of the TypedDict instance to see if there are any that are not marked as required. It iterates through the `children` attribute, which is a list of `TypedDictAttribute` instances, and utilizes the `is_required` method of each child to ascertain if it is optional.\n\nReturns:\n    bool: True if there are optional keys present; otherwise, False.\n\nDependencies:\n    - `children`: An iterable of `TypedDictAttribute` instances, defined during the initialization of the `TypeTypedDict` class. Each `TypedDictAttribute` represents an attribute of the TypedDict, and its `is_required` method is used to determine if the attribute is optional.\"\"\"\n        '\\n        Whether TypedDict has optional keys.\\n        '\n        return any((not child.is_required() for child in self.children))",
        "docstring": "Determine if the TypedDict contains any optional keys.\n\nThis method checks the attributes of the TypedDict instance to see if there are any that are not marked as required. It iterates through the `children` attribute, which is a list of `TypedDictAttribute` instances, and utilizes the `is_required` method of each child to ascertain if it is optional.\n\nReturns:\n    bool: True if there are optional keys present; otherwise, False.\n\nDependencies:\n    - `children`: An iterable of `TypedDictAttribute` instances, defined during the initialization of the `TypeTypedDict` class. Each `TypedDictAttribute` represents an attribute of the TypedDict, and its `is_required` method is used to determine if the attribute is optional.",
        "signature": "def has_optional(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.has_required": {
        "code": "    def has_required(self) -> bool:\n        \"\"\"Check if the TypedDict contains any required keys.\n\nThis method iterates over the `children` attributes of the TypedDict, which are instances of the `TypedDictAttribute` class, and assesses whether any of them are marked as required using their `is_required` method. It returns `True` if at least one required attribute exists; otherwise, it returns `False`.\n\nReturns:\n    bool: True if there are required attributes, False otherwise.\n\nAttributes:\n    self.children: A list of `TypedDictAttribute` instances initialized in the constructor, representing the attributes of the TypedDict. Each `TypedDictAttribute` contains information about whether it is required or optional.\"\"\"\n        '\\n        Whether TypedDict has required keys.\\n        '\n        return any((child.is_required() for child in self.children))",
        "docstring": "Check if the TypedDict contains any required keys.\n\nThis method iterates over the `children` attributes of the TypedDict, which are instances of the `TypedDictAttribute` class, and assesses whether any of them are marked as required using their `is_required` method. It returns `True` if at least one required attribute exists; otherwise, it returns `False`.\n\nReturns:\n    bool: True if there are required attributes, False otherwise.\n\nAttributes:\n    self.children: A list of `TypedDictAttribute` instances initialized in the constructor, representing the attributes of the TypedDict. Each `TypedDictAttribute` contains information about whether it is required or optional.",
        "signature": "def has_required(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.get_required": {
        "code": "    def get_required(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"Get a tuple of required attributes from the TypedDict.\n\nThis method iterates through the `children` attribute, which is a list of `TypedDictAttribute` instances, to collect those attributes marked as required. An attribute is considered required if its `is_required` method returns `True`. The result is returned as a tuple to maintain the order of attributes as they were added.\n\nReturns:\n    tuple[TypedDictAttribute, ...]: A tuple containing the required `TypedDictAttribute` objects.\n\nDependencies:\n- `self.children`: A list of `TypedDictAttribute` instances that represent the attributes of the TypedDict. Each instance can indicate whether it is required or optional via the `is_required` method.\"\"\"\n        '\\n        Get a list of required attributes.\\n        '\n        return tuple((child for child in self.children if child.is_required()))",
        "docstring": "Get a tuple of required attributes from the TypedDict.\n\nThis method iterates through the `children` attribute, which is a list of `TypedDictAttribute` instances, to collect those attributes marked as required. An attribute is considered required if its `is_required` method returns `True`. The result is returned as a tuple to maintain the order of attributes as they were added.\n\nReturns:\n    tuple[TypedDictAttribute, ...]: A tuple containing the required `TypedDictAttribute` objects.\n\nDependencies:\n- `self.children`: A list of `TypedDictAttribute` instances that represent the attributes of the TypedDict. Each instance can indicate whether it is required or optional via the `is_required` method.",
        "signature": "def get_required(self) -> tuple[TypedDictAttribute, ...]:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.get_optional": {
        "code": "    def get_optional(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"Get a list of optional attributes from the TypedDict.\n\nThis method iterates over the children attributes and filters out those that are not marked as required, as determined by the `is_required` method of the `TypedDictAttribute` class. It returns a tuple of `TypedDictAttribute` instances that represent optional fields in the typed dictionary.\n\nReturns:\n    tuple[TypedDictAttribute, ...]: A tuple containing all optional attributes of the TypedDict.\n\nDependencies:\n    - `self.children`: A list of `TypedDictAttribute` instances, representing the children attributes of the TypedDict.\n    - `TypedDictAttribute.is_required`: A method used to check if each child attribute is required or optional.\"\"\"\n        '\\n        Get a list of optional attributes.\\n        '\n        return tuple((child for child in self.children if not child.is_required()))",
        "docstring": "Get a list of optional attributes from the TypedDict.\n\nThis method iterates over the children attributes and filters out those that are not marked as required, as determined by the `is_required` method of the `TypedDictAttribute` class. It returns a tuple of `TypedDictAttribute` instances that represent optional fields in the typed dictionary.\n\nReturns:\n    tuple[TypedDictAttribute, ...]: A tuple containing all optional attributes of the TypedDict.\n\nDependencies:\n    - `self.children`: A list of `TypedDictAttribute` instances, representing the children attributes of the TypedDict.\n    - `TypedDictAttribute.is_required`: A method used to check if each child attribute is required or optional.",
        "signature": "def get_optional(self) -> tuple[TypedDictAttribute, ...]:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.is_same": {
        "code": "    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"Check if the current TypedDict instance is the same as another TypedDict instance by comparing their hash values. This method takes another instance of TypeTypedDict as a parameter and returns a boolean indicating whether the two instances are equivalent.\n\nParameters:\n- other (Self): The other TypedDict instance to compare against.\n\nReturns:\n- bool: True if both TypedDict instances have the same attributes and types (i.e., produce the same hash), otherwise False.\n\nThis method relies on the __hash__ implementation of the TypeTypedDict class, which computes a hash based on the name and children attributes of the TypedDict.\"\"\"\n        '\\n        Check whether typed dict attributes are the same as `other`.\\n        '\n        return hash(self) == hash(other)",
        "docstring": "Check if the current TypedDict instance is the same as another TypedDict instance by comparing their hash values. This method takes another instance of TypeTypedDict as a parameter and returns a boolean indicating whether the two instances are equivalent.\n\nParameters:\n- other (Self): The other TypedDict instance to compare against.\n\nReturns:\n- bool: True if both TypedDict instances have the same attributes and types (i.e., produce the same hash), otherwise False.\n\nThis method relies on the __hash__ implementation of the TypeTypedDict class, which computes a hash based on the name and children attributes of the TypedDict.",
        "signature": "def is_same(self: Self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.get_children_types": {
        "code": "    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"Extracts the type annotations from the attributes of the TypedDict. This method iterates over each child attribute of the TypedDict, accumulating their type annotations by calling the `iterate_types()` method on each child. \n\nReturns:\n    A set of `FakeAnnotation` instances representing the collected type annotations from all child attributes.\n\nDependencies:\n    - `self.children`: A list of `TypedDictAttribute` instances, each representing an attribute of the TypedDict. The attributes can be required or optional and their type annotations are explored to provide a comprehensive set of types used within the dict.\"\"\"\n        '\\n        Extract required type annotations from attributes.\\n        '\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result",
        "docstring": "Extracts the type annotations from the attributes of the TypedDict. This method iterates over each child attribute of the TypedDict, accumulating their type annotations by calling the `iterate_types()` method on each child. \n\nReturns:\n    A set of `FakeAnnotation` instances representing the collected type annotations from all child attributes.\n\nDependencies:\n    - `self.children`: A list of `TypedDictAttribute` instances, each representing an attribute of the TypedDict. The attributes can be required or optional and their type annotations are explored to provide a comprehensive set of types used within the dict.",
        "signature": "def get_children_types(self) -> set[FakeAnnotation]:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      },
      "TypeTypedDict.get_children_literals": {
        "code": "    def get_children_literals(self, processed: Iterable[str]=()) -> set[TypeLiteral]:\n        \"\"\"Extracts the required `TypeLiteral` instances from the attributes of the `TypeTypedDict`. The method takes an optional parameter `processed`, which is an iterable of strings representing names already processed to prevent cyclic references. It returns a set of `TypeLiteral` objects found within the child attributes. If the `name` of the current `TypeTypedDict` is in `processed`, the method returns an empty set to avoid infinite recursion. It utilizes the `get_children_types` method to retrieve all types associated with the child attributes, and it further explores any `TypeDefSortable` types recursively to gather their `TypeLiteral` instances.\"\"\"\n        '\\n        Extract required TypeLiteral list from attributes.\\n        '\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result",
        "docstring": "Extracts the required `TypeLiteral` instances from the attributes of the `TypeTypedDict`. The method takes an optional parameter `processed`, which is an iterable of strings representing names already processed to prevent cyclic references. It returns a set of `TypeLiteral` objects found within the child attributes. If the `name` of the current `TypeTypedDict` is in `processed`, the method returns an empty set to avoid infinite recursion. It utilizes the `get_children_types` method to retrieve all types associated with the child attributes, and it further explores any `TypeDefSortable` types recursively to gather their `TypeLiteral` instances.",
        "signature": "def get_children_literals(self, processed: Iterable[str]=()) -> set[TypeLiteral]:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ExternalImport instance, based on its attributes.\n\nThis method uses a tuple containing the instance's `source`, `name`, `alias`, and `safe` attributes to compute a hash value. The resulting hash can be used for storing and comparing instances of ExternalImport in collections like sets or as dictionary keys. It ensures that instances with the same attributes have the same hash value, which is crucial for maintaining consistency in hashed collections.\n\nReturns:\n    int: The computed hash value for the ExternalImport instance.\n\nAttributes:\n    - `source`: An instance of ImportString, representing the module import string.\n    - `name`: A string representing the import name.\n    - `alias`: A string for the local name of the import.\n    - `safe`: A boolean indicating whether the import is wrapped in a try-except block.\"\"\"\n        '\\n        Calcualte hash value based on import record.\\n        '\n        return hash((self.source, self.name, self.alias, self.safe))",
        "docstring": "Calculate a hash value for the ExternalImport instance, based on its attributes.\n\nThis method uses a tuple containing the instance's `source`, `name`, `alias`, and `safe` attributes to compute a hash value. The resulting hash can be used for storing and comparing instances of ExternalImport in collections like sets or as dictionary keys. It ensures that instances with the same attributes have the same hash value, which is crucial for maintaining consistency in hashed collections.\n\nReturns:\n    int: The computed hash value for the ExternalImport instance.\n\nAttributes:\n    - `source`: An instance of ImportString, representing the module import string.\n    - `name`: A string representing the import name.\n    - `alias`: A string for the local name of the import.\n    - `safe`: A boolean indicating whether the import is wrapped in a try-except block.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_parent.py": {
      "TypeParent.replace_self_references": {
        "code": "    def replace_self_references(self, replacement: FakeAnnotation) -> 'set[TypeParent]':\n        \"\"\"Replace self references in the type annotation hierarchy with a specified new type annotation to prevent infinite recursion during processing. This method identifies all parents of the current type annotation instance that refer to itself, replacing each occurrence with the provided replacement annotation.\n\nParameters:\n- replacement (FakeAnnotation): The new type annotation that will replace self references.\n\nReturns:\n- set[TypeParent]: A set of parent `TypeParent` instances where self references have been replaced.\n\nThis method interacts with the `find_type_annotation_parents` method to locate parent instances that reference the current type, ensuring that the replacement only affects relevant instances in the hierarchy.\"\"\"\n        '\\n        Replace self references with a new type annotation to avoid recursion.\\n        '\n        '\\n        Replace self references with a new type annotation to avoid recursion.\\n        '\n        parents = self.find_type_annotation_parents(self)\n        for parent in parents:\n            parent.replace_child(self, replacement)\n        return parents",
        "docstring": "Replace self references in the type annotation hierarchy with a specified new type annotation to prevent infinite recursion during processing. This method identifies all parents of the current type annotation instance that refer to itself, replacing each occurrence with the provided replacement annotation.\n\nParameters:\n- replacement (FakeAnnotation): The new type annotation that will replace self references.\n\nReturns:\n- set[TypeParent]: A set of parent `TypeParent` instances where self references have been replaced.\n\nThis method interacts with the `find_type_annotation_parents` method to locate parent instances that reference the current type, ensuring that the replacement only affects relevant instances in the hierarchy.",
        "signature": "def replace_self_references(self, replacement: FakeAnnotation) -> 'set[TypeParent]':",
        "type": "Method",
        "class_signature": "class TypeParent(FakeAnnotation, ABC):"
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.get_import_records": {
        "code": "    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Retrieve all import records necessary for using the type annotation represented by the instance of the FakeAnnotation class. This method filters out any import records that originate from built-in Python types by utilizing the `is_builtins()` method from the ImportRecord's source. The return value is a set of ImportRecord instances that represent external imports needed for appropriately using the type annotation.\n\nReturns:\n    set[ImportRecord]: A set containing import records for the type annotation, excluding built-in type imports.\"\"\"\n        '\\n        Get all import records required for using type annotation.\\n        '\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}",
        "docstring": "Retrieve all import records necessary for using the type annotation represented by the instance of the FakeAnnotation class. This method filters out any import records that originate from built-in Python types by utilizing the `is_builtins()` method from the ImportRecord's source. The return value is a set of ImportRecord instances that represent external imports needed for appropriately using the type annotation.\n\nReturns:\n    set[ImportRecord]: A set containing import records for the type annotation, excluding built-in type imports.",
        "signature": "def get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.iterate_types": {
        "code": "    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"Generate an iterator that recursively yields this type annotation and all nested type annotations. This method starts with the current instance of the FakeAnnotation class and allows traversal through any complex type structures it may encapsulate. It does not accept any parameters and returns an iterator of FakeAnnotation instances. This method is useful for collecting all distinct type annotations related to the current annotation, potentially helping with analysis or validation of type dependencies.\"\"\"\n        '\\n        Iterate over all used type annotations recursively including self.\\n        '\n        yield self",
        "docstring": "Generate an iterator that recursively yields this type annotation and all nested type annotations. This method starts with the current instance of the FakeAnnotation class and allows traversal through any complex type structures it may encapsulate. It does not accept any parameters and returns an iterator of FakeAnnotation instances. This method is useful for collecting all distinct type annotations related to the current annotation, potentially helping with analysis or validation of type dependencies.",
        "signature": "def iterate_types(self) -> Iterator['FakeAnnotation']:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.copy": {
        "code": "    def copy(self: Self) -> Self:\n        \"\"\"Create a copy of the type annotation wrapper.\n\nThis method utilizes the `copy` module to produce a shallow copy of the current instance of the `FakeAnnotation` class or any of its subclasses. It returns a new instance that preserves the state of the original object.\n\nReturns:\n    Self: A new instance of the type annotation wrapper, which is a copy of the original.\n\nDependencies:\n    This method depends on the `copy` module from the standard library to perform the copying operation.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return copy.copy(self)",
        "docstring": "Create a copy of the type annotation wrapper.\n\nThis method utilizes the `copy` module to produce a shallow copy of the current instance of the `FakeAnnotation` class or any of its subclasses. It returns a new instance that preserves the state of the original object.\n\nReturns:\n    Self: A new instance of the type annotation wrapper, which is a copy of the original.\n\nDependencies:\n    This method depends on the `copy` module from the standard library to perform the copying operation.",
        "signature": "def copy(self: Self) -> Self:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_literal.py": {
      "TypeLiteral.__init__": {
        "code": "    def __init__(self, name: str, children: Iterable[str]) -> None:\n        \"\"\"Initialize a TypeLiteral instance, representing a literal type annotation.\n\nParameters:\n    name (str): The name for the literal, used for non-inline definitions.\n    children (Iterable[str]): A collection of literal values. This must contain at least one child; otherwise, a TypeAnnotationError is raised.\n\nRaises:\n    TypeAnnotationError: If the 'children' parameter is empty, indicating that a literal should have at least one value.\n\nAttributes:\n    children (set[str]): A set of literal values derived from the 'children' parameter.\n    name (str): The name of the literal passed during initialization.\n\nThis constructor interacts with TypeAnnotationError from the mypy_boto3_builder.exceptions module to enforce that at least one child is provided for the literal.\"\"\"\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError('Literal should have children')",
        "docstring": "Initialize a TypeLiteral instance, representing a literal type annotation.\n\nParameters:\n    name (str): The name for the literal, used for non-inline definitions.\n    children (Iterable[str]): A collection of literal values. This must contain at least one child; otherwise, a TypeAnnotationError is raised.\n\nRaises:\n    TypeAnnotationError: If the 'children' parameter is empty, indicating that a literal should have at least one value.\n\nAttributes:\n    children (set[str]): A set of literal values derived from the 'children' parameter.\n    name (str): The name of the literal passed during initialization.\n\nThis constructor interacts with TypeAnnotationError from the mypy_boto3_builder.exceptions module to enforce that at least one child is provided for the literal.",
        "signature": "def __init__(self, name: str, children: Iterable[str]) -> None:",
        "type": "Method",
        "class_signature": "class TypeLiteral(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py": {
      "ImportRecord.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Generate a formatted import statement string based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns the import statement as a string, using the `source`, `name`, and `alias` attributes stored in the instance. If the `name` attribute is present, it creates a statement of the form \"from {source} import {name}\" or \"import {source} as {alias}\" if the `alias` is defined. If neither `name` nor `alias` is available, a simple \"import {source}\" statement is produced.\n\nReturns:\n    str: A string representation of the import statement.\n\nDependencies:\n    - Utilizes the `render_name` method to create the import name string.\n    - Relies on the `source` attribute, which must be an instance of `ImportString`, for constructing the import statement.\"\"\"\n        '\\n        Get rendered string.\\n        '\n        if self.name:\n            return f'from {self.source} import {self.render_name()}'\n        if self.alias:\n            return f'import {self.source} as {self.alias}'\n        return f'import {self.source}'",
        "docstring": "Generate a formatted import statement string based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns the import statement as a string, using the `source`, `name`, and `alias` attributes stored in the instance. If the `name` attribute is present, it creates a statement of the form \"from {source} import {name}\" or \"import {source} as {alias}\" if the `alias` is defined. If neither `name` nor `alias` is available, a simple \"import {source}\" statement is produced.\n\nReturns:\n    str: A string representation of the import statement.\n\nDependencies:\n    - Utilizes the `render_name` method to create the import name string.\n    - Relies on the `source` attribute, which must be an instance of `ImportString`, for constructing the import statement.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:render": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypedDictAttribute.get_type_annotation": {
          "code": "    def get_type_annotation(self) -> FakeAnnotation:\n        \"\"\"\n        Get wrapped for non-required type annotation or raw type annotation.\n        \"\"\"\n        if self.is_required():\n            return self.type_annotation\n        return TypeSubscript(Type.NotRequired, [self.type_annotation])",
          "docstring": "Get wrapped for non-required type annotation or raw type annotation.",
          "signature": "def get_type_annotation(self) -> FakeAnnotation:",
          "type": "Method",
          "class_signature": "class TypedDictAttribute:"
        }
      },
      "mypy_boto3_builder/type_annotations/type_subscript.py": {
        "TypeSubscript.render": {
          "code": "    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        result = self.parent.render()\n        if self.children:\n            children = \", \".join([i.render() for i in self.children])\n            result = f\"{result}[{children}]\"\n\n        if self._stringify:\n            result = f'\"{result}\"'\n        return result",
          "docstring": "Render type annotation to a valid Python code for local usage.\n\nReturns:\n    A string with a valid type annotation.",
          "signature": "def render(self) -> str:",
          "type": "Method",
          "class_signature": "class TypeSubscript(TypeParent):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypeTypedDict.__copy__": {
          "code": "    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, list(self.children), docstring=self.docstring, stringify=self.is_stringified())",
          "docstring": "Create a copy of type annotation wrapper.",
          "signature": "def __copy__(self) -> Self:",
          "type": "Method",
          "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:render": {},
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:render_definition": {
      "mypy_boto3_builder/utils/jinja2.py": {
        "render_jinja2_template": {
          "code": "def render_jinja2_template(template_path: Path, context: Mapping[str, Any]) -> str:\n    \"\"\"\n    Render Jinja2 template to a string.\n\n    Arguments:\n        template_path -- Relative path to template in `TEMPLATES_PATH`\n        kwargs -- Render arguments\n\n    Returns:\n        A rendered template.\n    \"\"\"\n    template = JinjaManager.singleton().get_template(template_path)\n    return template.render(context)",
          "docstring": "Render Jinja2 template to a string.\n\nArguments:\n    template_path -- Relative path to template in `TEMPLATES_PATH`\n    kwargs -- Render arguments\n\nReturns:\n    A rendered template.",
          "signature": "def render_jinja2_template(template_path: Path, context: Mapping[str, Any]) -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypeTypedDict._get_import_records": {
          "code": "    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}",
          "docstring": "Get import record required for using type annotation.",
          "signature": "def _get_import_records(self) -> set[ImportRecord]:",
          "type": "Method",
          "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.is_builtins": {
          "code": "    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS",
          "docstring": "Whether import is from Python `builtins` module.",
          "signature": "def is_builtins(self) -> bool:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))",
          "docstring": "Calculate hash value based on source, name and alias.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.render_name": {
          "code": "    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name",
          "docstring": "Get rendered import name.",
          "signature": "def render_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__str__": {
          "code": "    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()",
          "docstring": "Render as a part of a valid Python import statement.",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypedDictAttribute.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name, required and type annotation.\n        \"\"\"\n        return hash((self.name, self.required, self.type_annotation.get_sort_key()))",
          "docstring": "Calculate hash value based on name, required and type annotation.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class TypedDictAttribute:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:add_attribute": {},
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:has_optional": {},
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:has_required": {},
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_required": {},
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_optional": {},
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_same": {},
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_children_types": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypedDictAttribute.iterate_types": {
          "code": "    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Itera over type annotations.\n        \"\"\"\n        yield from self.type_annotation.iterate_types()",
          "docstring": "Itera over type annotations.",
          "signature": "def iterate_types(self) -> Iterator[FakeAnnotation]:",
          "type": "Method",
          "class_signature": "class TypedDictAttribute:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)",
          "docstring": "Calculate hash value based on all parts.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_children_literals": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py": {
        "FakeAnnotation.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())",
          "docstring": "Calculate hash value based on string render.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class FakeAnnotation(ABC):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:replace_self_references": {
      "mypy_boto3_builder/type_annotations/type_parent.py": {
        "TypeParent.find_type_annotation_parents": {
          "code": "    def find_type_annotation_parents(self, type_annotation: FakeAnnotation, skip: Iterable[FakeAnnotation]=()) -> 'set[TypeParent]':\n        \"\"\"\n        Check recursively if child is present in type def.\n        \"\"\"\n        result: set[TypeParent] = set()\n        for child_type in self.iterate_children_type_annotations():\n            if child_type == type_annotation:\n                result.add(self)\n            if not isinstance(child_type, TypeParent):\n                continue\n            if child_type in skip:\n                continue\n            parents = child_type.find_type_annotation_parents(type_annotation, skip={*skip, child_type})\n            result.update(parents)\n        return result",
          "docstring": "Check recursively if child is present in type def.",
          "signature": "def find_type_annotation_parents(self, type_annotation: FakeAnnotation, skip: Iterable[FakeAnnotation]=()) -> 'set[TypeParent]':",
          "type": "Method",
          "class_signature": "class TypeParent(FakeAnnotation, ABC):"
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
        "TypeTypedDict.replace_child": {
          "code": "    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        children_types = [i.type_annotation for i in self.children]\n        if child not in children_types:\n            raise TypeAnnotationError(f'Child not found: {child}')\n        indices = [i for i, x in enumerate(children_types) if x == child]\n        for index in indices:\n            self.children[index].type_annotation = new_child\n        return self",
          "docstring": "Replace child type annotation with a new one.",
          "signature": "def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:",
          "type": "Method",
          "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
        }
      }
    }
  },
  "call_tree": {
    "tests/type_annotations/test_type_typed_dict.py:TestTypedDictAttribute:setup_method": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypedDictAttribute:test_init": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypedDictAttribute:test_render": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:render": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:get_type_annotation": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
        },
        "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
          "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
            "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
          }
        }
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypedDictAttribute:test_mark_as_required": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:mark_as_required": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:setup_method": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_render": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__copy__": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {},
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:render": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {}
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:stringify": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_render_definition": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__copy__": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {},
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:render_definition": {
        "mypy_boto3_builder/utils/jinja2.py:render_jinja2_template": {
          "mypy_boto3_builder/jinja_manager.py:JinjaManager:singleton": {
            "mypy_boto3_builder/jinja_manager.py:JinjaManager:__init__": {}
          },
          "mypy_boto3_builder/jinja_manager.py:JinjaManager:get_template": {},
          "mypy_boto3_builder/templates/common/typed_dict_class.py.jinja2:root": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:iterate_children": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_required": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
              },
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_optional": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
              }
            },
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:render_attribute": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:get_type_annotation": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {},
                "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__": {}
              },
              "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                },
                "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
              },
              "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
                "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
                  "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
                },
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                  "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                  },
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
                }
              }
            }
          },
          "mypy_boto3_builder/templates/common/typed_dict.py.jinja2:root": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:iterate_children": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_required": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
              },
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_optional": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
              }
            },
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:render": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:get_type_annotation": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {},
                "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__": {}
              },
              "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                },
                "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
              },
              "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
                "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
                  "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
                },
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                  "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                  },
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
                }
              }
            }
          }
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_get_import_records": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:_get_import_records": {
          "mypy_boto3_builder/import_helpers/internal_import_record.py:InternalImportRecord:__init__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
          }
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_get_types": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__hash__": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
              "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                },
                "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
              }
            }
          }
        }
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_add_attribute": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:add_attribute": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {}
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_is_dict": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_dict": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_has_optional": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:has_optional": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_has_required": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:has_required": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_get_required": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_required": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_get_optional": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_optional": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_copy": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__copy__": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {},
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
        }
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_is_same": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_same": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__hash__": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
              "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                  "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                  },
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
                }
              }
            }
          }
        }
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_get_children_types": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_children_types": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:iterate_types": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
        },
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
        }
      },
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_get_children_literals": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__copy__": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {},
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_children_literals": {
        "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:TypeLiteral": {},
        "mypy_boto3_builder/type_annotations/type_def_sortable.py:TypeDefSortable:TypeDefSortable": {},
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_children_types": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:iterate_types": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:iterate_types": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
          },
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {
            "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:get_sort_key": {}
          }
        },
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {
          "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:get_sort_key": {}
        }
      },
      "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:add_attribute": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {}
      }
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_stringify": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__copy__": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {},
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:is_stringified": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:stringify": {}
    },
    "tests/type_annotations/test_type_typed_dict.py:TestTypeTypedDict:test_replace_self_references": {
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:add_attribute": {
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {}
      },
      "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:replace_self_references": {
        "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:find_type_annotation_parents": {
          "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:TypeParent": {},
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:iterate_children_type_annotations": {},
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__eq__": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation": {},
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
              "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                  "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                  },
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
                }
              }
            },
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_sort_key": {}
          },
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__hash__": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__hash__": {
              "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
                "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                  "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                    },
                    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
                  }
                }
              },
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_sort_key": {}
            }
          },
          "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:find_type_annotation_parents": {
            "[ignored_or_cut_off]": "..."
          }
        },
        "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:replace_child": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__eq__": {
            "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
              "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                  "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                  },
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
                }
              }
            },
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_sort_key": {}
          }
        }
      },
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:render_definition": {
        "mypy_boto3_builder/utils/jinja2.py:render_jinja2_template": {
          "mypy_boto3_builder/jinja_manager.py:JinjaManager:singleton": {},
          "mypy_boto3_builder/jinja_manager.py:JinjaManager:get_template": {},
          "mypy_boto3_builder/templates/common/typed_dict.py.jinja2:root": {
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:iterate_children": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_required": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
              },
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:get_optional": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {}
              }
            },
            "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:render": {
              "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:get_type_annotation": {
                "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:is_required": {},
                "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__": {}
              },
              "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                },
                "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
              },
              "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
                "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
                  "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
                },
                "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
                  "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
                    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
                  },
                  "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
                },
                "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
                  "[ignored_or_cut_off]": "..."
                }
              }
            }
          }
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_type_typed_dict\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 import_helpers/\n    \u2502   \u2514\u2500\u2500 import_record.py\n    \u2502       \u2514\u2500\u2500 ImportRecord.render\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 external_import.py\n        \u2502   \u2514\u2500\u2500 ExternalImport.__hash__\n        \u251c\u2500\u2500 fake_annotation.py\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.copy\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.get_import_records\n        \u2502   \u2514\u2500\u2500 FakeAnnotation.iterate_types\n        \u251c\u2500\u2500 type_literal.py\n        \u2502   \u2514\u2500\u2500 TypeLiteral.__init__\n        \u251c\u2500\u2500 type_parent.py\n        \u2502   \u2514\u2500\u2500 TypeParent.replace_self_references\n        \u2514\u2500\u2500 type_typed_dict.py\n            \u251c\u2500\u2500 TypeTypedDict.__hash__\n            \u251c\u2500\u2500 TypeTypedDict.__init__\n            \u251c\u2500\u2500 TypeTypedDict.add_attribute\n            \u251c\u2500\u2500 TypeTypedDict.get_children_literals\n            \u251c\u2500\u2500 TypeTypedDict.get_children_types\n            \u251c\u2500\u2500 TypeTypedDict.get_optional\n            \u251c\u2500\u2500 TypeTypedDict.get_required\n            \u251c\u2500\u2500 TypeTypedDict.has_optional\n            \u251c\u2500\u2500 TypeTypedDict.has_required\n            \u251c\u2500\u2500 TypeTypedDict.is_dict\n            \u251c\u2500\u2500 TypeTypedDict.is_same\n            \u251c\u2500\u2500 TypeTypedDict.is_stringified\n            \u251c\u2500\u2500 TypeTypedDict.render\n            \u251c\u2500\u2500 TypeTypedDict.render_definition\n            \u251c\u2500\u2500 TypeTypedDict.stringify\n            \u251c\u2500\u2500 TypedDictAttribute.__init__\n            \u251c\u2500\u2500 TypedDictAttribute.is_required\n            \u251c\u2500\u2500 TypedDictAttribute.mark_as_required\n            \u2514\u2500\u2500 TypedDictAttribute.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for defining, managing, and rendering strongly-typed data structures based on Python's `TypedDict`, enabling structured type definitions in a programmatic and reusable manner. It allows users to create custom typed dictionaries with mandatory and optional attributes, enforce type safety, and generate corresponding class definitions or dictionary representations. Additionally, the module supports advanced features such as self-referencing attributes, stringified rendering, and efficient type analysis, ensuring flexible and readable representations of complex data structures. By offering a standardized approach to defining and manipulating typed dictionaries, the module simplifies the development of robust, type-safe code, catering to developers working with type annotations, API definitions, or code generation tools.\n\n## FILE 1: mypy_boto3_builder/type_annotations/type_typed_dict.py\n\n- CLASS METHOD: TypeTypedDict.is_stringified\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def is_stringified(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the TypedDict usage should be rendered as a string.\n\nThis method returns the value of the `_stringify` attribute, which indicates whether the TypedDict's representation should be output as a string rather than as its standard type form. This functionality is essential for controlling the rendering format, especially in scenarios requiring serialized representations.\n\nReturns:\n    bool: `True` if the TypedDict should be rendered as a string, otherwise `False`.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.stringify\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def stringify(self) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nMark the TypedDict as stringified, indicating that its usage should be rendered as a string in type annotations. This method modifies the internal state of the TypeTypedDict instance by setting the `_stringify` attribute to `True`. This attribute controls how the TypedDict is rendered in the `render` method, allowing it to be presented as a string rather than a type. No parameters are required, and the method does not return any value.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.get_children_types\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def get_children_types(self) -> set[FakeAnnotation]:\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts the type annotations from the attributes of the TypedDict. This method iterates over each child attribute of the TypedDict, accumulating their type annotations by calling the `iterate_types()` method on each child. \n\nReturns:\n    A set of `FakeAnnotation` instances representing the collected type annotations from all child attributes.\n\nDependencies:\n    - `self.children`: A list of `TypedDictAttribute` instances, each representing an attribute of the TypedDict. The attributes can be required or optional and their type annotations are explored to provide a comprehensive set of types used within the dict.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.__hash__\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value for a `TypeTypedDict` instance.\n\nThe hash is computed using the `name` attribute and the `children` attributes. This allows `TypeTypedDict` objects to be used in sets and as keys in dictionaries, enabling efficient membership tests and lookups. The `children` are expected to be instances of `TypedDictAttribute`, which also implement the `__hash__` method.\n\nReturns:\n    int: The computed hash value for the instance.\n\nDependencies:\n    - `self.name`: A string representing the type name of the `TypedDict`.\n    - `self.children`: A list of `TypedDictAttribute` instances, which are included in the hash calculation.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.get_required\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def get_required(self) -> tuple[TypedDictAttribute, ...]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a tuple of required attributes from the TypedDict.\n\nThis method iterates through the `children` attribute, which is a list of `TypedDictAttribute` instances, to collect those attributes marked as required. An attribute is considered required if its `is_required` method returns `True`. The result is returned as a tuple to maintain the order of attributes as they were added.\n\nReturns:\n    tuple[TypedDictAttribute, ...]: A tuple containing the required `TypedDictAttribute` objects.\n\nDependencies:\n- `self.children`: A list of `TypedDictAttribute` instances that represent the attributes of the TypedDict. Each instance can indicate whether it is required or optional via the `is_required` method.\n\"\"\"\n```\n\n- CLASS METHOD: TypedDictAttribute.__init__\n  - CLASS SIGNATURE: class TypedDictAttribute:\n  - SIGNATURE: def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a `TypedDictAttribute` instance, which represents an attribute in a TypedDict with a specific type annotation and optional requirement status.\n\nParameters:\n- `name` (str): The name of the attribute.\n- `type_annotation` (FakeAnnotation): The type annotation associated with the attribute, which specifies the expected data type.\n- `required` (bool): Indicates whether the attribute is mandatory in the TypedDict.\n\nThis constructor does not return any value and creates an instance that holds the attribute name, its type annotation, and whether it is required. The `type_annotation` parameter must be an instance of `FakeAnnotation`, which is used throughout the code to define various types and supports rendering and iteration.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.has_required\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def has_required(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the TypedDict contains any required keys.\n\nThis method iterates over the `children` attributes of the TypedDict, which are instances of the `TypedDictAttribute` class, and assesses whether any of them are marked as required using their `is_required` method. It returns `True` if at least one required attribute exists; otherwise, it returns `False`.\n\nReturns:\n    bool: True if there are required attributes, False otherwise.\n\nAttributes:\n    self.children: A list of `TypedDictAttribute` instances initialized in the constructor, representing the attributes of the TypedDict. Each `TypedDictAttribute` contains information about whether it is required or optional.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.render_definition\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def render_definition(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the type annotation definition for the TypedDict.\n\nThis method generates a string representation of the type definition based on a Jinja2 template, selecting between two templates depending on the `is_safe_as_class` attribute. The `template` variable holds the path to the appropriate template file, either `common/typed_dict_class.py.jinja2` or `common/typed_dict.py.jinja2`. The rendered output incorporates the current instance of the `TypeTypedDict`, facilitating the creation of type definitions in a Pythonic format.\n\nReturns:\n    A string containing the complete type annotation definition for the TypedDict.\n\nDependencies:\n    - The method uses `render_jinja2_template`, which is expected to accept a template path and a context dictionary to generate the final output.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.get_children_literals\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def get_children_literals(self, processed: Iterable[str]=()) -> set[TypeLiteral]:\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts the required `TypeLiteral` instances from the attributes of the `TypeTypedDict`. The method takes an optional parameter `processed`, which is an iterable of strings representing names already processed to prevent cyclic references. It returns a set of `TypeLiteral` objects found within the child attributes. If the `name` of the current `TypeTypedDict` is in `processed`, the method returns an empty set to avoid infinite recursion. It utilizes the `get_children_types` method to retrieve all types associated with the child attributes, and it further explores any `TypeDefSortable` types recursively to gather their `TypeLiteral` instances.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.__init__\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeTypedDict instance, representing a TypedDict type annotation.\n\nParameters:\n- name (str): The name of the TypedDict type.\n- children (Iterable[TypedDictAttribute], optional): A collection of TypedDictAttribute instances defining the attributes of the TypedDict. Defaults to an empty iterable.\n- docstring (str, optional): A docstring for the TypedDict, providing documentation. Defaults to an empty string.\n- stringify (bool, optional): A flag indicating whether to render the TypedDict as a string. Defaults to False.\n\nAttributes:\n- self.name: Stores the name of the TypedDict.\n- self.children: A list of TypedDictAttribute instances.\n- self.docstring: Stores the provided docstring.\n- self._stringify: Indicates if the TypedDict should be represented as a string.\n- self.is_safe_as_class: A boolean flag set to True, suggesting that the TypedDict can be safely used as a class.\n\nThis constructor sets up an instance for further manipulation, allowing the addition of attributes and rendering for type annotations in type definitions.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.render\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the type annotation of the `TypeTypedDict` instance to produce a valid Python code representation for local usage. \n\nThe method checks if the `TypedDict` should be rendered as a string by calling the `is_stringified()` method. If it returns `True`, the method returns the type name enclosed in quotes (e.g., '\"type_name\"'). If not, it returns the type name directly.\n\nReturns:\n    A string representing the type annotation, either as a quoted string or as the type name itself.\n\nDependencies:\n    - `self.name`: The name of the typed dictionary, used when rendering the output.\n    - `is_stringified()`: Method that determines the rendering format based on the state of the `TypeTypedDict` instance.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.has_optional\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def has_optional(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the TypedDict contains any optional keys.\n\nThis method checks the attributes of the TypedDict instance to see if there are any that are not marked as required. It iterates through the `children` attribute, which is a list of `TypedDictAttribute` instances, and utilizes the `is_required` method of each child to ascertain if it is optional.\n\nReturns:\n    bool: True if there are optional keys present; otherwise, False.\n\nDependencies:\n    - `children`: An iterable of `TypedDictAttribute` instances, defined during the initialization of the `TypeTypedDict` class. Each `TypedDictAttribute` represents an attribute of the TypedDict, and its `is_required` method is used to determine if the attribute is optional.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.is_same\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def is_same(self: Self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the current TypedDict instance is the same as another TypedDict instance by comparing their hash values. This method takes another instance of TypeTypedDict as a parameter and returns a boolean indicating whether the two instances are equivalent.\n\nParameters:\n- other (Self): The other TypedDict instance to compare against.\n\nReturns:\n- bool: True if both TypedDict instances have the same attributes and types (i.e., produce the same hash), otherwise False.\n\nThis method relies on the __hash__ implementation of the TypeTypedDict class, which computes a hash based on the name and children attributes of the TypedDict.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.is_dict\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def is_dict(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the type annotation represented by `TypeTypedDict` is a dictionary, specifically whether it is a `Dict` or a `TypedDict`. This method serves to confirm the nature of the type annotation encapsulated by instances of `TypeTypedDict`, facilitating type checks and ensuring proper handling of dict-like structures in type annotations. There are no input parameters. The method returns a boolean value, `True`, indicating that the annotation is always treated as a type of dictionary. This method does not depend on any external constants or variables.\n\"\"\"\n```\n\n- CLASS METHOD: TypedDictAttribute.render\n  - CLASS SIGNATURE: class TypedDictAttribute:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the attribute of a `TypedDictAttribute` to a string format suitable for function-based TypedDict definitions.\n\nThis method constructs a string representation of the attribute in the format `\"<name>\": <type_annotation>`, where `<name>` is the name of the attribute and `<type_annotation>` is derived from the result of the `get_type_annotation().render()` method. The `get_type_annotation()` function determines the appropriate type annotation, which could be either a raw type or a wrapped type if the attribute is optional.\n\nReturns:\n    str: A formatted string containing the attribute definition, ready for inclusion in a TypedDict.\n\nDependencies:\n    - `self.name`: The name of the attribute as a string.\n    - `self.get_type_annotation()`: A method that returns the appropriate type annotation (an instance of `FakeAnnotation`) used to render the type in the output string.\n\"\"\"\n```\n\n- CLASS METHOD: TypedDictAttribute.is_required\n  - CLASS SIGNATURE: class TypedDictAttribute:\n  - SIGNATURE: def is_required(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the attribute wrapped by the `TypedDictAttribute` instance is required. This method checks the `required` attribute of the instance, which is set during initialization. If `True`, it indicates that the attribute must be included in a `TypedDict`, while `False` denotes that the attribute is optional. The `required` attribute directly controls the expected structure of the `TypedDict` instances that utilize this attribute.\n\"\"\"\n```\n\n- CLASS METHOD: TypedDictAttribute.mark_as_required\n  - CLASS SIGNATURE: class TypedDictAttribute:\n  - SIGNATURE: def mark_as_required(self) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nMark the attribute as required in the TypedDictAttribute.\n\nThis method sets the `required` attribute of the TypedDictAttribute instance to `True`, indicating that this attribute must be present when using the TypedDict. The `required` attribute is a boolean that influences how the TypedDict is rendered and validated.\n\nParameters:\n    None\n\nReturns:\n    None\n\nSide Effects:\n    This method modifies the internal state of the TypedDictAttribute instance by changing the value of the `required` attribute from `False` to `True`, if it was not already set.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.add_attribute\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nAdd a new attribute to the TypedDict.\n\nThis method appends a new TypedDictAttribute to the internal list of children,\nrepresenting an attribute of the TypedDict. The attribute includes a name,\ntype annotation, and a flag indicating if it is required.\n\nParameters:\n    name (str): The name of the attribute being added to the TypedDict.\n    type_annotation (FakeAnnotation): The type annotation for the attribute,\n        which describes the expected type of the attribute value.\n    required (bool): A flag indicating whether this attribute must be set\n        when creating an instance of the TypedDict.\n\nThis method interacts with the TypedDictAttribute class to manage individual\nattributes of the TypedDict, allowing for the flexible creation of type-safe\ndictionaries within the context of type definitions.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.get_optional\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def get_optional(self) -> tuple[TypedDictAttribute, ...]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a list of optional attributes from the TypedDict.\n\nThis method iterates over the children attributes and filters out those that are not marked as required, as determined by the `is_required` method of the `TypedDictAttribute` class. It returns a tuple of `TypedDictAttribute` instances that represent optional fields in the typed dictionary.\n\nReturns:\n    tuple[TypedDictAttribute, ...]: A tuple containing all optional attributes of the TypedDict.\n\nDependencies:\n    - `self.children`: A list of `TypedDictAttribute` instances, representing the children attributes of the TypedDict.\n    - `TypedDictAttribute.is_required`: A method used to check if each child attribute is required or optional.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.__hash__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ExternalImport instance, based on its attributes.\n\nThis method uses a tuple containing the instance's `source`, `name`, `alias`, and `safe` attributes to compute a hash value. The resulting hash can be used for storing and comparing instances of ExternalImport in collections like sets or as dictionary keys. It ensures that instances with the same attributes have the same hash value, which is crucial for maintaining consistency in hashed collections.\n\nReturns:\n    int: The computed hash value for the ExternalImport instance.\n\nAttributes:\n    - `source`: An instance of ImportString, representing the module import string.\n    - `name`: A string representing the import name.\n    - `alias`: A string for the local name of the import.\n    - `safe`: A boolean indicating whether the import is wrapped in a try-except block.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/type_annotations/type_parent.py\n\n- CLASS METHOD: TypeParent.replace_self_references\n  - CLASS SIGNATURE: class TypeParent(FakeAnnotation, ABC):\n  - SIGNATURE: def replace_self_references(self, replacement: FakeAnnotation) -> 'set[TypeParent]':\n  - DOCSTRING: \n```python\n\"\"\"\nReplace self references in the type annotation hierarchy with a specified new type annotation to prevent infinite recursion during processing. This method identifies all parents of the current type annotation instance that refer to itself, replacing each occurrence with the provided replacement annotation.\n\nParameters:\n- replacement (FakeAnnotation): The new type annotation that will replace self references.\n\nReturns:\n- set[TypeParent]: A set of parent `TypeParent` instances where self references have been replaced.\n\nThis method interacts with the `find_type_annotation_parents` method to locate parent instances that reference the current type, ensuring that the replacement only affects relevant instances in the hierarchy.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.get_import_records\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve all import records necessary for using the type annotation represented by the instance of the FakeAnnotation class. This method filters out any import records that originate from built-in Python types by utilizing the `is_builtins()` method from the ImportRecord's source. The return value is a set of ImportRecord instances that represent external imports needed for appropriately using the type annotation.\n\nReturns:\n    set[ImportRecord]: A set containing import records for the type annotation, excluding built-in type imports.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.iterate_types\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def iterate_types(self) -> Iterator['FakeAnnotation']:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate an iterator that recursively yields this type annotation and all nested type annotations. This method starts with the current instance of the FakeAnnotation class and allows traversal through any complex type structures it may encapsulate. It does not accept any parameters and returns an iterator of FakeAnnotation instances. This method is useful for collecting all distinct type annotations related to the current annotation, potentially helping with analysis or validation of type dependencies.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.copy\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def copy(self: Self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a copy of the type annotation wrapper.\n\nThis method utilizes the `copy` module to produce a shallow copy of the current instance of the `FakeAnnotation` class or any of its subclasses. It returns a new instance that preserves the state of the original object.\n\nReturns:\n    Self: A new instance of the type annotation wrapper, which is a copy of the original.\n\nDependencies:\n    This method depends on the `copy` module from the standard library to perform the copying operation.\n\"\"\"\n```\n\n## FILE 5: mypy_boto3_builder/type_annotations/type_literal.py\n\n- CLASS METHOD: TypeLiteral.__init__\n  - CLASS SIGNATURE: class TypeLiteral(FakeAnnotation):\n  - SIGNATURE: def __init__(self, name: str, children: Iterable[str]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeLiteral instance, representing a literal type annotation.\n\nParameters:\n    name (str): The name for the literal, used for non-inline definitions.\n    children (Iterable[str]): A collection of literal values. This must contain at least one child; otherwise, a TypeAnnotationError is raised.\n\nRaises:\n    TypeAnnotationError: If the 'children' parameter is empty, indicating that a literal should have at least one value.\n\nAttributes:\n    children (set[str]): A set of literal values derived from the 'children' parameter.\n    name (str): The name of the literal passed during initialization.\n\nThis constructor interacts with TypeAnnotationError from the mypy_boto3_builder.exceptions module to enforce that at least one child is provided for the literal.\n\"\"\"\n```\n\n## FILE 6: mypy_boto3_builder/import_helpers/import_record.py\n\n- CLASS METHOD: ImportRecord.render\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a formatted import statement string based on the attributes of the ImportRecord instance.\n\nThis method constructs and returns the import statement as a string, using the `source`, `name`, and `alias` attributes stored in the instance. If the `name` attribute is present, it creates a statement of the form \"from {source} import {name}\" or \"import {source} as {alias}\" if the `alias` is defined. If neither `name` nor `alias` is available, a simple \"import {source}\" statement is produced.\n\nReturns:\n    str: A string representation of the import statement.\n\nDependencies:\n    - Utilizes the `render_name` method to create the import name string.\n    - Relies on the `source` attribute, which must be an instance of `ImportString`, for constructing the import statement.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": "\"\"\"\nWrapper for `typing/typing_extensions.TypedDict` type annotations.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypedDictAttribute:\n    \"\"\"\n    TypedDict attribute wrapper.\n\n    Arguments:\n        name -- Attribute name.\n        type_annotation -- Attribute type annotation.\n        required -- Whether the attribute has to be set.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name, required and type annotation.\n        \"\"\"\n        return hash((self.name, self.required, self.type_annotation.get_sort_key()))\n\n    def get_type_annotation(self) -> FakeAnnotation:\n        \"\"\"\n        Get wrapped for non-required type annotation or raw type annotation.\n        \"\"\"\n        if self.is_required():\n            return self.type_annotation\n        return TypeSubscript(Type.NotRequired, [self.type_annotation])\n\n    def render_attribute(self) -> str:\n        \"\"\"\n        Render attribute to use in class-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'{self.name}: {self.get_type_annotation().render()}'\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Itera over type annotations.\n        \"\"\"\n        yield from self.type_annotation.iterate_types()\n\nclass TypeTypedDict(TypeParent, TypeDefSortable):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.TypedDict` type annotations.\n\n    Arguments:\n        name -- Type name.\n        children -- Typed dict attributes.\n        docstring -- Docstring for render.\n        stringify -- Convert type annotation to string to avoid circular deps.\n    \"\"\"\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort Typed Dicts by name.\n        \"\"\"\n        return self.name\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using TypedDict.\n        \"\"\"\n        result = Type.TypedDict.get_import_records()\n        for child in self.iterate_children():\n            result.update(child.get_type_annotation().get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, list(self.children), docstring=self.docstring, stringify=self.is_stringified())\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        for child in self.children:\n            yield child.type_annotation\n\n    def iterate_children(self) -> Iterator[TypedDictAttribute]:\n        \"\"\"\n        Iterate over children from required to optional.\n        \"\"\"\n        yield from self.get_required()\n        yield from self.get_optional()\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [child.type_annotation for child in self.children if child.type_annotation.get_local_types()]\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return True\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        children_types = [i.type_annotation for i in self.children]\n        if child not in children_types:\n            raise TypeAnnotationError(f'Child not found: {child}')\n        indices = [i for i, x in enumerate(children_types) if x == child]\n        for index in indices:\n            self.children[index].type_annotation = new_child\n        return self",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe",
    "mypy_boto3_builder/type_annotations/type_parent.py": "\"\"\"\nProtocol for types with children.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\n\nclass TypeParent(FakeAnnotation, ABC):\n    \"\"\"\n    Protocol for types with children.\n    \"\"\"\n\n    @abstractmethod\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children type annotations.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        ...\n\n    def find_type_annotation_parents(self, type_annotation: FakeAnnotation, skip: Iterable[FakeAnnotation]=()) -> 'set[TypeParent]':\n        \"\"\"\n        Check recursively if child is present in type def.\n        \"\"\"\n        result: set[TypeParent] = set()\n        for child_type in self.iterate_children_type_annotations():\n            if child_type == type_annotation:\n                result.add(self)\n            if not isinstance(child_type, TypeParent):\n                continue\n            if child_type in skip:\n                continue\n            parents = child_type.find_type_annotation_parents(type_annotation, skip={*skip, child_type})\n            result.update(parents)\n        return result\n\n    def get_sortable_children(self) -> list[TypeDefSortable]:\n        \"\"\"\n        Extract required TypeDefSortable list from attributes.\n        \"\"\"\n        result: list[TypeDefSortable] = []\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if not isinstance(type_annotation, TypeDefSortable):\n                continue\n            result.append(type_annotation)\n        return result",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.inline:\n            children = ', '.join([repr(i) for i in sorted(self.children)])\n            return f'Literal[{children}]'\n        return self.name\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation('Literal').get_import_records()\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation('Literal').get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError('Use add_literal_child function.')\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path('common/literal.py.jinja2'), {'literal': self})",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n        if self.source != other.source:\n            return self.source > other.source\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)"
  }
}