{
  "dir_path": "/app/stestr",
  "package_name": "stestr",
  "sample_name": "stestr-test_utils",
  "src_dir": "stestr/",
  "test_dir": "stestr/tests/",
  "test_file": "modified_testcases/test_utils.py",
  "test_code": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nfrom stestr.tests import base\nfrom stestr import utils\n\n\nclass TestUtils(base.TestCase):\n    def test_cleanup_test_name_defaults(self):\n        test_id_no_attrs = \"test.TestThing.test_thing\"\n        test_id_with_attrs = \"test.TestThing.test_thing[attr1,attr2,att3]\"\n        test_id_with_scenario = \"test.TestThing.test_thing(mysql)\"\n        test_id_with_attrs_and_scenario = \"test.TestThing.test_thing[attr]\" \"(mysql)\"\n        result_no_attrs = utils.cleanup_test_name(test_id_no_attrs)\n        self.assertEqual(test_id_no_attrs, result_no_attrs)\n        result_with_attrs = utils.cleanup_test_name(test_id_with_attrs)\n        self.assertEqual(test_id_no_attrs, result_with_attrs)\n        result_with_scenario = utils.cleanup_test_name(test_id_with_scenario)\n        self.assertEqual(test_id_with_scenario, result_with_scenario)\n        result_with_attr_and_scenario = utils.cleanup_test_name(\n            test_id_with_attrs_and_scenario\n        )\n        self.assertEqual(test_id_with_scenario, result_with_attr_and_scenario)\n\n    def test_cleanup_test_name_leave_attrs(self):\n        test_id_no_attrs = \"test.TestThing.test_thing\"\n        test_id_with_attrs = \"test.TestThing.test_thing[attr1,attr2,att3]\"\n        test_id_with_scenario = \"test.TestThing.test_thing(mysql)\"\n        test_id_with_attrs_and_scenario = \"test.TestThing.test_thing[attr]\" \"(mysql)\"\n        result_no_attrs = utils.cleanup_test_name(test_id_no_attrs, strip_tags=False)\n        self.assertEqual(test_id_no_attrs, result_no_attrs)\n        result_with_attrs = utils.cleanup_test_name(\n            test_id_with_attrs, strip_tags=False\n        )\n        self.assertEqual(test_id_with_attrs, result_with_attrs)\n        result_with_scenario = utils.cleanup_test_name(\n            test_id_with_scenario, strip_tags=False\n        )\n        self.assertEqual(test_id_with_scenario, result_with_scenario)\n        result_with_attr_and_scenario = utils.cleanup_test_name(\n            test_id_with_attrs_and_scenario, strip_tags=False\n        )\n        self.assertEqual(test_id_with_attrs_and_scenario, result_with_attr_and_scenario)\n\n    def test_cleanup_test_name_strip_scenario_and_attrs(self):\n        test_id_no_attrs = \"test.TestThing.test_thing\"\n        test_id_with_attrs = \"test.TestThing.test_thing[attr1,attr2,att3]\"\n        test_id_with_scenario = \"test.TestThing.test_thing(mysql)\"\n        test_id_with_attrs_and_scenario = \"test.TestThing.test_thing[attr]\" \"(mysql)\"\n        result_no_attrs = utils.cleanup_test_name(\n            test_id_no_attrs, strip_scenarios=True\n        )\n        self.assertEqual(test_id_no_attrs, result_no_attrs)\n        result_with_attrs = utils.cleanup_test_name(\n            test_id_with_attrs, strip_scenarios=True\n        )\n        self.assertEqual(test_id_no_attrs, result_with_attrs)\n        result_with_scenario = utils.cleanup_test_name(\n            test_id_with_scenario, strip_scenarios=True\n        )\n        self.assertEqual(test_id_no_attrs, result_with_scenario)\n        result_with_attr_and_scenario = utils.cleanup_test_name(\n            test_id_with_attrs_and_scenario, strip_scenarios=True\n        )\n        self.assertEqual(test_id_no_attrs, result_with_attr_and_scenario)\n\n    def test_cleanup_test_name_strip_scenario(self):\n        test_id_no_attrs = \"test.TestThing.test_thing\"\n        test_id_with_attrs = \"test.TestThing.test_thing[attr1,attr2,att3]\"\n        test_id_with_scenario = \"test.TestThing.test_thing(mysql)\"\n        test_id_with_attrs_and_scenario = \"test.TestThing.test_thing[attr]\" \"(mysql)\"\n        result_no_attrs = utils.cleanup_test_name(\n            test_id_no_attrs, strip_scenarios=True, strip_tags=False\n        )\n        self.assertEqual(test_id_no_attrs, result_no_attrs)\n        result_with_attrs = utils.cleanup_test_name(\n            test_id_with_attrs, strip_scenarios=True, strip_tags=False\n        )\n        self.assertEqual(test_id_with_attrs, result_with_attrs)\n        result_with_scenario = utils.cleanup_test_name(\n            test_id_with_scenario, strip_scenarios=True, strip_tags=False\n        )\n        self.assertEqual(test_id_no_attrs, result_with_scenario)\n        result_with_attr_and_scenario = utils.cleanup_test_name(\n            test_id_with_attrs_and_scenario, strip_scenarios=True, strip_tags=False\n        )\n        self.assertEqual(\n            \"test.TestThing.test_thing[attr]\", result_with_attr_and_scenario\n        )\n",
  "GT_file_code": {
    "stestr/utils.py": "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n# not use this file except in compliance with the License. You may obtain\n# a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n# License for the specific language governing permissions and limitations\n# under the License.\n\nimport io\n\nfrom stestr import output\n\n\ndef _iter_internal_streams(input_streams, stream_type):\n    streams = []\n    for in_stream in input_streams:\n        if in_stream[0] == stream_type:\n            streams.append(in_stream[1])\n    for stream_value in streams:\n        if isinstance(stream_value, output.ReturnCodeToSubunit):\n            if getattr(stream_value.source, \"detach\", None):\n                yield stream_value.source.detach()\n            else:\n                yield stream_value.source\n        elif getattr(stream_value, \"read\", None):\n            yield stream_value\n        else:\n            yield io.BytesIO(stream_value)\n\n\ndef iter_streams(input_streams, stream_type):\n    \"\"\"Iterate over all the streams of type stream_type.\n\n    :param stream_type: A simple string such as 'subunit' which matches\n        one of the stream types defined for the cmd object this UI is\n        being used with.\n    :return: A generator of stream objects. stream objects have a read\n        method and a close method which behave as for file objects.\n    \"\"\"\n    for stream_spec in input_streams:\n        _stream_spec = stream_spec[0]\n        if \"*\" in _stream_spec or \"?\" in _stream_spec or \"+\" in _stream_spec:\n            found = stream_type == _stream_spec[:-1]\n        else:\n            found = stream_type == _stream_spec\n        if found:\n            return _iter_internal_streams(input_streams, stream_type)\n    raise KeyError(stream_type)\n\n\ndef cleanup_test_name(name, strip_tags=True, strip_scenarios=False):\n    \"\"\"Clean up the test name for display.\n\n    By default we strip out the tags in the test because they don't help us\n    in identifying the test that is run to it's result.\n\n    Make it possible to strip out the testscenarios information (not to\n    be confused with tempest scenarios) however that's often needed to\n    identify generated negative tests.\n    \"\"\"\n    if strip_tags:\n        tags_start = name.find(\"[\")\n        tags_end = name.find(\"]\")\n        if tags_start > 0 and tags_end > tags_start:\n            newname = name[:tags_start]\n            newname += name[tags_end + 1 :]\n            name = newname\n\n    if strip_scenarios:\n        tags_start = name.find(\"(\")\n        tags_end = name.find(\")\")\n        if tags_start > 0 and tags_end > tags_start:\n            newname = name[:tags_start]\n            newname += name[tags_end + 1 :]\n            name = newname\n\n    return name\n"
  },
  "GT_src_dict": {
    "stestr/utils.py": {
      "cleanup_test_name": {
        "code": "def cleanup_test_name(name, strip_tags=True, strip_scenarios=False):\n    \"\"\"Clean up the provided test name for display by optionally removing tags and scenarios.\n\nParameters:\n- name (str): The original test name potentially containing tags and scenarios.\n- strip_tags (bool): If True (default), strips out any content within square brackets [] from the test name.\n- strip_scenarios (bool): If True (default is False), strips out any content within parentheses () from the test name.\n\nReturns:\n- str: The cleaned test name without specified tags or scenarios.\n\nThe function utilizes the string methods `find` and slicing to locate and remove unwanted parts from the test name based on the specified parameters. There are no external constants or variables used within this function; its behavior is entirely dependent on the input string provided.\"\"\"\n    \"Clean up the test name for display.\\n\\n    By default we strip out the tags in the test because they don't help us\\n    in identifying the test that is run to it's result.\\n\\n    Make it possible to strip out the testscenarios information (not to\\n    be confused with tempest scenarios) however that's often needed to\\n    identify generated negative tests.\\n    \"\n    if strip_tags:\n        tags_start = name.find('[')\n        tags_end = name.find(']')\n        if tags_start > 0 and tags_end > tags_start:\n            newname = name[:tags_start]\n            newname += name[tags_end + 1:]\n            name = newname\n    if strip_scenarios:\n        tags_start = name.find('(')\n        tags_end = name.find(')')\n        if tags_start > 0 and tags_end > tags_start:\n            newname = name[:tags_start]\n            newname += name[tags_end + 1:]\n            name = newname\n    return name",
        "docstring": "Clean up the provided test name for display by optionally removing tags and scenarios.\n\nParameters:\n- name (str): The original test name potentially containing tags and scenarios.\n- strip_tags (bool): If True (default), strips out any content within square brackets [] from the test name.\n- strip_scenarios (bool): If True (default is False), strips out any content within parentheses () from the test name.\n\nReturns:\n- str: The cleaned test name without specified tags or scenarios.\n\nThe function utilizes the string methods `find` and slicing to locate and remove unwanted parts from the test name based on the specified parameters. There are no external constants or variables used within this function; its behavior is entirely dependent on the input string provided.",
        "signature": "def cleanup_test_name(name, strip_tags=True, strip_scenarios=False):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: stestr-test_utils\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 stestr/\n    \u2514\u2500\u2500 utils.py\n        \u2514\u2500\u2500 cleanup_test_name\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the sanitization and normalization of test identifiers by providing functionality to clean up and format test names. It allows for optional removal of attributes, scenarios, or both from the test identifiers, enabling users to obtain simplified or standardized test names depending on their requirements. This capability is particularly useful for streamlining test reporting, enhancing test result readability, and improving compatibility across different testing systems or frameworks. By addressing the need for consistent and customizable test name handling, the module solves a common issue developers face when managing and interpreting complex test outputs.\n\n## FILE 1: stestr/utils.py\n\n- FUNCTION NAME: cleanup_test_name\n  - SIGNATURE: def cleanup_test_name(name, strip_tags=True, strip_scenarios=False):\n  - DOCSTRING: \n```python\n\"\"\"\nClean up the provided test name for display by optionally removing tags and scenarios.\n\nParameters:\n- name (str): The original test name potentially containing tags and scenarios.\n- strip_tags (bool): If True (default), strips out any content within square brackets [] from the test name.\n- strip_scenarios (bool): If True (default is False), strips out any content within parentheses () from the test name.\n\nReturns:\n- str: The cleaned test name without specified tags or scenarios.\n\nThe function utilizes the string methods `find` and slicing to locate and remove unwanted parts from the test name based on the specified parameters. There are no external constants or variables used within this function; its behavior is entirely dependent on the input string provided.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "stestr/utils.py": "import io\nfrom stestr import output\n\ndef _iter_internal_streams(input_streams, stream_type):\n    streams = []\n    for in_stream in input_streams:\n        if in_stream[0] == stream_type:\n            streams.append(in_stream[1])\n    for stream_value in streams:\n        if isinstance(stream_value, output.ReturnCodeToSubunit):\n            if getattr(stream_value.source, 'detach', None):\n                yield stream_value.source.detach()\n            else:\n                yield stream_value.source\n        elif getattr(stream_value, 'read', None):\n            yield stream_value\n        else:\n            yield io.BytesIO(stream_value)\n\ndef iter_streams(input_streams, stream_type):\n    \"\"\"Iterate over all the streams of type stream_type.\n\n    :param stream_type: A simple string such as 'subunit' which matches\n        one of the stream types defined for the cmd object this UI is\n        being used with.\n    :return: A generator of stream objects. stream objects have a read\n        method and a close method which behave as for file objects.\n    \"\"\"\n    for stream_spec in input_streams:\n        _stream_spec = stream_spec[0]\n        if '*' in _stream_spec or '?' in _stream_spec or '+' in _stream_spec:\n            found = stream_type == _stream_spec[:-1]\n        else:\n            found = stream_type == _stream_spec\n        if found:\n            return _iter_internal_streams(input_streams, stream_type)\n    raise KeyError(stream_type)"
  },
  "call_tree": {
    "modified_testcases/test_utils.py:TestUtils:test_cleanup_test_name_defaults": {
      "stestr/utils.py:cleanup_test_name": {}
    },
    "modified_testcases/test_utils.py:TestUtils:test_cleanup_test_name_leave_attrs": {
      "stestr/utils.py:cleanup_test_name": {}
    },
    "modified_testcases/test_utils.py:TestUtils:test_cleanup_test_name_strip_scenario": {
      "stestr/utils.py:cleanup_test_name": {}
    },
    "modified_testcases/test_utils.py:TestUtils:test_cleanup_test_name_strip_scenario_and_attrs": {
      "stestr/utils.py:cleanup_test_name": {}
    }
  }
}