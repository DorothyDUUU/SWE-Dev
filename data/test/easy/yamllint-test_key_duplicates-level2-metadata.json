{
  "dir_path": "/app/yamllint",
  "package_name": "yamllint",
  "sample_name": "yamllint-test_key_duplicates",
  "src_dir": "yamllint/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/rules/test_key_duplicates.py",
  "test_code": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom tests.common import RuleTestCase\n\n\nclass KeyDuplicatesTestCase(RuleTestCase):\n    rule_id = 'key-duplicates'\n\n    def test_disabled(self):\n        conf = 'key-duplicates: disable'\n        self.check('---\\n'\n                   'block mapping:\\n'\n                   '  key: a\\n'\n                   '  otherkey: b\\n'\n                   '  key: c\\n', conf)\n        self.check('---\\n'\n                   'flow mapping:\\n'\n                   '  {key: a, otherkey: b, key: c}\\n', conf)\n        self.check('---\\n'\n                   'duplicated twice:\\n'\n                   '  - k: a\\n'\n                   '    ok: b\\n'\n                   '    k: c\\n'\n                   '    k: d\\n', conf)\n        self.check('---\\n'\n                   'duplicated twice:\\n'\n                   '  - {k: a, ok: b, k: c, k: d}\\n', conf)\n        self.check('---\\n'\n                   'multiple duplicates:\\n'\n                   '  a: 1\\n'\n                   '  b: 2\\n'\n                   '  c: 3\\n'\n                   '  d: 4\\n'\n                   '  d: 5\\n'\n                   '  b: 6\\n', conf)\n        self.check('---\\n'\n                   'multiple duplicates:\\n'\n                   '  {a: 1, b: 2, c: 3, d: 4, d: 5, b: 6}\\n', conf)\n        self.check('---\\n'\n                   'at: root\\n'\n                   'multiple: times\\n'\n                   'at: root\\n', conf)\n        self.check('---\\n'\n                   'nested but OK:\\n'\n                   '  a: {a: {a: 1}}\\n'\n                   '  b:\\n'\n                   '    b: 2\\n'\n                   '    c: 3\\n', conf)\n        self.check('---\\n'\n                   'nested duplicates:\\n'\n                   '  a: {a: 1, a: 1}\\n'\n                   '  b:\\n'\n                   '    c: 3\\n'\n                   '    d: 4\\n'\n                   '    d: 4\\n'\n                   '  b: 2\\n', conf)\n        self.check('---\\n'\n                   'duplicates with many styles: 1\\n'\n                   '\"duplicates with many styles\": 1\\n'\n                   '\\'duplicates with many styles\\': 1\\n'\n                   '? duplicates with many styles\\n'\n                   ': 1\\n'\n                   '? >-\\n'\n                   '    duplicates with\\n'\n                   '    many styles\\n'\n                   ': 1\\n', conf)\n        self.check('---\\n'\n                   'Merge Keys are OK:\\n'\n                   'anchor_one: &anchor_one\\n'\n                   '  one: one\\n'\n                   'anchor_two: &anchor_two\\n'\n                   '  two: two\\n'\n                   'anchor_reference:\\n'\n                   '  <<: *anchor_one\\n'\n                   '  <<: *anchor_two\\n', conf)\n        self.check('---\\n'\n                   '{a: 1, b: 2}}\\n', conf, problem=(2, 13, 'syntax'))\n        self.check('---\\n'\n                   '[a, b, c]]\\n', conf, problem=(2, 10, 'syntax'))\n\n    def test_enabled(self):\n        conf = 'key-duplicates: enable'\n        self.check('---\\n'\n                   'block mapping:\\n'\n                   '  key: a\\n'\n                   '  otherkey: b\\n'\n                   '  key: c\\n', conf,\n                   problem=(5, 3))\n        self.check('---\\n'\n                   'flow mapping:\\n'\n                   '  {key: a, otherkey: b, key: c}\\n', conf,\n                   problem=(3, 25))\n        self.check('---\\n'\n                   'duplicated twice:\\n'\n                   '  - k: a\\n'\n                   '    ok: b\\n'\n                   '    k: c\\n'\n                   '    k: d\\n', conf,\n                   problem1=(5, 5), problem2=(6, 5))\n        self.check('---\\n'\n                   'duplicated twice:\\n'\n                   '  - {k: a, ok: b, k: c, k: d}\\n', conf,\n                   problem1=(3, 19), problem2=(3, 25))\n        self.check('---\\n'\n                   'multiple duplicates:\\n'\n                   '  a: 1\\n'\n                   '  b: 2\\n'\n                   '  c: 3\\n'\n                   '  d: 4\\n'\n                   '  d: 5\\n'\n                   '  b: 6\\n', conf,\n                   problem1=(7, 3), problem2=(8, 3))\n        self.check('---\\n'\n                   'multiple duplicates:\\n'\n                   '  {a: 1, b: 2, c: 3, d: 4, d: 5, b: 6}\\n', conf,\n                   problem1=(3, 28), problem2=(3, 34))\n        self.check('---\\n'\n                   'at: root\\n'\n                   'multiple: times\\n'\n                   'at: root\\n', conf,\n                   problem=(4, 1))\n        self.check('---\\n'\n                   'nested but OK:\\n'\n                   '  a: {a: {a: 1}}\\n'\n                   '  b:\\n'\n                   '    b: 2\\n'\n                   '    c: 3\\n', conf)\n        self.check('---\\n'\n                   'nested duplicates:\\n'\n                   '  a: {a: 1, a: 1}\\n'\n                   '  b:\\n'\n                   '    c: 3\\n'\n                   '    d: 4\\n'\n                   '    d: 4\\n'\n                   '  b: 2\\n', conf,\n                   problem1=(3, 13), problem2=(7, 5), problem3=(8, 3))\n        self.check('---\\n'\n                   'duplicates with many styles: 1\\n'\n                   '\"duplicates with many styles\": 1\\n'\n                   '\\'duplicates with many styles\\': 1\\n'\n                   '? duplicates with many styles\\n'\n                   ': 1\\n'\n                   '? >-\\n'\n                   '    duplicates with\\n'\n                   '    many styles\\n'\n                   ': 1\\n', conf,\n                   problem1=(3, 1), problem2=(4, 1), problem3=(5, 3),\n                   problem4=(7, 3))\n        self.check('---\\n'\n                   'Merge Keys are OK:\\n'\n                   'anchor_one: &anchor_one\\n'\n                   '  one: one\\n'\n                   'anchor_two: &anchor_two\\n'\n                   '  two: two\\n'\n                   'anchor_reference:\\n'\n                   '  <<: *anchor_one\\n'\n                   '  <<: *anchor_two\\n', conf)\n        self.check('---\\n'\n                   '{a: 1, b: 2}}\\n', conf, problem=(2, 13, 'syntax'))\n        self.check('---\\n'\n                   '[a, b, c]]\\n', conf, problem=(2, 10, 'syntax'))\n\n    def test_key_tokens_in_flow_sequences(self):\n        conf = 'key-duplicates: enable'\n        self.check('---\\n'\n                   '[\\n'\n                   '  flow: sequence, with, key: value, mappings\\n'\n                   ']\\n', conf)\n\n    def test_forbid_duplicated_merge_keys(self):\n        conf = 'key-duplicates: {forbid-duplicated-merge-keys: true}'\n        self.check('---\\n'\n                   'Multiple Merge Keys are NOT OK:\\n'\n                   'anchor_one: &anchor_one\\n'\n                   '  one: one\\n'\n                   'anchor_two: &anchor_two\\n'\n                   '  two: two\\n'\n                   'anchor_reference:\\n'\n                   '  <<: *anchor_one\\n'\n                   '  <<: *anchor_two\\n', conf, problem=(9, 3))\n        self.check('---\\n'\n                   'Multiple Merge Keys are NOT OK:\\n'\n                   'anchor_one: &anchor_one\\n'\n                   '  one: one\\n'\n                   'anchor_two: &anchor_two\\n'\n                   '  two: two\\n'\n                   'anchor_three: &anchor_three\\n'\n                   '  two: three\\n'\n                   'anchor_reference:\\n'\n                   '  <<: *anchor_one\\n'\n                   '  <<: *anchor_two\\n'\n                   '  <<: *anchor_three\\n', conf,\n                   problem1=(11, 3), problem2=(12, 3))\n        self.check('---\\n'\n                   'Multiple Merge Keys are NOT OK:\\n'\n                   'anchor_one: &anchor_one\\n'\n                   '  one: one\\n'\n                   'anchor_two: &anchor_two\\n'\n                   '  two: two\\n'\n                   'anchor_reference:\\n'\n                   '  a: 1\\n'\n                   '  <<: *anchor_one\\n'\n                   '  b: 2\\n'\n                   '  <<: *anchor_two\\n', conf, problem=(11, 3))\n        self.check('---\\n'\n                   'Single Merge Key is OK:\\n'\n                   'anchor_one: &anchor_one\\n'\n                   '  one: one\\n'\n                   'anchor_two: &anchor_two\\n'\n                   '  two: two\\n'\n                   'anchor_reference:\\n'\n                   '  <<: [*anchor_one, *anchor_two]\\n', conf)\n        self.check('---\\n'\n                   'Duplicate keys without Merge Keys:\\n'\n                   '  key: a\\n'\n                   '  otherkey: b\\n'\n                   '  key: c\\n', conf,\n                   problem=(5, 3))\n        self.check('---\\n'\n                   'No Merge Keys:\\n'\n                   '  key: a\\n'\n                   '  otherkey: b\\n', conf)\n",
  "GT_file_code": {
    "yamllint/linter.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport io\nimport re\n\nimport yaml\n\nfrom yamllint import parser\n\nPROBLEM_LEVELS = {\n    0: None,\n    1: 'warning',\n    2: 'error',\n    None: 0,\n    'warning': 1,\n    'error': 2,\n}\n\nDISABLE_RULE_PATTERN = re.compile(r'^# yamllint disable( rule:\\S+)*\\s*$')\nENABLE_RULE_PATTERN = re.compile(r'^# yamllint enable( rule:\\S+)*\\s*$')\n\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n    def __init__(self, line, column, desc='<no description>', rule=None):\n        #: Line on which the problem was found (starting at 1)\n        self.line = line\n        #: Column on which the problem was found (starting at 1)\n        self.column = column\n        #: Human-readable description of the problem\n        self.desc = desc\n        #: Identifier of the rule that detected the problem\n        self.rule = rule\n        self.level = None\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __eq__(self, other):\n        return (self.line == other.line and\n                self.column == other.column and\n                self.rule == other.rule)\n\n    def __lt__(self, other):\n        return (self.line < other.line or\n                (self.line == other.line and self.column < other.column))\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n\n    # Split token rules from line rules\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if re.match(r'^# yamllint disable-line( rule:\\S+)*\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n    # Use a cache to store problems and flush it only when an end of line is\n    # found. This allows the use of yamllint directive to disable some rules on\n    # some lines.\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf,\n                                          elem.curr, elem.prev, elem.next,\n                                          elem.nextnext,\n                                          context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            # This is the last token/comment/line of this line, let's flush the\n            # problems found (but filter them according to the directives)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or\n                        disabled.is_disabled_by_directive(problem)):\n                    yield problem\n\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1,\n                              e.problem_mark.column + 1,\n                              'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem\n\n\ndef _run(buffer, conf, filepath):\n    assert hasattr(buffer, '__getitem__'), \\\n        '_run() argument must be a buffer, not a stream'\n\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match(r'^#\\s*yamllint disable-file\\s*$', first_line):\n        return\n\n    # If the document contains a syntax error, save it and yield it at the\n    # right line\n    syntax_error = get_syntax_error(buffer)\n\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        # Insert the syntax error (if any) at the right place...\n        if (syntax_error and syntax_error.line <= problem.line and\n                syntax_error.column <= problem.column):\n            yield syntax_error\n\n            # Discard the problem since it is at the same place as the syntax\n            # error and is probably redundant (and maybe it's just a 'warning',\n            # in which case the script won't even exit with a failure status).\n            syntax_error = None\n            continue\n\n        yield problem\n\n    if syntax_error:\n        yield syntax_error\n\n\ndef run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source.\n\n    Returns a generator of LintProblem objects.\n\n    :param input: buffer, string or stream to read from\n    :param conf: yamllint configuration object\n    \"\"\"\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        # We need to have everything in memory to parse correctly\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')\n",
    "yamllint/parser.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport yaml\n\n\nclass Line:\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\n\nclass Token:\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\n\nclass Comment:\n    def __init__(self, line_no, column_no, buffer, pointer,\n                 token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\0', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return (isinstance(other, Comment) and\n                self.line_no == other.line_no and\n                self.column_no == other.column_no and\n                str(self) == str(other))\n\n    def is_inline(self):\n        return (\n            not isinstance(self.token_before, yaml.StreamStartToken) and\n            self.line_no == self.token_before.end_mark.line + 1 and\n            # sometimes token end marks are on the next line\n            self.buffer[self.token_before.end_mark.pointer - 1] != '\\n'\n        )\n\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif (token1.end_mark.line == token2.start_mark.line and\n          not isinstance(token1, yaml.StreamStartToken) and\n          not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:\n                                     token2.start_mark.pointer]\n\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos,\n                              token1.end_mark.buffer, pointer + pos,\n                              token1, token2, comment_before)\n            yield comment\n\n            comment_before = comment\n\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = (yaml_loader.peek_token()\n                        if yaml_loader.check_token() else None)\n\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n\n            yield from comments_between_tokens(curr, next)\n\n            prev = curr\n            curr = next\n\n    except yaml.scanner.ScannerError:\n        pass\n\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and\n                                  tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)\n"
  },
  "GT_src_dict": {
    "yamllint/linter.py": {
      "LintProblem.__init__": {
        "code": "    def __init__(self, line, column, desc='<no description>', rule=None):\n        \"\"\"Initializes a LintProblem, representing a linting issue found by yamllint.\n\nParameters:\n- line (int): The line number (starting from 1) where the problem was detected.\n- column (int): The column number (starting from 1) where the problem was detected.\n- desc (str, optional): A human-readable description of the problem (default is '<no description>').\n- rule (str, optional): The identifier of the linting rule that detected the problem (default is None).\n\nAttributes:\n- level (int, optional): This will store the severity level of the problem, which can be referenced through the PROBLEM_LEVELS constant defined outside the class.\"\"\"\n        self.line = line\n        self.column = column\n        self.desc = desc\n        self.rule = rule\n        self.level = None",
        "docstring": "Initializes a LintProblem, representing a linting issue found by yamllint.\n\nParameters:\n- line (int): The line number (starting from 1) where the problem was detected.\n- column (int): The column number (starting from 1) where the problem was detected.\n- desc (str, optional): A human-readable description of the problem (default is '<no description>').\n- rule (str, optional): The identifier of the linting rule that detected the problem (default is None).\n\nAttributes:\n- level (int, optional): This will store the severity level of the problem, which can be referenced through the PROBLEM_LEVELS constant defined outside the class.",
        "signature": "def __init__(self, line, column, desc='<no description>', rule=None):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks for equality between two LintProblem instances.\n\nThis method compares the line number, column number, and rule identifier of the current instance with another LintProblem instance. If both instances have the same line and column values and the same rule, they are considered equal.\n\nParameters:\n- other (LintProblem): The LintProblem instance to compare against.\n\nReturns:\n- bool: True if the instances are equal, otherwise False.\n\nThis method interacts with the attributes `line`, `column`, and `rule` defined in the LintProblem class, which are essential for identifying specific linting issues in YAML files.\"\"\"\n        return self.line == other.line and self.column == other.column and (self.rule == other.rule)",
        "docstring": "Checks for equality between two LintProblem instances.\n\nThis method compares the line number, column number, and rule identifier of the current instance with another LintProblem instance. If both instances have the same line and column values and the same rule, they are considered equal.\n\nParameters:\n- other (LintProblem): The LintProblem instance to compare against.\n\nReturns:\n- bool: True if the instances are equal, otherwise False.\n\nThis method interacts with the attributes `line`, `column`, and `rule` defined in the LintProblem class, which are essential for identifying specific linting issues in YAML files.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__lt__": {
        "code": "    def __lt__(self, other):\n        \"\"\"Compares two LintProblem instances based on their line and column attributes for sorting purposes.\n\nParameters:\n- other (LintProblem): The other LintProblem instance to compare against.\n\nReturns:\n- bool: True if the current instance is less than the other based on its line number, or if they are on the same line and the current instance's column number is less than the other's; otherwise, returns False.\n\nThis method is essential for sorting LintProblem objects, ensuring that problems are ordered first by their line in the YAML document and then by their position within the line. It interacts directly with the 'line' and 'column' attributes of the LintProblem class, which represent the exact location of a linting issue within the analyzed YAML content.\"\"\"\n        return self.line < other.line or (self.line == other.line and self.column < other.column)",
        "docstring": "Compares two LintProblem instances based on their line and column attributes for sorting purposes.\n\nParameters:\n- other (LintProblem): The other LintProblem instance to compare against.\n\nReturns:\n- bool: True if the current instance is less than the other based on its line number, or if they are on the same line and the current instance's column number is less than the other's; otherwise, returns False.\n\nThis method is essential for sorting LintProblem objects, ensuring that problems are ordered first by their line in the YAML document and then by their position within the line. It interacts directly with the 'line' and 'column' attributes of the LintProblem class, which represent the exact location of a linting issue within the analyzed YAML content.",
        "signature": "def __lt__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "_run": {
        "code": "def _run(buffer, conf, filepath):\n    \"\"\"Runs the linting process on a YAML source buffer, checking for syntax errors and cosmetic problems according to the provided configuration.\n\n:param buffer: A buffer object (should support item access) containing the YAML source to be processed.\n:param conf: A configuration object that specifies the linting rules to apply.\n:param filepath: An optional string that specifies the path of the YAML file, used for file-specific configurations.\n\n:yield: LintProblem objects representing detected linting issues. If a syntax error is encountered, it is yielded in place of any subsequent cosmetic problems at the same line.\n\n:raises AssertionError: If the buffer does not support item access, indicating that a stream is not allowed.\n\nThis function relies on other components in the code, such as `get_cosmetic_problems` to gather cosmetic issues, and `get_syntax_error` to check for syntax errors within the buffer. The first line of the buffer is checked for a disabling directive (`# yamllint disable-file`), which, if present, will terminate further processing.\"\"\"\n    assert hasattr(buffer, '__getitem__'), '_run() argument must be a buffer, not a stream'\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match('^#\\\\s*yamllint disable-file\\\\s*$', first_line):\n        return\n    syntax_error = get_syntax_error(buffer)\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        if syntax_error and syntax_error.line <= problem.line and (syntax_error.column <= problem.column):\n            yield syntax_error\n            syntax_error = None\n            continue\n        yield problem\n    if syntax_error:\n        yield syntax_error",
        "docstring": "Runs the linting process on a YAML source buffer, checking for syntax errors and cosmetic problems according to the provided configuration.\n\n:param buffer: A buffer object (should support item access) containing the YAML source to be processed.\n:param conf: A configuration object that specifies the linting rules to apply.\n:param filepath: An optional string that specifies the path of the YAML file, used for file-specific configurations.\n\n:yield: LintProblem objects representing detected linting issues. If a syntax error is encountered, it is yielded in place of any subsequent cosmetic problems at the same line.\n\n:raises AssertionError: If the buffer does not support item access, indicating that a stream is not allowed.\n\nThis function relies on other components in the code, such as `get_cosmetic_problems` to gather cosmetic issues, and `get_syntax_error` to check for syntax errors within the buffer. The first line of the buffer is checked for a disabling directive (`# yamllint disable-file`), which, if present, will terminate further processing.",
        "signature": "def _run(buffer, conf, filepath):",
        "type": "Function",
        "class_signature": null
      },
      "run": {
        "code": "def run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source by checking it against specified rules and returning any linting problems encountered.\n\n:param input: A buffer, string, or stream containing YAML data to be linted.\n:param conf: A configuration object for yamllint that specifies the rules to apply.\n:param filepath: Optional; the path to the YAML file being linted, used to determine if the file is ignored by the configuration.\n\nReturns a generator of LintProblem objects representing any linting issues discovered. Before linting, the function checks if the file is ignored based on the configuration using the `is_file_ignored` method of the `conf` object. The function detects both string and stream inputs and ensures the content is parsed correctly in memory for linting. If the input type is invalid, a TypeError is raised.\"\"\"\n    'Lints a YAML source.\\n\\n    Returns a generator of LintProblem objects.\\n\\n    :param input: buffer, string or stream to read from\\n    :param conf: yamllint configuration object\\n    '\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')",
        "docstring": "Lints a YAML source by checking it against specified rules and returning any linting problems encountered.\n\n:param input: A buffer, string, or stream containing YAML data to be linted.\n:param conf: A configuration object for yamllint that specifies the rules to apply.\n:param filepath: Optional; the path to the YAML file being linted, used to determine if the file is ignored by the configuration.\n\nReturns a generator of LintProblem objects representing any linting issues discovered. Before linting, the function checks if the file is ignored based on the configuration using the `is_file_ignored` method of the `conf` object. The function detects both string and stream inputs and ensures the content is parsed correctly in memory for linting. If the input type is invalid, a TypeError is raised.",
        "signature": "def run(input, conf, filepath=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "yamllint/parser.py": {}
  },
  "dependency_dict": {
    "yamllint/linter.py:run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:_run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      },
      "yamllint/parser.py": {
        "Line.content": {
          "code": "    def content(self):\n        return self.buffer[self.start:self.end]",
          "docstring": "",
          "signature": "def content(self):",
          "type": "Method",
          "class_signature": "class Line:"
        },
        "line_generator": {
          "code": "def line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))",
          "docstring": "",
          "signature": "def line_generator(buffer):",
          "type": "Function",
          "class_signature": null
        }
      },
      "yamllint/linter.py": {
        "get_cosmetic_problems": {
          "code": "def get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []",
          "docstring": "",
          "signature": "def get_cosmetic_problems(buffer, conf, filepath):",
          "type": "Function",
          "class_signature": null
        },
        "get_syntax_error": {
          "code": "def get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
          "docstring": "",
          "signature": "def get_syntax_error(buffer):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "yamllint/linter.py:LintProblem:__init__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__eq__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__lt__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    }
  },
  "call_tree": {
    "modified_testcases/rules/test_key_duplicates.py:KeyDuplicatesTestCase:test_disabled": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {
                "yamllint/config.py:YamlLintConfig:YamlLintConfig": {}
              }
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {
            "yamllint/linter.py:LintProblem:__init__": {}
          },
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_key_duplicates.py:KeyDuplicatesTestCase:test_enabled": {
      "tests/common.py:RuleTestCase:check": {
        "yamllint/linter.py:LintProblem:__init__": {},
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {
            "yamllint/linter.py:LintProblem:__init__": {}
          },
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {},
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__eq__": {},
        "yamllint/linter.py:LintProblem:__lt__": {}
      }
    },
    "modified_testcases/rules/test_key_duplicates.py:KeyDuplicatesTestCase:test_forbid_duplicated_merge_keys": {
      "tests/common.py:RuleTestCase:check": {
        "yamllint/linter.py:LintProblem:__init__": {},
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {},
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__eq__": {},
        "yamllint/linter.py:LintProblem:__lt__": {}
      }
    },
    "modified_testcases/rules/test_key_duplicates.py:KeyDuplicatesTestCase:test_key_tokens_in_flow_sequences": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {}
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {
              "yamllint/rules/common.py:spaces_after": {},
              "yamllint/rules/common.py:spaces_before": {}
            },
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/indentation.py:detect_indent": {},
                "yamllint/rules/common.py:is_explicit_key": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {}
          }
        }
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_key_duplicates/yamllint-test_key_duplicates/tests/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_key_duplicates/yamllint-test_key_duplicates/modified_testcases/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    }
  },
  "PRD": "# PROJECT NAME: yamllint-test_key_duplicates\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamllint/\n    \u251c\u2500\u2500 linter.py\n    \u2502   \u251c\u2500\u2500 LintProblem.__eq__\n    \u2502   \u251c\u2500\u2500 LintProblem.__init__\n    \u2502   \u251c\u2500\u2500 LintProblem.__lt__\n    \u2502   \u251c\u2500\u2500 _run\n    \u2502   \u2514\u2500\u2500 run\n    \u2514\u2500\u2500 parser.py\n        \u2514\u2500\u2500 Comment.Comment\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate YAML files by detecting and addressing duplicate keys within mappings. Its primary functionality is to ensure that YAML structures conform to best practices and are devoid of key duplication errors that could lead to application misbehavior or data inconsistencies. It offers configurable options to enable or disable duplicate key detection, distinguish between permissible and impermissible cases (e.g., handling merge keys), and identify errors at specific locations within the YAML. This module solves the problem of ensuring YAML file integrity, providing developers with a reliable tool to enforce correct and predictable configuration file behavior.\n\n## FILE 1: yamllint/linter.py\n\n- FUNCTION NAME: run\n  - SIGNATURE: def run(input, conf, filepath=None):\n  - DOCSTRING: \n```python\n\"\"\"\nLints a YAML source by checking it against specified rules and returning any linting problems encountered.\n\n:param input: A buffer, string, or stream containing YAML data to be linted.\n:param conf: A configuration object for yamllint that specifies the rules to apply.\n:param filepath: Optional; the path to the YAML file being linted, used to determine if the file is ignored by the configuration.\n\nReturns a generator of LintProblem objects representing any linting issues discovered. Before linting, the function checks if the file is ignored based on the configuration using the `is_file_ignored` method of the `conf` object. The function detects both string and stream inputs and ensures the content is parsed correctly in memory for linting. If the input type is invalid, a TypeError is raised.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n\n- CLASS METHOD: LintProblem.__init__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __init__(self, line, column, desc='<no description>', rule=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a LintProblem, representing a linting issue found by yamllint.\n\nParameters:\n- line (int): The line number (starting from 1) where the problem was detected.\n- column (int): The column number (starting from 1) where the problem was detected.\n- desc (str, optional): A human-readable description of the problem (default is '<no description>').\n- rule (str, optional): The identifier of the linting rule that detected the problem (default is None).\n\nAttributes:\n- level (int, optional): This will store the severity level of the problem, which can be referenced through the PROBLEM_LEVELS constant defined outside the class.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__eq__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks for equality between two LintProblem instances.\n\nThis method compares the line number, column number, and rule identifier of the current instance with another LintProblem instance. If both instances have the same line and column values and the same rule, they are considered equal.\n\nParameters:\n- other (LintProblem): The LintProblem instance to compare against.\n\nReturns:\n- bool: True if the instances are equal, otherwise False.\n\nThis method interacts with the attributes `line`, `column`, and `rule` defined in the LintProblem class, which are essential for identifying specific linting issues in YAML files.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__lt__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __lt__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nCompares two LintProblem instances based on their line and column attributes for sorting purposes.\n\nParameters:\n- other (LintProblem): The other LintProblem instance to compare against.\n\nReturns:\n- bool: True if the current instance is less than the other based on its line number, or if they are on the same line and the current instance's column number is less than the other's; otherwise, returns False.\n\nThis method is essential for sorting LintProblem objects, ensuring that problems are ordered first by their line in the YAML document and then by their position within the line. It interacts directly with the 'line' and 'column' attributes of the LintProblem class, which represent the exact location of a linting issue within the analyzed YAML content.\n\"\"\"\n```\n\n- FUNCTION NAME: _run\n  - SIGNATURE: def _run(buffer, conf, filepath):\n  - DOCSTRING: \n```python\n\"\"\"\nRuns the linting process on a YAML source buffer, checking for syntax errors and cosmetic problems according to the provided configuration.\n\n:param buffer: A buffer object (should support item access) containing the YAML source to be processed.\n:param conf: A configuration object that specifies the linting rules to apply.\n:param filepath: An optional string that specifies the path of the YAML file, used for file-specific configurations.\n\n:yield: LintProblem objects representing detected linting issues. If a syntax error is encountered, it is yielded in place of any subsequent cosmetic problems at the same line.\n\n:raises AssertionError: If the buffer does not support item access, indicating that a stream is not allowed.\n\nThis function relies on other components in the code, such as `get_cosmetic_problems` to gather cosmetic issues, and `get_syntax_error` to check for syntax errors within the buffer. The first line of the buffer is checked for a disabling directive (`# yamllint disable-file`), which, if present, will terminate further processing.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n    - yamllint/parser.py:Line:content\n    - yamllint/parser.py:line_generator\n    - yamllint/linter.py:get_cosmetic_problems\n    - yamllint/linter.py:get_syntax_error\n\n## FILE 2: yamllint/parser.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamllint/linter.py": "import io\nimport re\nimport yaml\nfrom yamllint import parser\nPROBLEM_LEVELS = {0: None, 1: 'warning', 2: 'error', None: 0, 'warning': 1, 'error': 2}\nDISABLE_RULE_PATTERN = re.compile('^# yamllint disable( rule:\\\\S+)*\\\\s*$')\nENABLE_RULE_PATTERN = re.compile('^# yamllint enable( rule:\\\\S+)*\\\\s*$')\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
    "yamllint/parser.py": "import yaml\n\nclass Line:\n\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\nclass Token:\n\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\nclass Comment:\n\n    def __init__(self, line_no, column_no, buffer, pointer, token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\x00', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return isinstance(other, Comment) and self.line_no == other.line_no and (self.column_no == other.column_no) and (str(self) == str(other))\n\n    def is_inline(self):\n        return not isinstance(self.token_before, yaml.StreamStartToken) and self.line_no == self.token_before.end_mark.line + 1 and (self.buffer[self.token_before.end_mark.pointer - 1] != '\\n')\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif token1.end_mark.line == token2.start_mark.line and (not isinstance(token1, yaml.StreamStartToken)) and (not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:token2.start_mark.pointer]\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos, token1.end_mark.buffer, pointer + pos, token1, token2, comment_before)\n            yield comment\n            comment_before = comment\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = yaml_loader.peek_token() if yaml_loader.check_token() else None\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n            yield from comments_between_tokens(curr, next)\n            prev = curr\n            curr = next\n    except yaml.scanner.ScannerError:\n        pass\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)"
  }
}