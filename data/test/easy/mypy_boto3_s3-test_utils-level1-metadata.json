{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_utils",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/writers/test_utils.py",
  "test_code": "from pathlib import Path\nfrom unittest.mock import MagicMock, patch\n\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData\nfrom mypy_boto3_builder.service_name import ServiceNameCatalog\nfrom mypy_boto3_builder.structures.package import Package\nfrom mypy_boto3_builder.writers.utils import (\n    format_md,\n    insert_md_toc,\n    render_jinja2_package_template,\n)\n\n\nclass TestUtils:\n    @patch(\"mypy_boto3_builder.writers.utils.render_jinja2_template\")\n    def test_render_jinja2_package_template(self, render_jinja2_template_mock: MagicMock) -> None:\n        template_path = Path(\"template.jinja2\")\n        package = Package(Boto3StubsPackageData, [ServiceNameCatalog.ec2, ServiceNameCatalog.s3])\n        result = render_jinja2_package_template(template_path, package)\n        render_jinja2_template_mock.assert_called_once_with(\n            template_path,\n            {\"package\": package, \"service_name\": None},\n        )\n        assert result == render_jinja2_template_mock()\n        render_jinja2_template_mock.reset_mock()\n\n        package = Package(Boto3StubsPackageData, [ServiceNameCatalog.s3])\n        result = render_jinja2_package_template(template_path, package)\n        render_jinja2_template_mock.assert_called_once_with(\n            template_path,\n            {\"package\": package, \"service_name\": ServiceNameCatalog.s3},\n        )\n        render_jinja2_template_mock.reset_mock()\n\n        package = Package(Boto3StubsPackageData, [])\n        result = render_jinja2_package_template(template_path, package)\n        render_jinja2_template_mock.assert_called_once_with(\n            template_path,\n            {\"package\": package, \"service_name\": None},\n        )\n\n    def test_insert_md_toc(self) -> None:\n        assert (\n            insert_md_toc(\"# a\\ntest\\n## b\\n## c\\ntest2\")\n            == \"# a\\ntest\\n- [a](#a)\\n  - [b](#b)\\n  - [c](#c)\\n\\n## b\\n## c\\ntest2\"\n        )\n        assert insert_md_toc(\"# a\\n\") == \"# a\\n- [a](#a)\\n\"\n\n    def test_format_md(self) -> None:\n        assert format_md(\" # a\") == \"# a\\n\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/writers/utils.py": "\"\"\"\nJinja2 renderer and formatters.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom pathlib import Path\n\nimport mdformat\n\nfrom mypy_boto3_builder.structures.package import Package\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\nfrom mypy_boto3_builder.utils.markdown import TableOfContents\n\n\ndef render_jinja2_package_template(template_path: Path, package: Package) -> str:\n    \"\"\"\n    Render Jinja2 package template to a string.\n\n    Arguments:\n        template_path -- Relative path to template in `TEMPLATES_PATH`\n        package -- Service or wrapper package\n\n    Returns:\n        A rendered template.\n    \"\"\"\n    return render_jinja2_template(\n        template_path,\n        {\n            \"package\": package,\n            \"service_name\": package.service_name if len(package.service_names) == 1 else None,\n        },\n    )\n\n\ndef insert_md_toc(text: str) -> str:\n    \"\"\"\n    Insert Table of Contents before the first second-level header.\n    \"\"\"\n    toc = TableOfContents.parse(text)\n    toc_lines = toc.render().splitlines()\n    lines = text.splitlines()\n    result: list[str] = []\n    inserted = False\n    for line in lines:\n        if not inserted and line.startswith(\"## \"):\n            result.extend(toc_lines)\n            result.append(\"\")\n            inserted = True\n\n        result.append(line)\n\n    if not inserted:\n        result.extend(toc_lines)\n        result.append(\"\")\n\n    return \"\\n\".join(result)\n\n\ndef format_md(text: str) -> str:\n    \"\"\"\n    Format MarkDown with mdformat.\n    \"\"\"\n    return mdformat.text(  # type: ignore\n        text,\n        options={\n            \"wrap\": 79,\n            \"number\": True,\n        },\n    )\n",
    "mypy_boto3_builder/structures/package.py": "\"\"\"\nParent class for all package structures.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable\n\nfrom packaging.version import InvalidVersion, Version\n\nfrom mypy_boto3_builder.constants import SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.package_data import BasePackageData\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.package_url import PackageURL\nfrom mypy_boto3_builder.utils.version import (\n    get_max_build_version,\n    get_min_build_version,\n)\n\n\nclass Package:\n    \"\"\"\n    Parent class for all package structures.\n    \"\"\"\n\n    def __init__(\n        self,\n        data: type[BasePackageData],\n        service_names: Iterable[ServiceName] = (),\n        version: str = \"\",\n    ) -> None:\n        self.data = data\n        self._pypi_name = self.data.PYPI_NAME\n        self.library_version = data.get_library_version()\n        self.botocore_version = data.get_botocore_version()\n        self._version: str = \"\"\n        if version:\n            self.version = version\n        self.service_names = tuple(service_names)\n        self.logger = get_logger()\n        self.url = PackageURL(self.pypi_name, self.data)\n\n    @property\n    def pypi_name(self) -> str:\n        \"\"\"\n        PyPI package name.\n        \"\"\"\n        return self._pypi_name\n\n    @pypi_name.setter\n    def pypi_name(self, value: str) -> None:\n        self._pypi_name = value\n        self.url.pypi_name = value\n\n    @property\n    def version(self) -> str:\n        \"\"\"\n        Package version.\n        \"\"\"\n        if not self._version:\n            raise StructureError(f\"Version is not set for {self.pypi_name}\")\n        return self._version\n\n    @version.setter\n    def version(self, value: str) -> None:\n        try:\n            Version(value)\n        except InvalidVersion:\n            raise StructureError(f\"Invalid version: {value}\") from None\n        self._version = value\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Package name.\n        \"\"\"\n        if not self.data.NAME:\n            raise StructureError(f\"Package name is not set for {self.pypi_name}\")\n\n        return self.data.NAME\n\n    @property\n    def library_name(self) -> str:\n        \"\"\"\n        PyPI library package name.\n        \"\"\"\n        return self.data.LIBRARY_NAME\n\n    def has_main_package(self) -> bool:\n        \"\"\"\n        Check if package has main package.\n        \"\"\"\n        return bool(self.data.NAME)\n\n    @property\n    def service_name(self) -> ServiceName:\n        \"\"\"\n        Service name for the package.\n        \"\"\"\n        if len(self.service_names) != 1:\n            raise StructureError(f\"Package {self.name} has more than one service name\")\n        return self.service_names[0]\n\n    @property\n    def directory_name(self) -> str:\n        \"\"\"\n        Directory name to store generated package.\n        \"\"\"\n        underscore_package_name = self.pypi_name.replace(\"-\", \"_\")\n        return f\"{underscore_package_name}_package\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get string representation for debugging.\n        \"\"\"\n        return f\"{self.name} {self._version} ({self.library_name} {self.library_version})\"\n\n    def get_local_doc_link(self, service_name: ServiceName | None = None) -> str:\n        \"\"\"\n        Get link to local docs.\n        \"\"\"\n        url = self.data.LOCAL_DOC_LINK\n        if service_name:\n            url = f\"{url}{self.get_module_name(service_name)}/\"\n        return url\n\n    def get_module_name(self, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service module name.\n        \"\"\"\n        return self.data.get_service_package_name(service_name)\n\n    def get_service_pypi_name(self, service_name: ServiceName) -> str:\n        \"\"\"\n        Get PyPI package name for a service package.\n        \"\"\"\n        return self.data.get_service_pypi_name(service_name)\n\n    @property\n    def min_library_version(self) -> str:\n        \"\"\"\n        Minimum required library version.\n        \"\"\"\n        return get_min_build_version(self.library_version)\n\n    @property\n    def max_library_version(self) -> str:\n        \"\"\"\n        Minimum required library version.\n        \"\"\"\n        return get_max_build_version(self.library_version)\n\n    @property\n    def min_python_version(self) -> str:\n        \"\"\"\n        Minimum required python version.\n        \"\"\"\n        min_version = min(SUPPORTED_PY_VERSIONS)\n        return \".\".join(str(i) for i in min_version)\n\n    def get_classifiers(self) -> list[str]:\n        \"\"\"\n        Get classifiers for package.\n        \"\"\"\n        result = [\n            \"Development Status :: 5 - Production/Stable\",\n            \"Intended Audience :: Developers\",\n            \"Environment :: Console\",\n            \"License :: OSI Approved :: MIT License\",\n            \"Natural Language :: English\",\n            \"Operating System :: OS Independent\",\n        ]\n        major_versions = {version[0] for version in SUPPORTED_PY_VERSIONS}\n        for major in sorted(major_versions):\n            result.append(f\"Programming Language :: Python :: {major}\")\n            minor_versions = {\n                version[1]\n                for version in SUPPORTED_PY_VERSIONS\n                if version[0] == major and len(version) > 1\n            }\n            result.extend(\n                f\"Programming Language :: Python :: {major}.{minor}\"\n                for minor in sorted(minor_versions)\n            )\n        if len(major_versions) == 1:\n            major = next(iter(major_versions))\n            result.append(f\"Programming Language :: Python :: {major} :: Only\")\n        result.extend(\n            (\n                \"Programming Language :: Python :: Implementation :: CPython\",\n                \"Typing :: Stubs Only\",\n            ),\n        )\n        return result\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/writers/utils.py": {
      "render_jinja2_package_template": {
        "code": "def render_jinja2_package_template(template_path: Path, package: Package) -> str:\n    \"\"\"Render a Jinja2 template using the provided package data.\n\nThis function takes a template path and a `Package` object, rendering the template with relevant data, including the package itself and its service name if applicable.\n\nParameters:\n    template_path (Path): A relative path to the Jinja2 template file located in the `TEMPLATES_PATH`.\n    package (Package): An instance of the `Package` class that represents a service or wrapper package.\n\nReturns:\n    str: A string containing the rendered template.\n\nThe function utilizes `render_jinja2_template`, which is responsible for processing the template with the provided context. The context includes the `package` and optionally the `service_name`, which is set only if there is a single service name present in the package's attributes.\"\"\"\n    '\\n    Render Jinja2 package template to a string.\\n\\n    Arguments:\\n        template_path -- Relative path to template in `TEMPLATES_PATH`\\n        package -- Service or wrapper package\\n\\n    Returns:\\n        A rendered template.\\n    '\n    return render_jinja2_template(template_path, {'package': package, 'service_name': package.service_name if len(package.service_names) == 1 else None})",
        "docstring": "Render a Jinja2 template using the provided package data.\n\nThis function takes a template path and a `Package` object, rendering the template with relevant data, including the package itself and its service name if applicable.\n\nParameters:\n    template_path (Path): A relative path to the Jinja2 template file located in the `TEMPLATES_PATH`.\n    package (Package): An instance of the `Package` class that represents a service or wrapper package.\n\nReturns:\n    str: A string containing the rendered template.\n\nThe function utilizes `render_jinja2_template`, which is responsible for processing the template with the provided context. The context includes the `package` and optionally the `service_name`, which is set only if there is a single service name present in the package's attributes.",
        "signature": "def render_jinja2_package_template(template_path: Path, package: Package) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "insert_md_toc": {
        "code": "def insert_md_toc(text: str) -> str:\n    \"\"\"Insert a Table of Contents (ToC) into the provided Markdown text before the first second-level header (##). The ToC is generated from the headers present in the input text.\n\nParameters:\n- text (str): The Markdown text in which the ToC will be inserted.\n\nReturns:\n- str: The Markdown text with the inserted ToC. If no second-level header exists, the ToC will be appended at the end of the text.\n\nDependencies:\n- TableOfContents: A class imported from the `mypy_boto3_builder.utils.markdown` module, which is utilized to parse the input text for headers and render the ToC. This interaction facilitates the generation of a structured ToC based on the content of the Markdown.\"\"\"\n    '\\n    Insert Table of Contents before the first second-level header.\\n    '\n    toc = TableOfContents.parse(text)\n    toc_lines = toc.render().splitlines()\n    lines = text.splitlines()\n    result: list[str] = []\n    inserted = False\n    for line in lines:\n        if not inserted and line.startswith('## '):\n            result.extend(toc_lines)\n            result.append('')\n            inserted = True\n        result.append(line)\n    if not inserted:\n        result.extend(toc_lines)\n        result.append('')\n    return '\\n'.join(result)",
        "docstring": "Insert a Table of Contents (ToC) into the provided Markdown text before the first second-level header (##). The ToC is generated from the headers present in the input text.\n\nParameters:\n- text (str): The Markdown text in which the ToC will be inserted.\n\nReturns:\n- str: The Markdown text with the inserted ToC. If no second-level header exists, the ToC will be appended at the end of the text.\n\nDependencies:\n- TableOfContents: A class imported from the `mypy_boto3_builder.utils.markdown` module, which is utilized to parse the input text for headers and render the ToC. This interaction facilitates the generation of a structured ToC based on the content of the Markdown.",
        "signature": "def insert_md_toc(text: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "format_md": {
        "code": "def format_md(text: str) -> str:\n    \"\"\"Format Markdown text using the `mdformat` package.\n\nArguments:\n    text -- A string containing Markdown text to format.\n\nReturns:\n    A formatted string where the Markdown text is styled according to the options specified.\n\nThe function uses `mdformat.text` with options to wrap text at 79 characters and number the lines, enhancing the readability and structure of the Markdown output. The `mdformat` package is imported at the beginning of the code and is essential for the formatting functionality provided by this function.\"\"\"\n    '\\n    Format MarkDown with mdformat.\\n    '\n    return mdformat.text(text, options={'wrap': 79, 'number': True})",
        "docstring": "Format Markdown text using the `mdformat` package.\n\nArguments:\n    text -- A string containing Markdown text to format.\n\nReturns:\n    A formatted string where the Markdown text is styled according to the options specified.\n\nThe function uses `mdformat.text` with options to wrap text at 79 characters and number the lines, enhancing the readability and structure of the Markdown output. The `mdformat` package is imported at the beginning of the code and is essential for the formatting functionality provided by this function.",
        "signature": "def format_md(text: str) -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/structures/package.py": {
      "Package.__init__": {
        "code": "    def __init__(self, data: type[BasePackageData], service_names: Iterable[ServiceName]=(), version: str='') -> None:\n        \"\"\"Initialize a Package instance.\n\nThis constructor initializes a Package object with essential metadata required for package management. It sets the data type for the package, retrieves the package's PyPI name, library version, and botocore version, and assigns the service names and optional version. It also initializes a logger and constructs a PackageURL object for the package.\n\nParameters:\n- data (type[BasePackageData]): A class type that contains package data, specifying attributes like PYPI_NAME, library version, and botocore version.\n- service_names (Iterable[ServiceName], optional): An iterable of ServiceName instances associated with the package. Defaults to an empty tuple.\n- version (str, optional): A string representing the package version. Defaults to an empty string.\n\nAttributes initialized:\n- self.data: Stores the package data class type.\n- self._pypi_name: Holds the PyPI name extracted from the data class.\n- self.library_version: Version of the library obtained from the data class.\n- self.botocore_version: Version of botocore retrieved from the data class.\n- self._version: Internal variable to store the package version, initialized as an empty string.\n- self.service_names: A tuple of service names passed during initialization.\n- self.logger: Logger instance obtained from the get_logger function.\n- self.url: A PackageURL instance initialized with the PyPI name and data.\n\nDependencies:\n- Requires the BasePackageData class for package data structure.\n- Uses the PackageURL class for constructing the package's URL.\n- Retrieves logging functionality from the get_logger function.\"\"\"\n        self.data = data\n        self._pypi_name = self.data.PYPI_NAME\n        self.library_version = data.get_library_version()\n        self.botocore_version = data.get_botocore_version()\n        self._version: str = ''\n        if version:\n            self.version = version\n        self.service_names = tuple(service_names)\n        self.logger = get_logger()\n        self.url = PackageURL(self.pypi_name, self.data)",
        "docstring": "Initialize a Package instance.\n\nThis constructor initializes a Package object with essential metadata required for package management. It sets the data type for the package, retrieves the package's PyPI name, library version, and botocore version, and assigns the service names and optional version. It also initializes a logger and constructs a PackageURL object for the package.\n\nParameters:\n- data (type[BasePackageData]): A class type that contains package data, specifying attributes like PYPI_NAME, library version, and botocore version.\n- service_names (Iterable[ServiceName], optional): An iterable of ServiceName instances associated with the package. Defaults to an empty tuple.\n- version (str, optional): A string representing the package version. Defaults to an empty string.\n\nAttributes initialized:\n- self.data: Stores the package data class type.\n- self._pypi_name: Holds the PyPI name extracted from the data class.\n- self.library_version: Version of the library obtained from the data class.\n- self.botocore_version: Version of botocore retrieved from the data class.\n- self._version: Internal variable to store the package version, initialized as an empty string.\n- self.service_names: A tuple of service names passed during initialization.\n- self.logger: Logger instance obtained from the get_logger function.\n- self.url: A PackageURL instance initialized with the PyPI name and data.\n\nDependencies:\n- Requires the BasePackageData class for package data structure.\n- Uses the PackageURL class for constructing the package's URL.\n- Retrieves logging functionality from the get_logger function.",
        "signature": "def __init__(self, data: type[BasePackageData], service_names: Iterable[ServiceName]=(), version: str='') -> None:",
        "type": "Method",
        "class_signature": "class Package:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/structures/package.py:Package:__init__": {
      "mypy_boto3_builder/structures/package_url.py": {
        "PackageURL.__init__": {
          "code": "    def __init__(self, pypi_name: str, data: type[BasePackageData]) -> None:\n        self.pypi_name = pypi_name\n        self.data = data",
          "docstring": "",
          "signature": "def __init__(self, pypi_name: str, data: type[BasePackageData]) -> None:",
          "type": "Method",
          "class_signature": "class PackageURL:"
        }
      },
      "mypy_boto3_builder/package_data.py": {
        "BasePackageData.get_library_version": {
          "code": "    def get_library_version() -> str:\n        \"\"\"\n        Get underlying library version.\n        \"\"\"\n        return get_boto3_version()",
          "docstring": "Get underlying library version.",
          "signature": "def get_library_version() -> str:",
          "type": "Method",
          "class_signature": "class BasePackageData:"
        },
        "BasePackageData.get_botocore_version": {
          "code": "    def get_botocore_version() -> str:\n        \"\"\"\n        Get underlying botocore version.\n        \"\"\"\n        return get_botocore_version()",
          "docstring": "Get underlying botocore version.",
          "signature": "def get_botocore_version() -> str:",
          "type": "Method",
          "class_signature": "class BasePackageData:"
        }
      },
      "mypy_boto3_builder/logger.py": {
        "get_logger": {
          "code": "def get_logger(level: int | None = None, name: str = LOGGER_NAME) -> logging.Logger:\n    \"\"\"\n    Get Logger instance.\n\n    Arguments:\n        level -- Log level.\n\n    Returns:\n        Overriden Logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s %(name)s: %(levelname)-7s %(message)s\",\n            datefmt=\"%H:%M:%S\",\n        )\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n\n    return logger",
          "docstring": "Get Logger instance.\n\nArguments:\n    level -- Log level.\n\nReturns:\n    Overriden Logger.",
          "signature": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/structures/package.py": {
        "Package.pypi_name": {
          "code": "    def pypi_name(self, value: str) -> None:\n        self._pypi_name = value\n        self.url.pypi_name = value",
          "docstring": "",
          "signature": "def pypi_name(self, value: str) -> None:",
          "type": "Method",
          "class_signature": "class Package:"
        }
      }
    },
    "mypy_boto3_builder/writers/utils.py:render_jinja2_package_template": {
      "mypy_boto3_builder/structures/package.py": {
        "Package.service_name": {
          "code": "    def service_name(self) -> ServiceName:\n        \"\"\"\n        Service name for the package.\n        \"\"\"\n        if len(self.service_names) != 1:\n            raise StructureError(f'Package {self.name} has more than one service name')\n        return self.service_names[0]",
          "docstring": "Service name for the package.",
          "signature": "def service_name(self) -> ServiceName:",
          "type": "Method",
          "class_signature": "class Package:"
        }
      }
    },
    "mypy_boto3_builder/writers/utils.py:insert_md_toc": {
      "mypy_boto3_builder/utils/markdown.py": {
        "TableOfContents.parse": {
          "code": "    def parse(cls, text: str) -> Self:\n        \"\"\"\n        Parse table of Contents for MarkDown text.\n\n        Arguments:\n            text -- MarkDown text.\n        \"\"\"\n        headers: list[Header] = []\n        in_codeblock = False\n        for line in text.splitlines():\n            if line.startswith(\"```\"):\n                in_codeblock = not in_codeblock\n            if in_codeblock:\n                continue\n            if not line.startswith(\"#\"):\n                continue\n\n            level, title = line.split(\" \", 1)\n            headers.append(Header(title.strip(), len(level)))\n\n        return cls(headers)",
          "docstring": "Parse table of Contents for MarkDown text.\n\nArguments:\n    text -- MarkDown text.",
          "signature": "def parse(cls, text: str) -> Self:",
          "type": "Method",
          "class_signature": "class TableOfContents:"
        },
        "TableOfContents.render": {
          "code": "    def render(self, max_level: int = 3) -> str:\n        \"\"\"\n        Render ToC to string.\n        \"\"\"\n        result: list[str] = []\n        for header in self.headers:\n            if header.level > max_level:\n                continue\n            result.append(header.render())\n        return \"\\n\".join(result)",
          "docstring": "Render ToC to string.",
          "signature": "def render(self, max_level: int=3) -> str:",
          "type": "Method",
          "class_signature": "class TableOfContents:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_utils\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 structures/\n    \u2502   \u2514\u2500\u2500 package.py\n    \u2502       \u2514\u2500\u2500 Package.__init__\n    \u2514\u2500\u2500 writers/\n        \u2514\u2500\u2500 utils.py\n            \u251c\u2500\u2500 format_md\n            \u251c\u2500\u2500 insert_md_toc\n            \u2514\u2500\u2500 render_jinja2_package_template\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module streamlines and validates utilities for generating and manipulating structured code documentation and templates for Python-based projects, with a specific focus on supporting AWS service type hinting through `boto3-stubs`. It provides key capabilities such as rendering Jinja2 templates for customized Python package generation, inserting and formatting Markdown documentation with automatic table of contents generation, and enabling efficient integration with predefined service catalog data for services like Amazon S3 and EC2. By standardizing template rendering and Markdown formatting, the module minimizes manual efforts for developers, ensures uniformity in generated outputs, and enhances productivity when working on Python packages or type hinting frameworks for AWS services.\n\n## FILE 1: mypy_boto3_builder/writers/utils.py\n\n- FUNCTION NAME: insert_md_toc\n  - SIGNATURE: def insert_md_toc(text: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nInsert a Table of Contents (ToC) into the provided Markdown text before the first second-level header (##). The ToC is generated from the headers present in the input text.\n\nParameters:\n- text (str): The Markdown text in which the ToC will be inserted.\n\nReturns:\n- str: The Markdown text with the inserted ToC. If no second-level header exists, the ToC will be appended at the end of the text.\n\nDependencies:\n- TableOfContents: A class imported from the `mypy_boto3_builder.utils.markdown` module, which is utilized to parse the input text for headers and render the ToC. This interaction facilitates the generation of a structured ToC based on the content of the Markdown.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/markdown.py:TableOfContents:parse\n    - mypy_boto3_builder/utils/markdown.py:TableOfContents:render\n\n- FUNCTION NAME: render_jinja2_package_template\n  - SIGNATURE: def render_jinja2_package_template(template_path: Path, package: Package) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender a Jinja2 template using the provided package data.\n\nThis function takes a template path and a `Package` object, rendering the template with relevant data, including the package itself and its service name if applicable.\n\nParameters:\n    template_path (Path): A relative path to the Jinja2 template file located in the `TEMPLATES_PATH`.\n    package (Package): An instance of the `Package` class that represents a service or wrapper package.\n\nReturns:\n    str: A string containing the rendered template.\n\nThe function utilizes `render_jinja2_template`, which is responsible for processing the template with the provided context. The context includes the `package` and optionally the `service_name`, which is set only if there is a single service name present in the package's attributes.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/structures/package.py:Package:service_name\n\n- FUNCTION NAME: format_md\n  - SIGNATURE: def format_md(text: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nFormat Markdown text using the `mdformat` package.\n\nArguments:\n    text -- A string containing Markdown text to format.\n\nReturns:\n    A formatted string where the Markdown text is styled according to the options specified.\n\nThe function uses `mdformat.text` with options to wrap text at 79 characters and number the lines, enhancing the readability and structure of the Markdown output. The `mdformat` package is imported at the beginning of the code and is essential for the formatting functionality provided by this function.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/structures/package.py\n\n- CLASS METHOD: Package.__init__\n  - CLASS SIGNATURE: class Package:\n  - SIGNATURE: def __init__(self, data: type[BasePackageData], service_names: Iterable[ServiceName]=(), version: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Package instance.\n\nThis constructor initializes a Package object with essential metadata required for package management. It sets the data type for the package, retrieves the package's PyPI name, library version, and botocore version, and assigns the service names and optional version. It also initializes a logger and constructs a PackageURL object for the package.\n\nParameters:\n- data (type[BasePackageData]): A class type that contains package data, specifying attributes like PYPI_NAME, library version, and botocore version.\n- service_names (Iterable[ServiceName], optional): An iterable of ServiceName instances associated with the package. Defaults to an empty tuple.\n- version (str, optional): A string representing the package version. Defaults to an empty string.\n\nAttributes initialized:\n- self.data: Stores the package data class type.\n- self._pypi_name: Holds the PyPI name extracted from the data class.\n- self.library_version: Version of the library obtained from the data class.\n- self.botocore_version: Version of botocore retrieved from the data class.\n- self._version: Internal variable to store the package version, initialized as an empty string.\n- self.service_names: A tuple of service names passed during initialization.\n- self.logger: Logger instance obtained from the get_logger function.\n- self.url: A PackageURL instance initialized with the PyPI name and data.\n\nDependencies:\n- Requires the BasePackageData class for package data structure.\n- Uses the PackageURL class for constructing the package's URL.\n- Retrieves logging functionality from the get_logger function.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/writers/utils.py": "\"\"\"\nJinja2 renderer and formatters.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom pathlib import Path\nimport mdformat\nfrom mypy_boto3_builder.structures.package import Package\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\nfrom mypy_boto3_builder.utils.markdown import TableOfContents",
    "mypy_boto3_builder/structures/package.py": "\"\"\"\nParent class for all package structures.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable\nfrom packaging.version import InvalidVersion, Version\nfrom mypy_boto3_builder.constants import SUPPORTED_PY_VERSIONS\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.package_data import BasePackageData\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.package_url import PackageURL\nfrom mypy_boto3_builder.utils.version import get_max_build_version, get_min_build_version\n\nclass Package:\n    \"\"\"\n    Parent class for all package structures.\n    \"\"\"\n\n    @property\n    def pypi_name(self) -> str:\n        \"\"\"\n        PyPI package name.\n        \"\"\"\n        return self._pypi_name\n\n    @pypi_name.setter\n    def pypi_name(self, value: str) -> None:\n        self._pypi_name = value\n        self.url.pypi_name = value\n\n    @property\n    def version(self) -> str:\n        \"\"\"\n        Package version.\n        \"\"\"\n        if not self._version:\n            raise StructureError(f'Version is not set for {self.pypi_name}')\n        return self._version\n\n    @version.setter\n    def version(self, value: str) -> None:\n        try:\n            Version(value)\n        except InvalidVersion:\n            raise StructureError(f'Invalid version: {value}') from None\n        self._version = value\n\n    @property\n    def name(self) -> str:\n        \"\"\"\n        Package name.\n        \"\"\"\n        if not self.data.NAME:\n            raise StructureError(f'Package name is not set for {self.pypi_name}')\n        return self.data.NAME\n\n    @property\n    def library_name(self) -> str:\n        \"\"\"\n        PyPI library package name.\n        \"\"\"\n        return self.data.LIBRARY_NAME\n\n    def has_main_package(self) -> bool:\n        \"\"\"\n        Check if package has main package.\n        \"\"\"\n        return bool(self.data.NAME)\n\n    @property\n    def service_name(self) -> ServiceName:\n        \"\"\"\n        Service name for the package.\n        \"\"\"\n        if len(self.service_names) != 1:\n            raise StructureError(f'Package {self.name} has more than one service name')\n        return self.service_names[0]\n\n    @property\n    def directory_name(self) -> str:\n        \"\"\"\n        Directory name to store generated package.\n        \"\"\"\n        underscore_package_name = self.pypi_name.replace('-', '_')\n        return f'{underscore_package_name}_package'\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get string representation for debugging.\n        \"\"\"\n        return f'{self.name} {self._version} ({self.library_name} {self.library_version})'\n\n    def get_local_doc_link(self, service_name: ServiceName | None=None) -> str:\n        \"\"\"\n        Get link to local docs.\n        \"\"\"\n        url = self.data.LOCAL_DOC_LINK\n        if service_name:\n            url = f'{url}{self.get_module_name(service_name)}/'\n        return url\n\n    def get_module_name(self, service_name: ServiceName) -> str:\n        \"\"\"\n        Get service module name.\n        \"\"\"\n        return self.data.get_service_package_name(service_name)\n\n    def get_service_pypi_name(self, service_name: ServiceName) -> str:\n        \"\"\"\n        Get PyPI package name for a service package.\n        \"\"\"\n        return self.data.get_service_pypi_name(service_name)\n\n    @property\n    def min_library_version(self) -> str:\n        \"\"\"\n        Minimum required library version.\n        \"\"\"\n        return get_min_build_version(self.library_version)\n\n    @property\n    def max_library_version(self) -> str:\n        \"\"\"\n        Minimum required library version.\n        \"\"\"\n        return get_max_build_version(self.library_version)\n\n    @property\n    def min_python_version(self) -> str:\n        \"\"\"\n        Minimum required python version.\n        \"\"\"\n        min_version = min(SUPPORTED_PY_VERSIONS)\n        return '.'.join((str(i) for i in min_version))\n\n    def get_classifiers(self) -> list[str]:\n        \"\"\"\n        Get classifiers for package.\n        \"\"\"\n        result = ['Development Status :: 5 - Production/Stable', 'Intended Audience :: Developers', 'Environment :: Console', 'License :: OSI Approved :: MIT License', 'Natural Language :: English', 'Operating System :: OS Independent']\n        major_versions = {version[0] for version in SUPPORTED_PY_VERSIONS}\n        for major in sorted(major_versions):\n            result.append(f'Programming Language :: Python :: {major}')\n            minor_versions = {version[1] for version in SUPPORTED_PY_VERSIONS if version[0] == major and len(version) > 1}\n            result.extend((f'Programming Language :: Python :: {major}.{minor}' for minor in sorted(minor_versions)))\n        if len(major_versions) == 1:\n            major = next(iter(major_versions))\n            result.append(f'Programming Language :: Python :: {major} :: Only')\n        result.extend(('Programming Language :: Python :: Implementation :: CPython', 'Typing :: Stubs Only'))\n        return result"
  },
  "call_tree": {
    "tests/writers/test_utils.py:TestUtils:test_render_jinja2_package_template": {
      "mypy_boto3_builder/structures/package.py:Package:__init__": {
        "mypy_boto3_builder/package_data.py:BasePackageData:get_library_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_boto3_version": {}
        },
        "mypy_boto3_builder/package_data.py:BasePackageData:get_botocore_version": {
          "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {}
        },
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/structures/package.py:Package:pypi_name": {},
        "mypy_boto3_builder/structures/package_url.py:PackageURL:__init__": {}
      },
      "mypy_boto3_builder/writers/utils.py:render_jinja2_package_template": {
        "mypy_boto3_builder/structures/package.py:Package:service_name": {}
      }
    },
    "tests/writers/test_utils.py:TestUtils:test_insert_md_toc": {
      "mypy_boto3_builder/writers/utils.py:insert_md_toc": {
        "mypy_boto3_builder/utils/markdown.py:TableOfContents:parse": {
          "mypy_boto3_builder/utils/markdown.py:Header:__init__": {},
          "mypy_boto3_builder/utils/markdown.py:TableOfContents:__init__": {}
        },
        "mypy_boto3_builder/utils/markdown.py:TableOfContents:render": {
          "mypy_boto3_builder/utils/markdown.py:Header:render": {
            "mypy_boto3_builder/utils/markdown.py:Header:anchor": {
              "mypy_boto3_builder/utils/strings.py:get_anchor_link": {}
            }
          }
        }
      }
    },
    "tests/writers/test_utils.py:TestUtils:test_format_md": {
      "mypy_boto3_builder/writers/utils.py:format_md": {}
    }
  }
}