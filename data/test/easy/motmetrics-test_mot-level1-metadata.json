{
  "dir_path": "/app/motmetrics",
  "package_name": "motmetrics",
  "sample_name": "motmetrics-test_mot",
  "src_dir": "motmetrics/",
  "test_dir": "motmetrics/tests/",
  "test_file": "motmetrics/tests/test_mot.py",
  "test_code": "# py-motmetrics - Metrics for multiple object tracker (MOT) benchmarking.\n# https://github.com/cheind/py-motmetrics/\n#\n# MIT License\n# Copyright (c) 2017-2020 Christoph Heindl, Jack Valmadre and others.\n# See LICENSE file for terms.\n\n\"\"\"Tests behavior of MOTAccumulator.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\nimport pandas as pd\nimport pytest\n\nimport motmetrics as mm\n\n\ndef test_events():\n    \"\"\"Tests that expected events are created by MOTAccumulator.update().\"\"\"\n    acc = mm.MOTAccumulator()\n\n    # All FP\n    acc.update([], [1, 2], [], frameid=0)\n    # All miss\n    acc.update([1, 2], [], [], frameid=1)\n    # Match\n    acc.update([1, 2], [1, 2], [[1, 0.5], [0.3, 1]], frameid=2)\n    # Switch\n    acc.update([1, 2], [1, 2], [[0.2, np.nan], [np.nan, 0.1]], frameid=3)\n    # Match. Better new match is available but should prefer history\n    acc.update([1, 2], [1, 2], [[5, 1], [1, 5]], frameid=4)\n    # No data\n    acc.update([], [], [], frameid=5)\n\n    expect = mm.MOTAccumulator.new_event_dataframe()\n    expect.loc[(0, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(0, 1), :] = [\"RAW\", np.nan, 1, np.nan]\n    expect.loc[(0, 2), :] = [\"RAW\", np.nan, 2, np.nan]\n    expect.loc[(0, 3), :] = [\"FP\", np.nan, 1, np.nan]\n    expect.loc[(0, 4), :] = [\"FP\", np.nan, 2, np.nan]\n\n    expect.loc[(1, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(1, 1), :] = [\"RAW\", 1, np.nan, np.nan]\n    expect.loc[(1, 2), :] = [\"RAW\", 2, np.nan, np.nan]\n    expect.loc[(1, 3), :] = [\"MISS\", 1, np.nan, np.nan]\n    expect.loc[(1, 4), :] = [\"MISS\", 2, np.nan, np.nan]\n\n    expect.loc[(2, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(2, 1), :] = [\"RAW\", 1, 1, 1.0]\n    expect.loc[(2, 2), :] = [\"RAW\", 1, 2, 0.5]\n    expect.loc[(2, 3), :] = [\"RAW\", 2, 1, 0.3]\n    expect.loc[(2, 4), :] = [\"RAW\", 2, 2, 1.0]\n    expect.loc[(2, 5), :] = [\"MATCH\", 1, 2, 0.5]\n    expect.loc[(2, 6), :] = [\"MATCH\", 2, 1, 0.3]\n\n    expect.loc[(3, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(3, 1), :] = [\"RAW\", 1, 1, 0.2]\n    expect.loc[(3, 2), :] = [\"RAW\", 2, 2, 0.1]\n    expect.loc[(3, 3), :] = [\"TRANSFER\", 1, 1, 0.2]\n    expect.loc[(3, 4), :] = [\"SWITCH\", 1, 1, 0.2]\n    expect.loc[(3, 5), :] = [\"TRANSFER\", 2, 2, 0.1]\n    expect.loc[(3, 6), :] = [\"SWITCH\", 2, 2, 0.1]\n\n    expect.loc[(4, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(4, 1), :] = [\"RAW\", 1, 1, 5.0]\n    expect.loc[(4, 2), :] = [\"RAW\", 1, 2, 1.0]\n    expect.loc[(4, 3), :] = [\"RAW\", 2, 1, 1.0]\n    expect.loc[(4, 4), :] = [\"RAW\", 2, 2, 5.0]\n    expect.loc[(4, 5), :] = [\"MATCH\", 1, 1, 5.0]\n    expect.loc[(4, 6), :] = [\"MATCH\", 2, 2, 5.0]\n\n    expect.loc[(5, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n\n    pd.testing.assert_frame_equal(acc.events, expect)\n\n\ndef test_max_switch_time():\n    \"\"\"Tests max_switch_time option.\"\"\"\n    acc = mm.MOTAccumulator(max_switch_time=1)\n    acc.update([1, 2], [1, 2], [[1, 0.5], [0.3, 1]], frameid=1)  # 1->a, 2->b\n    frameid = acc.update(\n        [1, 2], [1, 2], [[0.5, np.nan], [np.nan, 0.5]], frameid=2\n    )  # 1->b, 2->a\n\n    df = acc.events.loc[frameid]\n    assert ((df.Type == \"SWITCH\") | (df.Type == \"RAW\") | (df.Type == \"TRANSFER\")).all()\n\n    acc = mm.MOTAccumulator(max_switch_time=1)\n    acc.update([1, 2], [1, 2], [[1, 0.5], [0.3, 1]], frameid=1)  # 1->a, 2->b\n    frameid = acc.update(\n        [1, 2], [1, 2], [[0.5, np.nan], [np.nan, 0.5]], frameid=5\n    )  # Later frame 1->b, 2->a\n\n    df = acc.events.loc[frameid]\n    assert ((df.Type == \"MATCH\") | (df.Type == \"RAW\") | (df.Type == \"TRANSFER\")).all()\n\n\ndef test_auto_id():\n    \"\"\"Tests auto_id option.\"\"\"\n    acc = mm.MOTAccumulator(auto_id=True)\n    acc.update([1, 2, 3, 4], [], [])\n    acc.update([1, 2, 3, 4], [], [])\n    assert acc.events.index.levels[0][-1] == 1\n    acc.update([1, 2, 3, 4], [], [])\n    assert acc.events.index.levels[0][-1] == 2\n\n    with pytest.raises(AssertionError):\n        acc.update([1, 2, 3, 4], [], [], frameid=5)\n\n    acc = mm.MOTAccumulator(auto_id=False)\n    with pytest.raises(AssertionError):\n        acc.update([1, 2, 3, 4], [], [])\n\n\ndef test_merge_dataframes():\n    \"\"\"Tests merge_event_dataframes().\"\"\"\n    # pylint: disable=too-many-statements\n    acc = mm.MOTAccumulator()\n\n    acc.update([], [1, 2], [], frameid=0)\n    acc.update([1, 2], [], [], frameid=1)\n    acc.update([1, 2], [1, 2], [[1, 0.5], [0.3, 1]], frameid=2)\n    acc.update([1, 2], [1, 2], [[0.2, np.nan], [np.nan, 0.1]], frameid=3)\n\n    r, mappings = mm.MOTAccumulator.merge_event_dataframes(\n        [acc.events, acc.events], return_mappings=True\n    )\n\n    expect = mm.MOTAccumulator.new_event_dataframe()\n\n    expect.loc[(0, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(0, 1), :] = [\"RAW\", np.nan, mappings[0][\"hid_map\"][1], np.nan]\n    expect.loc[(0, 2), :] = [\"RAW\", np.nan, mappings[0][\"hid_map\"][2], np.nan]\n    expect.loc[(0, 3), :] = [\"FP\", np.nan, mappings[0][\"hid_map\"][1], np.nan]\n    expect.loc[(0, 4), :] = [\"FP\", np.nan, mappings[0][\"hid_map\"][2], np.nan]\n\n    expect.loc[(1, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(1, 1), :] = [\"RAW\", mappings[0][\"oid_map\"][1], np.nan, np.nan]\n    expect.loc[(1, 2), :] = [\"RAW\", mappings[0][\"oid_map\"][2], np.nan, np.nan]\n    expect.loc[(1, 3), :] = [\"MISS\", mappings[0][\"oid_map\"][1], np.nan, np.nan]\n    expect.loc[(1, 4), :] = [\"MISS\", mappings[0][\"oid_map\"][2], np.nan, np.nan]\n\n    expect.loc[(2, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(2, 1), :] = [\n        \"RAW\",\n        mappings[0][\"oid_map\"][1],\n        mappings[0][\"hid_map\"][1],\n        1,\n    ]\n    expect.loc[(2, 2), :] = [\n        \"RAW\",\n        mappings[0][\"oid_map\"][1],\n        mappings[0][\"hid_map\"][2],\n        0.5,\n    ]\n    expect.loc[(2, 3), :] = [\n        \"RAW\",\n        mappings[0][\"oid_map\"][2],\n        mappings[0][\"hid_map\"][1],\n        0.3,\n    ]\n    expect.loc[(2, 4), :] = [\n        \"RAW\",\n        mappings[0][\"oid_map\"][2],\n        mappings[0][\"hid_map\"][2],\n        1.0,\n    ]\n    expect.loc[(2, 5), :] = [\n        \"MATCH\",\n        mappings[0][\"oid_map\"][1],\n        mappings[0][\"hid_map\"][2],\n        0.5,\n    ]\n    expect.loc[(2, 6), :] = [\n        \"MATCH\",\n        mappings[0][\"oid_map\"][2],\n        mappings[0][\"hid_map\"][1],\n        0.3,\n    ]\n\n    expect.loc[(3, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(3, 1), :] = [\n        \"RAW\",\n        mappings[0][\"oid_map\"][1],\n        mappings[0][\"hid_map\"][1],\n        0.2,\n    ]\n    expect.loc[(3, 2), :] = [\n        \"RAW\",\n        mappings[0][\"oid_map\"][2],\n        mappings[0][\"hid_map\"][2],\n        0.1,\n    ]\n    expect.loc[(3, 3), :] = [\n        \"TRANSFER\",\n        mappings[0][\"oid_map\"][1],\n        mappings[0][\"hid_map\"][1],\n        0.2,\n    ]\n    expect.loc[(3, 4), :] = [\n        \"SWITCH\",\n        mappings[0][\"oid_map\"][1],\n        mappings[0][\"hid_map\"][1],\n        0.2,\n    ]\n    expect.loc[(3, 5), :] = [\n        \"TRANSFER\",\n        mappings[0][\"oid_map\"][2],\n        mappings[0][\"hid_map\"][2],\n        0.1,\n    ]\n    expect.loc[(3, 6), :] = [\n        \"SWITCH\",\n        mappings[0][\"oid_map\"][2],\n        mappings[0][\"hid_map\"][2],\n        0.1,\n    ]\n\n    # Merge duplication\n    expect.loc[(4, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(4, 1), :] = [\"RAW\", np.nan, mappings[1][\"hid_map\"][1], np.nan]\n    expect.loc[(4, 2), :] = [\"RAW\", np.nan, mappings[1][\"hid_map\"][2], np.nan]\n    expect.loc[(4, 3), :] = [\"FP\", np.nan, mappings[1][\"hid_map\"][1], np.nan]\n    expect.loc[(4, 4), :] = [\"FP\", np.nan, mappings[1][\"hid_map\"][2], np.nan]\n\n    expect.loc[(5, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(5, 1), :] = [\"RAW\", mappings[1][\"oid_map\"][1], np.nan, np.nan]\n    expect.loc[(5, 2), :] = [\"RAW\", mappings[1][\"oid_map\"][2], np.nan, np.nan]\n    expect.loc[(5, 3), :] = [\"MISS\", mappings[1][\"oid_map\"][1], np.nan, np.nan]\n    expect.loc[(5, 4), :] = [\"MISS\", mappings[1][\"oid_map\"][2], np.nan, np.nan]\n\n    expect.loc[(6, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(6, 1), :] = [\n        \"RAW\",\n        mappings[1][\"oid_map\"][1],\n        mappings[1][\"hid_map\"][1],\n        1,\n    ]\n    expect.loc[(6, 2), :] = [\n        \"RAW\",\n        mappings[1][\"oid_map\"][1],\n        mappings[1][\"hid_map\"][2],\n        0.5,\n    ]\n    expect.loc[(6, 3), :] = [\n        \"RAW\",\n        mappings[1][\"oid_map\"][2],\n        mappings[1][\"hid_map\"][1],\n        0.3,\n    ]\n    expect.loc[(6, 4), :] = [\n        \"RAW\",\n        mappings[1][\"oid_map\"][2],\n        mappings[1][\"hid_map\"][2],\n        1.0,\n    ]\n    expect.loc[(6, 5), :] = [\n        \"MATCH\",\n        mappings[1][\"oid_map\"][1],\n        mappings[1][\"hid_map\"][2],\n        0.5,\n    ]\n    expect.loc[(6, 6), :] = [\n        \"MATCH\",\n        mappings[1][\"oid_map\"][2],\n        mappings[1][\"hid_map\"][1],\n        0.3,\n    ]\n\n    expect.loc[(7, 0), :] = [\"RAW\", np.nan, np.nan, np.nan]\n    expect.loc[(7, 1), :] = [\n        \"RAW\",\n        mappings[1][\"oid_map\"][1],\n        mappings[1][\"hid_map\"][1],\n        0.2,\n    ]\n    expect.loc[(7, 2), :] = [\n        \"RAW\",\n        mappings[1][\"oid_map\"][2],\n        mappings[1][\"hid_map\"][2],\n        0.1,\n    ]\n    expect.loc[(7, 3), :] = [\n        \"TRANSFER\",\n        mappings[1][\"oid_map\"][1],\n        mappings[1][\"hid_map\"][1],\n        0.2,\n    ]\n    expect.loc[(7, 4), :] = [\n        \"SWITCH\",\n        mappings[1][\"oid_map\"][1],\n        mappings[1][\"hid_map\"][1],\n        0.2,\n    ]\n    expect.loc[(7, 5), :] = [\n        \"TRANSFER\",\n        mappings[1][\"oid_map\"][2],\n        mappings[1][\"hid_map\"][2],\n        0.1,\n    ]\n    expect.loc[(7, 6), :] = [\n        \"SWITCH\",\n        mappings[1][\"oid_map\"][2],\n        mappings[1][\"hid_map\"][2],\n        0.1,\n    ]\n\n    idx = expect.index\n    expect.index = expect.index.set_levels(\n        [\n            idx.levels[0].astype(r.index.levels[0].dtype),\n            idx.levels[1].astype(r.index.levels[1].dtype),\n        ]\n    )\n    pd.testing.assert_frame_equal(r, expect)\n",
  "GT_file_code": {
    "motmetrics/mot.py": "# py-motmetrics - Metrics for multiple object tracker (MOT) benchmarking.\n# https://github.com/cheind/py-motmetrics/\n#\n# MIT License\n# Copyright (c) 2017-2020 Christoph Heindl, Jack Valmadre and others.\n# See LICENSE file for terms.\n\n\"\"\"Accumulate tracking events frame by frame.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom collections import OrderedDict\nimport itertools\n\nimport numpy as np\nimport pandas as pd\n\nfrom motmetrics.lap import linear_sum_assignment\n\n_INDEX_FIELDS = ['FrameId', 'Event']\n_EVENT_FIELDS = ['Type', 'OId', 'HId', 'D']\n\n\nclass MOTAccumulator(object):\n    \"\"\"Manage tracking events.\n\n    This class computes per-frame tracking events from a given set of object / hypothesis\n    ids and pairwise distances. Indended usage\n\n        import motmetrics as mm\n        acc = mm.MOTAccumulator()\n        acc.update(['a', 'b'], [0, 1, 2], dists, frameid=0)\n        ...\n        acc.update(['d'], [6,10], other_dists, frameid=76)\n        summary = mm.metrics.summarize(acc)\n        print(mm.io.render_summary(summary))\n\n    Update is called once per frame and takes objects / hypothesis ids and a pairwise distance\n    matrix between those (see distances module for support). Per frame max(len(objects), len(hypothesis))\n    events are generated. Each event type is one of the following\n        - `'MATCH'` a match between a object and hypothesis was found\n        - `'SWITCH'` a match between a object and hypothesis was found but differs from previous assignment (hypothesisid != previous)\n        - `'MISS'` no match for an object was found\n        - `'FP'` no match for an hypothesis was found (spurious detections)\n        - `'RAW'` events corresponding to raw input\n        - `'TRANSFER'` a match between a object and hypothesis was found but differs from previous assignment (objectid != previous)\n        - `'ASCEND'` a match between a object and hypothesis was found but differs from previous assignment  (hypothesisid is new)\n        - `'MIGRATE'` a match between a object and hypothesis was found but differs from previous assignment  (objectid is new)\n\n    Events are tracked in a pandas Dataframe. The dataframe is hierarchically indexed by (`FrameId`, `EventId`),\n    where `FrameId` is either provided during the call to `update` or auto-incremented when `auto_id` is set\n    true during construction of MOTAccumulator. `EventId` is auto-incremented. The dataframe has the following\n    columns\n        - `Type` one of `('MATCH', 'SWITCH', 'MISS', 'FP', 'RAW')`\n        - `OId` object id or np.nan when `'FP'` or `'RAW'` and object is not present\n        - `HId` hypothesis id or np.nan when `'MISS'` or `'RAW'` and hypothesis is not present\n        - `D` distance or np.nan when `'FP'` or `'MISS'` or `'RAW'` and either object/hypothesis is absent\n\n    From the events and associated fields the entire tracking history can be recovered. Once the accumulator\n    has been populated with per-frame data use `metrics.summarize` to compute statistics. See `metrics.compute_metrics`\n    for a list of metrics computed.\n\n    References\n    ----------\n    1. Bernardin, Keni, and Rainer Stiefelhagen. \"Evaluating multiple object tracking performance: the CLEAR MOT metrics.\"\n    EURASIP Journal on Image and Video Processing 2008.1 (2008): 1-10.\n    2. Milan, Anton, et al. \"Mot16: A benchmark for multi-object tracking.\" arXiv preprint arXiv:1603.00831 (2016).\n    3. Li, Yuan, Chang Huang, and Ram Nevatia. \"Learning to associate: Hybridboosted multi-target tracker for crowded scene.\"\n    Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on. IEEE, 2009.\n    \"\"\"\n\n    def __init__(self, auto_id=False, max_switch_time=float('inf')):\n        \"\"\"Create a MOTAccumulator.\n\n        Params\n        ------\n        auto_id : bool, optional\n            Whether or not frame indices are auto-incremented or provided upon\n            updating. Defaults to false. Not specifying a frame-id when this value\n            is true results in an error. Specifying a frame-id when this value is\n            false also results in an error.\n\n        max_switch_time : scalar, optional\n            Allows specifying an upper bound on the timespan an unobserved but\n            tracked object is allowed to generate track switch events. Useful if groundtruth\n            objects leaving the field of view keep their ID when they reappear,\n            but your tracker is not capable of recognizing this (resulting in\n            track switch events). The default is that there is no upper bound\n            on the timespan. In units of frame timestamps. When using auto_id\n            in units of count.\n        \"\"\"\n\n        # Parameters of the accumulator.\n        self.auto_id = auto_id\n        self.max_switch_time = max_switch_time\n\n        # Accumulator state.\n        self._events = None\n        self._indices = None\n        self.m = None\n        self.res_m = None\n        self.last_occurrence = None\n        self.last_match = None\n        self.hypHistory = None\n        self.dirty_events = None\n        self.cached_events_df = None\n        self.last_update_frameid = None\n\n        self.reset()\n\n    def reset(self):\n        \"\"\"Reset the accumulator to empty state.\"\"\"\n\n        self._events = {field: [] for field in _EVENT_FIELDS}\n        self._indices = {field: [] for field in _INDEX_FIELDS}\n        self.m = {}  # Pairings up to current timestamp\n        self.res_m = {}  # Result pairings up to now\n        self.last_occurrence = {}  # Tracks most recent occurance of object\n        self.last_match = {}  # Tracks most recent match of object\n        self.hypHistory = {}\n        self.dirty_events = True\n        self.cached_events_df = None\n        self.last_update_frameid = None\n\n    def _append_to_indices(self, frameid, eid):\n        self._indices['FrameId'].append(frameid)\n        self._indices['Event'].append(eid)\n\n    def _append_to_events(self, typestr, oid, hid, distance):\n        self._events['Type'].append(typestr)\n        self._events['OId'].append(oid)\n        self._events['HId'].append(hid)\n        self._events['D'].append(distance)\n\n    def update(self, oids, hids, dists, frameid=None, vf='', similartiy_matrix=None, th=None):\n        \"\"\"Updates the accumulator with frame specific objects/detections.\n\n        This method generates events based on the following algorithm [1]:\n        1. Try to carry forward already established tracks. If any paired object / hypothesis\n        from previous timestamps are still visible in the current frame, create a 'MATCH'\n        event between them.\n        2. For the remaining constellations minimize the total object / hypothesis distance\n        error (Kuhn-Munkres algorithm). If a correspondence made contradicts a previous\n        match create a 'SWITCH' else a 'MATCH' event.\n        3. Create 'MISS' events for all remaining unassigned objects.\n        4. Create 'FP' events for all remaining unassigned hypotheses.\n\n        Params\n        ------\n        oids : N array\n            Array of object ids.\n        hids : M array\n            Array of hypothesis ids.\n        dists: NxM array\n            Distance matrix. np.nan values to signal do-not-pair constellations.\n            See `distances` module for support methods.\n\n        Kwargs\n        ------\n        frameId : id\n            Unique frame id. Optional when MOTAccumulator.auto_id is specified during\n            construction.\n        vf: file to log details\n        Returns\n        -------\n        frame_events : pd.DataFrame\n            Dataframe containing generated events\n\n        References\n        ----------\n        1. Bernardin, Keni, and Rainer Stiefelhagen. \"Evaluating multiple object tracking performance: the CLEAR MOT metrics.\"\n        EURASIP Journal on Image and Video Processing 2008.1 (2008): 1-10.\n        \"\"\"\n        # pylint: disable=too-many-locals, too-many-statements\n\n        self.dirty_events = True\n        oids = np.asarray(oids)\n        oids_masked = np.zeros_like(oids, dtype=np.bool_)\n        hids = np.asarray(hids)\n        hids_masked = np.zeros_like(hids, dtype=np.bool_)\n        dists = np.atleast_2d(dists).astype(float).reshape(oids.shape[0], hids.shape[0]).copy()\n\n        if frameid is None:\n            assert self.auto_id, 'auto-id is not enabled'\n            if len(self._indices['FrameId']) > 0:\n                frameid = self._indices['FrameId'][-1] + 1\n            else:\n                frameid = 0\n        else:\n            assert not self.auto_id, 'Cannot provide frame id when auto-id is enabled'\n\n        eid = itertools.count()\n\n        # 0. Record raw events\n\n        no = len(oids)\n        nh = len(hids)\n\n        # Add a RAW event simply to ensure the frame is counted.\n        self._append_to_indices(frameid, next(eid))\n        self._append_to_events('RAW', np.nan, np.nan, np.nan)\n\n        # Postcompute the distance matrix if necessary. (e.g., HOTA)\n        cost_for_matching = dists.copy()\n        if similartiy_matrix is not None and th is not None:\n            dists = 1 - similartiy_matrix\n            dists = np.where(similartiy_matrix < th - np.finfo(\"float\").eps, np.nan, dists)\n\n        # There must be at least one RAW event per object and hypothesis.\n        # Record all finite distances as RAW events.\n        valid_i, valid_j = np.where(np.isfinite(dists))\n        valid_dists = dists[valid_i, valid_j]\n        for i, j, dist_ij in zip(valid_i, valid_j, valid_dists):\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('RAW', oids[i], hids[j], dist_ij)\n        # Add a RAW event for objects and hypotheses that were present but did\n        # not overlap with anything.\n        used_i = np.unique(valid_i)\n        used_j = np.unique(valid_j)\n        unused_i = np.setdiff1d(np.arange(no), used_i)\n        unused_j = np.setdiff1d(np.arange(nh), used_j)\n        for oid in oids[unused_i]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('RAW', oid, np.nan, np.nan)\n        for hid in hids[unused_j]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('RAW', np.nan, hid, np.nan)\n\n        if oids.size * hids.size > 0:\n            # 1. Try to re-establish tracks from correspondences in last update\n            #    ignore this if post processing is performed (e.g., HOTA)\n            if similartiy_matrix is None or th is None:\n                for i in range(oids.shape[0]):\n                    # No need to check oids_masked[i] here.\n                    if not (oids[i] in self.m and self.last_match[oids[i]] == self.last_update_frameid):\n                        continue\n\n                    hprev = self.m[oids[i]]\n                    j, = np.where(~hids_masked & (hids == hprev))\n                    if j.shape[0] == 0:\n                        continue\n                    j = j[0]\n\n                    if np.isfinite(dists[i, j]):\n                        o = oids[i]\n                        h = hids[j]\n                        oids_masked[i] = True\n                        hids_masked[j] = True\n                        self.m[oids[i]] = hids[j]\n\n                        self._append_to_indices(frameid, next(eid))\n                        self._append_to_events('MATCH', oids[i], hids[j], dists[i, j])\n                        self.last_match[o] = frameid\n                        self.hypHistory[h] = frameid\n\n            # 2. Try to remaining objects/hypotheses\n            dists[oids_masked, :] = np.nan\n            dists[:, hids_masked] = np.nan\n\n            rids, cids = linear_sum_assignment(cost_for_matching)\n\n            for i, j in zip(rids, cids):\n                if not np.isfinite(dists[i, j]):\n                    continue\n\n                o = oids[i]\n                h = hids[j]\n                ######################################################################\n                # todo - fixed a bug:\n                # is_switch = (o in self.m and\n                #              self.m[o] != h and\n                #              abs(frameid - self.last_occurrence[o]) <= self.max_switch_time)\n                switch_condition = (\n                    o in self.m and\n                    self.m[o] != h and\n                    o in self.last_occurrence and  # Ensure the object ID 'o' is initialized in last_occurrence\n                    abs(frameid - self.last_occurrence[o]) <= self.max_switch_time\n                )\n                is_switch = switch_condition\n                ######################################################################\n                cat1 = 'SWITCH' if is_switch else 'MATCH'\n                if cat1 == 'SWITCH':\n                    if h not in self.hypHistory:\n                        subcat = 'ASCEND'\n                        self._append_to_indices(frameid, next(eid))\n                        self._append_to_events(subcat, oids[i], hids[j], dists[i, j])\n                # ignore the last condition temporarily\n                is_transfer = (h in self.res_m and\n                               self.res_m[h] != o)\n                # is_transfer = (h in self.res_m and\n                #                self.res_m[h] != o and\n                #                abs(frameid - self.last_occurrence[o]) <= self.max_switch_time)\n                cat2 = 'TRANSFER' if is_transfer else 'MATCH'\n                if cat2 == 'TRANSFER':\n                    if o not in self.last_match:\n                        subcat = 'MIGRATE'\n                        self._append_to_indices(frameid, next(eid))\n                        self._append_to_events(subcat, oids[i], hids[j], dists[i, j])\n                    self._append_to_indices(frameid, next(eid))\n                    self._append_to_events(cat2, oids[i], hids[j], dists[i, j])\n                if vf != '' and (cat1 != 'MATCH' or cat2 != 'MATCH'):\n                    if cat1 == 'SWITCH':\n                        vf.write('%s %d %d %d %d %d\\n' % (subcat[:2], o, self.last_match[o], self.m[o], frameid, h))\n                    if cat2 == 'TRANSFER':\n                        vf.write('%s %d %d %d %d %d\\n' % (subcat[:2], h, self.hypHistory[h], self.res_m[h], frameid, o))\n                self.hypHistory[h] = frameid\n                self.last_match[o] = frameid\n                self._append_to_indices(frameid, next(eid))\n                self._append_to_events(cat1, oids[i], hids[j], dists[i, j])\n                oids_masked[i] = True\n                hids_masked[j] = True\n                self.m[o] = h\n                self.res_m[h] = o\n\n        # 3. All remaining objects are missed\n        for o in oids[~oids_masked]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('MISS', o, np.nan, np.nan)\n            if vf != '':\n                vf.write('FN %d %d\\n' % (frameid, o))\n\n        # 4. All remaining hypotheses are false alarms\n        for h in hids[~hids_masked]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('FP', np.nan, h, np.nan)\n            if vf != '':\n                vf.write('FP %d %d\\n' % (frameid, h))\n\n        # 5. Update occurance state\n        for o in oids:\n            self.last_occurrence[o] = frameid\n\n        self.last_update_frameid = frameid\n\n        return frameid\n\n    @property\n    def events(self):\n        if self.dirty_events:\n            self.cached_events_df = MOTAccumulator.new_event_dataframe_with_data(self._indices, self._events)\n            self.dirty_events = False\n        return self.cached_events_df\n\n    @property\n    def mot_events(self):\n        df = self.events\n        return df[df.Type != 'RAW']\n\n    @staticmethod\n    def new_event_dataframe():\n        \"\"\"Create a new DataFrame for event tracking.\"\"\"\n        idx = pd.MultiIndex(levels=[[], []], codes=[[], []], names=['FrameId', 'Event'])\n        cats = pd.Categorical([], categories=['RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', 'MIGRATE'])\n        df = pd.DataFrame(\n            OrderedDict([\n                ('Type', pd.Series(cats)),          # Type of event. One of FP (false positive), MISS, SWITCH, MATCH\n                ('OId', pd.Series(dtype=float)),      # Object ID or -1 if FP. Using float as missing values will be converted to NaN anyways.\n                ('HId', pd.Series(dtype=float)),      # Hypothesis ID or NaN if MISS. Using float as missing values will be converted to NaN anyways.\n                ('D', pd.Series(dtype=float)),      # Distance or NaN when FP or MISS\n            ]),\n            index=idx\n        )\n        return df\n\n    @staticmethod\n    def new_event_dataframe_with_data(indices, events):\n        \"\"\"Create a new DataFrame filled with data.\n\n        Params\n        ------\n        indices: dict\n            dict of lists with fields 'FrameId' and 'Event'\n        events: dict\n            dict of lists with fields 'Type', 'OId', 'HId', 'D'\n        \"\"\"\n\n        if len(events) == 0:\n            return MOTAccumulator.new_event_dataframe()\n\n        raw_type = pd.Categorical(\n            events['Type'],\n            categories=['RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', 'MIGRATE'],\n            ordered=False)\n        series = [\n            pd.Series(raw_type, name='Type'),\n            pd.Series(events['OId'], dtype=float, name='OId'),\n            pd.Series(events['HId'], dtype=float, name='HId'),\n            pd.Series(events['D'], dtype=float, name='D')\n        ]\n\n        idx = pd.MultiIndex.from_arrays(\n            [indices[field] for field in _INDEX_FIELDS],\n            names=_INDEX_FIELDS)\n        df = pd.concat(series, axis=1)\n        df.index = idx\n        return df\n\n    @staticmethod\n    def merge_analysis(anas, infomap):\n        # pylint: disable=missing-function-docstring\n        res = {'hyp': {}, 'obj': {}}\n        mapp = {'hyp': 'hid_map', 'obj': 'oid_map'}\n        for ana, infom in zip(anas, infomap):\n            if ana is None:\n                return None\n            for t in ana.keys():\n                which = mapp[t]\n                if np.nan in infom[which]:\n                    res[t][int(infom[which][np.nan])] = 0\n                if 'nan' in infom[which]:\n                    res[t][int(infom[which]['nan'])] = 0\n                for _id, cnt in ana[t].items():\n                    if _id not in infom[which]:\n                        _id = str(_id)\n                    res[t][int(infom[which][_id])] = cnt\n        return res\n\n    @staticmethod\n    def merge_event_dataframes(dfs, update_frame_indices=True, update_oids=True, update_hids=True, return_mappings=False):\n        \"\"\"Merge dataframes.\n\n        Params\n        ------\n        dfs : list of pandas.DataFrame or MotAccumulator\n            A list of event containers to merge\n\n        Kwargs\n        ------\n        update_frame_indices : boolean, optional\n            Ensure that frame indices are unique in the merged container\n        update_oids : boolean, unique\n            Ensure that object ids are unique in the merged container\n        update_hids : boolean, unique\n            Ensure that hypothesis ids are unique in the merged container\n        return_mappings : boolean, unique\n            Whether or not to return mapping information\n\n        Returns\n        -------\n        df : pandas.DataFrame\n            Merged event data frame\n        \"\"\"\n\n        mapping_infos = []\n        new_oid = itertools.count()\n        new_hid = itertools.count()\n\n        r = MOTAccumulator.new_event_dataframe()\n        for df in dfs:\n\n            if isinstance(df, MOTAccumulator):\n                df = df.events\n\n            copy = df.copy()\n            infos = {}\n\n            # Update index\n            if update_frame_indices:\n                # pylint: disable=cell-var-from-loop\n                next_frame_id = max(r.index.get_level_values(0).max() + 1, r.index.get_level_values(0).unique().shape[0])\n                if np.isnan(next_frame_id):\n                    next_frame_id = 0\n                if not copy.index.empty:\n                    copy.index = copy.index.map(lambda x: (x[0] + next_frame_id, x[1]))\n                infos['frame_offset'] = next_frame_id\n\n            # Update object / hypothesis ids\n            if update_oids:\n                # pylint: disable=cell-var-from-loop\n                oid_map = dict([oid, str(next(new_oid))] for oid in copy['OId'].dropna().unique())\n                copy['OId'] = copy['OId'].map(lambda x: oid_map[x], na_action='ignore')\n                infos['oid_map'] = oid_map\n\n            if update_hids:\n                # pylint: disable=cell-var-from-loop\n                hid_map = dict([hid, str(next(new_hid))] for hid in copy['HId'].dropna().unique())\n                copy['HId'] = copy['HId'].map(lambda x: hid_map[x], na_action='ignore')\n                infos['hid_map'] = hid_map\n\n            r = pd.concat([r, copy])\n            mapping_infos.append(infos)\n\n        if return_mappings:\n            return r, mapping_infos\n        else:\n            return r\n"
  },
  "GT_src_dict": {
    "motmetrics/mot.py": {
      "MOTAccumulator.__init__": {
        "code": "    def __init__(self, auto_id=False, max_switch_time=float('inf')):\n        \"\"\"Initialize a MOTAccumulator to manage tracking events for multiple object tracking.\n\nParameters\n----------\nauto_id : bool, optional\n    If True, frame indices are auto-incremented. If False (default), frame indices must be provided during updates.\nmax_switch_time : scalar, optional\n    The maximum allowed duration (in frames) between observations of an object for it to retain its identity. Defaults to infinity, allowing unlimited duration.\n\nAttributes\n----------\nauto_id : bool\n    Configuration for auto-incrementing frame indices.\nmax_switch_time : scalar\n    Restriction on the duration an unobserved tracked object can generate switch events.\n_events : dict\n    Container for tracking event data, initialized in reset().\n_indices : dict\n    Container for frame and event indices, also initialized in reset().\nm : dict\n    Tracks the current pairings of object and hypothesis IDs.\nres_m : dict\n    Stores the historical pairings of hypothesis to object IDs.\nlast_occurrence : dict\n    Records the last frame each object was observed.\nlast_match : dict\n    Stores the last frame when an object was matched.\nhypHistory : dict\n    Tracks the historical occurrences of hypotheses.\ndirty_events : bool\n    Indicates whether the events DataFrame needs to be refreshed.\ncached_events_df : pandas.DataFrame or None\n    Caches the generated events DataFrame for efficiency.\nlast_update_frameid : int or None\n    Records the frame ID of the last update.\n\nInterdependencies\n-----------------\nThe class depends on the `reset()` method to initialize its state, ensuring all tracking data is empty at start. The `update()` method will drive the event accumulation using this initial state.\"\"\"\n        'Create a MOTAccumulator.\\n\\n        Params\\n        ------\\n        auto_id : bool, optional\\n            Whether or not frame indices are auto-incremented or provided upon\\n            updating. Defaults to false. Not specifying a frame-id when this value\\n            is true results in an error. Specifying a frame-id when this value is\\n            false also results in an error.\\n\\n        max_switch_time : scalar, optional\\n            Allows specifying an upper bound on the timespan an unobserved but\\n            tracked object is allowed to generate track switch events. Useful if groundtruth\\n            objects leaving the field of view keep their ID when they reappear,\\n            but your tracker is not capable of recognizing this (resulting in\\n            track switch events). The default is that there is no upper bound\\n            on the timespan. In units of frame timestamps. When using auto_id\\n            in units of count.\\n        '\n        self.auto_id = auto_id\n        self.max_switch_time = max_switch_time\n        self._events = None\n        self._indices = None\n        self.m = None\n        self.res_m = None\n        self.last_occurrence = None\n        self.last_match = None\n        self.hypHistory = None\n        self.dirty_events = None\n        self.cached_events_df = None\n        self.last_update_frameid = None\n        self.reset()",
        "docstring": "Initialize a MOTAccumulator to manage tracking events for multiple object tracking.\n\nParameters\n----------\nauto_id : bool, optional\n    If True, frame indices are auto-incremented. If False (default), frame indices must be provided during updates.\nmax_switch_time : scalar, optional\n    The maximum allowed duration (in frames) between observations of an object for it to retain its identity. Defaults to infinity, allowing unlimited duration.\n\nAttributes\n----------\nauto_id : bool\n    Configuration for auto-incrementing frame indices.\nmax_switch_time : scalar\n    Restriction on the duration an unobserved tracked object can generate switch events.\n_events : dict\n    Container for tracking event data, initialized in reset().\n_indices : dict\n    Container for frame and event indices, also initialized in reset().\nm : dict\n    Tracks the current pairings of object and hypothesis IDs.\nres_m : dict\n    Stores the historical pairings of hypothesis to object IDs.\nlast_occurrence : dict\n    Records the last frame each object was observed.\nlast_match : dict\n    Stores the last frame when an object was matched.\nhypHistory : dict\n    Tracks the historical occurrences of hypotheses.\ndirty_events : bool\n    Indicates whether the events DataFrame needs to be refreshed.\ncached_events_df : pandas.DataFrame or None\n    Caches the generated events DataFrame for efficiency.\nlast_update_frameid : int or None\n    Records the frame ID of the last update.\n\nInterdependencies\n-----------------\nThe class depends on the `reset()` method to initialize its state, ensuring all tracking data is empty at start. The `update()` method will drive the event accumulation using this initial state.",
        "signature": "def __init__(self, auto_id=False, max_switch_time=float('inf')):",
        "type": "Method",
        "class_signature": "class MOTAccumulator(object):"
      },
      "MOTAccumulator.update": {
        "code": "    def update(self, oids, hids, dists, frameid=None, vf='', similartiy_matrix=None, th=None):\n        \"\"\"Updates the MOTAccumulator with frame-specific object detections, generating tracking events based on the established algorithm. The method attempts to match objects with hypotheses from the current frame using a distance matrix, recording events such as 'MATCH', 'SWITCH', 'MISS', and 'FP' (false positives). The method requires unique object and hypothesis IDs along with their corresponding distances, while managing internal state associated with previous matches.\n\nParameters\n----------\noids : array-like\n    An array of object IDs present in the current frame.\nhids : array-like\n    An array of hypothesis IDs to match against the object IDs.\ndists : array-like, shape (N, M)\n    A distance matrix indicating pairwise distances between objects and hypotheses, where NaN values signal do-not-pair constellations.\nframeid : int, optional\n    An optional unique frame ID; auto-incremented if not provided and auto_id is enabled.\nvf : str, optional\n    A file path to log detailed events during the update.\nsimilartiy_matrix : array-like, optional\n    A similarity matrix for computing distances; modifies the distance matrix if provided alongside a threshold.\nth : float, optional\n    A threshold used to filter the similarity matrix, determining pairable objects.\n\nReturns\n-------\nint\n    The frame ID after the update.\n\nSide Effects\n------------\nUpdates internal state variables such as last occurrences of objects, match history, and caches generated events for later retrieval.\n\nNotes\n-----\nRequires `linear_sum_assignment` from `motmetrics.lap` for optimal pairing based on cost minimization. It employs an internal logical structure to determine event types, tracking changes and maintaining relationships between detections across frames.\"\"\"\n        'Updates the accumulator with frame specific objects/detections.\\n\\n        This method generates events based on the following algorithm [1]:\\n        1. Try to carry forward already established tracks. If any paired object / hypothesis\\n        from previous timestamps are still visible in the current frame, create a \\'MATCH\\'\\n        event between them.\\n        2. For the remaining constellations minimize the total object / hypothesis distance\\n        error (Kuhn-Munkres algorithm). If a correspondence made contradicts a previous\\n        match create a \\'SWITCH\\' else a \\'MATCH\\' event.\\n        3. Create \\'MISS\\' events for all remaining unassigned objects.\\n        4. Create \\'FP\\' events for all remaining unassigned hypotheses.\\n\\n        Params\\n        ------\\n        oids : N array\\n            Array of object ids.\\n        hids : M array\\n            Array of hypothesis ids.\\n        dists: NxM array\\n            Distance matrix. np.nan values to signal do-not-pair constellations.\\n            See `distances` module for support methods.\\n\\n        Kwargs\\n        ------\\n        frameId : id\\n            Unique frame id. Optional when MOTAccumulator.auto_id is specified during\\n            construction.\\n        vf: file to log details\\n        Returns\\n        -------\\n        frame_events : pd.DataFrame\\n            Dataframe containing generated events\\n\\n        References\\n        ----------\\n        1. Bernardin, Keni, and Rainer Stiefelhagen. \"Evaluating multiple object tracking performance: the CLEAR MOT metrics.\"\\n        EURASIP Journal on Image and Video Processing 2008.1 (2008): 1-10.\\n        '\n        self.dirty_events = True\n        oids = np.asarray(oids)\n        oids_masked = np.zeros_like(oids, dtype=np.bool_)\n        hids = np.asarray(hids)\n        hids_masked = np.zeros_like(hids, dtype=np.bool_)\n        dists = np.atleast_2d(dists).astype(float).reshape(oids.shape[0], hids.shape[0]).copy()\n        if frameid is None:\n            assert self.auto_id, 'auto-id is not enabled'\n            if len(self._indices['FrameId']) > 0:\n                frameid = self._indices['FrameId'][-1] + 1\n            else:\n                frameid = 0\n        else:\n            assert not self.auto_id, 'Cannot provide frame id when auto-id is enabled'\n        eid = itertools.count()\n        no = len(oids)\n        nh = len(hids)\n        self._append_to_indices(frameid, next(eid))\n        self._append_to_events('RAW', np.nan, np.nan, np.nan)\n        cost_for_matching = dists.copy()\n        if similartiy_matrix is not None and th is not None:\n            dists = 1 - similartiy_matrix\n            dists = np.where(similartiy_matrix < th - np.finfo('float').eps, np.nan, dists)\n        valid_i, valid_j = np.where(np.isfinite(dists))\n        valid_dists = dists[valid_i, valid_j]\n        for i, j, dist_ij in zip(valid_i, valid_j, valid_dists):\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('RAW', oids[i], hids[j], dist_ij)\n        used_i = np.unique(valid_i)\n        used_j = np.unique(valid_j)\n        unused_i = np.setdiff1d(np.arange(no), used_i)\n        unused_j = np.setdiff1d(np.arange(nh), used_j)\n        for oid in oids[unused_i]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('RAW', oid, np.nan, np.nan)\n        for hid in hids[unused_j]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('RAW', np.nan, hid, np.nan)\n        if oids.size * hids.size > 0:\n            if similartiy_matrix is None or th is None:\n                for i in range(oids.shape[0]):\n                    if not (oids[i] in self.m and self.last_match[oids[i]] == self.last_update_frameid):\n                        continue\n                    hprev = self.m[oids[i]]\n                    j, = np.where(~hids_masked & (hids == hprev))\n                    if j.shape[0] == 0:\n                        continue\n                    j = j[0]\n                    if np.isfinite(dists[i, j]):\n                        o = oids[i]\n                        h = hids[j]\n                        oids_masked[i] = True\n                        hids_masked[j] = True\n                        self.m[oids[i]] = hids[j]\n                        self._append_to_indices(frameid, next(eid))\n                        self._append_to_events('MATCH', oids[i], hids[j], dists[i, j])\n                        self.last_match[o] = frameid\n                        self.hypHistory[h] = frameid\n            dists[oids_masked, :] = np.nan\n            dists[:, hids_masked] = np.nan\n            rids, cids = linear_sum_assignment(cost_for_matching)\n            for i, j in zip(rids, cids):\n                if not np.isfinite(dists[i, j]):\n                    continue\n                o = oids[i]\n                h = hids[j]\n                switch_condition = o in self.m and self.m[o] != h and (o in self.last_occurrence) and (abs(frameid - self.last_occurrence[o]) <= self.max_switch_time)\n                is_switch = switch_condition\n                cat1 = 'SWITCH' if is_switch else 'MATCH'\n                if cat1 == 'SWITCH':\n                    if h not in self.hypHistory:\n                        subcat = 'ASCEND'\n                        self._append_to_indices(frameid, next(eid))\n                        self._append_to_events(subcat, oids[i], hids[j], dists[i, j])\n                is_transfer = h in self.res_m and self.res_m[h] != o\n                cat2 = 'TRANSFER' if is_transfer else 'MATCH'\n                if cat2 == 'TRANSFER':\n                    if o not in self.last_match:\n                        subcat = 'MIGRATE'\n                        self._append_to_indices(frameid, next(eid))\n                        self._append_to_events(subcat, oids[i], hids[j], dists[i, j])\n                    self._append_to_indices(frameid, next(eid))\n                    self._append_to_events(cat2, oids[i], hids[j], dists[i, j])\n                if vf != '' and (cat1 != 'MATCH' or cat2 != 'MATCH'):\n                    if cat1 == 'SWITCH':\n                        vf.write('%s %d %d %d %d %d\\n' % (subcat[:2], o, self.last_match[o], self.m[o], frameid, h))\n                    if cat2 == 'TRANSFER':\n                        vf.write('%s %d %d %d %d %d\\n' % (subcat[:2], h, self.hypHistory[h], self.res_m[h], frameid, o))\n                self.hypHistory[h] = frameid\n                self.last_match[o] = frameid\n                self._append_to_indices(frameid, next(eid))\n                self._append_to_events(cat1, oids[i], hids[j], dists[i, j])\n                oids_masked[i] = True\n                hids_masked[j] = True\n                self.m[o] = h\n                self.res_m[h] = o\n        for o in oids[~oids_masked]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('MISS', o, np.nan, np.nan)\n            if vf != '':\n                vf.write('FN %d %d\\n' % (frameid, o))\n        for h in hids[~hids_masked]:\n            self._append_to_indices(frameid, next(eid))\n            self._append_to_events('FP', np.nan, h, np.nan)\n            if vf != '':\n                vf.write('FP %d %d\\n' % (frameid, h))\n        for o in oids:\n            self.last_occurrence[o] = frameid\n        self.last_update_frameid = frameid\n        return frameid",
        "docstring": "Updates the MOTAccumulator with frame-specific object detections, generating tracking events based on the established algorithm. The method attempts to match objects with hypotheses from the current frame using a distance matrix, recording events such as 'MATCH', 'SWITCH', 'MISS', and 'FP' (false positives). The method requires unique object and hypothesis IDs along with their corresponding distances, while managing internal state associated with previous matches.\n\nParameters\n----------\noids : array-like\n    An array of object IDs present in the current frame.\nhids : array-like\n    An array of hypothesis IDs to match against the object IDs.\ndists : array-like, shape (N, M)\n    A distance matrix indicating pairwise distances between objects and hypotheses, where NaN values signal do-not-pair constellations.\nframeid : int, optional\n    An optional unique frame ID; auto-incremented if not provided and auto_id is enabled.\nvf : str, optional\n    A file path to log detailed events during the update.\nsimilartiy_matrix : array-like, optional\n    A similarity matrix for computing distances; modifies the distance matrix if provided alongside a threshold.\nth : float, optional\n    A threshold used to filter the similarity matrix, determining pairable objects.\n\nReturns\n-------\nint\n    The frame ID after the update.\n\nSide Effects\n------------\nUpdates internal state variables such as last occurrences of objects, match history, and caches generated events for later retrieval.\n\nNotes\n-----\nRequires `linear_sum_assignment` from `motmetrics.lap` for optimal pairing based on cost minimization. It employs an internal logical structure to determine event types, tracking changes and maintaining relationships between detections across frames.",
        "signature": "def update(self, oids, hids, dists, frameid=None, vf='', similartiy_matrix=None, th=None):",
        "type": "Method",
        "class_signature": "class MOTAccumulator(object):"
      },
      "MOTAccumulator.events": {
        "code": "    def events(self):\n        \"\"\"Returns a DataFrame containing accumulated tracking events.\n\nThis property generates a DataFrame of events based on internal state stored in `_events` and `_indices`. The events are created if they were marked as 'dirty', which means they were modified since the last time they were accessed. It uses the static method `new_event_dataframe_with_data` to create or update the DataFrame.\n\nReturns\n-------\npd.DataFrame\n    A DataFrame indexed by `FrameId` and `EventId`, containing columns for `Type`, `OId`, `HId`, and `D`, representing the type of event (e.g., 'MATCH', 'MISS'), object ID, hypothesis ID, and distance, respectively.\n\nDependencies\n------------\n- _EVENT_FIELDS: A constant list containing the relevant fields for event tracking.\n- _INDEX_FIELDS: A constant list defining the indexing structure for organizing events into a multi-index DataFrame.\n- `MOTAccumulator.new_event_dataframe_with_data`: A static method used to create the DataFrame with event data.\"\"\"\n        if self.dirty_events:\n            self.cached_events_df = MOTAccumulator.new_event_dataframe_with_data(self._indices, self._events)\n            self.dirty_events = False\n        return self.cached_events_df",
        "docstring": "Returns a DataFrame containing accumulated tracking events.\n\nThis property generates a DataFrame of events based on internal state stored in `_events` and `_indices`. The events are created if they were marked as 'dirty', which means they were modified since the last time they were accessed. It uses the static method `new_event_dataframe_with_data` to create or update the DataFrame.\n\nReturns\n-------\npd.DataFrame\n    A DataFrame indexed by `FrameId` and `EventId`, containing columns for `Type`, `OId`, `HId`, and `D`, representing the type of event (e.g., 'MATCH', 'MISS'), object ID, hypothesis ID, and distance, respectively.\n\nDependencies\n------------\n- _EVENT_FIELDS: A constant list containing the relevant fields for event tracking.\n- _INDEX_FIELDS: A constant list defining the indexing structure for organizing events into a multi-index DataFrame.\n- `MOTAccumulator.new_event_dataframe_with_data`: A static method used to create the DataFrame with event data.",
        "signature": "def events(self):",
        "type": "Method",
        "class_signature": "class MOTAccumulator(object):"
      },
      "MOTAccumulator.new_event_dataframe": {
        "code": "    def new_event_dataframe():\n        \"\"\"Create a new DataFrame for event tracking in the MOTAccumulator.\n\nThis method initializes an empty pandas DataFrame structured for tracking events related to\nmultiple object tracking. The DataFrame contains hierarchical indices for `FrameId` and `Event`, \nalong with a categorical column for event `Type`, and float columns for `OId` (Object ID), \n`HId` (Hypothesis ID), and `D` (Distance). The `Type` column categorizes the events as one of \nthe following: 'RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', or 'MIGRATE'.\n\nReturns\n-------\npd.DataFrame\n    An empty DataFrame initialized for tracking events, ready to be populated with event data.\n\nConstants:\n- `categories`: Defines the valid types of events as a categorical list used for the \n  `Type` column. This is critical for consistency in event type representation across instances.\"\"\"\n        'Create a new DataFrame for event tracking.'\n        idx = pd.MultiIndex(levels=[[], []], codes=[[], []], names=['FrameId', 'Event'])\n        cats = pd.Categorical([], categories=['RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', 'MIGRATE'])\n        df = pd.DataFrame(OrderedDict([('Type', pd.Series(cats)), ('OId', pd.Series(dtype=float)), ('HId', pd.Series(dtype=float)), ('D', pd.Series(dtype=float))]), index=idx)\n        return df",
        "docstring": "Create a new DataFrame for event tracking in the MOTAccumulator.\n\nThis method initializes an empty pandas DataFrame structured for tracking events related to\nmultiple object tracking. The DataFrame contains hierarchical indices for `FrameId` and `Event`, \nalong with a categorical column for event `Type`, and float columns for `OId` (Object ID), \n`HId` (Hypothesis ID), and `D` (Distance). The `Type` column categorizes the events as one of \nthe following: 'RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', or 'MIGRATE'.\n\nReturns\n-------\npd.DataFrame\n    An empty DataFrame initialized for tracking events, ready to be populated with event data.\n\nConstants:\n- `categories`: Defines the valid types of events as a categorical list used for the \n  `Type` column. This is critical for consistency in event type representation across instances.",
        "signature": "def new_event_dataframe():",
        "type": "Method",
        "class_signature": "class MOTAccumulator(object):"
      },
      "MOTAccumulator.merge_event_dataframes": {
        "code": "    def merge_event_dataframes(dfs, update_frame_indices=True, update_oids=True, update_hids=True, return_mappings=False):\n        \"\"\"Merge multiple event dataframes from MOTAccumulator instances or pandas DataFrames into a single, unified DataFrame.\n\nParameters\n----------\ndfs : list of pandas.DataFrame or MOTAccumulator\n    A list containing event dataframes to merge. If an element is an instance of MOTAccumulator, its event DataFrame will be used.\n\nupdate_frame_indices : bool, optional\n    If True, ensures that frame indices in the merged DataFrame are unique. Default is True.\n\nupdate_oids : bool, optional\n    If True, ensures that object IDs in the merged DataFrame are unique. Default is True.\n\nupdate_hids : bool, optional\n    If True, ensures that hypothesis IDs in the merged DataFrame are unique. Default is True.\n\nreturn_mappings : bool, optional\n    If True, returns a mapping of original object and hypothesis IDs to their new IDs in addition to the merged DataFrame. Default is False.\n\nReturns\n-------\npd.DataFrame\n    A new DataFrame containing merged events from the provided DataFrames, updated according to the specified parameters.\n\nNotes\n-----\n- The method utilizes itertools.count to create new unique identifiers for object and hypothesis IDs during the merge process.\n- The method makes use of the helper function `MOTAccumulator.new_event_dataframe()` to initialize the merged DataFrame.\n- The merging operation adjusts indices and IDs based on the specified update flags, ensuring no conflicts arise in the resulting DataFrame.\"\"\"\n        'Merge dataframes.\\n\\n        Params\\n        ------\\n        dfs : list of pandas.DataFrame or MotAccumulator\\n            A list of event containers to merge\\n\\n        Kwargs\\n        ------\\n        update_frame_indices : boolean, optional\\n            Ensure that frame indices are unique in the merged container\\n        update_oids : boolean, unique\\n            Ensure that object ids are unique in the merged container\\n        update_hids : boolean, unique\\n            Ensure that hypothesis ids are unique in the merged container\\n        return_mappings : boolean, unique\\n            Whether or not to return mapping information\\n\\n        Returns\\n        -------\\n        df : pandas.DataFrame\\n            Merged event data frame\\n        '\n        mapping_infos = []\n        new_oid = itertools.count()\n        new_hid = itertools.count()\n        r = MOTAccumulator.new_event_dataframe()\n        for df in dfs:\n            if isinstance(df, MOTAccumulator):\n                df = df.events\n            copy = df.copy()\n            infos = {}\n            if update_frame_indices:\n                next_frame_id = max(r.index.get_level_values(0).max() + 1, r.index.get_level_values(0).unique().shape[0])\n                if np.isnan(next_frame_id):\n                    next_frame_id = 0\n                if not copy.index.empty:\n                    copy.index = copy.index.map(lambda x: (x[0] + next_frame_id, x[1]))\n                infos['frame_offset'] = next_frame_id\n            if update_oids:\n                oid_map = dict(([oid, str(next(new_oid))] for oid in copy['OId'].dropna().unique()))\n                copy['OId'] = copy['OId'].map(lambda x: oid_map[x], na_action='ignore')\n                infos['oid_map'] = oid_map\n            if update_hids:\n                hid_map = dict(([hid, str(next(new_hid))] for hid in copy['HId'].dropna().unique()))\n                copy['HId'] = copy['HId'].map(lambda x: hid_map[x], na_action='ignore')\n                infos['hid_map'] = hid_map\n            r = pd.concat([r, copy])\n            mapping_infos.append(infos)\n        if return_mappings:\n            return (r, mapping_infos)\n        else:\n            return r",
        "docstring": "Merge multiple event dataframes from MOTAccumulator instances or pandas DataFrames into a single, unified DataFrame.\n\nParameters\n----------\ndfs : list of pandas.DataFrame or MOTAccumulator\n    A list containing event dataframes to merge. If an element is an instance of MOTAccumulator, its event DataFrame will be used.\n\nupdate_frame_indices : bool, optional\n    If True, ensures that frame indices in the merged DataFrame are unique. Default is True.\n\nupdate_oids : bool, optional\n    If True, ensures that object IDs in the merged DataFrame are unique. Default is True.\n\nupdate_hids : bool, optional\n    If True, ensures that hypothesis IDs in the merged DataFrame are unique. Default is True.\n\nreturn_mappings : bool, optional\n    If True, returns a mapping of original object and hypothesis IDs to their new IDs in addition to the merged DataFrame. Default is False.\n\nReturns\n-------\npd.DataFrame\n    A new DataFrame containing merged events from the provided DataFrames, updated according to the specified parameters.\n\nNotes\n-----\n- The method utilizes itertools.count to create new unique identifiers for object and hypothesis IDs during the merge process.\n- The method makes use of the helper function `MOTAccumulator.new_event_dataframe()` to initialize the merged DataFrame.\n- The merging operation adjusts indices and IDs based on the specified update flags, ensuring no conflicts arise in the resulting DataFrame.",
        "signature": "def merge_event_dataframes(dfs, update_frame_indices=True, update_oids=True, update_hids=True, return_mappings=False):",
        "type": "Method",
        "class_signature": "class MOTAccumulator(object):"
      }
    }
  },
  "dependency_dict": {
    "motmetrics/mot.py:MOTAccumulator:__init__": {
      "motmetrics/mot.py": {
        "MOTAccumulator.reset": {
          "code": "    def reset(self):\n        \"\"\"Reset the accumulator to empty state.\"\"\"\n        self._events = {field: [] for field in _EVENT_FIELDS}\n        self._indices = {field: [] for field in _INDEX_FIELDS}\n        self.m = {}\n        self.res_m = {}\n        self.last_occurrence = {}\n        self.last_match = {}\n        self.hypHistory = {}\n        self.dirty_events = True\n        self.cached_events_df = None\n        self.last_update_frameid = None",
          "docstring": "Reset the accumulator to empty state.",
          "signature": "def reset(self):",
          "type": "Method",
          "class_signature": "class MOTAccumulator(object):"
        }
      }
    },
    "motmetrics/mot.py:MOTAccumulator:update": {
      "motmetrics/mot.py": {
        "MOTAccumulator._append_to_indices": {
          "code": "    def _append_to_indices(self, frameid, eid):\n        self._indices['FrameId'].append(frameid)\n        self._indices['Event'].append(eid)",
          "docstring": "",
          "signature": "def _append_to_indices(self, frameid, eid):",
          "type": "Method",
          "class_signature": "class MOTAccumulator(object):"
        },
        "MOTAccumulator._append_to_events": {
          "code": "    def _append_to_events(self, typestr, oid, hid, distance):\n        self._events['Type'].append(typestr)\n        self._events['OId'].append(oid)\n        self._events['HId'].append(hid)\n        self._events['D'].append(distance)",
          "docstring": "",
          "signature": "def _append_to_events(self, typestr, oid, hid, distance):",
          "type": "Method",
          "class_signature": "class MOTAccumulator(object):"
        }
      },
      "motmetrics/lap.py": {
        "linear_sum_assignment": {
          "code": "def linear_sum_assignment(costs, solver=None):\n    \"\"\"Solve a linear sum assignment problem (LSA).\n\n    For large datasets solving the minimum cost assignment becomes the dominant runtime part.\n    We therefore support various solvers out of the box (currently lapsolver, scipy, ortools, munkres)\n\n    Params\n    ------\n    costs : np.array\n        numpy matrix containing costs. Use NaN/Inf values for unassignable\n        row/column pairs.\n\n    Kwargs\n    ------\n    solver : callable or str, optional\n        When str: name of solver to use.\n        When callable: function to invoke\n        When None: uses first available solver\n    \"\"\"\n    costs = np.asarray(costs)\n    if not costs.size:\n        return np.array([], dtype=int), np.array([], dtype=int)\n\n    solver = solver or default_solver\n\n    if isinstance(solver, str):\n        # Try resolve from string\n        solver = solver_map.get(solver, None)\n\n    assert callable(solver), 'Invalid LAP solver.'\n    rids, cids = solver(costs)\n    rids = np.asarray(rids).astype(int)\n    cids = np.asarray(cids).astype(int)\n    return rids, cids",
          "docstring": "Solve a linear sum assignment problem (LSA).\n\nFor large datasets solving the minimum cost assignment becomes the dominant runtime part.\nWe therefore support various solvers out of the box (currently lapsolver, scipy, ortools, munkres)\n\nParams\n------\ncosts : np.array\n    numpy matrix containing costs. Use NaN/Inf values for unassignable\n    row/column pairs.\n\nKwargs\n------\nsolver : callable or str, optional\n    When str: name of solver to use.\n    When callable: function to invoke\n    When None: uses first available solver",
          "signature": "def linear_sum_assignment(costs, solver=None):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "motmetrics/mot.py:MOTAccumulator:events": {
      "motmetrics/mot.py": {
        "MOTAccumulator.new_event_dataframe_with_data": {
          "code": "    def new_event_dataframe_with_data(indices, events):\n        \"\"\"Create a new DataFrame filled with data.\n\n        Params\n        ------\n        indices: dict\n            dict of lists with fields 'FrameId' and 'Event'\n        events: dict\n            dict of lists with fields 'Type', 'OId', 'HId', 'D'\n        \"\"\"\n        if len(events) == 0:\n            return MOTAccumulator.new_event_dataframe()\n        raw_type = pd.Categorical(events['Type'], categories=['RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', 'MIGRATE'], ordered=False)\n        series = [pd.Series(raw_type, name='Type'), pd.Series(events['OId'], dtype=float, name='OId'), pd.Series(events['HId'], dtype=float, name='HId'), pd.Series(events['D'], dtype=float, name='D')]\n        idx = pd.MultiIndex.from_arrays([indices[field] for field in _INDEX_FIELDS], names=_INDEX_FIELDS)\n        df = pd.concat(series, axis=1)\n        df.index = idx\n        return df",
          "docstring": "Create a new DataFrame filled with data.\n\nParams\n------\nindices: dict\n    dict of lists with fields 'FrameId' and 'Event'\nevents: dict\n    dict of lists with fields 'Type', 'OId', 'HId', 'D'",
          "signature": "def new_event_dataframe_with_data(indices, events):",
          "type": "Method",
          "class_signature": "class MOTAccumulator(object):"
        }
      }
    },
    "motmetrics/mot.py:MOTAccumulator:merge_event_dataframes": {}
  },
  "call_tree": {
    "motmetrics/tests/test_mot.py:test_events": {
      "motmetrics/mot.py:MOTAccumulator:__init__": {
        "motmetrics/mot.py:MOTAccumulator:reset": {}
      },
      "motmetrics/mot.py:MOTAccumulator:update": {
        "motmetrics/mot.py:MOTAccumulator:_append_to_indices": {},
        "motmetrics/mot.py:MOTAccumulator:_append_to_events": {},
        "motmetrics/lap.py:linear_sum_assignment": {
          "motmetrics/lap.py:lsa_solve_scipy": {
            "motmetrics/lap.py:add_expensive_edges": {},
            "motmetrics/lap.py:_exclude_missing_edges": {}
          }
        }
      },
      "motmetrics/mot.py:MOTAccumulator:new_event_dataframe": {},
      "motmetrics/mot.py:MOTAccumulator:events": {
        "motmetrics/mot.py:MOTAccumulator:new_event_dataframe_with_data": {}
      }
    },
    "motmetrics/tests/test_mot.py:test_max_switch_time": {
      "motmetrics/mot.py:MOTAccumulator:__init__": {
        "motmetrics/mot.py:MOTAccumulator:reset": {}
      },
      "motmetrics/mot.py:MOTAccumulator:update": {
        "motmetrics/mot.py:MOTAccumulator:_append_to_indices": {},
        "motmetrics/mot.py:MOTAccumulator:_append_to_events": {},
        "motmetrics/lap.py:linear_sum_assignment": {
          "motmetrics/lap.py:lsa_solve_scipy": {
            "motmetrics/lap.py:add_expensive_edges": {},
            "motmetrics/lap.py:_exclude_missing_edges": {}
          }
        }
      },
      "motmetrics/mot.py:MOTAccumulator:events": {
        "motmetrics/mot.py:MOTAccumulator:new_event_dataframe_with_data": {}
      }
    },
    "motmetrics/tests/test_mot.py:test_auto_id": {
      "motmetrics/mot.py:MOTAccumulator:__init__": {
        "motmetrics/mot.py:MOTAccumulator:reset": {}
      },
      "motmetrics/mot.py:MOTAccumulator:update": {
        "motmetrics/mot.py:MOTAccumulator:_append_to_indices": {},
        "motmetrics/mot.py:MOTAccumulator:_append_to_events": {}
      },
      "motmetrics/mot.py:MOTAccumulator:events": {
        "motmetrics/mot.py:MOTAccumulator:new_event_dataframe_with_data": {}
      }
    },
    "motmetrics/tests/test_mot.py:test_merge_dataframes": {
      "motmetrics/mot.py:MOTAccumulator:__init__": {
        "motmetrics/mot.py:MOTAccumulator:reset": {}
      },
      "motmetrics/mot.py:MOTAccumulator:update": {
        "motmetrics/mot.py:MOTAccumulator:_append_to_indices": {},
        "motmetrics/mot.py:MOTAccumulator:_append_to_events": {},
        "motmetrics/lap.py:linear_sum_assignment": {
          "motmetrics/lap.py:lsa_solve_scipy": {
            "motmetrics/lap.py:add_expensive_edges": {},
            "motmetrics/lap.py:_exclude_missing_edges": {}
          }
        }
      },
      "motmetrics/mot.py:MOTAccumulator:events": {
        "motmetrics/mot.py:MOTAccumulator:new_event_dataframe_with_data": {}
      },
      "motmetrics/mot.py:MOTAccumulator:merge_event_dataframes": {
        "motmetrics/mot.py:MOTAccumulator:new_event_dataframe": {}
      },
      "motmetrics/mot.py:MOTAccumulator:new_event_dataframe": {}
    }
  },
  "PRD": "# PROJECT NAME: motmetrics-test_mot\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 motmetrics/\n    \u2514\u2500\u2500 mot.py\n        \u251c\u2500\u2500 MOTAccumulator.__init__\n        \u251c\u2500\u2500 MOTAccumulator.events\n        \u251c\u2500\u2500 MOTAccumulator.merge_event_dataframes\n        \u251c\u2500\u2500 MOTAccumulator.new_event_dataframe\n        \u2514\u2500\u2500 MOTAccumulator.update\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module tests the functionality of the MOTAccumulator within the `py-motmetrics` library, which is designed for benchmarking multiple object tracking (MOT) performance. It ensures the accurate tracking of object assignments, events, and transitions across frames, including handling false positives, misses, matches, and identity switches. Additionally, the module verifies support for advanced features such as managing maximum switch times, automatic frame identification, and merging dataframes for consolidated event analysis. By validating these capabilities, the module ensures reliable evaluation of MOT algorithms, enabling developers and researchers to benchmark and optimize tracking systems effectively.\n\n## FILE 1: motmetrics/mot.py\n\n- CLASS METHOD: MOTAccumulator.events\n  - CLASS SIGNATURE: class MOTAccumulator(object):\n  - SIGNATURE: def events(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a DataFrame containing accumulated tracking events.\n\nThis property generates a DataFrame of events based on internal state stored in `_events` and `_indices`. The events are created if they were marked as 'dirty', which means they were modified since the last time they were accessed. It uses the static method `new_event_dataframe_with_data` to create or update the DataFrame.\n\nReturns\n-------\npd.DataFrame\n    A DataFrame indexed by `FrameId` and `EventId`, containing columns for `Type`, `OId`, `HId`, and `D`, representing the type of event (e.g., 'MATCH', 'MISS'), object ID, hypothesis ID, and distance, respectively.\n\nDependencies\n------------\n- _EVENT_FIELDS: A constant list containing the relevant fields for event tracking.\n- _INDEX_FIELDS: A constant list defining the indexing structure for organizing events into a multi-index DataFrame.\n- `MOTAccumulator.new_event_dataframe_with_data`: A static method used to create the DataFrame with event data.\n\"\"\"\n```\n\n- CLASS METHOD: MOTAccumulator.update\n  - CLASS SIGNATURE: class MOTAccumulator(object):\n  - SIGNATURE: def update(self, oids, hids, dists, frameid=None, vf='', similartiy_matrix=None, th=None):\n  - DOCSTRING: \n```python\n\"\"\"\nUpdates the MOTAccumulator with frame-specific object detections, generating tracking events based on the established algorithm. The method attempts to match objects with hypotheses from the current frame using a distance matrix, recording events such as 'MATCH', 'SWITCH', 'MISS', and 'FP' (false positives). The method requires unique object and hypothesis IDs along with their corresponding distances, while managing internal state associated with previous matches.\n\nParameters\n----------\noids : array-like\n    An array of object IDs present in the current frame.\nhids : array-like\n    An array of hypothesis IDs to match against the object IDs.\ndists : array-like, shape (N, M)\n    A distance matrix indicating pairwise distances between objects and hypotheses, where NaN values signal do-not-pair constellations.\nframeid : int, optional\n    An optional unique frame ID; auto-incremented if not provided and auto_id is enabled.\nvf : str, optional\n    A file path to log detailed events during the update.\nsimilartiy_matrix : array-like, optional\n    A similarity matrix for computing distances; modifies the distance matrix if provided alongside a threshold.\nth : float, optional\n    A threshold used to filter the similarity matrix, determining pairable objects.\n\nReturns\n-------\nint\n    The frame ID after the update.\n\nSide Effects\n------------\nUpdates internal state variables such as last occurrences of objects, match history, and caches generated events for later retrieval.\n\nNotes\n-----\nRequires `linear_sum_assignment` from `motmetrics.lap` for optimal pairing based on cost minimization. It employs an internal logical structure to determine event types, tracking changes and maintaining relationships between detections across frames.\n\"\"\"\n```\n\n- CLASS METHOD: MOTAccumulator.new_event_dataframe\n  - CLASS SIGNATURE: class MOTAccumulator(object):\n  - SIGNATURE: def new_event_dataframe():\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new DataFrame for event tracking in the MOTAccumulator.\n\nThis method initializes an empty pandas DataFrame structured for tracking events related to\nmultiple object tracking. The DataFrame contains hierarchical indices for `FrameId` and `Event`, \nalong with a categorical column for event `Type`, and float columns for `OId` (Object ID), \n`HId` (Hypothesis ID), and `D` (Distance). The `Type` column categorizes the events as one of \nthe following: 'RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', or 'MIGRATE'.\n\nReturns\n-------\npd.DataFrame\n    An empty DataFrame initialized for tracking events, ready to be populated with event data.\n\nConstants:\n- `categories`: Defines the valid types of events as a categorical list used for the \n  `Type` column. This is critical for consistency in event type representation across instances.\n\"\"\"\n```\n\n- CLASS METHOD: MOTAccumulator.merge_event_dataframes\n  - CLASS SIGNATURE: class MOTAccumulator(object):\n  - SIGNATURE: def merge_event_dataframes(dfs, update_frame_indices=True, update_oids=True, update_hids=True, return_mappings=False):\n  - DOCSTRING: \n```python\n\"\"\"\nMerge multiple event dataframes from MOTAccumulator instances or pandas DataFrames into a single, unified DataFrame.\n\nParameters\n----------\ndfs : list of pandas.DataFrame or MOTAccumulator\n    A list containing event dataframes to merge. If an element is an instance of MOTAccumulator, its event DataFrame will be used.\n\nupdate_frame_indices : bool, optional\n    If True, ensures that frame indices in the merged DataFrame are unique. Default is True.\n\nupdate_oids : bool, optional\n    If True, ensures that object IDs in the merged DataFrame are unique. Default is True.\n\nupdate_hids : bool, optional\n    If True, ensures that hypothesis IDs in the merged DataFrame are unique. Default is True.\n\nreturn_mappings : bool, optional\n    If True, returns a mapping of original object and hypothesis IDs to their new IDs in addition to the merged DataFrame. Default is False.\n\nReturns\n-------\npd.DataFrame\n    A new DataFrame containing merged events from the provided DataFrames, updated according to the specified parameters.\n\nNotes\n-----\n- The method utilizes itertools.count to create new unique identifiers for object and hypothesis IDs during the merge process.\n- The method makes use of the helper function `MOTAccumulator.new_event_dataframe()` to initialize the merged DataFrame.\n- The merging operation adjusts indices and IDs based on the specified update flags, ensuring no conflicts arise in the resulting DataFrame.\n\"\"\"\n```\n\n- CLASS METHOD: MOTAccumulator.__init__\n  - CLASS SIGNATURE: class MOTAccumulator(object):\n  - SIGNATURE: def __init__(self, auto_id=False, max_switch_time=float('inf')):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a MOTAccumulator to manage tracking events for multiple object tracking.\n\nParameters\n----------\nauto_id : bool, optional\n    If True, frame indices are auto-incremented. If False (default), frame indices must be provided during updates.\nmax_switch_time : scalar, optional\n    The maximum allowed duration (in frames) between observations of an object for it to retain its identity. Defaults to infinity, allowing unlimited duration.\n\nAttributes\n----------\nauto_id : bool\n    Configuration for auto-incrementing frame indices.\nmax_switch_time : scalar\n    Restriction on the duration an unobserved tracked object can generate switch events.\n_events : dict\n    Container for tracking event data, initialized in reset().\n_indices : dict\n    Container for frame and event indices, also initialized in reset().\nm : dict\n    Tracks the current pairings of object and hypothesis IDs.\nres_m : dict\n    Stores the historical pairings of hypothesis to object IDs.\nlast_occurrence : dict\n    Records the last frame each object was observed.\nlast_match : dict\n    Stores the last frame when an object was matched.\nhypHistory : dict\n    Tracks the historical occurrences of hypotheses.\ndirty_events : bool\n    Indicates whether the events DataFrame needs to be refreshed.\ncached_events_df : pandas.DataFrame or None\n    Caches the generated events DataFrame for efficiency.\nlast_update_frameid : int or None\n    Records the frame ID of the last update.\n\nInterdependencies\n-----------------\nThe class depends on the `reset()` method to initialize its state, ensuring all tracking data is empty at start. The `update()` method will drive the event accumulation using this initial state.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "motmetrics/mot.py": "\"\"\"Accumulate tracking events frame by frame.\"\"\"\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nfrom collections import OrderedDict\nimport itertools\nimport numpy as np\nimport pandas as pd\nfrom motmetrics.lap import linear_sum_assignment\n_INDEX_FIELDS = ['FrameId', 'Event']\n_EVENT_FIELDS = ['Type', 'OId', 'HId', 'D']\n\nclass MOTAccumulator(object):\n    \"\"\"Manage tracking events.\n\n    This class computes per-frame tracking events from a given set of object / hypothesis\n    ids and pairwise distances. Indended usage\n\n        import motmetrics as mm\n        acc = mm.MOTAccumulator()\n        acc.update(['a', 'b'], [0, 1, 2], dists, frameid=0)\n        ...\n        acc.update(['d'], [6,10], other_dists, frameid=76)\n        summary = mm.metrics.summarize(acc)\n        print(mm.io.render_summary(summary))\n\n    Update is called once per frame and takes objects / hypothesis ids and a pairwise distance\n    matrix between those (see distances module for support). Per frame max(len(objects), len(hypothesis))\n    events are generated. Each event type is one of the following\n        - `'MATCH'` a match between a object and hypothesis was found\n        - `'SWITCH'` a match between a object and hypothesis was found but differs from previous assignment (hypothesisid != previous)\n        - `'MISS'` no match for an object was found\n        - `'FP'` no match for an hypothesis was found (spurious detections)\n        - `'RAW'` events corresponding to raw input\n        - `'TRANSFER'` a match between a object and hypothesis was found but differs from previous assignment (objectid != previous)\n        - `'ASCEND'` a match between a object and hypothesis was found but differs from previous assignment  (hypothesisid is new)\n        - `'MIGRATE'` a match between a object and hypothesis was found but differs from previous assignment  (objectid is new)\n\n    Events are tracked in a pandas Dataframe. The dataframe is hierarchically indexed by (`FrameId`, `EventId`),\n    where `FrameId` is either provided during the call to `update` or auto-incremented when `auto_id` is set\n    true during construction of MOTAccumulator. `EventId` is auto-incremented. The dataframe has the following\n    columns\n        - `Type` one of `('MATCH', 'SWITCH', 'MISS', 'FP', 'RAW')`\n        - `OId` object id or np.nan when `'FP'` or `'RAW'` and object is not present\n        - `HId` hypothesis id or np.nan when `'MISS'` or `'RAW'` and hypothesis is not present\n        - `D` distance or np.nan when `'FP'` or `'MISS'` or `'RAW'` and either object/hypothesis is absent\n\n    From the events and associated fields the entire tracking history can be recovered. Once the accumulator\n    has been populated with per-frame data use `metrics.summarize` to compute statistics. See `metrics.compute_metrics`\n    for a list of metrics computed.\n\n    References\n    ----------\n    1. Bernardin, Keni, and Rainer Stiefelhagen. \"Evaluating multiple object tracking performance: the CLEAR MOT metrics.\"\n    EURASIP Journal on Image and Video Processing 2008.1 (2008): 1-10.\n    2. Milan, Anton, et al. \"Mot16: A benchmark for multi-object tracking.\" arXiv preprint arXiv:1603.00831 (2016).\n    3. Li, Yuan, Chang Huang, and Ram Nevatia. \"Learning to associate: Hybridboosted multi-target tracker for crowded scene.\"\n    Computer Vision and Pattern Recognition, 2009. CVPR 2009. IEEE Conference on. IEEE, 2009.\n    \"\"\"\n\n    def reset(self):\n        \"\"\"Reset the accumulator to empty state.\"\"\"\n        self._events = {field: [] for field in _EVENT_FIELDS}\n        self._indices = {field: [] for field in _INDEX_FIELDS}\n        self.m = {}\n        self.res_m = {}\n        self.last_occurrence = {}\n        self.last_match = {}\n        self.hypHistory = {}\n        self.dirty_events = True\n        self.cached_events_df = None\n        self.last_update_frameid = None\n\n    def _append_to_indices(self, frameid, eid):\n        self._indices['FrameId'].append(frameid)\n        self._indices['Event'].append(eid)\n\n    def _append_to_events(self, typestr, oid, hid, distance):\n        self._events['Type'].append(typestr)\n        self._events['OId'].append(oid)\n        self._events['HId'].append(hid)\n        self._events['D'].append(distance)\n\n    @property\n    def mot_events(self):\n        df = self.events\n        return df[df.Type != 'RAW']\n\n    @staticmethod\n    def new_event_dataframe_with_data(indices, events):\n        \"\"\"Create a new DataFrame filled with data.\n\n        Params\n        ------\n        indices: dict\n            dict of lists with fields 'FrameId' and 'Event'\n        events: dict\n            dict of lists with fields 'Type', 'OId', 'HId', 'D'\n        \"\"\"\n        if len(events) == 0:\n            return MOTAccumulator.new_event_dataframe()\n        raw_type = pd.Categorical(events['Type'], categories=['RAW', 'FP', 'MISS', 'SWITCH', 'MATCH', 'TRANSFER', 'ASCEND', 'MIGRATE'], ordered=False)\n        series = [pd.Series(raw_type, name='Type'), pd.Series(events['OId'], dtype=float, name='OId'), pd.Series(events['HId'], dtype=float, name='HId'), pd.Series(events['D'], dtype=float, name='D')]\n        idx = pd.MultiIndex.from_arrays([indices[field] for field in _INDEX_FIELDS], names=_INDEX_FIELDS)\n        df = pd.concat(series, axis=1)\n        df.index = idx\n        return df\n\n    @staticmethod\n    def merge_analysis(anas, infomap):\n        res = {'hyp': {}, 'obj': {}}\n        mapp = {'hyp': 'hid_map', 'obj': 'oid_map'}\n        for ana, infom in zip(anas, infomap):\n            if ana is None:\n                return None\n            for t in ana.keys():\n                which = mapp[t]\n                if np.nan in infom[which]:\n                    res[t][int(infom[which][np.nan])] = 0\n                if 'nan' in infom[which]:\n                    res[t][int(infom[which]['nan'])] = 0\n                for _id, cnt in ana[t].items():\n                    if _id not in infom[which]:\n                        _id = str(_id)\n                    res[t][int(infom[which][_id])] = cnt\n        return res"
  }
}