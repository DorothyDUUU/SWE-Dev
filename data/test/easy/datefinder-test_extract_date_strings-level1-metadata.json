{
  "dir_path": "/app/datefinder",
  "package_name": "datefinder",
  "sample_name": "datefinder-test_extract_date_strings",
  "src_dir": "datefinder/",
  "test_dir": "tests/",
  "test_file": "tests/test_extract_date_strings.py",
  "test_code": "import pytest\nimport datefinder\nimport sys, logging\nlogging.basicConfig(level=logging.DEBUG, stream=sys.stdout)\nlogger = logging.getLogger(__name__)\n\n#TODO: many more TZINFO examples\n\n@pytest.mark.parametrize('date_string, expected_match_date_string', [\n    ['March 20, 2015 3:30 pm GMT ', 'March 20, 2015 3:30 pm GMT'],\n    ['March 20, 2015 3:30 pm ACWDT in the parking lot', 'March 20, 2015 3:30 pm ACWDT'],\n    ['blah blah March 20, 2015 3pm MADMT for some thing', 'March 20, 2015 3pm MADMT'],\n    ['we need it back on Friday 2p.m. central standard time', 'on Friday 2p.m. central standard time'],\n    ['the big fight at 2p.m. mountain standard time on ufc.com', 'at 2p.m. mountain standard time on'],\n\n    # issue: Thu not recognised by regex #138\n    ['starting Thursday 2020-11-05 13:50 GMT', 'Thursday 2020-11-05 13:50 GMT'],\n    ['starting Thu 2020-11-05 13:50 GMT', 'Thu 2020-11-05 13:50 GMT'],\n])\ndef test_extract_date_strings(date_string, expected_match_date_string):\n    dt = datefinder.DateFinder()\n    for actual_date_string, indexes, captures in dt.extract_date_strings(date_string):\n        logger.debug(\"actual={}  expected={}\".format(actual_date_string, expected_match_date_string))\n        assert actual_date_string == expected_match_date_string\n        assert len(captures.get('timezones',[])) > 0, \"timezone expected in result\"\n\n# TODO: 'May 20th 2015 is nowhere near the other date' was not recognized as\n# a date string: this string produced no result, but there was no error\n# because for-loop didn't make this iteration (no result in dt.extract_date_strings)\n\n@pytest.mark.parametrize('date_string, expected_match_date_string', [\n    ['the Friday after next Tuesday the 20th', ''], # no matches\n    ['This Tuesday March 2015 in the evening', ''], # no matches\n    ['They said it was on 01-03-2015', 'on 01-03-2015'], # 3 digits strict match\n    ['May 20 2015 is nowhere near the other date', 'May 20 2015'], # one month two digit match\n])\ndef test_extract_date_strings_with_strict_option(date_string, expected_match_date_string):\n    \"\"\"\n    make sure that `strict` mode works for the dates we care about\n    and doesn't work for others\n\n    :param date_string:\n    :param expected_match_date_string:\n    :return:\n    \"\"\"\n    dt = datefinder.DateFinder()\n    for actual_date_string, indexes, captures in dt.extract_date_strings(date_string,strict=True):\n        logger.debug(\"actual={}  expected={}\".format(actual_date_string, expected_match_date_string))\n        assert actual_date_string == expected_match_date_string\n",
  "GT_file_code": {
    "datefinder/__init__.py": "import copy\nimport logging\nimport regex as re\nfrom dateutil import tz, parser\nfrom datefinder.date_fragment import DateFragment\nfrom .constants import (\n    REPLACEMENTS,\n    DELIMITERS_PATTERN,\n    TIMEZONE_REPLACEMENTS,\n    STRIP_CHARS,\n    DATE_REGEX,\n    ALL_GROUPS,\n    RANGE_SPLIT_REGEX,\n)\n\nlogger = logging.getLogger(\"datefinder\")\n\n\nclass DateFinder(object):\n    \"\"\"\n    Locates dates in a text\n    \"\"\"\n\n    def __init__(self, base_date=None, first=\"month\"):\n        self.base_date = base_date\n        self.dayfirst = False\n        self.yearfirst = False\n        if first == \"day\":\n            self.dayfirst = True\n        if first == \"year\":\n            self.yearfirst = True\n\n    def find_dates(self, text, source=False, index=False, strict=False):\n\n        for date_string, indices, captures in self.extract_date_strings(\n            text, strict=strict\n        ):\n\n            as_dt = self.parse_date_string(date_string, captures)\n            if as_dt is None:\n                ## Dateutil couldn't make heads or tails of it\n                ## move on to next\n                continue\n\n            returnables = (as_dt,)\n            if source:\n                returnables = returnables + (date_string,)\n            if index:\n                returnables = returnables + (indices,)\n\n            if len(returnables) == 1:\n                returnables = returnables[0]\n            yield returnables\n\n    def _find_and_replace(self, date_string, captures):\n        \"\"\"\n        :warning: when multiple tz matches exist the last sorted capture will trump\n        :param date_string:\n        :return: date_string, tz_string\n        \"\"\"\n        # add timezones to replace\n        cloned_replacements = copy.copy(REPLACEMENTS)  # don't mutate\n        for tz_string in captures.get(\"timezones\", []):\n            cloned_replacements.update({tz_string: \" \"})\n\n        date_string = date_string.lower()\n        for key, replacement in cloned_replacements.items():\n            # we really want to match all permutations of the key surrounded by whitespace chars except one\n            # for example: consider the key = 'to'\n            # 1. match 'to '\n            # 2. match ' to'\n            # 3. match ' to '\n            # but never match r'(\\s|)to(\\s|)' which would make 'october' > 'ocber'\n            # but also include delimiters, like this 'date: '\n            full_match_pattern = (\n                r\"(^|{delimiters_pattern}){key}($|{delimiters_pattern})\".format(\n                    delimiters_pattern=DELIMITERS_PATTERN, key=key\n                )\n            )\n            date_string = re.sub(\n                full_match_pattern,\n                replacement,\n                date_string,\n                flags=re.IGNORECASE,\n            )\n\n        return date_string, self._pop_tz_string(sorted(captures.get(\"timezones\", [])))\n\n    def _pop_tz_string(self, list_of_timezones):\n        try:\n            tz_string = list_of_timezones.pop()\n            # make sure it's not a timezone we\n            # want replaced with better abbreviation\n            return TIMEZONE_REPLACEMENTS.get(tz_string, tz_string)\n        except IndexError:\n            return \"\"\n\n    def _add_tzinfo(self, datetime_obj, tz_string):\n        \"\"\"\n        take a naive datetime and add dateutil.tz.tzinfo object\n\n        :param datetime_obj: naive datetime object\n        :return: datetime object with tzinfo\n        \"\"\"\n        if datetime_obj is None:\n            return None\n\n        tzinfo_match = tz.gettz(tz_string)\n        return datetime_obj.replace(tzinfo=tzinfo_match)\n\n    def parse_date_string(self, date_string, captures):\n        # For well formatted string, we can already let dateutils parse them\n        # otherwise self._find_and_replace method might corrupt them\n        try:\n            as_dt = parser.parse(\n                date_string,\n                default=self.base_date,\n                dayfirst=self.dayfirst,\n                yearfirst=self.yearfirst,\n            )\n        except (ValueError, OverflowError):\n            # replace tokens that are problematic for dateutil\n            date_string, tz_string = self._find_and_replace(date_string, captures)\n\n            ## One last sweep after removing\n            date_string = date_string.strip(STRIP_CHARS)\n            ## Match strings must be at least 3 characters long\n            ## < 3 tends to be garbage\n            if len(date_string) < 3:\n                return None\n\n            try:\n                logger.debug(\"Parsing {0} with dateutil\".format(date_string))\n                as_dt = parser.parse(\n                    date_string,\n                    default=self.base_date,\n                    dayfirst=self.dayfirst,\n                    yearfirst=self.yearfirst,\n                )\n            except Exception as e:\n                logger.debug(e)\n                as_dt = None\n            if tz_string:\n                as_dt = self._add_tzinfo(as_dt, tz_string)\n        return as_dt\n\n    def extract_date_strings(self, text, strict=False):\n        \"\"\"\n        Scans text for possible datetime strings and extracts them\n        :param strict: Strict mode will only return dates sourced with day, month, and year\n        \"\"\"\n        return self.extract_date_strings_inner(text, text_start=0, strict=strict)\n\n    def extract_date_strings_inner(self, text, text_start=0, strict=False):\n        \"\"\"\n        Extends extract_date_strings by text_start parameter: used in recursive calls to\n        store true text coordinates in output\n        \"\"\"\n\n        # Try to find ranges first\n        rng = self.split_date_range(text)\n        if rng and len(rng) > 1:\n            range_strings = []\n            for range_str in rng:\n                range_strings.extend(\n                    self.extract_date_strings_inner(\n                        range_str[0], text_start=range_str[1][0], strict=strict\n                    )\n                )\n            for range_string in range_strings:\n                yield range_string\n            return\n\n        tokens = self.tokenize_string(text)\n        items = self.merge_tokens(tokens)\n        for match in items:\n            match_str = match.match_str\n            indices = (match.indices[0] + text_start, match.indices[1] + text_start)\n\n            ## Get individual group matches\n            captures = match.captures\n            # time = captures.get('time')\n            digits = captures.get(\"digits\")\n            # digits_modifiers = captures.get('digits_modifiers')\n            # days = captures.get('days')\n            months = captures.get(\"months\")\n            years = captures.get(\"years\")\n            # timezones = captures.get('timezones')\n            # delimiters = captures.get('delimiters')\n            # time_periods = captures.get('time_periods')\n            # extra_tokens = captures.get('extra_tokens')\n\n            if strict:\n                complete = False\n                if len(digits) == 3:  # 12-05-2015\n                    complete = True\n                elif (len(months) == 1) and (\n                    len(digits) == 2\n                ):  # 19 February 2013 year 09:10\n                    complete = True\n                elif (len(years) == 1) and (len(digits) == 2):  # 09/06/2018\n                    complete = True\n\n                elif (\n                    (len(years) == 1) and (len(months) == 1) and (len(digits) == 1)\n                ):  # '19th day of May, 2015'\n                    complete = True\n\n                if not complete:\n                    continue\n\n            ## sanitize date string\n            ## replace unhelpful whitespace characters with single whitespace\n            match_str = re.sub(r\"[\\n\\t\\s\\xa0]+\", \" \", match_str)\n            match_str = match_str.strip(STRIP_CHARS)\n\n            ## Save sanitized source string\n            yield match_str, indices, captures\n\n    def tokenize_string(self, text):\n        \"\"\"\n        Get matches from source text. Method merge_tokens will later compose\n        potential date strings out of these matches.\n        :param text: source text like 'the big fight at 2p.m. mountain standard time on ufc.com'\n        :return: [(match_text, match_group, {match.capturesdict()}), ...]\n        \"\"\"\n        items = []\n\n        last_index = 0\n\n        for match in DATE_REGEX.finditer(text):\n            match_str = match.group(0)\n            indices = match.span(0)\n            captures = match.capturesdict()\n            group = self.get_token_group(captures)\n\n            if indices[0] > last_index:\n                items.append((text[last_index : indices[0]], \"\", {}))\n            items.append((match_str, group, captures))\n            last_index = indices[1]\n        if last_index < len(text):\n            items.append((text[last_index : len(text)], \"\", {}))\n        return items\n\n    def merge_tokens(self, tokens):\n        \"\"\"\n        Makes potential date strings out of matches, got from tokenize_string method.\n        :param tokens: [(match_text, match_group, {match.capturesdict()}), ...]\n        :return: potential date strings\n        \"\"\"\n        MIN_MATCHES = 3\n        fragments = []\n        frag = DateFragment()\n\n        start_char, total_chars = 0, 0\n\n        for token in tokens:\n            total_chars += len(token[0])\n\n            tok_text, group, tok_capts = token[0], token[1], token[2]\n            if not group:\n                if frag.indices[1] > 0:\n                    if frag.get_captures_count() >= MIN_MATCHES:\n                        fragments.append(frag)\n                frag = DateFragment()\n                start_char = total_chars\n                continue\n\n            if frag.indices[1] == 0:\n                frag.indices = (start_char, total_chars)\n            else:\n                frag.indices = (frag.indices[0], total_chars)  # -1\n\n            frag.match_str += tok_text\n\n            for capt in tok_capts:\n                if capt in frag.captures:\n                    frag.captures[capt] += tok_capts[capt]\n                else:\n                    frag.captures[capt] = tok_capts[capt]\n\n            start_char = total_chars\n\n        if frag.get_captures_count() >= MIN_MATCHES:  # frag.matches\n            fragments.append(frag)\n\n        for frag in fragments:\n            for gr in ALL_GROUPS:\n                if gr not in frag.captures:\n                    frag.captures[gr] = []\n\n        return fragments\n\n    @staticmethod\n    def get_token_group(captures):\n        for gr in ALL_GROUPS:\n            lst = captures.get(gr)\n            if lst and len(lst) > 0:\n                return gr\n        return \"\"\n\n    @staticmethod\n    def split_date_range(text):\n        st_matches = RANGE_SPLIT_REGEX.finditer(text)\n        start = 0\n        parts = []  # List[Tuple[str, Tuple[int, int]]]\n\n        for match in st_matches:\n            match_start = match.start()\n            if match_start > start:\n                parts.append((text[start:match_start], (start, match_start)))\n            start = match.end()\n\n        if start < len(text):\n            parts.append((text[start:], (start, len(text))))\n\n        return parts\n\n\ndef find_dates(\n    text, source=False, index=False, strict=False, base_date=None, first=\"month\"\n):\n    \"\"\"\n    Extract datetime strings from text\n\n    :param text:\n        A string that contains one or more natural language or literal\n        datetime strings\n    :type text: str|unicode\n    :param source:\n        Return the original string segment\n    :type source: boolean\n    :param index:\n        Return the indices where the datetime string was located in text\n    :type index: boolean\n    :param strict:\n        Only return datetimes with complete date information. For example:\n        `July 2016` of `Monday` will not return datetimes.\n        `May 16, 2015` will return datetimes.\n    :type strict: boolean\n    :param base_date:\n        Set a default base datetime when parsing incomplete dates\n    :type base_date: datetime\n    :param first:\n        Whether to interpret the the first value in an ambiguous 3-integer date\n        (01/02/03) as the month, day, or year. Values can be `month`, `day`, `year`.\n        Default is `month`.\n    :type first: str|unicode\n\n\n    :return: Returns a generator that produces :mod:`datetime.datetime` objects,\n        or a tuple with the source text and index, if requested\n    \"\"\"\n    date_finder = DateFinder(base_date=base_date, first=first)\n    return date_finder.find_dates(text, source=source, index=index, strict=strict)\n"
  },
  "GT_src_dict": {
    "datefinder/__init__.py": {
      "DateFinder.__init__": {
        "code": "    def __init__(self, base_date=None, first='month'):\n        \"\"\"Initializes a DateFinder instance to locate dates within a text.\n\nParameters:\n- base_date (datetime, optional): A default datetime used when parsing incomplete date strings. This helps establish a reference point for relative dates.\n- first (str, optional): Determines how to interpret ambiguous dates represented by three integers. The choices are \"month\" (default), \"day\", or \"year\", which informs how the class will parse dates like \"01/02/03\".\n\nAttributes:\n- self.base_date: Stores the base date for parsing.\n- self.dayfirst: A boolean indicating if the parser should prioritize day over month in ambiguous dates, initially set to False.\n- self.yearfirst: A boolean indicating if the parser should prioritize year over month, initially set to False.\n\nThe class also interacts with constants such as REPLACEMENTS, which are utilized in methods for date extraction and cleaning, ensuring that the date-finding logic adheres to defined rules and formats.\"\"\"\n        self.base_date = base_date\n        self.dayfirst = False\n        self.yearfirst = False\n        if first == 'day':\n            self.dayfirst = True\n        if first == 'year':\n            self.yearfirst = True",
        "docstring": "Initializes a DateFinder instance to locate dates within a text.\n\nParameters:\n- base_date (datetime, optional): A default datetime used when parsing incomplete date strings. This helps establish a reference point for relative dates.\n- first (str, optional): Determines how to interpret ambiguous dates represented by three integers. The choices are \"month\" (default), \"day\", or \"year\", which informs how the class will parse dates like \"01/02/03\".\n\nAttributes:\n- self.base_date: Stores the base date for parsing.\n- self.dayfirst: A boolean indicating if the parser should prioritize day over month in ambiguous dates, initially set to False.\n- self.yearfirst: A boolean indicating if the parser should prioritize year over month, initially set to False.\n\nThe class also interacts with constants such as REPLACEMENTS, which are utilized in methods for date extraction and cleaning, ensuring that the date-finding logic adheres to defined rules and formats.",
        "signature": "def __init__(self, base_date=None, first='month'):",
        "type": "Method",
        "class_signature": "class DateFinder(object):"
      },
      "DateFinder.extract_date_strings": {
        "code": "    def extract_date_strings(self, text, strict=False):\n        \"\"\"Scans the provided text for potential datetime strings and extracts them. The method can return dates based on strict criteria, ensuring only those containing day, month, and year information are included when `strict` is set to True.\n\n    :param text: A string containing potential datetime information to be scanned and extracted.\n    :type text: str\n    :param strict: If set to True, restricts the extraction to only complete dates that include day, month, and year.\n    :type strict: bool\n    :return: A generator that yields tuples of matched date strings, their indices in the original text, and captured groups from regex matches.\n\n    This method calls `extract_date_strings_inner`, which processes the text through tokenization and merging of date tokens. It interacts with constants such as `DATE_REGEX` from the `constants` module to identify potential date patterns. The `strict` parameter allows for customizable extraction based on the completeness of date information, ensuring that the method's output aligns with user expectations.\"\"\"\n        '\\n        Scans text for possible datetime strings and extracts them\\n        :param strict: Strict mode will only return dates sourced with day, month, and year\\n        '\n        return self.extract_date_strings_inner(text, text_start=0, strict=strict)",
        "docstring": "Scans the provided text for potential datetime strings and extracts them. The method can return dates based on strict criteria, ensuring only those containing day, month, and year information are included when `strict` is set to True.\n\n:param text: A string containing potential datetime information to be scanned and extracted.\n:type text: str\n:param strict: If set to True, restricts the extraction to only complete dates that include day, month, and year.\n:type strict: bool\n:return: A generator that yields tuples of matched date strings, their indices in the original text, and captured groups from regex matches.\n\nThis method calls `extract_date_strings_inner`, which processes the text through tokenization and merging of date tokens. It interacts with constants such as `DATE_REGEX` from the `constants` module to identify potential date patterns. The `strict` parameter allows for customizable extraction based on the completeness of date information, ensuring that the method's output aligns with user expectations.",
        "signature": "def extract_date_strings(self, text, strict=False):",
        "type": "Method",
        "class_signature": "class DateFinder(object):"
      },
      "DateFinder.extract_date_strings_inner": {
        "code": "    def extract_date_strings_inner(self, text, text_start=0, strict=False):\n        \"\"\"Extends the functionality of the `extract_date_strings` method by including a `text_start` parameter, which is utilized in recursive calls to maintain accurate indices of date matches within the original text. This method scans the provided text for potential date representations, handling both date ranges and individual date fragments.\n\nParameters:\n- text (str): The input string containing potential date representations to be extracted.\n- text_start (int): The starting index in the input string from which to continue extracting dates. Defaults to 0.\n- strict (bool): If set to True, only complete date representations (having day, month, and year) will be considered. Partial dates will be excluded.\n\nYields:\n- Tuple (str, Tuple[int, int], dict): Each yield contains a sanitized string representing a found date, its corresponding character indices within the original text, and a dictionary of captures corresponding to date components (like digits, months, and years).\n\nDependencies:\n- Uses the `split_date_range` method to first check for ranges of dates within the text.\n- Utilizes `tokenize_string` to identify individual date tokens and `merge_tokens` to combine these into coherent date strings.\n- Employs the `STRIP_CHARS` constant to sanitize extracted date strings by removing unwanted characters.\n\nConstants:\n- `STRIP_CHARS`: A constant defined in the module that specifies which characters to strip from date strings for sanitization. This ensures that the output is clean and easier to parse by subsequent processing in the `find_dates` method.\"\"\"\n        '\\n        Extends extract_date_strings by text_start parameter: used in recursive calls to\\n        store true text coordinates in output\\n        '\n        rng = self.split_date_range(text)\n        if rng and len(rng) > 1:\n            range_strings = []\n            for range_str in rng:\n                range_strings.extend(self.extract_date_strings_inner(range_str[0], text_start=range_str[1][0], strict=strict))\n            for range_string in range_strings:\n                yield range_string\n            return\n        tokens = self.tokenize_string(text)\n        items = self.merge_tokens(tokens)\n        for match in items:\n            match_str = match.match_str\n            indices = (match.indices[0] + text_start, match.indices[1] + text_start)\n            captures = match.captures\n            digits = captures.get('digits')\n            months = captures.get('months')\n            years = captures.get('years')\n            if strict:\n                complete = False\n                if len(digits) == 3:\n                    complete = True\n                elif len(months) == 1 and len(digits) == 2:\n                    complete = True\n                elif len(years) == 1 and len(digits) == 2:\n                    complete = True\n                elif len(years) == 1 and len(months) == 1 and (len(digits) == 1):\n                    complete = True\n                if not complete:\n                    continue\n            match_str = re.sub('[\\\\n\\\\t\\\\s\\\\xa0]+', ' ', match_str)\n            match_str = match_str.strip(STRIP_CHARS)\n            yield (match_str, indices, captures)",
        "docstring": "Extends the functionality of the `extract_date_strings` method by including a `text_start` parameter, which is utilized in recursive calls to maintain accurate indices of date matches within the original text. This method scans the provided text for potential date representations, handling both date ranges and individual date fragments.\n\nParameters:\n- text (str): The input string containing potential date representations to be extracted.\n- text_start (int): The starting index in the input string from which to continue extracting dates. Defaults to 0.\n- strict (bool): If set to True, only complete date representations (having day, month, and year) will be considered. Partial dates will be excluded.\n\nYields:\n- Tuple (str, Tuple[int, int], dict): Each yield contains a sanitized string representing a found date, its corresponding character indices within the original text, and a dictionary of captures corresponding to date components (like digits, months, and years).\n\nDependencies:\n- Uses the `split_date_range` method to first check for ranges of dates within the text.\n- Utilizes `tokenize_string` to identify individual date tokens and `merge_tokens` to combine these into coherent date strings.\n- Employs the `STRIP_CHARS` constant to sanitize extracted date strings by removing unwanted characters.\n\nConstants:\n- `STRIP_CHARS`: A constant defined in the module that specifies which characters to strip from date strings for sanitization. This ensures that the output is clean and easier to parse by subsequent processing in the `find_dates` method.",
        "signature": "def extract_date_strings_inner(self, text, text_start=0, strict=False):",
        "type": "Method",
        "class_signature": "class DateFinder(object):"
      }
    }
  },
  "dependency_dict": {
    "datefinder/__init__.py:DateFinder:extract_date_strings_inner": {
      "datefinder/__init__.py": {
        "DateFinder.tokenize_string": {
          "code": "    def tokenize_string(self, text):\n        \"\"\"\n        Get matches from source text. Method merge_tokens will later compose\n        potential date strings out of these matches.\n        :param text: source text like 'the big fight at 2p.m. mountain standard time on ufc.com'\n        :return: [(match_text, match_group, {match.capturesdict()}), ...]\n        \"\"\"\n        items = []\n        last_index = 0\n        for match in DATE_REGEX.finditer(text):\n            match_str = match.group(0)\n            indices = match.span(0)\n            captures = match.capturesdict()\n            group = self.get_token_group(captures)\n            if indices[0] > last_index:\n                items.append((text[last_index:indices[0]], '', {}))\n            items.append((match_str, group, captures))\n            last_index = indices[1]\n        if last_index < len(text):\n            items.append((text[last_index:len(text)], '', {}))\n        return items",
          "docstring": "Get matches from source text. Method merge_tokens will later compose\npotential date strings out of these matches.\n:param text: source text like 'the big fight at 2p.m. mountain standard time on ufc.com'\n:return: [(match_text, match_group, {match.capturesdict()}), ...]",
          "signature": "def tokenize_string(self, text):",
          "type": "Method",
          "class_signature": "class DateFinder(object):"
        },
        "DateFinder.merge_tokens": {
          "code": "    def merge_tokens(self, tokens):\n        \"\"\"\n        Makes potential date strings out of matches, got from tokenize_string method.\n        :param tokens: [(match_text, match_group, {match.capturesdict()}), ...]\n        :return: potential date strings\n        \"\"\"\n        MIN_MATCHES = 3\n        fragments = []\n        frag = DateFragment()\n        start_char, total_chars = (0, 0)\n        for token in tokens:\n            total_chars += len(token[0])\n            tok_text, group, tok_capts = (token[0], token[1], token[2])\n            if not group:\n                if frag.indices[1] > 0:\n                    if frag.get_captures_count() >= MIN_MATCHES:\n                        fragments.append(frag)\n                frag = DateFragment()\n                start_char = total_chars\n                continue\n            if frag.indices[1] == 0:\n                frag.indices = (start_char, total_chars)\n            else:\n                frag.indices = (frag.indices[0], total_chars)\n            frag.match_str += tok_text\n            for capt in tok_capts:\n                if capt in frag.captures:\n                    frag.captures[capt] += tok_capts[capt]\n                else:\n                    frag.captures[capt] = tok_capts[capt]\n            start_char = total_chars\n        if frag.get_captures_count() >= MIN_MATCHES:\n            fragments.append(frag)\n        for frag in fragments:\n            for gr in ALL_GROUPS:\n                if gr not in frag.captures:\n                    frag.captures[gr] = []\n        return fragments",
          "docstring": "Makes potential date strings out of matches, got from tokenize_string method.\n:param tokens: [(match_text, match_group, {match.capturesdict()}), ...]\n:return: potential date strings",
          "signature": "def merge_tokens(self, tokens):",
          "type": "Method",
          "class_signature": "class DateFinder(object):"
        },
        "DateFinder.split_date_range": {
          "code": "    def split_date_range(text):\n        st_matches = RANGE_SPLIT_REGEX.finditer(text)\n        start = 0\n        parts = []\n        for match in st_matches:\n            match_start = match.start()\n            if match_start > start:\n                parts.append((text[start:match_start], (start, match_start)))\n            start = match.end()\n        if start < len(text):\n            parts.append((text[start:], (start, len(text))))\n        return parts",
          "docstring": "",
          "signature": "def split_date_range(text):",
          "type": "Method",
          "class_signature": "class DateFinder(object):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: datefinder-test_extract_date_strings\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 datefinder/\n    \u2514\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 DateFinder.__init__\n        \u251c\u2500\u2500 DateFinder.extract_date_strings\n        \u2514\u2500\u2500 DateFinder.extract_date_strings_inner\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate and enhance the functionality of parsing and extracting date-related information from natural language text strings using the `datefinder` library. It ensures accurate identification of date and time expressions, including support for various formats, time zones, and locale-specific phrases, while testing strict and lenient matching modes. The module provides capabilities to detect and extract date strings, validate timezone captures, and differentiate between valid and invalid date expressions. By providing robust and extensible parsing validation, it addresses challenges developers face with inconsistencies or ambiguities in date extraction, enabling reliable handling of complex temporal data in natural language inputs.\n\n## FILE 1: datefinder/__init__.py\n\n- CLASS METHOD: DateFinder.extract_date_strings_inner\n  - CLASS SIGNATURE: class DateFinder(object):\n  - SIGNATURE: def extract_date_strings_inner(self, text, text_start=0, strict=False):\n  - DOCSTRING: \n```python\n\"\"\"\nExtends the functionality of the `extract_date_strings` method by including a `text_start` parameter, which is utilized in recursive calls to maintain accurate indices of date matches within the original text. This method scans the provided text for potential date representations, handling both date ranges and individual date fragments.\n\nParameters:\n- text (str): The input string containing potential date representations to be extracted.\n- text_start (int): The starting index in the input string from which to continue extracting dates. Defaults to 0.\n- strict (bool): If set to True, only complete date representations (having day, month, and year) will be considered. Partial dates will be excluded.\n\nYields:\n- Tuple (str, Tuple[int, int], dict): Each yield contains a sanitized string representing a found date, its corresponding character indices within the original text, and a dictionary of captures corresponding to date components (like digits, months, and years).\n\nDependencies:\n- Uses the `split_date_range` method to first check for ranges of dates within the text.\n- Utilizes `tokenize_string` to identify individual date tokens and `merge_tokens` to combine these into coherent date strings.\n- Employs the `STRIP_CHARS` constant to sanitize extracted date strings by removing unwanted characters.\n\nConstants:\n- `STRIP_CHARS`: A constant defined in the module that specifies which characters to strip from date strings for sanitization. This ensures that the output is clean and easier to parse by subsequent processing in the `find_dates` method.\n\"\"\"\n```\n\n- CLASS METHOD: DateFinder.__init__\n  - CLASS SIGNATURE: class DateFinder(object):\n  - SIGNATURE: def __init__(self, base_date=None, first='month'):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a DateFinder instance to locate dates within a text.\n\nParameters:\n- base_date (datetime, optional): A default datetime used when parsing incomplete date strings. This helps establish a reference point for relative dates.\n- first (str, optional): Determines how to interpret ambiguous dates represented by three integers. The choices are \"month\" (default), \"day\", or \"year\", which informs how the class will parse dates like \"01/02/03\".\n\nAttributes:\n- self.base_date: Stores the base date for parsing.\n- self.dayfirst: A boolean indicating if the parser should prioritize day over month in ambiguous dates, initially set to False.\n- self.yearfirst: A boolean indicating if the parser should prioritize year over month, initially set to False.\n\nThe class also interacts with constants such as REPLACEMENTS, which are utilized in methods for date extraction and cleaning, ensuring that the date-finding logic adheres to defined rules and formats.\n\"\"\"\n```\n\n- CLASS METHOD: DateFinder.extract_date_strings\n  - CLASS SIGNATURE: class DateFinder(object):\n  - SIGNATURE: def extract_date_strings(self, text, strict=False):\n  - DOCSTRING: \n```python\n\"\"\"\nScans the provided text for potential datetime strings and extracts them. The method can return dates based on strict criteria, ensuring only those containing day, month, and year information are included when `strict` is set to True.\n\n:param text: A string containing potential datetime information to be scanned and extracted.\n:type text: str\n:param strict: If set to True, restricts the extraction to only complete dates that include day, month, and year.\n:type strict: bool\n:return: A generator that yields tuples of matched date strings, their indices in the original text, and captured groups from regex matches.\n\nThis method calls `extract_date_strings_inner`, which processes the text through tokenization and merging of date tokens. It interacts with constants such as `DATE_REGEX` from the `constants` module to identify potential date patterns. The `strict` parameter allows for customizable extraction based on the completeness of date information, ensuring that the method's output aligns with user expectations.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "datefinder/__init__.py": "import copy\nimport logging\nimport regex as re\nfrom dateutil import tz, parser\nfrom datefinder.date_fragment import DateFragment\nfrom .constants import REPLACEMENTS, DELIMITERS_PATTERN, TIMEZONE_REPLACEMENTS, STRIP_CHARS, DATE_REGEX, ALL_GROUPS, RANGE_SPLIT_REGEX\nlogger = logging.getLogger('datefinder')\n\nclass DateFinder(object):\n    \"\"\"\n    Locates dates in a text\n    \"\"\"\n\n    def find_dates(self, text, source=False, index=False, strict=False):\n        for date_string, indices, captures in self.extract_date_strings(text, strict=strict):\n            as_dt = self.parse_date_string(date_string, captures)\n            if as_dt is None:\n                continue\n            returnables = (as_dt,)\n            if source:\n                returnables = returnables + (date_string,)\n            if index:\n                returnables = returnables + (indices,)\n            if len(returnables) == 1:\n                returnables = returnables[0]\n            yield returnables\n\n    def _find_and_replace(self, date_string, captures):\n        \"\"\"\n        :warning: when multiple tz matches exist the last sorted capture will trump\n        :param date_string:\n        :return: date_string, tz_string\n        \"\"\"\n        cloned_replacements = copy.copy(REPLACEMENTS)\n        for tz_string in captures.get('timezones', []):\n            cloned_replacements.update({tz_string: ' '})\n        date_string = date_string.lower()\n        for key, replacement in cloned_replacements.items():\n            full_match_pattern = '(^|{delimiters_pattern}){key}($|{delimiters_pattern})'.format(delimiters_pattern=DELIMITERS_PATTERN, key=key)\n            date_string = re.sub(full_match_pattern, replacement, date_string, flags=re.IGNORECASE)\n        return (date_string, self._pop_tz_string(sorted(captures.get('timezones', []))))\n\n    def _pop_tz_string(self, list_of_timezones):\n        try:\n            tz_string = list_of_timezones.pop()\n            return TIMEZONE_REPLACEMENTS.get(tz_string, tz_string)\n        except IndexError:\n            return ''\n\n    def _add_tzinfo(self, datetime_obj, tz_string):\n        \"\"\"\n        take a naive datetime and add dateutil.tz.tzinfo object\n\n        :param datetime_obj: naive datetime object\n        :return: datetime object with tzinfo\n        \"\"\"\n        if datetime_obj is None:\n            return None\n        tzinfo_match = tz.gettz(tz_string)\n        return datetime_obj.replace(tzinfo=tzinfo_match)\n\n    def parse_date_string(self, date_string, captures):\n        try:\n            as_dt = parser.parse(date_string, default=self.base_date, dayfirst=self.dayfirst, yearfirst=self.yearfirst)\n        except (ValueError, OverflowError):\n            date_string, tz_string = self._find_and_replace(date_string, captures)\n            date_string = date_string.strip(STRIP_CHARS)\n            if len(date_string) < 3:\n                return None\n            try:\n                logger.debug('Parsing {0} with dateutil'.format(date_string))\n                as_dt = parser.parse(date_string, default=self.base_date, dayfirst=self.dayfirst, yearfirst=self.yearfirst)\n            except Exception as e:\n                logger.debug(e)\n                as_dt = None\n            if tz_string:\n                as_dt = self._add_tzinfo(as_dt, tz_string)\n        return as_dt\n\n    def tokenize_string(self, text):\n        \"\"\"\n        Get matches from source text. Method merge_tokens will later compose\n        potential date strings out of these matches.\n        :param text: source text like 'the big fight at 2p.m. mountain standard time on ufc.com'\n        :return: [(match_text, match_group, {match.capturesdict()}), ...]\n        \"\"\"\n        items = []\n        last_index = 0\n        for match in DATE_REGEX.finditer(text):\n            match_str = match.group(0)\n            indices = match.span(0)\n            captures = match.capturesdict()\n            group = self.get_token_group(captures)\n            if indices[0] > last_index:\n                items.append((text[last_index:indices[0]], '', {}))\n            items.append((match_str, group, captures))\n            last_index = indices[1]\n        if last_index < len(text):\n            items.append((text[last_index:len(text)], '', {}))\n        return items\n\n    def merge_tokens(self, tokens):\n        \"\"\"\n        Makes potential date strings out of matches, got from tokenize_string method.\n        :param tokens: [(match_text, match_group, {match.capturesdict()}), ...]\n        :return: potential date strings\n        \"\"\"\n        MIN_MATCHES = 3\n        fragments = []\n        frag = DateFragment()\n        start_char, total_chars = (0, 0)\n        for token in tokens:\n            total_chars += len(token[0])\n            tok_text, group, tok_capts = (token[0], token[1], token[2])\n            if not group:\n                if frag.indices[1] > 0:\n                    if frag.get_captures_count() >= MIN_MATCHES:\n                        fragments.append(frag)\n                frag = DateFragment()\n                start_char = total_chars\n                continue\n            if frag.indices[1] == 0:\n                frag.indices = (start_char, total_chars)\n            else:\n                frag.indices = (frag.indices[0], total_chars)\n            frag.match_str += tok_text\n            for capt in tok_capts:\n                if capt in frag.captures:\n                    frag.captures[capt] += tok_capts[capt]\n                else:\n                    frag.captures[capt] = tok_capts[capt]\n            start_char = total_chars\n        if frag.get_captures_count() >= MIN_MATCHES:\n            fragments.append(frag)\n        for frag in fragments:\n            for gr in ALL_GROUPS:\n                if gr not in frag.captures:\n                    frag.captures[gr] = []\n        return fragments\n\n    @staticmethod\n    def get_token_group(captures):\n        for gr in ALL_GROUPS:\n            lst = captures.get(gr)\n            if lst and len(lst) > 0:\n                return gr\n        return ''\n\n    @staticmethod\n    def split_date_range(text):\n        st_matches = RANGE_SPLIT_REGEX.finditer(text)\n        start = 0\n        parts = []\n        for match in st_matches:\n            match_start = match.start()\n            if match_start > start:\n                parts.append((text[start:match_start], (start, match_start)))\n            start = match.end()\n        if start < len(text):\n            parts.append((text[start:], (start, len(text))))\n        return parts\n\ndef find_dates(text, source=False, index=False, strict=False, base_date=None, first='month'):\n    \"\"\"\n    Extract datetime strings from text\n\n    :param text:\n        A string that contains one or more natural language or literal\n        datetime strings\n    :type text: str|unicode\n    :param source:\n        Return the original string segment\n    :type source: boolean\n    :param index:\n        Return the indices where the datetime string was located in text\n    :type index: boolean\n    :param strict:\n        Only return datetimes with complete date information. For example:\n        `July 2016` of `Monday` will not return datetimes.\n        `May 16, 2015` will return datetimes.\n    :type strict: boolean\n    :param base_date:\n        Set a default base datetime when parsing incomplete dates\n    :type base_date: datetime\n    :param first:\n        Whether to interpret the the first value in an ambiguous 3-integer date\n        (01/02/03) as the month, day, or year. Values can be `month`, `day`, `year`.\n        Default is `month`.\n    :type first: str|unicode\n\n\n    :return: Returns a generator that produces :mod:`datetime.datetime` objects,\n        or a tuple with the source text and index, if requested\n    \"\"\"\n    date_finder = DateFinder(base_date=base_date, first=first)\n    return date_finder.find_dates(text, source=source, index=index, strict=strict)"
  },
  "call_tree": {
    "tests/test_extract_date_strings.py:test_extract_date_strings": {
      "datefinder/__init__.py:DateFinder:__init__": {},
      "datefinder/__init__.py:DateFinder:extract_date_strings": {},
      "datefinder/__init__.py:DateFinder:extract_date_strings_inner": {
        "datefinder/__init__.py:DateFinder:split_date_range": {},
        "datefinder/__init__.py:DateFinder:tokenize_string": {
          "datefinder/__init__.py:DateFinder:get_token_group": {}
        },
        "datefinder/__init__.py:DateFinder:merge_tokens": {
          "datefinder/date_fragment.py:DateFragment:__init__": {},
          "datefinder/date_fragment.py:DateFragment:get_captures_count": {}
        }
      }
    },
    "tests/test_extract_date_strings.py:test_extract_date_strings_with_strict_option": {
      "datefinder/__init__.py:DateFinder:__init__": {},
      "datefinder/__init__.py:DateFinder:extract_date_strings": {},
      "datefinder/__init__.py:DateFinder:extract_date_strings_inner": {
        "datefinder/__init__.py:DateFinder:split_date_range": {},
        "datefinder/__init__.py:DateFinder:tokenize_string": {
          "datefinder/__init__.py:DateFinder:get_token_group": {}
        },
        "datefinder/__init__.py:DateFinder:merge_tokens": {
          "datefinder/date_fragment.py:DateFragment:__init__": {},
          "datefinder/date_fragment.py:DateFragment:get_captures_count": {}
        }
      }
    }
  }
}