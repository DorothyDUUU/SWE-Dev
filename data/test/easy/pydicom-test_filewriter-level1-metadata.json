{
  "dir_path": "/app/pydicom",
  "package_name": "pydicom",
  "sample_name": "pydicom-test_filewriter",
  "src_dir": "pydicom/src/pydicom/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_filewriter.py",
  "test_code": "# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n\"\"\"test cases for pydicom.filewriter module\"\"\"\nimport tempfile\nfrom copy import deepcopy\nfrom datetime import date, datetime, time, timedelta, timezone\nfrom io import BytesIO\nimport os\nimport sys\nfrom pathlib import Path\nimport pickle\nimport platform\n\nfrom struct import unpack\nfrom tempfile import TemporaryFile\nfrom typing import cast\nimport zlib\n\ntry:\n    import resource\n\n    HAVE_RESOURCE = True\nexcept ImportError:\n    HAVE_RESOURCE = False\n\nimport pytest\n\nfrom pydicom import config, __version_info__, uid\nfrom pydicom.data import get_testdata_file, get_charset_files\nfrom pydicom.dataset import Dataset, FileDataset, FileMetaDataset\nfrom pydicom.dataelem import DataElement, RawDataElement\nfrom pydicom.filebase import DicomBytesIO\nfrom pydicom.filereader import dcmread, read_dataset\nfrom pydicom.filewriter import (\n    _determine_encoding,\n    write_data_element,\n    write_dataset,\n    correct_ambiguous_vr,\n    write_file_meta_info,\n    correct_ambiguous_vr_element,\n    write_numbers,\n    write_PN,\n    _format_DT,\n    write_text,\n    write_OBvalue,\n    write_OWvalue,\n    writers,\n    dcmwrite,\n)\nfrom pydicom.multival import MultiValue\nfrom pydicom.sequence import Sequence\nfrom .test_helpers import assert_no_warning\nfrom pydicom.uid import (\n    ImplicitVRLittleEndian,\n    ExplicitVRBigEndian,\n    ExplicitVRLittleEndian,\n    RLELossless,\n    PYDICOM_IMPLEMENTATION_UID,\n    CTImageStorage,\n    UID,\n)\nfrom pydicom.util.hexutil import hex2bytes\nfrom pydicom.valuerep import BUFFERABLE_VRS, DA, DT, TM, VR\nfrom pydicom.values import convert_text\nfrom ._write_stds import impl_LE_deflen_std_hex\n\nrtplan_name = get_testdata_file(\"rtplan.dcm\")\nrtdose_name = get_testdata_file(\"rtdose.dcm\")\nct_name = get_testdata_file(\"CT_small.dcm\")\nmr_name = get_testdata_file(\"MR_small.dcm\")\nmr_implicit_name = get_testdata_file(\"MR_small_implicit.dcm\")\nmr_bigendian_name = get_testdata_file(\"MR_small_bigendian.dcm\")\njpeg_name = get_testdata_file(\"JPEG2000.dcm\")\nno_ts = get_testdata_file(\"meta_missing_tsyntax.dcm\")\ncolor_pl_name = get_testdata_file(\"color-pl.dcm\")\nsc_rgb_name = get_testdata_file(\"SC_rgb.dcm\")\ndatetime_name = mr_name\n\nunicode_name = get_charset_files(\"chrH31.dcm\")[0]\nmultiPN_name = get_charset_files(\"chrFrenMulti.dcm\")[0]\ndeflate_name = get_testdata_file(\"image_dfl.dcm\")\n\nbase_version = \".\".join(str(i) for i in __version_info__)\n\n\nIS_WINDOWS = platform.system() == \"Windows\"\n\n\ndef files_identical(a, b):\n    \"\"\"Return a tuple (file a == file b, index of first difference)\"\"\"\n    with open(a, \"rb\") as A:\n        with open(b, \"rb\") as B:\n            a_bytes = A.read()\n            b_bytes = B.read()\n\n    return bytes_identical(a_bytes, b_bytes)\n\n\ndef bytes_identical(a_bytes, b_bytes):\n    \"\"\"Return a tuple\n    (bytes a == bytes b, index of first difference)\"\"\"\n    if len(a_bytes) != len(b_bytes):\n        return False, min([len(a_bytes), len(b_bytes)])\n    elif a_bytes == b_bytes:\n        return True, 0  # True, dummy argument\n    else:\n        pos = 0\n        while a_bytes[pos] == b_bytes[pos]:\n            pos += 1\n        return False, pos  # False if not identical, position of 1st diff\n\n\ndef as_assertable(dataset):\n    \"\"\"Copy the elements in a Dataset (including the file_meta, if any)\n    to a set that can be safely compared using pytest's assert.\n    (Datasets can't be so compared because DataElements are not\n    hashable.)\"\"\"\n    safe_dict = dict(\n        (str(elem.tag) + \" \" + elem.keyword, elem.value) for elem in dataset\n    )\n    if hasattr(dataset, \"file_meta\"):\n        safe_dict.update(as_assertable(dataset.file_meta))\n    return safe_dict\n\n\nclass TestWriteFile:\n    def setup_method(self):\n        self.file_out = TemporaryFile(\"w+b\")\n\n    def teardown_method(self):\n        self.file_out.close()\n\n    def compare(self, in_filename):\n        \"\"\"Read Dataset from in_filename, write to file, compare\"\"\"\n        with open(in_filename, \"rb\") as f:\n            bytes_in = BytesIO(f.read())\n            bytes_in.seek(0)\n\n        ds = dcmread(bytes_in)\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        bytes_out = BytesIO(self.file_out.read())\n        bytes_in.seek(0)\n        bytes_out.seek(0)\n        same, pos = bytes_identical(bytes_in.getvalue(), bytes_out.getvalue())\n        assert same\n\n    def compare_bytes(self, bytes_in, bytes_out):\n        \"\"\"Compare two bytestreams for equality\"\"\"\n        same, pos = bytes_identical(bytes_in, bytes_out)\n        assert same\n\n    def testRTPlan(self):\n        \"\"\"Input file, write back and verify\n        them identical (RT Plan file)\"\"\"\n        self.compare(rtplan_name)\n\n    def testRTDose(self):\n        \"\"\"Input file, write back and\n        verify them identical (RT Dose file)\"\"\"\n        self.compare(rtdose_name)\n\n    def testCT(self):\n        \"\"\"Input file, write back and\n        verify them identical (CT file).....\"\"\"\n        self.compare(ct_name)\n\n    def testMR(self):\n        \"\"\"Input file, write back and verify\n        them identical (MR file).....\"\"\"\n        self.compare(mr_name)\n\n    def testUnicode(self):\n        \"\"\"Ensure decoded string DataElements\n        are written to file properly\"\"\"\n        self.compare(unicode_name)\n\n    def testMultiPN(self):\n        \"\"\"Ensure multiple Person Names are written\n        to the file correctly.\"\"\"\n        self.compare(multiPN_name)\n\n    def testJPEG2000(self):\n        \"\"\"Input file, write back and verify\n        them identical (JPEG2K file).\"\"\"\n        self.compare(jpeg_name)\n\n    def test_None_parent(self):\n        \"\"\"Ensure can write nested sequence with no parent dataset\"\"\"\n        # from issues 1836, 1838, 1839\n\n        # (0040,9096)  Real World Value Mapping Sequence  1 item(s) ----\n        #    (0040,9211) Real World Value Last Value Mapped  US: 8699\n        byts = (\n            b\"\\0\" * 128\n            + b\"DICM\"\n            + bytes.fromhex(\n                \"4000 9690 FFFFFFFF\"  # (0040,9096) Sequence undefined length\n                \"  FEFF 00E0 FFFFFFFF\"  # Sequence Item undefined length\n                \"    4000 1192 02000000\"  # (0040,9211) length 2\n                \"    FB 21                  \"  # value\n                \"  FEFF 0DE0 00000000\"  # Item Delimiter\n                \"FEFF DDE0 00000000\"  # Sequence Delimiter\n            )\n        )\n\n        ds = dcmread(BytesIO(byts))\n        # original bug raises 'NoneType' object is not callable on decode\n        ds.decode()\n\n    def test_pathlib_path_filename(self):\n        \"\"\"Check that file can be written using pathlib.Path\"\"\"\n        ds = dcmread(Path(ct_name))\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        ds1 = dcmread(self.file_out)\n        assert ds.PatientName == ds1.PatientName\n\n    def testListItemWriteBack(self):\n        \"\"\"Change item in a list and confirm\n        it is written to file\"\"\"\n        DS_expected = 0\n        CS_expected = \"new\"\n        SS_expected = 999\n        ds = dcmread(ct_name)\n        ds.ImagePositionPatient[2] = DS_expected\n        ds.ImageType[1] = CS_expected\n        ds[(0x0043, 0x1012)].value[0] = SS_expected\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        # Now read it back in and check that the values were changed\n        ds = dcmread(self.file_out)\n        assert CS_expected == ds.ImageType[1]\n        assert SS_expected == ds[0x00431012].value[0]\n        assert DS_expected == ds.ImagePositionPatient[2]\n\n    def testwrite_short_uid(self):\n        ds = dcmread(rtplan_name)\n        ds.SOPInstanceUID = \"1.2\"\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        ds = dcmread(self.file_out)\n        assert \"1.2\" == ds.SOPInstanceUID\n\n    def test_write_no_ts(self):\n        \"\"\"Test reading a file with no ts and writing it out identically.\"\"\"\n        ds = dcmread(no_ts)\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        with open(no_ts, \"rb\") as ref_file:\n            written_bytes = self.file_out.read()\n            read_bytes = ref_file.read()\n            self.compare_bytes(read_bytes, written_bytes)\n\n    def test_write_double_filemeta(self):\n        \"\"\"Test writing file meta from Dataset doesn't work\"\"\"\n        ds = dcmread(ct_name)\n        ds.TransferSyntaxUID = \"1.1\"\n        with pytest.raises(ValueError):\n            ds.save_as(self.file_out)\n\n    def test_write_ffff_ffff(self):\n        \"\"\"Test writing element (FFFF,FFFF) to file #92\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.file_meta = FileMetaDataset()\n        ds.add_new(0xFFFFFFFF, \"LO\", \"123456\")\n        ds.save_as(fp, implicit_vr=True)\n\n        fp.seek(0)\n        ds = dcmread(fp, force=True)\n        assert ds[0xFFFFFFFF].value == b\"123456\"\n\n    def test_write_removes_grouplength(self):\n        ds = dcmread(color_pl_name)\n        assert 0x00080000 in ds\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        ds = dcmread(self.file_out)\n        # group length has been removed\n        assert 0x00080000 not in ds\n\n    def test_write_empty_sequence(self):\n        \"\"\"Make sure that empty sequence is correctly written.\"\"\"\n        # regression test for #1030\n        ds = dcmread(get_testdata_file(\"test-SR.dcm\"))\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        ds = dcmread(self.file_out)\n        assert ds.PerformedProcedureCodeSequence == []\n\n    def test_write_deflated_retains_elements(self):\n        \"\"\"Read a Deflated Explicit VR Little Endian file, write it,\n        and then read the output, to verify that the written file\n        contains the same data.\n        \"\"\"\n        original = dcmread(deflate_name)\n        original.save_as(self.file_out)\n\n        self.file_out.seek(0)\n        rewritten = dcmread(self.file_out)\n\n        assert as_assertable(rewritten) == as_assertable(original)\n\n    def test_write_deflated_deflates_post_file_meta(self):\n        \"\"\"Read a Deflated Explicit VR Little Endian file, write it,\n        and then check the bytes in the output, to verify that the\n        written file is deflated past the file meta information.\n        \"\"\"\n        original = dcmread(deflate_name)\n        original.save_as(self.file_out)\n\n        first_byte_past_file_meta = 0x14E\n        with open(deflate_name, \"rb\") as original_file:\n            original_file.seek(first_byte_past_file_meta)\n            original_post_meta_file_bytes = original_file.read()\n        unzipped_original = zlib.decompress(\n            original_post_meta_file_bytes, -zlib.MAX_WBITS\n        )\n\n        self.file_out.seek(first_byte_past_file_meta)\n        rewritten_post_meta_file_bytes = self.file_out.read()\n        unzipped_rewritten = zlib.decompress(\n            rewritten_post_meta_file_bytes, -zlib.MAX_WBITS\n        )\n\n        assert unzipped_rewritten == unzipped_original\n\n    def test_write_dataset_without_encoding(self):\n        \"\"\"Test that write_dataset() raises if encoding not set.\"\"\"\n        msg = (\n            \"Unable to determine the encoding to use for writing the dataset, \"\n            \"please set the file meta's Transfer Syntax UID or use the \"\n            \"'implicit_vr' and 'little_endian' arguments\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            dcmwrite(BytesIO(), Dataset())\n\n\nclass TestScratchWriteDateTime(TestWriteFile):\n    \"\"\"Write and reread simple or multi-value DA/DT/TM data elements\"\"\"\n\n    def setup_method(self):\n        config.datetime_conversion = True\n        self.file_out = TemporaryFile(\"w+b\")\n\n    def teardown_method(self):\n        config.datetime_conversion = False\n        self.file_out.close()\n\n    def test_multivalue_DA(self):\n        \"\"\"Write DA/DT/TM data elements..........\"\"\"\n        multi_DA_expected = (date(1961, 8, 4), date(1963, 11, 22))\n        DA_expected = date(1961, 8, 4)\n        tzinfo = timezone(timedelta(seconds=-21600), \"-0600\")\n        multi_DT_expected = (\n            datetime(1961, 8, 4),\n            datetime(1963, 11, 22, 12, 30, 0, 0, tzinfo),\n        )\n        multi_TM_expected = (time(1, 23, 45), time(11, 11, 11))\n        TM_expected = time(11, 11, 11, 1)\n        ds = dcmread(datetime_name)\n        # Add date/time data elements\n        ds.CalibrationDate = MultiValue(DA, multi_DA_expected)\n        ds.DateOfLastCalibration = DA(DA_expected)\n        ds.ReferencedDateTime = MultiValue(DT, multi_DT_expected)\n        ds.CalibrationTime = MultiValue(TM, multi_TM_expected)\n        ds.TimeOfLastCalibration = TM(TM_expected)\n        ds.save_as(self.file_out)\n        self.file_out.seek(0)\n        # Now read it back in and check the values are as expected\n        ds = dcmread(self.file_out)\n        assert all([a == b for a, b in zip(ds.CalibrationDate, multi_DA_expected)])\n        assert DA_expected == ds.DateOfLastCalibration\n        assert all([a == b for a, b in zip(ds.ReferencedDateTime, multi_DT_expected)])\n        assert all([a == b for a, b in zip(ds.CalibrationTime, multi_TM_expected)])\n        assert TM_expected == ds.TimeOfLastCalibration\n\n\nclass TestWriteDataElement:\n    \"\"\"Attempt to write data elements has the expected behaviour\"\"\"\n\n    def setup_method(self):\n        # Create a dummy (in memory) file to write to\n        self.f1 = DicomBytesIO()\n        self.f1.is_little_endian = True\n        self.f1.is_implicit_VR = True\n\n    @staticmethod\n    def encode_element(elem, is_implicit_VR=True, is_little_endian=True):\n        \"\"\"Return the encoded `elem`.\n\n        Parameters\n        ----------\n        elem : pydicom.dataelem.DataElement\n            The element to encode\n        is_implicit_VR : bool\n            Encode using implicit VR, default True\n        is_little_endian : bool\n            Encode using little endian, default True\n\n        Returns\n        -------\n        str or bytes\n            The encoded element as str (python2) or bytes (python3)\n        \"\"\"\n        with DicomBytesIO() as fp:\n            fp.is_implicit_VR = is_implicit_VR\n            fp.is_little_endian = is_little_endian\n            write_data_element(fp, elem)\n            return fp.getvalue()\n\n    def test_empty_AT(self):\n        \"\"\"Write empty AT correctly..........\"\"\"\n        # Was issue 74\n        data_elem = DataElement(0x00280009, \"AT\", [])\n        expected = hex2bytes(\n            \" 28 00 09 00\"  # (0028,0009) Frame Increment Pointer\n            \" 00 00 00 00\"  # length 0\n        )\n        write_data_element(self.f1, data_elem)\n        assert expected == self.f1.getvalue()\n\n    def check_data_element(self, data_elem, expected):\n        encoded_elem = self.encode_element(data_elem)\n        assert expected == encoded_elem\n\n    def test_write_empty_LO(self):\n        data_elem = DataElement(0x00080070, \"LO\", None)\n        expected = b\"\\x08\\x00\\x70\\x00\\x00\\x00\\x00\\x00\"  # tag  # length  # value\n        self.check_data_element(data_elem, expected)\n\n    def test_write_DA(self):\n        data_elem = DataElement(0x00080022, \"DA\", \"20000101\")\n        expected = (\n            b\"\\x08\\x00\\x22\\x00\"  # tag\n            b\"\\x08\\x00\\x00\\x00\"  # length\n            b\"20000101\"\n        )  # value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080022, \"DA\", date(2000, 1, 1))\n        self.check_data_element(data_elem, expected)\n\n    def test_write_multi_DA(self):\n        data_elem = DataElement(0x0014407E, \"DA\", [\"20100101\", b\"20101231\"])\n        expected = (\n            b\"\\x14\\x00\\x7E\\x40\"  # tag\n            b\"\\x12\\x00\\x00\\x00\"  # length\n            b\"20100101\\\\20101231 \"\n        )  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(\n            0x0014407E, \"DA\", [date(2010, 1, 1), date(2010, 12, 31)]\n        )\n        self.check_data_element(data_elem, expected)\n\n    def test_write_TM(self):\n        data_elem = DataElement(0x00080030, \"TM\", \"010203\")\n        expected = (\n            b\"\\x08\\x00\\x30\\x00\"  # tag\n            b\"\\x06\\x00\\x00\\x00\"  # length\n            b\"010203\"\n        )  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080030, \"TM\", b\"010203\")\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080030, \"TM\", time(1, 2, 3))\n        self.check_data_element(data_elem, expected)\n\n    def test_write_multi_TM(self):\n        data_elem = DataElement(0x0014407C, \"TM\", [\"082500\", b\"092655\"])\n        expected = (\n            b\"\\x14\\x00\\x7C\\x40\"  # tag\n            b\"\\x0E\\x00\\x00\\x00\"  # length\n            b\"082500\\\\092655 \"\n        )  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0014407C, \"TM\", [time(8, 25), time(9, 26, 55)])\n        self.check_data_element(data_elem, expected)\n\n    def test_write_DT(self):\n        data_elem = DataElement(0x0008002A, \"DT\", \"20170101120000\")\n        expected = (\n            b\"\\x08\\x00\\x2A\\x00\"  # tag\n            b\"\\x0E\\x00\\x00\\x00\"  # length\n            b\"20170101120000\"\n        )  # value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0008002A, \"DT\", b\"20170101120000\")\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0008002A, \"DT\", datetime(2017, 1, 1, 12))\n        self.check_data_element(data_elem, expected)\n\n    def test_write_multi_DT(self):\n        data_elem = DataElement(0x0040A13A, \"DT\", [\"20120820120804\", b\"20130901111111\"])\n        expected = (\n            b\"\\x40\\x00\\x3A\\xA1\"  # tag\n            b\"\\x1E\\x00\\x00\\x00\"  # length\n            b\"20120820120804\\\\20130901111111 \"\n        )  # padded value\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0040A13A, \"DT\", \"20120820120804\\\\20130901111111\")\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x0040A13A, \"DT\", b\"20120820120804\\\\20130901111111\")\n        self.check_data_element(data_elem, expected)\n\n        data_elem = DataElement(\n            0x0040A13A,\n            \"DT\",\n            [datetime(2012, 8, 20, 12, 8, 4), datetime(2013, 9, 1, 11, 11, 11)],\n        )\n        self.check_data_element(data_elem, expected)\n\n    def test_write_ascii_vr_with_padding(self):\n        expected = (\n            b\"\\x08\\x00\\x54\\x00\"  # tag\n            b\"\\x0C\\x00\\x00\\x00\"  # length\n            b\"CONQUESTSRV \"\n        )  # padded value\n        data_elem = DataElement(0x00080054, \"AE\", \"CONQUESTSRV\")\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080054, \"AE\", b\"CONQUESTSRV\")\n        self.check_data_element(data_elem, expected)\n\n        expected = (\n            b\"\\x08\\x00\\x62\\x00\"  # tag\n            b\"\\x06\\x00\\x00\\x00\"  # length\n            b\"1.2.3\\x00\"\n        )  # padded value\n        data_elem = DataElement(0x00080062, \"UI\", \"1.2.3\")\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080062, \"UI\", b\"1.2.3\")\n        self.check_data_element(data_elem, expected)\n\n        expected = b\"\\x08\\x00\\x60\\x00\\x04\\x00\\x00\\x00REG \"  # tag  # length\n        data_elem = DataElement(0x00080060, \"CS\", \"REG\")\n        self.check_data_element(data_elem, expected)\n        data_elem = DataElement(0x00080060, \"CS\", b\"REG\")\n        self.check_data_element(data_elem, expected)\n\n    def test_write_OB_odd(self):\n        \"\"\"Test an odd-length OB element is padded during write\"\"\"\n        value = b\"\\x00\\x01\\x02\"\n        elem = DataElement(0x7FE00010, \"OB\", value)\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\xe0\\x7f\\x10\\x00\\x04\\x00\\x00\\x00\" + value + b\"\\x00\"\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b\"\"\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\xe0\\x7f\\x10\\x00\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_OD_implicit_little(self):\n        \"\"\"Test writing elements with VR of OD works correctly.\"\"\"\n        # VolumetricCurvePoints\n        bytestring = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n        elem = DataElement(0x0070150D, \"OD\", bytestring)\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0070,150D): 70 00 0d 15\n        # Length (16): 10 00 00 00\n        #             | Tag          |   Length      |    Value ->\n        ref_bytes = b\"\\x70\\x00\\x0d\\x15\\x10\\x00\\x00\\x00\" + bytestring\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b\"\"\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\x70\\x00\\x0d\\x15\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_OD_explicit_little(self):\n        \"\"\"Test writing elements with VR of OD works correctly.\n\n        Elements with a VR of 'OD' use the newer explicit VR\n        encoding (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # VolumetricCurvePoints\n        bytestring = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x01\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n        elem = DataElement(0x0070150D, \"OD\", bytestring)\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0070,150D): 70 00 0d 15\n        # VR (OD): \\x4f\\x44\n        # Reserved: \\x00\\x00\n        # Length (16): \\x10\\x00\\x00\\x00\n        #             | Tag          | VR    |\n        ref_bytes = b\"\\x70\\x00\\x0d\\x15\\x4f\\x44\\x00\\x00\\x10\\x00\\x00\\x00\" + bytestring\n        #             |Rsrvd |   Length      |    Value ->\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b\"\"\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b\"\\x70\\x00\\x0d\\x15\\x4f\\x44\\x00\\x00\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_OL_implicit_little(self):\n        \"\"\"Test writing elements with VR of OL works correctly.\"\"\"\n        # TrackPointIndexList\n        bytestring = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x01\\x01\\x02\\x03\"\n        elem = DataElement(0x00660129, \"OL\", bytestring)\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0066,0129): 66 00 29 01\n        # Length (12): 0c 00 00 00\n        #             | Tag          |   Length      |    Value ->\n        ref_bytes = b\"\\x66\\x00\\x29\\x01\\x0c\\x00\\x00\\x00\" + bytestring\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b\"\"\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\x66\\x00\\x29\\x01\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_OL_explicit_little(self):\n        \"\"\"Test writing elements with VR of OL works correctly.\n\n        Elements with a VR of 'OL' use the newer explicit VR\n        encoding (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # TrackPointIndexList\n        bytestring = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x01\\x01\\x02\\x03\"\n        elem = DataElement(0x00660129, \"OL\", bytestring)\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0066,0129): 66 00 29 01\n        # VR (OL): \\x4f\\x4c\n        # Reserved: \\x00\\x00\n        # Length (12): 0c 00 00 00\n        #             | Tag          | VR    |\n        ref_bytes = b\"\\x66\\x00\\x29\\x01\\x4f\\x4c\\x00\\x00\\x0c\\x00\\x00\\x00\" + bytestring\n        #             |Rsrvd |   Length      |    Value ->\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = b\"\"\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b\"\\x66\\x00\\x29\\x01\\x4f\\x4c\\x00\\x00\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_UC_implicit_little(self):\n        \"\"\"Test writing elements with VR of UC works correctly.\"\"\"\n        # VM 1, even data\n        elem = DataElement(0x00189908, \"UC\", \"Test\")\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0018,9908): 08 00 20 01\n        # Length (4): 04 00 00 00\n        # Value: \\x54\\x65\\x73\\x74\n        ref_bytes = b\"\\x18\\x00\\x08\\x99\\x04\\x00\\x00\\x00\\x54\\x65\\x73\\x74\"\n        assert ref_bytes == encoded_elem\n\n        # VM 1, odd data - padded to even length\n        elem.value = \"Test.\"\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\x18\\x00\\x08\\x99\\x06\\x00\\x00\\x00\\x54\\x65\\x73\\x74\\x2e\\x20\"\n        assert ref_bytes == encoded_elem\n\n        # VM 3, even data\n        elem.value = [\"Aa\", \"B\", \"C\"]\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\x18\\x00\\x08\\x99\\x06\\x00\\x00\\x00\\x41\\x61\\x5c\\x42\\x5c\\x43\"\n        assert ref_bytes == encoded_elem\n\n        # VM 3, odd data - padded to even length\n        elem.value = [\"A\", \"B\", \"C\"]\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\x18\\x00\\x08\\x99\\x06\\x00\\x00\\x00\\x41\\x5c\\x42\\x5c\\x43\\x20\"\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = \"\"\n        encoded_elem = self.encode_element(elem)\n        ref_bytes = b\"\\x18\\x00\\x08\\x99\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_UC_explicit_little(self):\n        \"\"\"Test writing elements with VR of UC works correctly.\n\n        Elements with a VR of 'UC' use the newer explicit VR\n        encoding (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # VM 1, even data\n        elem = DataElement(0x00189908, \"UC\", \"Test\")\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0018,9908): 08 00 20 01\n        # VR (UC): \\x55\\x43\n        # Reserved: \\x00\\x00\n        # Length (4): \\x04\\x00\\x00\\x00\n        # Value: \\x54\\x65\\x73\\x74\n        ref_bytes = b\"\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x04\\x00\\x00\\x00\\x54\\x65\\x73\\x74\"\n        assert ref_bytes == encoded_elem\n\n        # VM 1, odd data - padded to even length\n        elem.value = \"Test.\"\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = (\n            b\"\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x06\\x00\\x00\\x00\"\n            b\"\\x54\\x65\\x73\\x74\\x2e\\x20\"\n        )\n        assert ref_bytes == encoded_elem\n\n        # VM 3, even data\n        elem.value = [\"Aa\", \"B\", \"C\"]\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = (\n            b\"\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x06\\x00\\x00\\x00\"\n            b\"\\x41\\x61\\x5c\\x42\\x5c\\x43\"\n        )\n        assert ref_bytes == encoded_elem\n\n        # VM 3, odd data - padded to even length\n        elem.value = [\"A\", \"B\", \"C\"]\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = (\n            b\"\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x06\\x00\\x00\\x00\"\n            b\"\\x41\\x5c\\x42\\x5c\\x43\\x20\"\n        )\n        assert ref_bytes == encoded_elem\n\n        # Empty data\n        elem.value = \"\"\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b\"\\x18\\x00\\x08\\x99\\x55\\x43\\x00\\x00\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_UR_implicit_little(self):\n        \"\"\"Test writing elements with VR of UR works correctly.\"\"\"\n        # Even length URL\n        elem = DataElement(0x00080120, \"UR\", \"http://github.com/darcymason/pydicom\")\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0008,2001): 08 00 20 01\n        # Length (36): 24 00 00 00\n        # Value: 68 to 6d\n        ref_bytes = (\n            b\"\\x08\\x00\\x20\\x01\\x24\\x00\\x00\\x00\\x68\\x74\"\n            b\"\\x74\\x70\\x3a\\x2f\\x2f\\x67\\x69\\x74\\x68\\x75\"\n            b\"\\x62\\x2e\\x63\\x6f\\x6d\\x2f\\x64\\x61\\x72\\x63\"\n            b\"\\x79\\x6d\\x61\\x73\\x6f\\x6e\\x2f\\x70\\x79\\x64\"\n            b\"\\x69\\x63\\x6f\\x6d\"\n        )\n        assert ref_bytes == encoded_elem\n\n        # Odd length URL has trailing \\x20 (SPACE) padding\n        elem.value = \"../test/test.py\"\n        encoded_elem = self.encode_element(elem)\n        # Tag pair (0008,2001): 08 00 20 01\n        # Length (16): 10 00 00 00\n        # Value: 2e to 20\n        ref_bytes = (\n            b\"\\x08\\x00\\x20\\x01\\x10\\x00\\x00\\x00\\x2e\\x2e\"\n            b\"\\x2f\\x74\\x65\\x73\\x74\\x2f\\x74\\x65\\x73\\x74\"\n            b\"\\x2e\\x70\\x79\\x20\"\n        )\n        assert ref_bytes == encoded_elem\n\n        # Empty value\n        elem.value = \"\"\n        encoded_elem = self.encode_element(elem)\n        assert b\"\\x08\\x00\\x20\\x01\\x00\\x00\\x00\\x00\" == encoded_elem\n\n    def test_write_UR_explicit_little(self):\n        \"\"\"Test writing elements with VR of UR works correctly.\n\n        Elements with a VR of 'UR' use the newer explicit VR\n        encoded (see PS3.5 Section 7.1.2).\n        \"\"\"\n        # Even length URL\n        elem = DataElement(0x00080120, \"UR\", \"ftp://bits\")\n        encoded_elem = self.encode_element(elem, False, True)\n        # Tag pair (0008,2001): 08 00 20 01\n        # VR (UR): \\x55\\x52\n        # Reserved: \\x00\\x00\n        # Length (4): \\x0a\\x00\\x00\\x00\n        # Value: \\x66\\x74\\x70\\x3a\\x2f\\x2f\\x62\\x69\\x74\\x73\n        ref_bytes = (\n            b\"\\x08\\x00\\x20\\x01\\x55\\x52\\x00\\x00\\x0a\\x00\\x00\\x00\"\n            b\"\\x66\\x74\\x70\\x3a\\x2f\\x2f\\x62\\x69\\x74\\x73\"\n        )\n        assert ref_bytes == encoded_elem\n\n        # Odd length URL has trailing \\x20 (SPACE) padding\n        elem.value = \"ftp://bit\"\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = (\n            b\"\\x08\\x00\\x20\\x01\\x55\\x52\\x00\\x00\\x0a\\x00\\x00\\x00\"\n            b\"\\x66\\x74\\x70\\x3a\\x2f\\x2f\\x62\\x69\\x74\\x20\"\n        )\n        assert ref_bytes == encoded_elem\n\n        # Empty value\n        elem.value = \"\"\n        encoded_elem = self.encode_element(elem, False, True)\n        ref_bytes = b\"\\x08\\x00\\x20\\x01\\x55\\x52\\x00\\x00\\x00\\x00\\x00\\x00\"\n        assert ref_bytes == encoded_elem\n\n    def test_write_UN_implicit_little(self):\n        \"\"\"Test writing UN VR in implicit little\"\"\"\n        elem = DataElement(0x00100010, \"UN\", b\"\\x01\\x02\")\n        assert self.encode_element(elem) == (\n            b\"\\x10\\x00\\x10\\x00\\x02\\x00\\x00\\x00\\x01\\x02\"\n        )\n\n    def test_write_unknown_vr_raises(self):\n        \"\"\"Test exception raised trying to write unknown VR element\"\"\"\n        fp = DicomBytesIO()\n        fp.is_implicit_VR = True\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, \"ZZ\", \"Test\")\n        with pytest.raises(\n            NotImplementedError,\n            match=\"write_data_element: unknown Value Representation 'ZZ'\",\n        ):\n            write_data_element(fp, elem)\n\n\nclass TestCorrectAmbiguousVR:\n    \"\"\"Test correct_ambiguous_vr.\"\"\"\n\n    def test_pixel_representation_vm_one(self):\n        \"\"\"Test correcting VM 1 elements which require PixelRepresentation.\"\"\"\n        ref_ds = Dataset()\n\n        # If PixelRepresentation is 0 then VR should be US\n        ref_ds.PixelRepresentation = 0\n        ref_ds.SmallestValidPixelValue = b\"\\x00\\x01\"  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert 256 == ds.SmallestValidPixelValue\n        assert \"US\" == ds[0x00280104].VR\n\n        # If PixelRepresentation is 1 then VR should be SS\n        ref_ds.PixelRepresentation = 1\n        ref_ds.SmallestValidPixelValue = b\"\\x00\\x01\"  # Big endian 1\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)\n        assert 1 == ds.SmallestValidPixelValue\n        assert \"SS\" == ds[0x00280104].VR\n\n        # If no PixelRepresentation and no PixelData is present 'US' is set\n        ref_ds = Dataset()\n        ref_ds.SmallestValidPixelValue = b\"\\x00\\x01\"  # Big endian 1\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert \"US\" == ds[0x00280104].VR\n\n        # If no PixelRepresentation but PixelData is present\n        # AttributeError shall be raised\n        ref_ds.PixelData = b\"123\"\n        with pytest.raises(\n            AttributeError,\n            match=r\"Failed to resolve ambiguous VR for tag \"\n            r\"\\(0028,0104\\):.* 'PixelRepresentation'\",\n        ):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n\n    def test_pixel_representation_vm_three(self):\n        \"\"\"Test correcting VM 3 elements which require PixelRepresentation.\"\"\"\n        ref_ds = Dataset()\n\n        # If PixelRepresentation is 0 then VR should be US - Little endian\n        ref_ds.PixelRepresentation = 0\n        ref_ds.LUTDescriptor = b\"\\x01\\x00\\x00\\x01\\x10\\x00\"  # 1\\256\\16\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert [1, 256, 16] == ds.LUTDescriptor\n        assert \"US\" == ds[0x00283002].VR\n\n        # If PixelRepresentation is 1 then VR should be SS\n        ref_ds.PixelRepresentation = 1\n        ref_ds.LUTDescriptor = b\"\\x01\\x00\\x00\\x01\\x00\\x10\"\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)\n        assert [256, 1, 16] == ds.LUTDescriptor\n        assert \"SS\" == ds[0x00283002].VR\n\n        # If no PixelRepresentation and no PixelData is present 'US' is set\n        ref_ds = Dataset()\n        ref_ds.LUTDescriptor = b\"\\x01\\x00\\x00\\x01\\x00\\x10\"\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert \"US\" == ds[0x00283002].VR\n\n        # If no PixelRepresentation AttributeError shall be raised\n        ref_ds.PixelData = b\"123\"\n        with pytest.raises(\n            AttributeError,\n            match=r\"Failed to resolve ambiguous VR for tag \"\n            r\"\\(0028,3002\\):.* 'PixelRepresentation'\",\n        ):\n            correct_ambiguous_vr(deepcopy(ref_ds), False)\n\n    def test_pixel_data(self):\n        \"\"\"Test correcting PixelData.\"\"\"\n        ref_ds = Dataset()\n\n        # If BitsAllocated  > 8 then VR must be OW\n        ref_ds.BitsAllocated = 16\n        ref_ds.PixelData = b\"\\x00\\x01\"  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert b\"\\x00\\x01\" == ds.PixelData\n        assert \"OW\" == ds[0x7FE00010].VR\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)  # Big endian\n        assert b\"\\x00\\x01\" == ds.PixelData\n        assert \"OW\" == ds[0x7FE00010].VR\n\n        # If BitsAllocated <= 8 then VR can be OB or OW: we set it to OB\n        ref_ds = Dataset()\n        ref_ds.BitsAllocated = 8\n        ref_ds.Rows = 2\n        ref_ds.Columns = 2\n        ref_ds.PixelData = b\"\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\"\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert b\"\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\" == ds.PixelData\n        assert \"OB\" == ds[0x7FE00010].VR\n\n        # If no BitsAllocated set then AttributesError is raised\n        ref_ds = Dataset()\n        ref_ds.PixelData = b\"\\x00\\x01\"  # Big endian 1\n        with pytest.raises(\n            AttributeError,\n            match=r\"Failed to resolve ambiguous VR for tag \"\n            r\"\\(7FE0,0010\\):.* 'BitsAllocated'\",\n        ):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n\n    def test_waveform_bits_allocated(self):\n        \"\"\"Test correcting elements which require WaveformBitsAllocated.\"\"\"\n        ref_ds = Dataset()\n        ref_ds.set_original_encoding(False, True)\n\n        # If WaveformBitsAllocated  > 8 then VR must be OW\n        ref_ds.WaveformBitsAllocated = 16\n        ref_ds.WaveformData = b\"\\x00\\x01\"  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert b\"\\x00\\x01\" == ds.WaveformData\n        assert \"OW\" == ds[0x54001010].VR\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), False)  # Big endian\n        assert b\"\\x00\\x01\" == ds.WaveformData\n        assert \"OW\" == ds[0x54001010].VR\n\n        # If WaveformBitsAllocated == 8 then VR is OB or OW - set it to OB\n        ref_ds.WaveformBitsAllocated = 8\n        ref_ds.WaveformData = b\"\\x01\\x02\"\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert b\"\\x01\\x02\" == ds.WaveformData\n        assert \"OB\" == ds[0x54001010].VR\n\n        # For implicit VR, VR is always OW\n        ref_ds.set_original_encoding(True, True)\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert b\"\\x01\\x02\" == ds.WaveformData\n        assert \"OW\" == ds[0x54001010].VR\n        ref_ds.set_original_encoding(False, True)\n\n        # If no WaveformBitsAllocated then AttributeError shall be raised\n        ref_ds = Dataset()\n        ref_ds.WaveformData = b\"\\x00\\x01\"  # Big endian 1\n        with pytest.raises(\n            AttributeError,\n            match=r\"Failed to resolve ambiguous VR for tag \"\n            r\"\\(5400,1010\\):.* 'WaveformBitsAllocated'\",\n        ):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n\n    def test_lut_descriptor(self):\n        \"\"\"Test correcting elements which require LUTDescriptor.\"\"\"\n        ref_ds = Dataset()\n        ref_ds.PixelRepresentation = 0\n\n        # If LUTDescriptor[0] is 1 then LUTData VR is 'US'\n        ref_ds.LUTDescriptor = b\"\\x01\\x00\\x00\\x01\\x10\\x00\"  # 1\\256\\16\n        ref_ds.LUTData = b\"\\x00\\x01\"  # Little endian 256\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert 1 == ds.LUTDescriptor[0]\n        assert \"US\" == ds[0x00283002].VR\n        assert 256 == ds.LUTData\n        assert \"US\" == ds[0x00283006].VR\n\n        # If LUTDescriptor[0] is not 1 then LUTData VR is 'OW'\n        ref_ds.LUTDescriptor = b\"\\x02\\x00\\x00\\x01\\x10\\x00\"  # 2\\256\\16\n        ref_ds.LUTData = b\"\\x00\\x01\\x00\\x02\"\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)  # Little endian\n        assert 2 == ds.LUTDescriptor[0]\n        assert \"US\" == ds[0x00283002].VR\n        assert b\"\\x00\\x01\\x00\\x02\" == ds.LUTData\n        assert \"OW\" == ds[0x00283006].VR\n\n        # If no LUTDescriptor then raise AttributeError\n        ref_ds = Dataset()\n        ref_ds.LUTData = b\"\\x00\\x01\"\n        with pytest.raises(\n            AttributeError,\n            match=r\"Failed to resolve ambiguous VR for tag \"\n            r\"\\(0028,3006\\):.* 'LUTDescriptor'\",\n        ):\n            correct_ambiguous_vr(deepcopy(ref_ds), True)\n\n    def test_overlay(self):\n        \"\"\"Test correcting OverlayData\"\"\"\n        # VR must be 'OW'\n        ref_ds = Dataset()\n        ref_ds.set_original_encoding(True, True)\n        ref_ds.add(DataElement(0x60003000, \"OB or OW\", b\"\\x00\"))\n        ref_ds.add(DataElement(0x601E3000, \"OB or OW\", b\"\\x00\"))\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert \"OW\" == ds[0x60003000].VR\n        assert \"OW\" == ds[0x601E3000].VR\n        assert \"OB or OW\" == ref_ds[0x60003000].VR\n        assert \"OB or OW\" == ref_ds[0x601E3000].VR\n\n        ref_ds.set_original_encoding(False, True)\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert \"OW\" == ds[0x60003000].VR\n        assert \"OB or OW\" == ref_ds[0x60003000].VR\n\n    def test_sequence(self):\n        \"\"\"Test correcting elements in a sequence.\"\"\"\n        ref_ds = Dataset()\n        ref_ds.BeamSequence = [Dataset()]\n        ref_ds.BeamSequence[0].PixelRepresentation = 0\n        ref_ds.BeamSequence[0].SmallestValidPixelValue = b\"\\x00\\x01\"\n        ref_ds.BeamSequence[0].BeamSequence = [Dataset()]\n\n        ref_ds.BeamSequence[0].BeamSequence[0].PixelRepresentation = 0\n        ref_ds.BeamSequence[0].BeamSequence[0].SmallestValidPixelValue = b\"\\x00\\x01\"\n\n        ds = correct_ambiguous_vr(deepcopy(ref_ds), True)\n        assert ds.BeamSequence[0].SmallestValidPixelValue == 256\n        assert ds.BeamSequence[0][0x00280104].VR == \"US\"\n        assert ds.BeamSequence[0].BeamSequence[0].SmallestValidPixelValue == 256\n        assert ds.BeamSequence[0].BeamSequence[0][0x00280104].VR == \"US\"\n\n    def test_write_new_ambiguous(self):\n        \"\"\"Regression test for #781\"\"\"\n        ds = Dataset()\n        ds.SmallestImagePixelValue = 0\n        assert ds[0x00280106].VR == \"US or SS\"\n        ds.PixelRepresentation = 0\n        ds.LUTDescriptor = [1, 0]\n        assert ds[0x00283002].VR == \"US or SS\"\n        ds.LUTData = 0\n        assert ds[0x00283006].VR == \"US or OW\"\n        ds.save_as(DicomBytesIO(), implicit_vr=True)\n\n        assert ds[0x00280106].VR == \"US\"\n        assert ds.SmallestImagePixelValue == 0\n        assert ds[0x00283006].VR == \"US\"\n        assert ds.LUTData == 0\n        assert ds[0x00283002].VR == \"US\"\n        assert ds.LUTDescriptor == [1, 0]\n\n    def dataset_with_modality_lut_sequence(self, pixel_repr):\n        ds = Dataset()\n        ds.PixelRepresentation = pixel_repr\n        ds.ModalityLUTSequence = [Dataset()]\n        ds.ModalityLUTSequence[0].LUTDescriptor = [0, 0, 16]\n        ds.ModalityLUTSequence[0].LUTExplanation = None\n        ds.ModalityLUTSequence[0].ModalityLUTType = \"US\"  # US = unspecified\n        ds.ModalityLUTSequence[0].LUTData = b\"\\x0000\\x149a\\x1f1c\\xc2637\"\n        return ds\n\n    def test_ambiguous_element_in_sequence_explicit_using_attribute(self):\n        \"\"\"Test that writing a sequence with an ambiguous element\n        as explicit transfer syntax works if accessing the tag via keyword.\"\"\"\n        # regression test for #804\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        assert \"US\" == ds.ModalityLUTSequence[0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        assert \"SS\" == ds.ModalityLUTSequence[0][0x00283002].VR\n\n    def test_ambiguous_element_in_sequence_explicit_using_index(self):\n        \"\"\"Test that writing a sequence with an ambiguous element\n        as explicit transfer syntax works if accessing the tag\n        via the tag number.\"\"\"\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        assert \"US\" == ds[0x00283000][0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        assert \"SS\" == ds[0x00283000][0][0x00283002].VR\n\n    def test_ambiguous_element_in_sequence_implicit_using_attribute(self):\n        \"\"\"Test that reading a sequence with an ambiguous element\n        from a file with implicit transfer syntax works if accessing the\n        tag via keyword.\"\"\"\n        # regression test for #804\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        assert \"US\" == ds.ModalityLUTSequence[0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        assert \"SS\" == ds.ModalityLUTSequence[0][0x00283002].VR\n\n    def test_ambiguous_element_in_sequence_implicit_using_index(self):\n        \"\"\"Test that reading a sequence with an ambiguous element\n        from a file with implicit transfer syntax works if accessing the tag\n        via the tag number.\"\"\"\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        assert \"US\" == ds[0x00283000][0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        assert \"SS\" == ds[0x00283000][0][0x00283002].VR\n\n    def test_ambiguous_element_sequence_implicit_nearest(self):\n        \"\"\"Test that the nearest dataset with pixel rep to the ambiguous\n        element is used for correction.\n        \"\"\"\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        ds.ModalityLUTSequence[0].PixelRepresentation = 1\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        assert \"SS\" == ds[0x00283000][0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        ds.ModalityLUTSequence[0].PixelRepresentation = 0\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        assert \"US\" == ds[0x00283000][0][0x00283002].VR\n\n    def test_ambiguous_element_sequence_explicit_nearest(self):\n        \"\"\"Test that the nearest dataset with pixel rep to the ambiguous\n        element is used for correction.\n        \"\"\"\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        ds.ModalityLUTSequence[0].PixelRepresentation = 1\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        assert \"SS\" == ds[0x00283000][0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        ds.ModalityLUTSequence[0].PixelRepresentation = 0\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        assert \"US\" == ds[0x00283000][0][0x00283002].VR\n\n    def test_pickle_deepcopy_implicit(self):\n        \"\"\"Test we can correct VR after pickling and deepcopy.\"\"\"\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        ds.filename = None\n\n        ds2 = deepcopy(ds)\n\n        s = pickle.dumps({\"ds\": ds})\n        ds = pickle.loads(s)[\"ds\"]\n\n        assert \"US\" == ds[0x00283000][0][0x00283002].VR\n        assert \"US\" == ds2[0x00283000][0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n        ds.filename = None\n\n        ds2 = deepcopy(ds)\n\n        s = pickle.dumps({\"ds\": ds})\n        ds = pickle.loads(s)[\"ds\"]\n\n        assert \"SS\" == ds[0x00283000][0][0x00283002].VR\n        assert \"SS\" == ds2[0x00283000][0][0x00283002].VR\n\n    def test_pickle_deepcopy_explicit(self):\n        \"\"\"Test we can correct VR after pickling and deepcopy.\"\"\"\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=0)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        ds.filename = None\n\n        ds2 = deepcopy(ds)\n\n        s = pickle.dumps({\"ds\": ds})\n        ds = pickle.loads(s)[\"ds\"]\n\n        assert \"US\" == ds[0x00283000][0][0x00283002].VR\n        assert \"US\" == ds2[0x00283000][0][0x00283002].VR\n\n        ds = self.dataset_with_modality_lut_sequence(pixel_repr=1)\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False)\n        ds = dcmread(fp, force=True)\n        ds.filename = None\n\n        ds2 = deepcopy(ds)\n\n        s = pickle.dumps({\"ds\": ds})\n        ds = pickle.loads(s)[\"ds\"]\n\n        assert \"SS\" == ds[0x00283000][0][0x00283002].VR\n        assert \"SS\" == ds2[0x00283000][0][0x00283002].VR\n\n    def test_parent_change_implicit(self):\n        \"\"\"Test ambiguous VR correction when parent is changed.\"\"\"\n        ds = Dataset()\n        ds.PixelRepresentation = 0\n        ds.BeamSequence = [Dataset()]\n        # Nesting Modality LUT Sequence to avoid raw -> elem conversion\n        seq = ds.BeamSequence[0]\n        seq.ModalityLUTSequence = [Dataset()]\n        seq.ModalityLUTSequence[0].LUTDescriptor = [0, 0, 16]\n        seq.ModalityLUTSequence[0].LUTExplanation = None\n        seq.ModalityLUTSequence[0].ModalityLUTType = \"US\"  # US = unspecified\n        seq.ModalityLUTSequence[0].LUTData = b\"\\x0000\\x149a\\x1f1c\\xc2637\"\n\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n\n        ds1 = dcmread(ct_name)\n        ds1.PixelRepresentation = 1\n        ds1.BeamSequence = ds.BeamSequence\n        assert ds1._pixel_rep == 1\n        assert ds1[\"BeamSequence\"][0]._pixel_rep == 1\n        assert isinstance(ds1.BeamSequence[0]._dict[0x00283000], RawDataElement)\n\n        modality_seq = ds1.BeamSequence[0].ModalityLUTSequence\n        assert modality_seq[0]._pixel_rep == 1\n        assert \"SS\" == ds1.BeamSequence[0][0x00283000][0][0x00283002].VR\n\n    def test_pixel_repr_none_in_nearer_implicit(self):\n        \"\"\"Test a pixel representation of None in a nearer dataset.\"\"\"\n        ds = self.dataset_with_modality_lut_sequence(0)\n        ds.ModalityLUTSequence[0].PixelRepresentation = None\n\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n\n        item = ds.ModalityLUTSequence[0]\n        assert ds._pixel_rep == 0\n        assert item._pixel_rep == 0\n        assert \"US\" == item[0x00283002].VR\n\n    def test_pixel_repr_none_in_further_implicit(self):\n        \"\"\"Test a pixel representation of None in a further dataset.\"\"\"\n        ds = self.dataset_with_modality_lut_sequence(None)\n        ds.ModalityLUTSequence[0].PixelRepresentation = 0\n\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=True)\n        ds = dcmread(fp, force=True)\n\n        item = ds.ModalityLUTSequence[0]\n        assert not hasattr(ds, \"_pixel_rep\")\n        assert item._pixel_rep == 0\n        assert \"US\" == item[0x00283002].VR\n\n\nclass TestCorrectAmbiguousVRElement:\n    \"\"\"Test filewriter.correct_ambiguous_vr_element\"\"\"\n\n    def test_not_ambiguous(self):\n        \"\"\"Test no change in element if not ambiguous\"\"\"\n        elem = DataElement(0x60003000, \"OB\", b\"\\x00\")\n        out = correct_ambiguous_vr_element(elem, Dataset(), True)\n        assert out.VR == \"OB\"\n        assert out.tag == 0x60003000\n        assert out.value == b\"\\x00\"\n\n    def test_not_ambiguous_raw_data_element(self):\n        \"\"\"Test no change in raw data element if not ambiguous\"\"\"\n        elem = RawDataElement(0x60003000, \"OB\", 1, b\"\\x00\", 0, True, True)\n        out = correct_ambiguous_vr_element(elem, Dataset(), True)\n        assert out == elem\n        assert isinstance(out, RawDataElement)\n\n    def test_correct_ambiguous_data_element(self):\n        \"\"\"Test correct ambiguous US/SS element\"\"\"\n        ds = Dataset()\n        ds.PixelPaddingValue = b\"\\xfe\\xff\"\n        out = correct_ambiguous_vr_element(ds[0x00280120], ds, True)\n        # assume US if PixelData is not set\n        assert \"US\" == out.VR\n\n        ds = Dataset()\n        ds.PixelPaddingValue = b\"\\xfe\\xff\"\n        ds.PixelData = b\"3456\"\n        with pytest.raises(\n            AttributeError,\n            match=r\"Failed to resolve ambiguous VR for tag \"\n            r\"\\(0028,0120\\):.* 'PixelRepresentation'\",\n        ):\n            correct_ambiguous_vr_element(ds[0x00280120], ds, True)\n\n        ds.PixelRepresentation = 0\n        out = correct_ambiguous_vr_element(ds[0x00280120], ds, True)\n        assert out.VR == \"US\"\n        assert out.value == 0xFFFE\n\n    def test_correct_ambiguous_raw_data_element(self):\n        \"\"\"Test that correcting ambiguous US/SS raw data element\n        works and converts it to a data element\"\"\"\n        ds = Dataset()\n        elem = RawDataElement(0x00280120, \"US or SS\", 2, b\"\\xfe\\xff\", 0, True, True)\n        ds[0x00280120] = elem\n        ds.PixelRepresentation = 0\n        out = correct_ambiguous_vr_element(elem, ds, True)\n        assert isinstance(out, DataElement)\n        assert out.VR == \"US\"\n        assert out.value == 0xFFFE\n\n    def test_empty_value(self):\n        \"\"\"Regression test for #1193: empty value raises exception.\"\"\"\n        ds = Dataset()\n        elem = RawDataElement(0x00280106, \"US or SS\", 0, None, 0, True, True)\n        ds[0x00280106] = elem\n        out = correct_ambiguous_vr_element(elem, ds, True)\n        assert isinstance(out, DataElement)\n        assert out.VR == \"US\"\n\n        ds.LUTDescriptor = [1, 1, 1]\n        elem = RawDataElement(0x00283006, \"US or SS\", 0, None, 0, True, True)\n        assert out.value is None\n        ds[0x00283006] = elem\n        out = correct_ambiguous_vr_element(elem, ds, True)\n        assert isinstance(out, DataElement)\n        assert out.VR == \"US\"\n        assert out.value is None\n\n\nclass TestWriteAmbiguousVR:\n    \"\"\"Attempt to write data elements with ambiguous VR.\"\"\"\n\n    def setup_method(self):\n        # Create a dummy (in memory) file to write to\n        self.fp = DicomBytesIO()\n        self.fp.is_implicit_VR = False\n        self.fp.is_little_endian = True\n\n    def test_write_explicit_vr_raises(self):\n        \"\"\"Test writing explicit vr raises exception if unsolved element.\"\"\"\n        ds = Dataset()\n        ds.PerimeterValue = b\"\\x00\\x01\"\n        with pytest.raises(ValueError):\n            write_dataset(self.fp, ds)\n\n    def test_write_explicit_vr_little_endian(self):\n        \"\"\"Test writing explicit little data for ambiguous elements.\"\"\"\n        # Create a dataset containing element with ambiguous VRs\n        ref_ds = Dataset()\n        ref_ds.PixelRepresentation = 0\n        ref_ds.SmallestValidPixelValue = b\"\\x00\\x01\"  # Little endian 256\n\n        fp = BytesIO()\n        file_ds = FileDataset(fp, ref_ds)\n        file_ds.save_as(fp, implicit_vr=False)\n        fp.seek(0)\n\n        ds = read_dataset(fp, False, True, parent_encoding=\"latin1\")\n        assert 256 == ds.SmallestValidPixelValue\n        assert \"US\" == ds[0x00280104].VR\n        msg = \"'Dataset.read_implicit_vr' will be removed in v4.0\"\n        with pytest.warns(DeprecationWarning, match=msg):\n            assert not ds.read_implicit_vr\n\n        msg = \"'Dataset.read_little_endian' will be removed in v4.0\"\n        with pytest.warns(DeprecationWarning, match=msg):\n            assert ds.read_little_endian\n\n        msg = \"'Dataset.read_encoding' will be removed in v4.0\"\n        with pytest.warns(DeprecationWarning, match=msg):\n            assert ds.read_encoding == \"latin1\"\n\n    def test_write_explicit_vr_big_endian(self):\n        \"\"\"Test writing explicit big data for ambiguous elements.\"\"\"\n        # Create a dataset containing element with ambiguous VRs\n        ds = Dataset()\n        ds.PixelRepresentation = 1\n        ds.SmallestValidPixelValue = b\"\\x00\\x01\"  # Big endian 1\n        ds.SpecificCharacterSet = b\"ISO_IR 192\"\n\n        fp = BytesIO()\n        ds.save_as(fp, implicit_vr=False, little_endian=False)\n        fp.seek(0)\n\n        ds = read_dataset(fp, False, False)\n        assert 1 == ds.SmallestValidPixelValue\n        assert \"SS\" == ds[0x00280104].VR\n        with pytest.warns(DeprecationWarning):\n            assert not ds.read_implicit_vr\n            assert not ds.read_little_endian\n\n        msg = \"'Dataset.read_encoding' will be removed in v4.0\"\n        with pytest.warns(DeprecationWarning, match=msg):\n            assert [\"UTF8\"] == ds.read_encoding\n\n\nclass TestScratchWrite:\n    \"\"\"Simple dataset from scratch, written in all endian/VR combinations\"\"\"\n\n    def setup_method(self):\n        # Create simple dataset for all tests\n        ds = Dataset()\n        ds.PatientName = \"Name^Patient\"\n        ds.InstanceNumber = None\n\n        # Set up a simple nested sequence\n        # first, the innermost sequence\n        subitem1 = Dataset()\n        subitem1.ContourNumber = 1\n        subitem1.ContourData = [\"2\", \"4\", \"8\", \"16\"]\n        subitem2 = Dataset()\n        subitem2.ContourNumber = 2\n        subitem2.ContourData = [\"32\", \"64\", \"128\", \"196\"]\n\n        sub_ds = Dataset()\n        sub_ds.ContourSequence = Sequence((subitem1, subitem2))\n\n        # Now the top-level sequence\n        ds.ROIContourSequence = Sequence((sub_ds,))  # Comma to make one-tuple\n\n        # Store so each test can use it\n        self.ds = ds\n\n    def compare_write(self, hex_std, file_ds):\n        \"\"\"Write file and compare with expected byte string\n\n        :arg hex_std: the bytes which should be written, as space separated hex\n        :arg file_ds: a FileDataset instance containing the dataset to write\n        \"\"\"\n        out_filename = \"scratch.dcm\"\n        file_ds.save_as(out_filename)\n        std = hex2bytes(hex_std)\n        with open(out_filename, \"rb\") as f:\n            bytes_written = f.read()\n        # print \"std    :\", bytes2hex(std)\n        # print \"written:\", bytes2hex(bytes_written)\n        same, pos = bytes_identical(std, bytes_written)\n        assert same\n\n        if os.path.exists(out_filename):\n            os.remove(out_filename)  # get rid of the file\n\n    def testImpl_LE_deflen_write(self):\n        \"\"\"Scratch Write for implicit VR little endian, defined length SQs\"\"\"\n        file_ds = FileDataset(\"test\", self.ds)\n        self.compare_write(impl_LE_deflen_std_hex, file_ds)\n\n\nclass TestDCMWrite:\n    \"\"\"Tests for dcmwrite()\"\"\"\n\n    def test_implicit_big_raises(self):\n        \"\"\"Test implicit VR big endian encoding raises exception.\"\"\"\n        msg = \"Implicit VR and big endian is not a valid encoding combination\"\n        with pytest.raises(ValueError, match=msg):\n            dcmwrite(DicomBytesIO(), Dataset(), implicit_vr=True, little_endian=False)\n\n    def test_implicit_big_force_encoding(self):\n        \"\"\"Test implicit VR big endian encoding with force_encoding\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.PatientName = \"Foo\"\n        dcmwrite(fp, ds, implicit_vr=True, little_endian=False, force_encoding=True)\n        fp.seek(0)\n        assert fp.getvalue() == b\"\\x00\\x10\\x00\\x10\\x00\\x00\\x00\\x04\\x46\\x6f\\x6f\\x20\"\n\n    def test_bad_filename(self):\n        \"\"\"Test that TypeError is raised for a bad filename.\"\"\"\n        ds = dcmread(ct_name)\n        with pytest.raises(\n            TypeError,\n            match=(\n                \"dcmwrite: Expected a file path, file-like or writeable \"\n                \"buffer, but got NoneType\"\n            ),\n        ):\n            ds.save_as(None)\n        with pytest.raises(\n            TypeError,\n            match=(\n                \"dcmwrite: Expected a file path, file-like or writeable \"\n                \"buffer, but got int\"\n            ),\n        ):\n            ds.save_as(42)\n\n    def test_write_like_original_warns(self):\n        \"\"\"Test deprecation warning for write_like_original.\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.file_meta = FileMetaDataset()\n        ds.file_meta.TransferSyntaxUID = ImplicitVRLittleEndian\n        ds.SOPClassUID = \"1.2\"\n        ds.SOPInstanceUID = \"1.2.3\"\n        msg = (\n            \"'write_like_original' is deprecated and will be removed in \"\n            \"v4.0, please use 'enforce_file_format' instead\"\n        )\n        with pytest.warns(DeprecationWarning, match=msg):\n            dcmwrite(fp, ds, write_like_original=False)\n\n        with pytest.warns(DeprecationWarning, match=msg):\n            dcmwrite(fp, ds, write_like_original=True)\n\n        with pytest.warns(DeprecationWarning, match=msg):\n            dcmwrite(fp, ds, False)\n\n        with pytest.warns(DeprecationWarning, match=msg):\n            dcmwrite(fp, ds, True)\n\n    def test_extra_kwargs_raises(self):\n        \"\"\"Test unknown kwargs raise exception.\"\"\"\n        msg = r\"Invalid keyword argument\\(s\\) for dcmwrite\\(\\): is_implicit_VR\"\n        with pytest.warns(DeprecationWarning):\n            with pytest.raises(TypeError, match=msg):\n                dcmwrite(\n                    DicomBytesIO(),\n                    Dataset(),\n                    implicit_vr=False,\n                    write_like_original=True,\n                    is_implicit_VR=False,\n                )\n\n    def test_extra_args_raises(self):\n        \"\"\"Test unknown kwargs raise exception.\"\"\"\n        msg = r\"dcmwrite\\(\\) takes from 2 to 3 positional arguments but 4 were given\"\n        with pytest.raises(TypeError, match=msg):\n            dcmwrite(\n                DicomBytesIO(),\n                Dataset(),\n                True,\n                False,\n                is_implicit_VR=False,\n            )\n\n    def test_position_and_keyword_raises(self):\n        \"\"\"Test position and keyword arg raises exception.\"\"\"\n        msg = (\n            \"'write_like_original' cannot be used as both a positional and \"\n            \"keyword argument\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            dcmwrite(\n                DicomBytesIO(),\n                Dataset(),\n                True,\n                implicit_vr=False,\n                write_like_original=True,\n                is_implicit_VR=False,\n            )\n\n    def test_command_set_raises(self):\n        \"\"\"Test exception if command set elements present.\"\"\"\n        ds = Dataset()\n        ds.MessageID = 1\n        msg = (\n            r\"Command Set elements \\(0000,eeee\\) are not allowed when using \"\n            r\"dcmwrite\\(\\), use write_dataset\\(\\) instead\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            dcmwrite(\n                DicomBytesIO(),\n                ds,\n                implicit_vr=True,\n                enforce_file_format=True,\n            )\n\n    def test_file_meta_raises(self):\n        \"\"\"Test file meta elements in dataset raises exception.\"\"\"\n        ds = Dataset()\n        ds.TransferSyntaxUID = ImplicitVRLittleEndian\n        msg = (\n            r\"File Meta Information Group elements \\(0002,eeee\\) must be in a \"\n            r\"FileMetaDataset instance in the 'Dataset.file_meta' attribute\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            dcmwrite(DicomBytesIO(), ds, implicit_vr=True)\n\n    def test_dataset_file_meta_unchanged(self):\n        \"\"\"Test writing the dataset doesn't change its file_meta.\"\"\"\n        # Dataset has no file_meta\n        ds = Dataset()\n        ds.SOPClassUID = \"1.2\"\n        ds.SOPInstanceUID = \"1.2.3\"\n\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, implicit_vr=True)\n        assert not hasattr(ds, \"file_meta\")\n\n        dcmwrite(fp, ds, implicit_vr=True, enforce_file_format=True)\n        assert not hasattr(ds, \"file_meta\")\n\n        # Dataset has file_meta\n        ds.file_meta = FileMetaDataset()\n        ds.file_meta.ImplementationVersionName = \"Foo\"\n\n        dcmwrite(fp, ds, implicit_vr=True)\n        assert len(ds.file_meta) == 1\n        assert ds.file_meta.ImplementationVersionName == \"Foo\"\n\n        dcmwrite(fp, ds, implicit_vr=True, enforce_file_format=True)\n        assert len(ds.file_meta) == 1\n        assert ds.file_meta.ImplementationVersionName == \"Foo\"\n\n    def test_preamble_custom(self):\n        \"\"\"Test that a custom preamble is written correctly when present.\"\"\"\n        ds = dcmread(ct_name)\n        ds.preamble = b\"\\x01\\x02\\x03\\x04\" + b\"\\x00\" * 124\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds)\n        fp.seek(0)\n        assert b\"\\x01\\x02\\x03\\x04\" + b\"\\x00\" * 124 == fp.read(128)\n\n    def test_preamble_default(self):\n        \"\"\"Test that the default preamble is written correctly when present.\"\"\"\n        ds = dcmread(ct_name)\n        ds.preamble = b\"\\x00\" * 128\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds)\n        fp.seek(0)\n        assert b\"\\x00\" * 128 == fp.read(128)\n\n    def test_convert_big_to_little(self):\n        \"\"\"Test simple conversion from big to little endian.\"\"\"\n        # Note that O* and UN elements are not converted\n        ds = dcmread(mr_bigendian_name)\n        assert not ds.original_encoding[1]\n        ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        assert ds_out.original_encoding[1]\n\n        # pixel data is not converted automatically\n        ds_explicit = dcmread(mr_name)\n        del ds_out.PixelData\n        del ds_explicit.PixelData\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n\n    def test_convert_little_to_big(self):\n        \"\"\"Test simple conversion from little to big endian.\"\"\"\n        # Note that O* and UN elements are not converted\n        ds = dcmread(mr_name)\n        assert ds.original_encoding[1]\n        ds.file_meta.TransferSyntaxUID = ExplicitVRBigEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, little_endian=False)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        assert not ds_out.original_encoding[1]\n\n        # pixel data is not converted automatically\n        ds_explicit = dcmread(mr_bigendian_name)\n        del ds_out.PixelData\n        del ds_explicit.PixelData\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n\n    def test_raw_elements_preserved_implicit_vr(self):\n        \"\"\"Test writing the dataset preserves raw elements.\"\"\"\n        ds = dcmread(rtplan_name)\n\n        # raw data elements after reading\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100020).is_raw  # Patient ID\n        assert ds.get_item(0x300A0006).is_raw  # RT Plan Date\n        assert ds.get_item(0x300A0010).is_raw  # Dose Reference Sequence\n\n        dcmwrite(DicomBytesIO(), ds, enforce_file_format=True)\n\n        # data set still contains raw data elements after writing\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100020).is_raw  # Patient ID\n        assert ds.get_item(0x300A0006).is_raw  # RT Plan Date\n        assert ds.get_item(0x300A0010).is_raw  # Dose Reference Sequence\n\n    def test_raw_elements_preserved_explicit_vr(self):\n        \"\"\"Test writing the dataset preserves raw elements.\"\"\"\n        ds = dcmread(color_pl_name)\n\n        # raw data elements after reading\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100010).is_raw  # Patient Name\n        assert ds.get_item(0x00080030).is_raw  # Study Time\n        assert ds.get_item(0x00089215).is_raw  # Derivation Code Sequence\n\n        dcmwrite(DicomBytesIO(), ds, enforce_file_format=True)\n\n        # data set still contains raw data elements after writing\n        assert ds.get_item(0x00080070).is_raw  # Manufacturer\n        assert ds.get_item(0x00100010).is_raw  # Patient Name\n        assert ds.get_item(0x00080030).is_raw  # Study Time\n        assert ds.get_item(0x00089215).is_raw  # Derivation Code Sequence\n\n    def test_convert_implicit_to_explicit_vr(self):\n        # make sure conversion from implicit to explicit VR works\n        # without private tags\n        ds = dcmread(mr_implicit_name)\n        assert ds.is_implicit_VR\n        ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, enforce_file_format=True)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        assert not ds_out.is_implicit_VR\n        ds_explicit = dcmread(mr_name)\n\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n\n    def test_convert_implicit_to_explicit_vr_using_destination(self):\n        # make sure conversion from implicit to explicit VR works\n        # if setting the property in the destination\n        ds = dcmread(mr_implicit_name)\n        assert ds.is_implicit_VR\n        ds.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, enforce_file_format=True)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        assert not ds_out.is_implicit_VR\n        ds_explicit = dcmread(mr_name)\n\n        for elem_in, elem_out in zip(ds_explicit, ds_out):\n            assert elem_in == elem_out\n\n    def test_convert_explicit_to_implicit_vr(self):\n        # make sure conversion from explicit to implicit VR works\n        # without private tags\n        ds = dcmread(mr_name)\n        assert not ds.is_implicit_VR\n        ds.file_meta.TransferSyntaxUID = ImplicitVRLittleEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, enforce_file_format=True)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        assert ds_out.is_implicit_VR\n        ds_implicit = dcmread(mr_implicit_name)\n\n        for elem_in, elem_out in zip(ds_implicit, ds_out):\n            assert elem_in == elem_out\n\n    def test_changed_character_set(self):\n        \"\"\"Make sure that a changed character set is reflected\n        in the written data elements.\"\"\"\n        ds = dcmread(multiPN_name)\n        # Latin 1 original encoding\n        assert ds.get_item(0x00100010).value == b\"Buc^J\\xe9r\\xf4me\"\n\n        # change encoding to UTF-8\n        ds.SpecificCharacterSet = \"ISO_IR 192\"\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, enforce_file_format=True)\n        fp.seek(0)\n        ds_out = dcmread(fp)\n        # patient name shall be UTF-8 encoded\n        assert ds_out.get_item(0x00100010).value == b\"Buc^J\\xc3\\xa9r\\xc3\\xb4me\"\n        # decoded values shall be the same as in original dataset\n        for elem_in, elem_out in zip(ds, ds_out):\n            assert elem_in == elem_out\n\n    def test_private_tag_vr_from_implicit_data(self):\n        \"\"\"Test that private tags have the correct VR if converting\n        a dataset from implicit to explicit VR.\n        \"\"\"\n        # convert a dataset with private tags to Implicit VR\n        ds_orig = dcmread(ct_name)\n        assert not ds_orig.is_implicit_VR\n        ds_orig.file_meta.TransferSyntaxUID = ImplicitVRLittleEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds_orig, enforce_file_format=True)\n        fp.seek(0)\n        ds_impl = dcmread(fp)\n\n        # convert the dataset back to explicit VR - private tag VR now unknown\n        assert ds_impl.is_implicit_VR\n        ds_impl.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds_impl, enforce_file_format=True)\n        fp.seek(0)\n        ds_expl = dcmread(fp)\n        assert not ds_expl.is_implicit_VR\n\n        assert ds_expl[(0x0009, 0x0010)].VR == \"LO\"  # private creator\n        assert ds_expl[(0x0009, 0x1001)].VR == \"LO\"\n        assert ds_expl[(0x0009, 0x10E7)].VR == \"UL\"\n        assert ds_expl[(0x0043, 0x1010)].VR == \"US\"\n\n    def test_convert_rgb_from_implicit_to_explicit_vr(self, no_numpy_use):\n        \"\"\"Test converting an RGB dataset from implicit to explicit VR\n        and vice verse.\"\"\"\n        ds_orig = dcmread(sc_rgb_name)\n        assert not ds_orig.is_implicit_VR\n        ds_orig.file_meta.TransferSyntaxUID = ImplicitVRLittleEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds_orig, enforce_file_format=True)\n        fp.seek(0)\n        ds_impl = dcmread(fp)\n        assert ds_impl.is_implicit_VR\n        for elem_orig, elem_conv in zip(ds_orig, ds_impl):\n            assert elem_orig.value == elem_conv.value\n        assert \"OW\" == ds_impl[0x7FE00010].VR\n\n        ds_impl.file_meta.TransferSyntaxUID = ExplicitVRLittleEndian\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds_impl, enforce_file_format=True)\n        fp.seek(0)\n        # used to raise, see #620\n        ds_expl = dcmread(fp)\n        assert not ds_expl.is_implicit_VR\n        for elem_orig, elem_conv in zip(ds_orig, ds_expl):\n            assert elem_orig.value == elem_conv.value\n\n    def test_overwrite(self):\n        \"\"\"Test the overwrite argument\"\"\"\n        ds = dcmread(ct_name)\n        patient_name = ds.PatientName\n\n        with tempfile.TemporaryDirectory() as tdir:\n            p = Path(tdir) / \"foo.dcm\"\n            p.touch()\n\n            assert p.exists()\n\n            msg = r\"File exists: '(.*)foo.dcm'\"\n            with pytest.raises(FileExistsError, match=msg):\n                dcmwrite(p, ds, overwrite=False)\n\n            dcmwrite(p, ds, overwrite=True)\n            assert dcmread(p).PatientName == patient_name\n\n\nclass TestDCMWrite_EnforceFileFormat:\n    \"\"\"Tests for dcmwrite(enforce_file_format=True)\"\"\"\n\n    def test_force_encoding_raises(self):\n        \"\"\"Test that force_encoding raises.\"\"\"\n        msg = \"'force_encoding' cannot be used with 'enforce_file_format'\"\n        with pytest.raises(ValueError, match=msg):\n            dcmwrite(\n                DicomBytesIO(),\n                Dataset(),\n                force_encoding=True,\n                enforce_file_format=True,\n            )\n\n    def test_preamble_default(self):\n        \"\"\"Test that the default preamble is written correctly when present.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = b\"\\x00\" * 128\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(0)\n        assert fp.read(128) == b\"\\x00\" * 128\n\n    def test_preamble_custom(self):\n        \"\"\"Test that a custom preamble is written correctly when present.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = b\"\\x01\\x02\\x03\\x04\" + b\"\\x00\" * 124\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(0)\n        assert fp.read(128) == b\"\\x01\\x02\\x03\\x04\" + b\"\\x00\" * 124\n\n    def test_no_preamble(self):\n        \"\"\"Test that a default preamble is written when absent.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        del ds.preamble\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(0)\n        assert fp.read(128) == b\"\\x00\" * 128\n\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = None\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(0)\n        assert fp.read(128) == b\"\\x00\" * 128\n\n    def test_bad_preamble(self):\n        \"\"\"Test that ValueError is raised when preamble is bad.\"\"\"\n        ds = dcmread(ct_name)\n        msg = \"'FileDataset.preamble' must be 128-bytes long\"\n        for preamble in (b\"\\x00\" * 127, b\"\\x00\" * 129):\n            ds.preamble = preamble\n            with pytest.raises(ValueError, match=msg):\n                ds.save_as(DicomBytesIO(), enforce_file_format=True)\n\n    def test_prefix(self):\n        \"\"\"Test that the 'DICM' prefix is written with preamble.\"\"\"\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = b\"\\x00\" * 128\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(128)\n        assert fp.read(4) == b\"DICM\"\n\n        fp = DicomBytesIO()\n        ds = dcmread(ct_name)\n        ds.preamble = None\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(128)\n        assert fp.read(4) == b\"DICM\"\n\n    def test_file_meta_none(self):\n        \"\"\"Test writing a dataset with no file_meta\"\"\"\n        fp = DicomBytesIO()\n        version = \"PYDICOM \" + base_version\n        ds = dcmread(rtplan_name)\n        transfer_syntax = ds.file_meta.TransferSyntaxUID\n        ds.file_meta = FileMetaDataset()\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.MediaStorageSOPClassUID == ds.SOPClassUID\n        assert out.file_meta.MediaStorageSOPInstanceUID == ds.SOPInstanceUID\n        assert out.file_meta.ImplementationClassUID == PYDICOM_IMPLEMENTATION_UID\n        assert out.file_meta.ImplementationVersionName == version\n        assert out.file_meta.TransferSyntaxUID == transfer_syntax\n\n        fp = DicomBytesIO()\n        del ds.file_meta\n        ds.save_as(fp, enforce_file_format=True)\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.MediaStorageSOPClassUID == ds.SOPClassUID\n        assert out.file_meta.MediaStorageSOPInstanceUID == ds.SOPInstanceUID\n        assert out.file_meta.ImplementationClassUID == PYDICOM_IMPLEMENTATION_UID\n        assert out.file_meta.ImplementationVersionName == version\n        assert out.file_meta.TransferSyntaxUID == transfer_syntax\n\n    def test_file_meta_no_syntax(self):\n        \"\"\"Test a file meta with no transfer syntax.\"\"\"\n        ds = Dataset()\n        ds.SOPClassUID = \"1.2\"\n        ds.SOPInstanceUID = \"1.2.3\"\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, implicit_vr=True, little_endian=True, enforce_file_format=True)\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.TransferSyntaxUID == ImplicitVRLittleEndian\n\n        fp = DicomBytesIO()\n        dcmwrite(\n            fp, ds, implicit_vr=False, little_endian=False, enforce_file_format=True\n        )\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.TransferSyntaxUID == ExplicitVRBigEndian\n\n        msg = (\n            r\"Required File Meta Information elements are either missing \"\n            r\"or have an empty value: \\(0002,0010\\) Transfer Syntax UID\"\n        )\n        with pytest.raises(AttributeError, match=msg):\n            dcmwrite(\n                fp, ds, implicit_vr=False, little_endian=True, enforce_file_format=True\n            )\n\n    def test_file_meta_sop_class_sop_instance(self):\n        \"\"\"Test a file meta with no Media Storage SOP Class/Instance UID.\"\"\"\n        # Test values overwritten if missing or None\n        ds = Dataset()\n        ds.file_meta = FileMetaDataset()\n        ds.SOPClassUID = \"1.2\"\n        ds.SOPInstanceUID = \"1.2.3\"\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, implicit_vr=True, enforce_file_format=True)\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.MediaStorageSOPClassUID == \"1.2\"\n        assert out.file_meta.MediaStorageSOPInstanceUID == \"1.2.3\"\n\n        ds.file_meta.MediaStorageSOPClassUID = None\n        ds.file_meta.MediaStorageSOPInstanceUID = None\n        fp = DicomBytesIO()\n        dcmwrite(fp, ds, implicit_vr=True, enforce_file_format=True)\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.MediaStorageSOPClassUID == \"1.2\"\n        assert out.file_meta.MediaStorageSOPInstanceUID == \"1.2.3\"\n\n        # Test value not overwritten if None in dataset\n        ds.SOPClassUID = None\n        ds.SOPInstanceUID = None\n        ds.file_meta.MediaStorageSOPClassUID = \"1.2\"\n        ds.file_meta.MediaStorageSOPInstanceUID = \"1.2.3\"\n        fp = DicomBytesIO()\n        dcmwrite(\n            fp, ds, implicit_vr=False, little_endian=False, enforce_file_format=True\n        )\n        fp.seek(0)\n        out = dcmread(fp)\n        assert out.file_meta.MediaStorageSOPClassUID == \"1.2\"\n        assert out.file_meta.MediaStorageSOPInstanceUID == \"1.2.3\"\n\n        # Test exception if missing or None\n        del ds.file_meta\n        msg = (\n            r\"Required File Meta Information elements are either missing \"\n            r\"or have an empty value: \\(0002,0002\\) Media Storage SOP Class \"\n            r\"UID, \\(0002,0003\\) Media Storage SOP Instance UID\"\n        )\n        with pytest.raises(AttributeError, match=msg):\n            dcmwrite(fp, ds, implicit_vr=True, enforce_file_format=True)\n\n\nclass TestDetermineEncoding:\n    \"\"\"Tests for _determine_encoding().\"\"\"\n\n    def test_force_encoding_raises(self):\n        \"\"\"Test exception raised if force_encoding used without args.\"\"\"\n        ds = Dataset()\n        ds._read_implicit = True\n        ds._read_little = True\n        tsyntax = ImplicitVRLittleEndian\n        msg = (\n            \"'implicit_vr' and 'little_endian' are required if \"\n            \"'force_encoding' is used\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            _determine_encoding(ds, tsyntax, None, True, True)\n\n        with pytest.raises(ValueError, match=msg):\n            _determine_encoding(ds, tsyntax, True, None, True)\n\n    def test_force_encoding(self):\n        \"\"\"Test results with force_encoding are as expected.\"\"\"\n        ds = Dataset()\n        ds._is_implicit_VR = True\n        ds._is_little_endian = True\n        tsyntax = ImplicitVRLittleEndian\n        result = _determine_encoding(ds, tsyntax, False, False, True)\n        assert result == (False, False)\n\n    def test_transfer_syntax(self):\n        \"\"\"Test when transfer syntax is available.\"\"\"\n        ds = Dataset()\n        ds._is_implicit_VR = False\n        ds._is_little_endian = True\n        tsyntax = ImplicitVRLittleEndian\n        result = _determine_encoding(ds, tsyntax, True, None, False)\n        assert result == (True, True)\n\n    def test_args(self):\n        \"\"\"Test fallback to args when transfer syntax not available.\"\"\"\n        ds = Dataset()\n        ds._is_implicit_VR = False\n        ds._is_little_endian = True\n        result = _determine_encoding(ds, None, True, False, False)\n        assert result == (True, False)\n\n    def test_dataset(self):\n        \"\"\"Test fallback to dataset when transfer syntax and args not available.\"\"\"\n        ds = Dataset()\n        ds._is_implicit_VR = False\n        ds._is_little_endian = True\n        result = _determine_encoding(ds, None, None, False, False)\n        assert result == (False, True)\n\n    def test_original(self):\n        \"\"\"Test fallback to original when tsyntax, args and ds attr not available.\"\"\"\n        ds = Dataset()\n        ds._read_implicit = False\n        ds._read_little = True\n        result = _determine_encoding(ds, None, None, False, False)\n        assert result == (False, True)\n\n    def test_none_raises(self):\n        \"\"\"Test exception raised if unable to determine encoding.\"\"\"\n        msg = (\n            \"Unable to determine the encoding to use for writing the dataset, \"\n            \"please set the file meta's Transfer Syntax UID or use the \"\n            \"'implicit_vr' and 'little_endian' arguments\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            _determine_encoding(Dataset(), None, None, None, False)\n\n    def test_private_transfer_syntax_raises(self):\n        \"\"\"Test private syntax raises if no args.\"\"\"\n        syntax = UID(\"1.2.3\")\n        msg = (\n            \"The 'implicit_vr' and 'little_endian' arguments are required \"\n            \"when using a private transfer syntax\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            _determine_encoding(Dataset(), syntax, None, None, False)\n\n    def test_private_transfer_syntax(self):\n        \"\"\"Test private syntax raises if no args.\"\"\"\n        syntax = UID(\"1.2.3\")\n        result = _determine_encoding(Dataset(), syntax, True, True, False)\n        assert result == (True, True)\n\n    def test_invalid_transfer_syntax_raises(self):\n        \"\"\"Test public non-transfer syntax raises.\"\"\"\n        syntax = CTImageStorage\n        msg = (\n            \"The Transfer Syntax UID 'CT Image Storage' is not a valid \"\n            \"transfer syntax\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            _determine_encoding(Dataset(), syntax, False, True, False)\n\n    def test_mismatch_raises(self):\n        \"\"\"Test mismatch between args and transfer syntax raises.\"\"\"\n        ds = Dataset()\n        ds._is_implicit_VR = False\n        ds._is_little_endian = True\n        tsyntax = ImplicitVRLittleEndian\n        msg = (\n            \"The 'little_endian' value is not consistent with the required \"\n            \"endianness for the 'Implicit VR Little Endian' transfer syntax\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            _determine_encoding(ds, tsyntax, True, False, False)\n\n        msg = (\n            \"The 'implicit_vr' value is not consistent with the required \"\n            \"VR encoding for the 'Implicit VR Little Endian' transfer syntax\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            _determine_encoding(ds, tsyntax, False, True, False)\n\n\nclass TestWriteDataset:\n    \"\"\"Tests for write_dataset()\"\"\"\n\n    def test_encoding_buffer(self):\n        \"\"\"Test buffer.is_implicit_VR, buffer.is_little_endian used.\"\"\"\n        ds = Dataset()\n        ds.PatientName = \"Foo\"\n        ds._read_little = False\n        ds._read_implicit = False\n        ds._is_little_endian = False\n        ds._is_implicit_VR = False\n        fp = DicomBytesIO()\n        fp.is_implicit_VR = True\n        fp.is_little_endian = True\n        # Should use fp's encoding - implicit little\n        write_dataset(fp, ds)\n        assert fp.getvalue()[:8] == b\"\\x10\\x00\\x10\\x00\\x04\\x00\\x00\\x00\"\n\n    def test_encoding_ds_attr(self):\n        \"\"\"Tests ds.is_implicit_VR, ds.is_little_endian used.\"\"\"\n        ds = Dataset()\n        ds.PatientName = \"Foo\"\n        ds._read_little = False\n        ds._read_implicit = False\n        ds._is_little_endian = True\n        ds._is_implicit_VR = True\n        fp = DicomBytesIO()\n        # Should use ds's encoding - implicit little\n        write_dataset(fp, ds)\n        assert fp.getvalue()[:8] == b\"\\x10\\x00\\x10\\x00\\x04\\x00\\x00\\x00\"\n\n    def test_encoding_ds_original(self):\n        \"\"\"Test original ds encoding used.\"\"\"\n        ds = Dataset()\n        ds.PatientName = \"Foo\"\n        ds._read_little = True\n        ds._read_implicit = True\n        fp = DicomBytesIO()\n        # Should use ds's original encoding - implicit little\n        write_dataset(fp, ds)\n        assert fp.getvalue()[:8] == b\"\\x10\\x00\\x10\\x00\\x04\\x00\\x00\\x00\"\n\n    def test_encoding_raises(self):\n        \"\"\"Test raises exception if no encoding set\"\"\"\n\n    def test_write_dataset(self):\n        # make sure writing and reading back a dataset works correctly\n        ds = dcmread(mr_implicit_name)\n        fp = DicomBytesIO()\n        write_dataset(fp, ds)\n        fp.seek(0)\n        ds_read = read_dataset(fp, is_implicit_VR=True, is_little_endian=True)\n        for elem_orig, elem_read in zip(ds_read, ds):\n            assert elem_orig == elem_read\n\n    def test_write_dataset_with_explicit_vr(self):\n        # make sure conversion from implicit to explicit VR does not\n        # raise (regression test for #632)\n        ds = dcmread(mr_implicit_name)\n        fp = DicomBytesIO()\n        fp.is_implicit_VR = False\n        fp.is_little_endian = True\n        write_dataset(fp, ds)\n        fp.seek(0)\n        ds_read = read_dataset(fp, is_implicit_VR=False, is_little_endian=True)\n        for elem_orig, elem_read in zip(ds_read, ds):\n            assert elem_orig == elem_read\n\n    def test_no_source_raises(self):\n        \"\"\"Test trying to write without an encoding source raises.\"\"\"\n        ds = Dataset()\n        fp = DicomBytesIO()\n        msg = \"'fp.is_implicit_VR' and 'fp.is_little_endian' attributes are required\"\n        with pytest.raises(AttributeError, match=msg):\n            write_dataset(fp, ds)\n\n\nclass TestWriteFileMetaInfoToStandard:\n    \"\"\"Unit tests for writing File Meta Info to the DICOM standard.\"\"\"\n\n    def test_bad_elements(self):\n        \"\"\"Test that non-group 2 elements aren't written to the file meta.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.PatientID = \"12345678\"\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        meta.ImplementationClassUID = \"1.4\"\n        with pytest.raises(ValueError):\n            write_file_meta_info(fp, meta, enforce_standard=True)\n\n    def test_missing_elements(self):\n        \"\"\"Test that missing required elements raises ValueError.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        msg = (\n            r\"Required File Meta Information elements are either missing or \"\n            r\"have an empty value: \\(0002,0002\\) Media Storage SOP Class UID, \"\n            r\"\\(0002,0003\\) Media Storage SOP Instance UID, \\(0002,0010\\) \"\n            r\"Transfer Syntax UID\"\n        )\n        with pytest.raises(AttributeError, match=msg):\n            write_file_meta_info(fp, meta)\n\n        msg = (\n            r\"Required File Meta Information elements are either missing or \"\n            r\"have an empty value: \\(0002,0003\\) Media Storage SOP Instance \"\n            r\"UID, \\(0002,0010\\) Transfer Syntax UID\"\n        )\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        with pytest.raises(AttributeError, match=msg):\n            write_file_meta_info(fp, meta)\n\n        msg = (\n            r\"Required File Meta Information elements are either missing or \"\n            r\"have an empty value: \\(0002,0010\\) Transfer Syntax UID\"\n        )\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        with pytest.raises(AttributeError, match=msg):\n            write_file_meta_info(fp, meta)\n\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n    def test_group_length(self):\n        \"\"\"Test that the value for FileMetaInformationGroupLength is OK.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        class_length = len(PYDICOM_IMPLEMENTATION_UID)\n        if class_length % 2:\n            class_length += 1\n        version_length = len(meta.ImplementationVersionName)\n        # Padded to even length\n        if version_length % 2:\n            version_length += 1\n\n        fp.seek(8)\n        test_length = unpack(\"<I\", fp.read(4))[0]\n        assert test_length == 66 + class_length + version_length\n\n    def test_group_length_updated(self):\n        \"\"\"Test that FileMetaInformationGroupLength gets updated if present.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.FileMetaInformationGroupLength = 100  # Not actual length\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        class_length = len(PYDICOM_IMPLEMENTATION_UID)\n        if class_length % 2:\n            class_length += 1\n        version_length = len(meta.ImplementationVersionName)\n        # Padded to even length\n        if version_length % 2:\n            version_length += 1\n\n        fp.seek(8)\n        test_length = unpack(\"<I\", fp.read(4))[0]\n        assert test_length == (61 + class_length + version_length + len(base_version))\n        # Check original file meta is unchanged/updated\n        assert meta.FileMetaInformationGroupLength == test_length\n        assert meta.FileMetaInformationVersion == b\"\\x00\\x01\"\n        assert meta.MediaStorageSOPClassUID == \"1.1\"\n        assert meta.MediaStorageSOPInstanceUID == \"1.2\"\n        assert meta.TransferSyntaxUID == \"1.3\"\n        # Updated to meet standard\n        assert meta.ImplementationClassUID == PYDICOM_IMPLEMENTATION_UID\n        assert meta.ImplementationVersionName == \"PYDICOM \" + base_version\n\n    def test_version(self):\n        \"\"\"Test that the value for FileMetaInformationVersion is OK.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        fp.seek(12 + 12)\n        assert fp.read(2) == b\"\\x00\\x01\"\n\n    def test_implementation_version_name_length(self):\n        \"\"\"Test that the written Implementation Version Name length is OK\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n        version_length = len(meta.ImplementationVersionName)\n        # VR of SH, 16 bytes max\n        assert version_length <= 16\n\n    def test_implementation_class_uid_length(self):\n        \"\"\"Test that the written Implementation Class UID length is OK\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n        class_length = len(meta.ImplementationClassUID)\n        # VR of UI, 64 bytes max\n        assert class_length <= 64\n\n    def test_filelike_position(self):\n        \"\"\"Test that the file-like's ending position is OK.\"\"\"\n        fp = DicomBytesIO()\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n\n        # 8 + 4 bytes FileMetaInformationGroupLength\n        # 12 + 2 bytes FileMetaInformationVersion\n        # 8 + 4 bytes MediaStorageSOPClassUID\n        # 8 + 4 bytes MediaStorageSOPInstanceUID\n        # 8 + 4 bytes TransferSyntaxUID\n        # 8 + XX bytes ImplementationClassUID\n        # 8 + YY bytes ImplementationVersionName\n        # 78 + XX + YY bytes total\n        class_length = len(PYDICOM_IMPLEMENTATION_UID)\n        if class_length % 2:\n            class_length += 1\n        version_length = len(meta.ImplementationVersionName)\n        # Padded to even length\n        if version_length % 2:\n            version_length += 1\n\n        assert fp.tell() == 78 + class_length + version_length\n\n        fp = DicomBytesIO()\n        # 8 + 6 bytes MediaStorageSOPInstanceUID\n        meta.MediaStorageSOPInstanceUID = \"1.4.1\"\n        write_file_meta_info(fp, meta, enforce_standard=True)\n        # Check File Meta length\n        assert fp.tell() == 80 + class_length + version_length\n\n        # Check Group Length - 68 + XX + YY as bytes\n        fp.seek(8)\n        test_length = unpack(\"<I\", fp.read(4))[0]\n        assert test_length == 68 + class_length + version_length\n\n\nclass TestWriteNonStandard:\n    \"\"\"Unit tests for writing datasets not to the DICOM standard.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Create an empty file-like for use in testing.\"\"\"\n        self.fp = DicomBytesIO()\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = True\n\n    def compare_bytes(self, bytes_in, bytes_out):\n        \"\"\"Compare two bytestreams for equality\"\"\"\n        same, pos = bytes_identical(bytes_in, bytes_out)\n        assert same\n\n    def ensure_no_raw_data_elements(self, ds):\n        for _ in ds.file_meta:\n            pass\n        for _ in ds:\n            pass\n\n    def test_no_preamble(self):\n        \"\"\"Test no preamble or prefix is written if preamble absent.\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds.preamble\n        ds.save_as(self.fp)\n        self.fp.seek(0)\n        assert b\"\\x00\" * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert preamble != self.fp.read(128)\n        self.fp.seek(0)\n        assert b\"DICM\" != self.fp.read(4)\n\n    def test_ds_unchanged(self):\n        \"\"\"Test writing the dataset doesn't change it.\"\"\"\n        ds = dcmread(rtplan_name)\n        ref_ds = dcmread(rtplan_name)\n        ds.save_as(self.fp)\n\n        self.ensure_no_raw_data_elements(ds)\n        self.ensure_no_raw_data_elements(ref_ds)\n        assert ref_ds == ds\n\n    def test_file_meta_unchanged(self):\n        \"\"\"Test no file_meta elements are added if missing.\"\"\"\n        ds = dcmread(rtplan_name)\n        ds.file_meta = FileMetaDataset()\n        ds.save_as(self.fp)\n        assert Dataset() == ds.file_meta\n\n    def test_dataset(self):\n        \"\"\"Test dataset written OK with no preamble or file meta\"\"\"\n        ds = dcmread(ct_name)\n        del ds.preamble\n        del ds.file_meta\n        ds.save_as(self.fp)\n        self.fp.seek(0)\n        assert b\"\\x00\" * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert b\"DICM\" != self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert ds_out.preamble is None\n        assert Dataset() == ds_out.file_meta\n        assert \"PatientID\" in ds_out\n\n    def test_preamble_dataset(self):\n        \"\"\"Test dataset written OK with no file meta\"\"\"\n        ds = dcmread(ct_name)\n        del ds.file_meta\n        preamble = ds.preamble[:]\n        ds.save_as(self.fp)\n        self.fp.seek(0)\n        assert preamble == self.fp.read(128)\n        assert b\"DICM\" == self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert Dataset() == ds_out.file_meta\n        assert \"PatientID\" in ds_out\n\n    def test_filemeta_dataset(self):\n        \"\"\"Test file meta written OK if preamble absent.\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        del ds.preamble\n        ds.save_as(self.fp)\n        self.fp.seek(0)\n        assert b\"\\x00\" * 128 != self.fp.read(128)\n        self.fp.seek(0)\n        assert preamble != self.fp.read(128)\n        self.fp.seek(0)\n        assert b\"DICM\" != self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        assert \"ImplementationClassUID\" in ds_out.file_meta\n        assert ds_out.preamble is None\n        assert \"PatientID\" in ds_out\n\n    def test_preamble_filemeta_dataset(self):\n        \"\"\"Test non-standard file meta written with preamble OK\"\"\"\n        ds = dcmread(ct_name)\n        preamble = ds.preamble[:]\n        ds.save_as(self.fp)\n        self.fp.seek(0)\n        assert preamble == self.fp.read(128)\n        assert b\"DICM\" == self.fp.read(4)\n\n        self.fp.seek(0)\n        ds_out = dcmread(self.fp, force=True)\n        self.ensure_no_raw_data_elements(ds)\n        self.ensure_no_raw_data_elements(ds_out)\n\n        assert ds.file_meta[:] == ds_out.file_meta[:]\n        assert \"TransferSyntaxUID\" in ds_out.file_meta[:]\n        assert preamble == ds_out.preamble\n        assert \"PatientID\" in ds_out\n\n    def test_read_write_identical(self):\n        \"\"\"Test the written bytes matches the read bytes.\"\"\"\n        for dcm_in in [\n            rtplan_name,\n            rtdose_name,\n            ct_name,\n            mr_name,\n            jpeg_name,\n            no_ts,\n            unicode_name,\n            multiPN_name,\n        ]:\n            with open(dcm_in, \"rb\") as f:\n                bytes_in = BytesIO(f.read())\n                ds_in = dcmread(bytes_in)\n                bytes_out = BytesIO()\n                ds_in.save_as(bytes_out)\n                self.compare_bytes(bytes_in.getvalue(), bytes_out.getvalue())\n\n\nclass TestWriteFileMetaInfoNonStandard:\n    \"\"\"Unit tests for writing File Meta Info not to the DICOM standard.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Create an empty file-like for use in testing.\"\"\"\n        self.fp = DicomBytesIO()\n\n    def test_transfer_syntax_not_added(self):\n        \"\"\"Test that the TransferSyntaxUID isn't added if missing\"\"\"\n        ds = dcmread(no_ts)\n        write_file_meta_info(self.fp, ds.file_meta, enforce_standard=False)\n        assert \"TransferSyntaxUID\" not in ds.file_meta\n        assert \"ImplementationClassUID\" in ds.file_meta\n\n        # Check written meta dataset doesn't contain TransferSyntaxUID\n        written_ds = dcmread(self.fp, force=True)\n        assert \"ImplementationClassUID\" in written_ds.file_meta\n        assert \"TransferSyntaxUID\" not in written_ds.file_meta\n\n    def test_bad_elements(self):\n        \"\"\"Test that non-group 2 elements aren't written to the file meta.\"\"\"\n        meta = Dataset()\n        meta.PatientID = \"12345678\"\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        meta.ImplementationClassUID = \"1.4\"\n        with pytest.raises(ValueError):\n            write_file_meta_info(self.fp, meta, enforce_standard=False)\n\n    def test_missing_elements(self):\n        \"\"\"Test that missing required elements doesn't raise ValueError.\"\"\"\n        meta = Dataset()\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.TransferSyntaxUID = \"1.3\"\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        meta.ImplementationClassUID = \"1.4\"\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n\n    def test_group_length_updated(self):\n        \"\"\"Test that FileMetaInformationGroupLength gets updated if present.\"\"\"\n        meta = Dataset()\n        meta.FileMetaInformationGroupLength = 100\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        meta.ImplementationClassUID = \"1.4\"\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n\n        # 8 + 4 bytes FileMetaInformationGroupLength\n        # 8 + 4 bytes MediaStorageSOPClassUID\n        # 8 + 4 bytes MediaStorageSOPInstanceUID\n        # 8 + 4 bytes TransferSyntaxUID\n        # 8 + 4 bytes ImplementationClassUID\n        # 60 bytes total, - 12 for group length = 48\n        self.fp.seek(8)\n        assert b\"\\x30\\x00\\x00\\x00\" == self.fp.read(4)\n        # Check original file meta is unchanged/updated\n        assert 48 == meta.FileMetaInformationGroupLength\n        assert \"FileMetaInformationVersion\" not in meta\n        assert \"1.1\" == meta.MediaStorageSOPClassUID\n        assert \"1.2\" == meta.MediaStorageSOPInstanceUID\n        assert \"1.3\" == meta.TransferSyntaxUID\n        assert \"1.4\" == meta.ImplementationClassUID\n\n    def test_filelike_position(self):\n        \"\"\"Test that the file-like's ending position is OK.\"\"\"\n        # 8 + 4 bytes MediaStorageSOPClassUID\n        # 8 + 4 bytes MediaStorageSOPInstanceUID\n        # 8 + 4 bytes TransferSyntaxUID\n        # 8 + 4 bytes ImplementationClassUID\n        # 48 bytes total\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        meta.ImplementationClassUID = \"1.4\"\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert 48 == self.fp.tell()\n\n        # 8 + 6 bytes ImplementationClassUID\n        # 50 bytes total\n        self.fp.seek(0)\n        meta.ImplementationClassUID = \"1.4.1\"\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        # Check File Meta length\n        assert 50 == self.fp.tell()\n\n    def test_meta_unchanged(self):\n        \"\"\"Test that the meta dataset doesn't change when writing it\"\"\"\n        # Empty\n        meta = Dataset()\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert Dataset() == meta\n\n        # Incomplete\n        meta = Dataset()\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        meta.ImplementationClassUID = \"1.4\"\n        ref_meta = deepcopy(meta)\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert ref_meta == meta\n\n        # Conformant\n        meta = Dataset()\n        meta.FileMetaInformationGroupLength = 62  # Correct length\n        meta.FileMetaInformationVersion = b\"\\x00\\x01\"\n        meta.MediaStorageSOPClassUID = \"1.1\"\n        meta.MediaStorageSOPInstanceUID = \"1.2\"\n        meta.TransferSyntaxUID = \"1.3\"\n        meta.ImplementationClassUID = \"1.4\"\n        ref_meta = deepcopy(meta)\n        write_file_meta_info(self.fp, meta, enforce_standard=False)\n        assert ref_meta == meta\n\n\nclass TestWriteNumbers:\n    \"\"\"Test filewriter.write_numbers\"\"\"\n\n    def test_write_empty_value(self):\n        \"\"\"Test writing an empty value does nothing\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, \"US\", None)\n        fmt = \"H\"\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b\"\"\n\n    def test_write_list(self):\n        \"\"\"Test writing an element value with VM > 1\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, \"US\", [1, 2, 3, 4])\n        fmt = \"H\"\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b\"\\x01\\x00\\x02\\x00\\x03\\x00\\x04\\x00\"\n\n    def test_write_singleton(self):\n        \"\"\"Test writing an element value with VM = 1\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00100010, \"US\", 1)\n        fmt = \"H\"\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b\"\\x01\\x00\"\n\n    def test_exception(self):\n        \"\"\"Test exceptions raise OSError\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        with pytest.warns(UserWarning, match=\"Invalid value length 1\"):\n            elem = DataElement(0x00100010, \"US\", b\"\\x00\")\n        fmt = \"H\"\n        with pytest.raises(OSError, match=r\"for data_element:\\n\\(0010,0010\\)\"):\n            write_numbers(fp, elem, fmt)\n\n    def test_write_big_endian(self):\n        \"\"\"Test writing big endian\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = False\n        elem = DataElement(0x00100010, \"US\", 1)\n        fmt = \"H\"\n        write_numbers(fp, elem, fmt)\n        assert fp.getvalue() == b\"\\x00\\x01\"\n\n    def test_write_lut_descriptor(self):\n        \"\"\"Test writing LUT Descriptor\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00283002, \"SS\", [32768, 0, 16])\n        write_numbers(fp, elem, \"h\")\n        assert fp.getvalue() == b\"\\x00\\x80\\x00\\x00\\x10\\x00\"\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x00283002, \"SS\", [])\n        write_numbers(fp, elem, \"h\")\n        assert fp.getvalue() == b\"\"\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = False\n        elem = DataElement(0x00283002, \"SS\", [32768, 0, 16])\n        write_numbers(fp, elem, \"h\")\n        assert fp.getvalue() == b\"\\x80\\x00\\x00\\x00\\x00\\x10\"\n\n\nclass TestWriteOtherVRs:\n    \"\"\"Tests for writing the 'O' VRs like OB, OW, OF, etc.\"\"\"\n\n    def test_write_ob(self):\n        \"\"\"Test writing element with VR OF\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OB\", b\"\\x00\\x01\\x02\\x03\")\n        write_OBvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x03\"\n\n        # Odd length value padded\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OB\", b\"\\x00\\x01\\x02\")\n        write_OBvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x00\"\n\n    def test_write_ob_buffered(self):\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        b = BytesIO(b\"\\x00\\x01\\x02\\x03\")\n        elem = DataElement(0x7FE00008, \"OB\", b)\n        write_OBvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x03\"\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OB\", b)\n        b.close()\n        msg = \"the buffer has been closed\"\n        with pytest.raises(ValueError, match=msg):\n            write_OBvalue(fp, elem)\n\n        # Odd length value padded\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OB\", BytesIO(b\"\\x00\\x01\\x02\"))\n        write_OBvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x00\"\n\n    def test_write_ow(self):\n        \"\"\"Test writing element with VR OW\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OW\", b\"\\x00\\x01\\x02\\x03\")\n        write_OWvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x03\"\n\n        # Odd length value padded\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OW\", b\"\\x00\\x01\\x02\")\n        write_OWvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x00\"\n\n    def test_write_ow_buffered(self):\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        b = BytesIO(b\"\\x00\\x01\\x02\\x03\")\n        elem = DataElement(0x7FE00008, \"OW\", b)\n        write_OBvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x03\"\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OW\", b)\n        b.close()\n        msg = \"the buffer has been closed\"\n        with pytest.raises(ValueError, match=msg):\n            write_OBvalue(fp, elem)\n\n        # Odd length value padded\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OW\", BytesIO(b\"\\x00\\x01\\x02\"))\n        write_OBvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x00\"\n\n    def test_write_of(self):\n        \"\"\"Test writing element with VR OF\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        elem = DataElement(0x7FE00008, \"OF\", b\"\\x00\\x01\\x02\\x03\")\n        write_OWvalue(fp, elem)\n        assert fp.getvalue() == b\"\\x00\\x01\\x02\\x03\"\n\n    def test_write_of_dataset(self):\n        \"\"\"Test writing a dataset with an element with VR OF.\"\"\"\n        fp = DicomBytesIO()\n        ds = Dataset()\n        ds.FloatPixelData = b\"\\x00\\x01\\x02\\x03\"\n        ds.save_as(fp, implicit_vr=False)\n        assert fp.getvalue() == (\n            # Tag             | VR            | Length        | Value\n            b\"\\xe0\\x7f\\x08\\x00\\x4F\\x46\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x01\\x02\\x03\"\n        )\n\n\nclass TestWritePN:\n    \"\"\"Test filewriter.write_PN\"\"\"\n\n    def test_no_encoding(self):\n        \"\"\"If PN element has no encoding info, default is used\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with encoded value\n        elem = DataElement(0x00100010, \"PN\", \"Test\")\n        write_PN(fp, elem)\n        assert b\"Test\" == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00100010, \"PN\", \"Test\")\n        write_PN(fp, elem)\n        assert b\"Test\" == fp.getvalue()\n\n    def test_single_byte_multi_charset_groups(self):\n        \"\"\"Test component groups with different encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encodings = [\"latin_1\", \"iso_ir_126\"]\n        # data element with encoded value\n        encoded = b\"Dionysios=\\x1b\\x2d\\x46\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\"\n        elem = DataElement(0x00100010, \"PN\", encoded)\n        write_PN(fp, elem)\n        assert encoded == fp.getvalue()\n\n        # regression test: make sure no warning is issued, e.g. the\n        # PersonName value has not saved the default encoding\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        with assert_no_warning():\n            write_PN(fp, elem, encodings)\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00100010, \"PN\", \"Dionysios=\u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\")\n        write_PN(fp, elem, encodings=encodings)\n        assert encoded == fp.getvalue()\n\n    def test_single_byte_multi_charset_values(self):\n        \"\"\"Test multiple values with different encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encodings = [\"latin_1\", \"iso_ir_144\", \"iso_ir_126\"]\n        # data element with encoded value\n        encoded = (\n            b\"Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46\"\n            b\"\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\\"\n            b\"\\x1b\\x2d\\x4C\"\n            b\"\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3 \"\n        )\n        elem = DataElement(0x00100060, \"PN\", encoded)\n        write_PN(fp, elem)\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00100060, \"PN\", [\"Buc^J\u00e9r\u00f4me\", \"\u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\", \"\u041b\u044e\u043ace\u043c\u0431yp\u0433\"])\n        write_PN(fp, elem, encodings=encodings)\n        assert encoded == fp.getvalue()\n\n\nclass TestWriteText:\n    \"\"\"Test filewriter.write_PN\"\"\"\n\n    def test_no_encoding(self):\n        \"\"\"If text element has no encoding info, default is used\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with encoded value\n        elem = DataElement(0x00081039, \"LO\", \"Test\")\n        write_text(fp, elem)\n        assert b\"Test\" == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, \"LO\", \"Test\")\n        write_text(fp, elem)\n        assert b\"Test\" == fp.getvalue()\n\n    def test_single_byte_multi_charset_text(self):\n        \"\"\"Test changed encoding inside the string\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encoded = b\"Dionysios=\\x1b\\x2d\\x46\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\"\n        # data element with encoded value\n        elem = DataElement(0x00081039, \"LO\", encoded)\n        encodings = [\"latin_1\", \"iso_ir_126\"]\n        write_text(fp, elem)\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, \"LO\", \"Dionysios is \u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\")\n        write_text(fp, elem, encodings=encodings)\n        # encoding may not be the same, so decode it first\n        encoded = fp.getvalue()\n        assert \"Dionysios is \u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\" == convert_text(encoded, encodings)\n\n    def test_encode_mixed_charsets_text(self):\n        \"\"\"Test encodings used inside the string in arbitrary order\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encodings = [\"latin_1\", \"euc_kr\", \"iso-2022-jp\", \"iso_ir_127\"]\n        decoded = \"\u5c71\u7530-\u0642\u0628\u0627\u0646\u064a-\u5409\u6d1e-\u0644\u0646\u0632\u0627\u0631\"\n\n        # data element with encoded value\n        elem = DataElement(0x00081039, \"LO\", decoded)\n        write_text(fp, elem, encodings=encodings)\n        encoded = fp.getvalue()\n        # make sure that the encoded string can be converted back\n        assert decoded == convert_text(encoded, encodings)\n\n    def test_single_byte_multi_charset_text_multivalue(self):\n        \"\"\"Test multiple values with different encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        encoded = (\n            b\"Buc^J\\xe9r\\xf4me\\\\\\x1b\\x2d\\x46\"\n            b\"\\xc4\\xe9\\xef\\xed\\xf5\\xf3\\xe9\\xef\\xf2\\\\\"\n            b\"\\x1b\\x2d\\x4C\"\n            b\"\\xbb\\xee\\xda\\x63\\x65\\xdc\\xd1\\x79\\x70\\xd3 \"\n        )\n        # data element with encoded value\n        elem = DataElement(0x00081039, \"LO\", encoded)\n        encodings = [\"latin_1\", \"iso_ir_144\", \"iso_ir_126\"]\n        write_text(fp, elem, encodings=encodings)\n        assert encoded == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        decoded = [\"Buc^J\u00e9r\u00f4me\", \"\u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\", \"\u041b\u044e\u043ace\u043c\u0431yp\u0433\"]\n        elem = DataElement(0x00081039, \"LO\", decoded)\n        write_text(fp, elem, encodings=encodings)\n        # encoding may not be the same, so decode it first\n        encoded = fp.getvalue()\n        assert decoded == convert_text(encoded, encodings)\n\n    def test_invalid_encoding(self, allow_writing_invalid_values):\n        \"\"\"Test encoding text with invalid encodings\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, \"LO\", \"Dionysios \u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\")\n        msg = \"Failed to encode value with encodings: iso-2022-jp\"\n        expected = b\"Dionysios \\x1b$B&$&I&O&M&T&R&I&O\\x1b(B? \"\n        with pytest.warns(UserWarning, match=msg):\n            # encode with one invalid encoding\n            write_text(fp, elem, encodings=[\"iso-2022-jp\"])\n            assert expected == fp.getvalue()\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, \"LO\", \"Dionysios \u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\")\n        msg = \"Failed to encode value with encodings: iso-2022-jp, iso_ir_58\"\n        with pytest.warns(UserWarning, match=msg):\n            # encode with two invalid encodings\n            write_text(fp, elem, encodings=[\"iso-2022-jp\", \"iso_ir_58\"])\n            assert expected == fp.getvalue()\n\n    def test_invalid_encoding_enforce_standard(self, enforce_writing_invalid_values):\n        \"\"\"Test encoding text with invalid encodings with\n        `config.settings.reading_validation_mode` is RAISE\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, \"LO\", \"Dionysios \u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\")\n        msg = (\n            r\"'iso2022_jp' codec can't encode character u?'\\\\u03c2' in \"\n            r\"position 18: illegal multibyte sequence\"\n        )\n        with pytest.raises(UnicodeEncodeError, match=msg):\n            # encode with one invalid encoding\n            write_text(fp, elem, encodings=[\"iso-2022-jp\"])\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        # data element with decoded value\n        elem = DataElement(0x00081039, \"LO\", \"Dionysios \u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\")\n        with pytest.raises(UnicodeEncodeError, match=msg):\n            # encode with two invalid encodings\n            write_text(fp, elem, encodings=[\"iso-2022-jp\", \"iso_ir_58\"])\n\n    def test_single_value_with_delimiters(self):\n        \"\"\"Test that text with delimiters encodes correctly\"\"\"\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        decoded = \"\u0394\u03b9\u03bf\u03bd\u03c5\u03c3\u03b9\u03bf\u03c2\\r\\nJ\u00e9r\u00f4me/\u041b\u044e\u043ace\u043c\u0431yp\u0433\\tJ\u00e9r\u00f4me\"\n        elem = DataElement(0x00081039, \"LO\", decoded)\n        encodings = (\"latin_1\", \"iso_ir_144\", \"iso_ir_126\")\n        write_text(fp, elem, encodings=encodings)\n        encoded = fp.getvalue()\n        assert decoded == convert_text(encoded, encodings)\n\n\nclass TestWriteDT:\n    \"\"\"Test filewriter.write_DT\"\"\"\n\n    def test_format_dt(self):\n        \"\"\"Test _format_DT\"\"\"\n        elem = DataElement(0x00181078, \"DT\", DT(\"20010203123456.123456\"))\n        assert hasattr(elem.value, \"original_string\")\n        assert _format_DT(elem.value) == \"20010203123456.123456\"\n        del elem.value.original_string\n        assert not hasattr(elem.value, \"original_string\")\n        assert elem.value.microsecond > 0\n        assert _format_DT(elem.value) == \"20010203123456.123456\"\n\n        elem = DataElement(0x00181078, \"DT\", DT(\"20010203123456\"))\n        del elem.value.original_string\n        assert _format_DT(elem.value) == \"20010203123456\"\n\n\nclass TestWriteUndefinedLengthPixelData:\n    \"\"\"Test write_data_element() for pixel data with undefined length.\"\"\"\n\n    def setup_method(self):\n        self.fp = DicomBytesIO()\n\n    def test_little_endian_correct_data(self):\n        \"\"\"Pixel data starting with an item tag is written.\"\"\"\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(\n            0x7FE00010,\n            \"OB\",\n            b\"\\xfe\\xff\\x00\\xe0\\x00\\x01\\x02\\x03\",\n            is_undefined_length=True,\n        )\n        write_data_element(self.fp, pixel_data)\n\n        expected = (\n            b\"\\xe0\\x7f\\x10\\x00\"  # tag\n            b\"OB\\x00\\x00\"  # VR\n            b\"\\xff\\xff\\xff\\xff\"  # length\n            b\"\\xfe\\xff\\x00\\xe0\\x00\\x01\\x02\\x03\"  # contents\n            b\"\\xfe\\xff\\xdd\\xe0\\x00\\x00\\x00\\x00\"\n        )  # SQ delimiter\n        self.fp.seek(0)\n        assert self.fp.read() == expected\n\n    def test_big_endian_correct_data(self):\n        \"\"\"Pixel data starting with an item tag is written.\"\"\"\n        self.fp.is_little_endian = False\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(\n            0x7FE00010,\n            \"OB\",\n            b\"\\xff\\xfe\\xe0\\x00\\x00\\x01\\x02\\x03\",\n            is_undefined_length=True,\n        )\n        write_data_element(self.fp, pixel_data)\n        expected = (\n            b\"\\x7f\\xe0\\x00\\x10\"  # tag\n            b\"OB\\x00\\x00\"  # VR\n            b\"\\xff\\xff\\xff\\xff\"  # length\n            b\"\\xff\\xfe\\xe0\\x00\\x00\\x01\\x02\\x03\"  # contents\n            b\"\\xff\\xfe\\xe0\\xdd\\x00\\x00\\x00\\x00\"\n        )  # SQ delimiter\n        self.fp.seek(0)\n        assert self.fp.read() == expected\n\n    @pytest.mark.parametrize(\n        \"data\",\n        (\n            b\"\\xff\\xff\\x00\\xe0\" b\"\\x00\\x01\\x02\\x03\" b\"\\xfe\\xff\\xdd\\xe0\",\n            BytesIO(b\"\\xff\\xff\\x00\\xe0\" b\"\\x00\\x01\\x02\\x03\" b\"\\xfe\\xff\\xdd\\xe0\"),\n        ),\n    )\n    def test_little_endian_incorrect_data(self, data):\n        \"\"\"Writing pixel data not starting with an item tag raises.\"\"\"\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(\n            0x7FE00010,\n            \"OB\",\n            data,\n            is_undefined_length=True,\n        )\n        msg = (\n            r\"The \\(7FE0,0010\\) 'Pixel Data' element value hasn't been encapsulated \"\n            \"as required for a compressed transfer syntax - see \"\n            r\"pydicom.encaps.encapsulate\\(\\) for more information\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            write_data_element(self.fp, pixel_data)\n\n    @pytest.mark.parametrize(\n        \"data\",\n        (\n            b\"\\x00\\x00\\x00\\x00\" b\"\\x00\\x01\\x02\\x03\" b\"\\xff\\xfe\\xe0\\xdd\",\n            BytesIO(b\"\\x00\\x00\\x00\\x00\" b\"\\x00\\x01\\x02\\x03\" b\"\\xff\\xfe\\xe0\\xdd\"),\n        ),\n    )\n    def test_big_endian_incorrect_data(self, data):\n        \"\"\"Writing pixel data not starting with an item tag raises.\"\"\"\n        self.fp.is_little_endian = False\n        self.fp.is_implicit_VR = False\n        pixel_data = DataElement(\n            0x7FE00010,\n            \"OB\",\n            data,\n            is_undefined_length=True,\n        )\n        msg = (\n            r\"The \\(7FE0,0010\\) 'Pixel Data' element value hasn't been encapsulated \"\n            \"as required for a compressed transfer syntax - see \"\n            r\"pydicom.encaps.encapsulate\\(\\) for more information\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            write_data_element(self.fp, pixel_data)\n\n    def test_writing_to_gzip(self):\n        file_path = tempfile.NamedTemporaryFile(suffix=\".dcm\").name\n        ds = dcmread(rtplan_name)\n        import gzip\n\n        with gzip.open(file_path, \"w\") as fp:\n            ds.save_as(fp, enforce_file_format=True)\n        with gzip.open(file_path, \"r\") as fp:\n            ds_unzipped = dcmread(fp)\n            for elem_in, elem_out in zip(ds, ds_unzipped):\n                assert elem_in == elem_out\n\n    def test_writing_too_big_data_in_explicit_encoding(self):\n        \"\"\"Data too large to be written in explicit transfer syntax.\"\"\"\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = True\n        # make a multi-value larger than 64kB\n        single_value = b\"123456.789012345\"\n        large_value = b\"\\\\\".join([single_value] * 4500)\n        # can be written with implicit transfer syntax,\n        # where the length field is 4 bytes long\n        pixel_data = DataElement(\n            0x30040058, \"DS\", large_value, is_undefined_length=False\n        )\n        write_data_element(self.fp, pixel_data)\n        self.fp.seek(0)\n        ds = read_dataset(self.fp, True, True)\n        assert \"DS\" == ds[0x30040058].VR\n\n        self.fp = DicomBytesIO()\n        self.fp.is_little_endian = True\n        self.fp.is_implicit_VR = False\n\n        msg = (\n            r\"The value for the data element \\(3004,0058\\) exceeds the \"\n            r\"size of 64 kByte and cannot be written in an explicit \"\n            r\"transfer syntax. The data element VR is changed from \"\n            r\"'DS' to 'UN' to allow saving the data.\"\n        )\n\n        with pytest.warns(UserWarning, match=msg):\n            write_data_element(self.fp, pixel_data)\n        self.fp.seek(0)\n        ds = read_dataset(self.fp, False, True)\n        assert \"UN\" == ds[0x30040058].VR\n\n        # we expect the same behavior in Big Endian transfer syntax\n        self.fp = DicomBytesIO()\n        self.fp.is_little_endian = False\n        self.fp.is_implicit_VR = False\n        with pytest.warns(UserWarning, match=msg):\n            write_data_element(self.fp, pixel_data)\n        self.fp.seek(0)\n        ds = read_dataset(self.fp, False, False)\n        assert \"UN\" == ds[0x30040058].VR\n\n\ndef test_all_writers():\n    \"\"\"Test that the VR writer functions are complete\"\"\"\n    assert set(VR) == set(writers)\n\n\nclass TestWritingBufferedPixelData:\n    @pytest.mark.parametrize(\"bits_allocated\", (8, 16))\n    def test_writing_dataset_with_buffered_pixel_data(self, bits_allocated):\n        pixel_data = b\"\\x00\\x01\\x02\\x03\"\n\n        # Baseline\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        fp.is_implicit_VR = False\n\n        ds = Dataset()\n        ds.BitsAllocated = bits_allocated\n        ds.PixelData = pixel_data\n\n        ds.save_as(fp, implicit_vr=False, little_endian=True)\n\n        fp_buffered = DicomBytesIO()\n        fp_buffered.is_little_endian = True\n        fp_buffered.is_implicit_VR = False\n\n        ds_buffered = Dataset()\n        ds_buffered.BitsAllocated = bits_allocated\n        ds_buffered.PixelData = BytesIO(pixel_data)\n\n        ds_buffered.save_as(fp_buffered, implicit_vr=False, little_endian=True)\n\n        assert fp.getvalue() == fp_buffered.getvalue()\n\n    @pytest.mark.skipif(not HAVE_RESOURCE, reason=\"resource is unix only\")\n    @pytest.mark.parametrize(\"bits_allocated\", (8, 16))\n    def test_writing_dataset_with_buffered_pixel_data_reads_data_in_chunks(\n        self, bits_allocated\n    ):\n        KILOBYTE = 1000\n        MEGABYTE = KILOBYTE * 1000\n        FILE_SIZE = 50 * MEGABYTE\n\n        ds = Dataset()\n        ds.BitsAllocated = bits_allocated\n\n        with TemporaryFile(\"+wb\") as buffer, TemporaryFile(\"+wb\") as fp:\n            buffer.write(b\"\\x00\" * FILE_SIZE)\n            buffer.seek(0)\n\n            # take a snapshot of memory\n            baseline_memory_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n\n            # set the pixel data to the buffer\n            ds.PixelData = buffer\n            ds.save_as(fp, little_endian=True, implicit_vr=False)\n\n            memory_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss\n\n            # on MacOS, maxrss is in bytes. On unix, its in kilobytes\n            limit = 0\n            if sys.platform.startswith(\"linux\"):\n                # memory usage is in kilobytes\n                limit = (FILE_SIZE / 5 * 4) / KILOBYTE\n            elif sys.platform.startswith(\"darwin\"):\n                # memory usage is in bytes\n                limit = FILE_SIZE / 5 * 4\n            else:\n                pytest.skip(\"This test is not setup to run on this platform\")\n\n            # if we have successfully kept the PixelData out of memory, then our peak\n            #   memory usage # usage be less than prev peak + the size of the file\n            assert memory_usage < (baseline_memory_usage + limit)\n\n    @pytest.mark.parametrize(\"vr\", BUFFERABLE_VRS)\n    def test_all_supported_VRS_can_write_a_buffered_value(self, vr):\n        data = b\"\\x00\\x01\\x02\\x03\"\n        buffer = BytesIO(data)\n\n        fp = DicomBytesIO()\n        fp.is_little_endian = True\n        fp.is_implicit_VR = False\n\n        fn, _ = writers[cast(VR, vr)]\n        fn(fp, DataElement(\"PixelData\", vr, buffer))\n\n        assert fp.getvalue() == data\n\n    @pytest.mark.skipif(IS_WINDOWS, reason=\"TemporaryFile on Windows always readable\")\n    def test_saving_a_file_with_a_closed_file(self):\n        ds = Dataset()\n        ds.BitsAllocated = 8\n\n        with TemporaryFile(\"+wb\") as f:\n            ds.PixelData = f\n\n        with TemporaryFile(\"+wb\") as f:\n            msg = (\n                r\"Invalid buffer for \\(7FE0,0010\\) 'Pixel Data': the buffer has been \"\n                \"closed\"\n            )\n            with pytest.raises(ValueError, match=msg):\n                ds.save_as(f, little_endian=True, implicit_vr=True)\n\n\n@pytest.fixture\ndef use_future():\n    original = config._use_future\n    config._use_future = True\n    yield\n    config._use_future = original\n\n\nclass TestFuture:\n    def test_dcmwrite_write_like_original_raises(self, use_future):\n        ds = Dataset()\n        msg = (\n            \"'write_like_original' is no longer accepted as a positional \"\n            \"or keyword argument, use 'enforce_file_format' instead\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            dcmwrite(None, ds, write_like_original=True)\n\n        with pytest.raises(TypeError, match=msg):\n            dcmwrite(None, ds, write_like_original=False)\n\n        with pytest.raises(TypeError, match=msg):\n            dcmwrite(None, ds, False)\n\n        with pytest.raises(TypeError, match=msg):\n            dcmwrite(None, ds, True)\n\n    def test_dcmwrite_arg_kwarg_raises(self, use_future):\n        ds = Dataset()\n        msg = (\n            \"'write_like_original' is no longer accepted as a positional \"\n            \"or keyword argument, use 'enforce_file_format' instead\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            dcmwrite(None, ds, True, write_like_original=True)\n",
  "GT_file_code": {
    "modified_testcases/test_helpers.py": "# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n\"\"\"Helper functions for tests.\"\"\"\n\nimport warnings\nfrom contextlib import contextmanager\nfrom collections.abc import Generator\n\n\n@contextmanager\ndef assert_no_warning() -> Generator:\n    \"\"\"Assert that no warning is issued.\n    Any warning will be handled as an error.\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"error\")\n        yield\n"
  },
  "GT_src_dict": {
    "modified_testcases/test_helpers.py": {
      "assert_no_warning": {
        "code": "def assert_no_warning() -> Generator:\n    \"\"\"This context manager asserts that no warnings are issued during the block of code it encloses. It utilizes the `warnings` module to change the warning filter to treat all warnings as errors, ensuring that any warning raised will cause an exception. The function does not take any parameters and does not return a value, but raises an exception if a warning is encountered. It is important for testing scenarios where warning-free execution is required. This function relies on the `warnings` module, which is part of Python's standard library, and is specifically designed to handle warning control during runtime.\"\"\"\n    'Assert that no warning is issued.\\n    Any warning will be handled as an error.\\n    '\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        yield",
        "docstring": "This context manager asserts that no warnings are issued during the block of code it encloses. It utilizes the `warnings` module to change the warning filter to treat all warnings as errors, ensuring that any warning raised will cause an exception. The function does not take any parameters and does not return a value, but raises an exception if a warning is encountered. It is important for testing scenarios where warning-free execution is required. This function relies on the `warnings` module, which is part of Python's standard library, and is specifically designed to handle warning control during runtime.",
        "signature": "def assert_no_warning() -> Generator:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "call_tree": {
    "modified_testcases/test_filewriter.py:TestWriteFile:testRTPlan": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:testRTDose": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:testCT": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:testMR": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:testUnicode": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:testMultiPN": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:testJPEG2000": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:test_write_no_ts": {
      "modified_testcases/test_filewriter.py:TestWriteFile:compare_bytes": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteFile:test_write_deflated_retains_elements": {
      "modified_testcases/test_filewriter.py:as_assertable": {
        "modified_testcases/test_filewriter.py:as_assertable": {
          "[ignored_or_cut_off]": "..."
        }
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_empty_LO": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_DA": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_multi_DA": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_TM": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_multi_TM": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_DT": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_multi_DT": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_ascii_vr_with_padding": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:check_data_element": {
        "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_OB_odd": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_OD_implicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_OD_explicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_OL_implicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_OL_explicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_UC_implicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_UC_explicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_UR_implicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_UR_explicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteDataElement:test_write_UN_implicit_little": {
      "modified_testcases/test_filewriter.py:TestWriteDataElement:encode_element": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_ambiguous_element_in_sequence_explicit_using_attribute": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_ambiguous_element_in_sequence_explicit_using_index": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_ambiguous_element_in_sequence_implicit_using_attribute": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_ambiguous_element_in_sequence_implicit_using_index": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_ambiguous_element_sequence_implicit_nearest": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_ambiguous_element_sequence_explicit_nearest": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_pickle_deepcopy_implicit": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_pickle_deepcopy_explicit": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_pixel_repr_none_in_nearer_implicit": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:test_pixel_repr_none_in_further_implicit": {
      "modified_testcases/test_filewriter.py:TestCorrectAmbiguousVR:dataset_with_modality_lut_sequence": {}
    },
    "modified_testcases/test_filewriter.py:TestScratchWrite:testImpl_LE_deflen_write": {
      "modified_testcases/test_filewriter.py:TestScratchWrite:compare_write": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWriteNonStandard:test_ds_unchanged": {
      "modified_testcases/test_filewriter.py:TestWriteNonStandard:ensure_no_raw_data_elements": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteNonStandard:test_preamble_filemeta_dataset": {
      "modified_testcases/test_filewriter.py:TestWriteNonStandard:ensure_no_raw_data_elements": {}
    },
    "modified_testcases/test_filewriter.py:TestWriteNonStandard:test_read_write_identical": {
      "modified_testcases/test_filewriter.py:TestWriteNonStandard:compare_bytes": {
        "modified_testcases/test_filewriter.py:bytes_identical": {}
      }
    },
    "modified_testcases/test_filewriter.py:TestWritePN:test_single_byte_multi_charset_groups": {
      "modified_testcases/test_helpers.py:assert_no_warning": {}
    }
  },
  "PRD": "# PROJECT NAME: pydicom-test_filewriter\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 modified_testcases/\n    \u2514\u2500\u2500 test_helpers.py\n        \u2514\u2500\u2500 assert_no_warning\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is responsible for handling the serialization and writing of DICOM datasets, including their associated file metadata, while adhering to the DICOM standard. It provides functionality to encode and write datasets in various transfer syntaxes, such as implicit and explicit VR, and supports little-endian and big-endian formats. Key features include writing standard and non-standard file metadata, handling diverse data types (e.g., pixel data, text, dates, and private tags), and managing encoding for multi-character sets. The module resolves ambiguities in value representation (VR), maintains DICOM data integrity during writing processes, and ensures compliance with file format specifications. This capability simplifies generating and manipulating DICOM files for developers, enabling seamless integration with compliant medical imaging systems.\n\n## FILE 1: modified_testcases/test_helpers.py\n\n- FUNCTION NAME: assert_no_warning\n  - SIGNATURE: def assert_no_warning() -> Generator:\n  - DOCSTRING: \n```python\n\"\"\"\nThis context manager asserts that no warnings are issued during the block of code it encloses. It utilizes the `warnings` module to change the warning filter to treat all warnings as errors, ensuring that any warning raised will cause an exception. The function does not take any parameters and does not return a value, but raises an exception if a warning is encountered. It is important for testing scenarios where warning-free execution is required. This function relies on the `warnings` module, which is part of Python's standard library, and is specifically designed to handle warning control during runtime.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "modified_testcases/test_helpers.py": "\"\"\"Helper functions for tests.\"\"\"\nimport warnings\nfrom contextlib import contextmanager\nfrom collections.abc import Generator"
  }
}