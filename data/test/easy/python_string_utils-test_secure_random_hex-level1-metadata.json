{
  "dir_path": "/app/python_string_utils",
  "package_name": "python_string_utils",
  "sample_name": "python_string_utils-test_secure_random_hex",
  "src_dir": "string_utils/",
  "test_dir": "tests/",
  "test_file": "tests/test_secure_random_hex.py",
  "test_code": "from unittest import TestCase\n\nfrom string_utils import secure_random_hex\n\n\nclass SecureRandomHexTestCase(TestCase):\n    def test_throws_error_if_size_is_null(self):\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            secure_random_hex(None)\n\n        self.assertEqual(str(raised.exception), 'byte_count must be >= 1')\n\n    def test_throws_error_if_size_is_less_than_1(self):\n        msg = 'byte_count must be >= 1'\n\n        with self.assertRaises(ValueError) as raised:\n            secure_random_hex(-12)\n\n        self.assertEqual(str(raised.exception), msg)\n\n        with self.assertRaises(ValueError) as raised:\n            secure_random_hex(0)\n\n        self.assertEqual(str(raised.exception), msg)\n\n    def test_returns_random_hex(self):\n        sr = secure_random_hex(9)\n        self.assertEqual(len(sr), 18)\n        self.assertTrue(sr.isalnum())\n\n    def test_returns_different_string_on_each_call(self):\n        strings = [secure_random_hex(12) for _ in range(1000)]\n\n        self.assertEqual(len(strings), len(set(strings)))\n",
  "GT_file_code": {
    "string_utils/generation.py": "# -*- coding: utf-8 -*-\n\n# public api to export\n__all__ = [\n    'uuid',\n    'random_string',\n    'secure_random_hex',\n    'roman_range',\n]\n\nimport binascii\nimport os\nimport random\nimport string\nfrom typing import Generator\nfrom uuid import uuid4\n\nfrom .manipulation import roman_encode\n\n\ndef uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)\n\n\ndef random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out\n\n\ndef secure_random_hex(byte_count: int) -> str:\n    \"\"\"\n    Generates a random string using secure low level random generator (os.urandom).\n\n    **Bear in mind**: due to hex conversion, the returned string will have a size that is exactly\\\n    the double of the given `byte_count`.\n\n    *Example:*\n\n    >>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n    :param byte_count: Number of random bytes to generate\n    :type byte_count: int\n    :return: Hexadecimal string representation of generated random bytes\n    \"\"\"\n    if not isinstance(byte_count, int) or byte_count < 1:\n        raise ValueError('byte_count must be >= 1')\n\n    random_bytes = os.urandom(byte_count)\n    hex_bytes = binascii.hexlify(random_bytes)\n    hex_string = hex_bytes.decode()\n\n    return hex_string\n\n\ndef roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n\n    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)\n\n    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)\n\n    # checks each single argument value\n    validate(stop, 'stop')\n    validate(start, 'start')\n    validate(step, 'step', allow_negative=True)\n\n    # checks if the provided configuration leads to a feasible iteration with respect to boundaries or not\n    forward_exceed = step > 0 and (start > stop or start + step > stop)\n    backward_exceed = step < 0 and (start < stop or start + step < stop)\n    if forward_exceed or backward_exceed:\n        raise OverflowError('Invalid start/stop/step configuration')\n\n    return generate()\n"
  },
  "GT_src_dict": {
    "string_utils/generation.py": {
      "secure_random_hex": {
        "code": "def secure_random_hex(byte_count: int) -> str:\n    \"\"\"Generates a secure random hexadecimal string by using the low-level random generator `os.urandom`. The length of the returned string is exactly double the specified `byte_count` due to hex conversion.\n\nParameters:\n- byte_count (int): The number of random bytes to generate. Must be an integer greater than or equal to 1.\n\nReturns:\n- str: A hexadecimal string representation of the generated random bytes.\n\nRaises:\n- ValueError: If `byte_count` is not an integer or is less than 1.\n\nThis function utilizes the `os` and `binascii` modules from the Python Standard Library to ensure secure randomization and proper binary-to-hex conversion.\"\"\"\n    \"\\n    Generates a random string using secure low level random generator (os.urandom).\\n\\n    **Bear in mind**: due to hex conversion, the returned string will have a size that is exactly    the double of the given `byte_count`.\\n\\n    *Example:*\\n\\n    >>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\\n\\n    :param byte_count: Number of random bytes to generate\\n    :type byte_count: int\\n    :return: Hexadecimal string representation of generated random bytes\\n    \"\n    if not isinstance(byte_count, int) or byte_count < 1:\n        raise ValueError('byte_count must be >= 1')\n    random_bytes = os.urandom(byte_count)\n    hex_bytes = binascii.hexlify(random_bytes)\n    hex_string = hex_bytes.decode()\n    return hex_string",
        "docstring": "Generates a secure random hexadecimal string by using the low-level random generator `os.urandom`. The length of the returned string is exactly double the specified `byte_count` due to hex conversion.\n\nParameters:\n- byte_count (int): The number of random bytes to generate. Must be an integer greater than or equal to 1.\n\nReturns:\n- str: A hexadecimal string representation of the generated random bytes.\n\nRaises:\n- ValueError: If `byte_count` is not an integer or is less than 1.\n\nThis function utilizes the `os` and `binascii` modules from the Python Standard Library to ensure secure randomization and proper binary-to-hex conversion.",
        "signature": "def secure_random_hex(byte_count: int) -> str:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: python_string_utils-test_secure_random_hex\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 string_utils/\n    \u2514\u2500\u2500 generation.py\n        \u2514\u2500\u2500 secure_random_hex\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and ensure the reliable functionality of a utility responsible for generating secure random hexadecimal strings of a specified byte length. It provides essential capabilities, such as verifying proper error handling for invalid input (e.g., null or non-positive sizes) and confirming consistent generation of correctly formatted, unique hexadecimal strings on each invocation. By testing edge cases and core use cases, it ensures that the hexadecimal generation utility performs as expected, addressing developer needs for robust, secure random string generation in applications requiring unique identifiers or cryptographic operations. This contributes to system reliability by preventing errors and ensuring compliance with input validation requirements.\n\n## FILE 1: string_utils/generation.py\n\n- FUNCTION NAME: secure_random_hex\n  - SIGNATURE: def secure_random_hex(byte_count: int) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a secure random hexadecimal string by using the low-level random generator `os.urandom`. The length of the returned string is exactly double the specified `byte_count` due to hex conversion.\n\nParameters:\n- byte_count (int): The number of random bytes to generate. Must be an integer greater than or equal to 1.\n\nReturns:\n- str: A hexadecimal string representation of the generated random bytes.\n\nRaises:\n- ValueError: If `byte_count` is not an integer or is less than 1.\n\nThis function utilizes the `os` and `binascii` modules from the Python Standard Library to ensure secure randomization and proper binary-to-hex conversion.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "string_utils/generation.py": "__all__ = ['uuid', 'random_string', 'secure_random_hex', 'roman_range']\nimport binascii\nimport os\nimport random\nimport string\nfrom typing import Generator\nfrom uuid import uuid4\nfrom .manipulation import roman_encode\n\ndef uuid(as_hex: bool=False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n    if as_hex:\n        return uid.hex\n    return str(uid)\n\ndef random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n    return out\n\ndef roman_range(stop: int, start: int=1, step: int=1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n\n    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n        if allow_negative:\n            arg_value = abs(arg_value)\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)\n\n    def generate():\n        current = start\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n        yield roman_encode(current)\n    validate(stop, 'stop')\n    validate(start, 'start')\n    validate(step, 'step', allow_negative=True)\n    forward_exceed = step > 0 and (start > stop or start + step > stop)\n    backward_exceed = step < 0 and (start < stop or start + step < stop)\n    if forward_exceed or backward_exceed:\n        raise OverflowError('Invalid start/stop/step configuration')\n    return generate()"
  },
  "call_tree": {
    "tests/test_secure_random_hex.py:SecureRandomHexTestCase:test_returns_different_string_on_each_call": {
      "string_utils/generation.py:secure_random_hex": {}
    },
    "tests/test_secure_random_hex.py:SecureRandomHexTestCase:test_returns_random_hex": {
      "string_utils/generation.py:secure_random_hex": {}
    },
    "tests/test_secure_random_hex.py:SecureRandomHexTestCase:test_throws_error_if_size_is_less_than_1": {
      "string_utils/generation.py:secure_random_hex": {}
    },
    "tests/test_secure_random_hex.py:SecureRandomHexTestCase:test_throws_error_if_size_is_null": {
      "string_utils/generation.py:secure_random_hex": {}
    }
  }
}