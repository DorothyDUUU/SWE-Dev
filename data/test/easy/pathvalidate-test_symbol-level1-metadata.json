{
  "dir_path": "/app/pathvalidate",
  "package_name": "pathvalidate",
  "sample_name": "pathvalidate-test_symbol",
  "src_dir": "pathvalidate/",
  "test_dir": "test/",
  "test_file": "test/test_symbol.py",
  "test_code": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport itertools\n\nimport pytest\n\nfrom pathvalidate import (\n    ascii_symbols,\n    replace_symbol,\n    unprintable_ascii_chars,\n    validate_symbol,\n    validate_unprintable_char,\n)\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom ._common import alphanum_chars\n\n\nclass Test_validate_symbol:\n    VALID_CHARS = alphanum_chars\n    INVALID_CHARS = ascii_symbols\n\n    @pytest.mark.parametrize(\n        [\"value\"], [[\"abc\" + valid_char + \"hoge123\"] for valid_char in VALID_CHARS]\n    )\n    def test_normal(self, value):\n        validate_symbol(value)\n\n    @pytest.mark.parametrize([\"value\"], [[\"\u3042\u3044\u3046\u3048\u304a\"], [\"\u30b7\u30fc\u30c8\"]])\n    def test_normal_multibyte(self, value):\n        pytest.skip(\"TODO\")\n\n        validate_symbol(value)\n\n    @pytest.mark.parametrize(\n        [\"value\"],\n        [\n            [\"abc\" + invalid_char + \"hoge123\"]\n            for invalid_char in INVALID_CHARS + unprintable_ascii_chars\n        ],\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_symbol(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n\nclass Test_replace_symbol:\n    TARGET_CHARS = ascii_symbols\n    NOT_TARGET_CHARS = alphanum_chars\n    REPLACE_TEXT_LIST = [\"\", \"_\"]\n\n    @pytest.mark.parametrize(\n        [\"value\", \"replace_text\", \"expected\"],\n        [\n            [\"A\" + c + \"B\", rep, \"A\" + rep + \"B\"]\n            for c, rep in itertools.product(TARGET_CHARS, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [\"A\" + c + \"B\", rep, \"A\" + c + \"B\"]\n            for c, rep in itertools.product(NOT_TARGET_CHARS, REPLACE_TEXT_LIST)\n        ]\n        + [[\"\", \"\", \"\"]],\n    )\n    def test_normal(self, value, replace_text, expected):\n        assert replace_symbol(value, replace_text) == expected\n\n    @pytest.mark.parametrize(\n        [\"value\", \"exclude_symbols\", \"expected\"],\n        [\n            [\"/tmp/h!o|g$e.txt\", [\"/\", \".\"], \"/tmp/hoge.txt\"],\n            [\"/tmp/h!o|g$e.txt\", [], \"tmphogetxt\"],\n            [\"/tmp/h!o|g$e.txt\", [\"n\", \"o\", \"p\"], \"tmphogetxt\"],\n        ],\n    )\n    def test_normal_exclude_symbols(self, value, exclude_symbols, expected):\n        assert replace_symbol(value, exclude_symbols=exclude_symbols) == expected\n\n    @pytest.mark.parametrize(\n        [\"value\", \"replace_text\", \"is_replace_consecutive_chars\", \"is_strip\", \"expected\"],\n        [\n            [\"!a##b$$$c((((d]]]])\", \"_\", True, True, \"a_b_c_d\"],\n            [\"!a##b$$$c((((d]]]])\", \"_\", True, False, \"_a_b_c_d_\"],\n            [\"!a##b$$$c((((d]]]])\", \"_\", False, True, \"a__b___c____d\"],\n            [\"!a##b$$$c((((d]]]])\", \"_\", False, False, \"_a__b___c____d_____\"],\n        ],\n    )\n    def test_normal_consecutive(\n        self, value, replace_text, is_replace_consecutive_chars, is_strip, expected\n    ):\n        assert (\n            replace_symbol(\n                value,\n                replace_text,\n                is_replace_consecutive_chars=is_replace_consecutive_chars,\n                is_strip=is_strip,\n            )\n            == expected\n        )\n\n    @pytest.mark.parametrize(\n        [\"value\", \"expected\"],\n        [\n            [None, TypeError],\n            [1, TypeError],\n            [True, TypeError],\n        ],\n    )\n    def test_abnormal(self, value, expected):\n        with pytest.raises(expected):\n            replace_symbol(value)\n\n\nclass Test_validate_unprintable_char:\n    VALID_CHARS = alphanum_chars\n    INVALID_CHARS = unprintable_ascii_chars\n\n    @pytest.mark.parametrize(\n        [\"value\"], [[\"abc\" + valid_char + \"hoge123\"] for valid_char in VALID_CHARS]\n    )\n    def test_normal(self, value):\n        validate_unprintable_char(value)\n\n    @pytest.mark.parametrize([\"value\"], [[\"\u3042\u3044\u3046\u3048\u304a\"], [\"\u30b7\u30fc\u30c8\"]])\n    def test_normal_multibyte(self, value):\n        pytest.skip(\"TODO\")\n\n        validate_unprintable_char(value)\n\n    @pytest.mark.parametrize(\n        [\"value\"],\n        [\n            [\"abc\" + invalid_char + \"hoge123\"]\n            for invalid_char in INVALID_CHARS + unprintable_ascii_chars\n        ],\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_unprintable_char(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n",
  "GT_file_code": {
    "pathvalidate/_symbol.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport re\nfrom typing import Sequence\n\nfrom ._common import ascii_symbols, to_str, unprintable_ascii_chars\nfrom .error import InvalidCharError\n\n\n__RE_SYMBOL = re.compile(\n    \"[{}]\".format(re.escape(\"\".join(ascii_symbols + unprintable_ascii_chars))), re.UNICODE\n)\n\n\ndef validate_symbol(text: str) -> None:\n    \"\"\"\n    Verifying whether symbol(s) included in the ``text`` or not.\n\n    Args:\n        text:\n            Input text to validate.\n\n    Raises:\n        ValidationError (ErrorReason.INVALID_CHARACTER):\n            If symbol(s) included in the ``text``.\n    \"\"\"\n\n    match_list = __RE_SYMBOL.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f\"invalid symbols found: {match_list}\")\n\n\ndef replace_symbol(\n    text: str,\n    replacement_text: str = \"\",\n    exclude_symbols: Sequence[str] = [],\n    is_replace_consecutive_chars: bool = False,\n    is_strip: bool = False,\n) -> str:\n    \"\"\"\n    Replace all of the symbols in the ``text``.\n\n    Args:\n        text:\n            Input text.\n        replacement_text:\n            Replacement text.\n        exclude_symbols:\n            Symbols that were excluded from the replacement.\n        is_replace_consecutive_chars:\n            If |True|, replace consecutive multiple ``replacement_text`` characters\n            to a single character.\n        is_strip:\n            If |True|, strip ``replacement_text`` from the beginning/end of the replacement text.\n\n    Returns:\n        A replacement string.\n\n    Example:\n\n        :ref:`example-sanitize-symbol`\n    \"\"\"\n\n    if exclude_symbols:\n        regexp = re.compile(\n            \"[{}]\".format(\n                re.escape(\n                    \"\".join(set(ascii_symbols + unprintable_ascii_chars) - set(exclude_symbols))\n                )\n            ),\n            re.UNICODE,\n        )\n    else:\n        regexp = __RE_SYMBOL\n\n    try:\n        new_text = regexp.sub(replacement_text, to_str(text))\n    except TypeError:\n        raise TypeError(\"text must be a string\")\n\n    if not replacement_text:\n        return new_text\n\n    if is_replace_consecutive_chars:\n        new_text = re.sub(f\"{re.escape(replacement_text)}+\", replacement_text, new_text)\n\n    if is_strip:\n        new_text = new_text.strip(replacement_text)\n\n    return new_text\n",
    "pathvalidate/_common.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport ntpath\nimport platform\nimport re\nimport string\nimport sys\nfrom pathlib import PurePath\nfrom typing import Any, List, Optional\n\nfrom ._const import Platform\nfrom ._types import PathType, PlatformType\n\n\n_re_whitespaces = re.compile(r\"^[\\s]+$\")\n\n\ndef validate_pathtype(\n    text: PathType, allow_whitespaces: bool = False, error_msg: Optional[str] = None\n) -> None:\n    from .error import ErrorReason, ValidationError\n\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n\n    raise TypeError(f\"text must be a string: actual={type(text)}\")\n\n\ndef to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n\n    return name\n\n\ndef is_nt_abspath(value: str) -> bool:\n    ver_info = sys.version_info[:2]\n    if ver_info <= (3, 10):\n        if value.startswith(\"\\\\\\\\\"):\n            return True\n    elif ver_info >= (3, 13):\n        return ntpath.isabs(value)\n\n    drive, _tail = ntpath.splitdrive(value)\n\n    return ntpath.isabs(value) and len(drive) > 0\n\n\ndef is_null_string(value: Any) -> bool:\n    if value is None:\n        return True\n\n    try:\n        return len(value.strip()) == 0\n    except AttributeError:\n        return False\n\n\ndef _is_not_null_string(value: Any) -> bool:\n    try:\n        return len(value.strip()) > 0\n    except AttributeError:\n        return False\n\n\ndef _get_unprintable_ascii_chars() -> List[str]:\n    return [chr(c) for c in range(128) if chr(c) not in string.printable]\n\n\nunprintable_ascii_chars = tuple(_get_unprintable_ascii_chars())\n\n\ndef _get_ascii_symbols() -> List[str]:\n    symbol_list: List[str] = []\n\n    for i in range(128):\n        c = chr(i)\n\n        if c in unprintable_ascii_chars or c in string.digits + string.ascii_letters:\n            continue\n\n        symbol_list.append(c)\n\n    return symbol_list\n\n\nascii_symbols = tuple(_get_ascii_symbols())\n\n__RE_UNPRINTABLE_CHARS = re.compile(\n    \"[{}]\".format(re.escape(\"\".join(unprintable_ascii_chars))), re.UNICODE\n)\n__RE_ANSI_ESCAPE = re.compile(\n    r\"(?:\\x1B[@-Z\\\\-_]|[\\x80-\\x9A\\x9C-\\x9F]|(?:\\x1B\\[|\\x9B)[0-?]*[ -/]*[@-~])\"\n)\n\n\ndef validate_unprintable_char(text: str) -> None:\n    from .error import InvalidCharError\n\n    match_list = __RE_UNPRINTABLE_CHARS.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f\"unprintable character found: {match_list}\")\n\n\ndef replace_unprintable_char(text: str, replacement_text: str = \"\") -> str:\n    try:\n        return __RE_UNPRINTABLE_CHARS.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError(\"text must be a string\")\n\n\ndef replace_ansi_escape(text: str, replacement_text: str = \"\") -> str:\n    try:\n        return __RE_ANSI_ESCAPE.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError(\"text must be a string\")\n\n\ndef normalize_platform(name: Optional[PlatformType]) -> Platform:\n    if isinstance(name, Platform):\n        return name\n\n    if not name:\n        return Platform.UNIVERSAL\n\n    platform_str = name.strip().casefold()\n\n    if platform_str == \"posix\":\n        return Platform.POSIX\n\n    if platform_str == \"auto\":\n        platform_str = platform.system().casefold()\n\n    if platform_str in [\"linux\"]:\n        return Platform.LINUX\n\n    if platform_str and platform_str.startswith(\"win\"):\n        return Platform.WINDOWS\n\n    if platform_str in [\"mac\", \"macos\", \"darwin\"]:\n        return Platform.MACOS\n\n    return Platform.UNIVERSAL\n\n\ndef findall_to_str(match: List[Any]) -> str:\n    return \", \".join([repr(text) for text in match])\n\n\ndef truncate_str(text: str, encoding: str, max_bytes: int) -> str:\n    str_bytes = text.encode(encoding)\n    str_bytes = str_bytes[:max_bytes]\n    # last char might be malformed, ignore it\n    return str_bytes.decode(encoding, \"ignore\")\n",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport enum\nfrom typing import Dict, Optional\n\nfrom ._const import Platform\n\n\ndef _to_error_code(code: int) -> str:\n    return f\"PV{code:04d}\"\n\n\nclass ErrorAttrKey:\n    BYTE_COUNT = \"byte_count\"\n    DESCRIPTION = \"description\"\n    FS_ENCODING = \"fs_encoding\"\n    PLATFORM = \"platform\"\n    REASON = \"reason\"\n    RESERVED_NAME = \"reserved_name\"\n    REUSABLE_NAME = \"reusable_name\"\n\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n\n    NULL_NAME = (_to_error_code(1001), \"NULL_NAME\", \"the value must not be an empty string\")\n    RESERVED_NAME = (\n        _to_error_code(1002),\n        \"RESERVED_NAME\",\n        \"found a reserved name by a platform\",\n    )\n    INVALID_CHARACTER = (\n        _to_error_code(1100),\n        \"INVALID_CHARACTER\",\n        \"invalid characters found\",\n    )\n    INVALID_LENGTH = (\n        _to_error_code(1101),\n        \"INVALID_LENGTH\",\n        \"found an invalid string length\",\n    )\n    FOUND_ABS_PATH = (\n        _to_error_code(1200),\n        \"FOUND_ABS_PATH\",\n        \"found an absolute path where must be a relative path\",\n    )\n    MALFORMED_ABS_PATH = (\n        _to_error_code(1201),\n        \"MALFORMED_ABS_PATH\",\n        \"found a malformed absolute path\",\n    )\n    INVALID_AFTER_SANITIZE = (\n        _to_error_code(2000),\n        \"INVALID_AFTER_SANITIZE\",\n        \"found invalid value after sanitizing\",\n    )\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f\"[{self.__code}] {self.__description}\"\n\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def reason(self) -> ErrorReason:\n        \"\"\"\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\n        \"\"\"\n        return self.__reason\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f\"{ErrorAttrKey.REASON} must be specified\")\n\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, \"\")\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n\n        slog: Dict[str, str] = {\n            \"code\": self.reason.code,\n            ErrorAttrKey.DESCRIPTION: self.reason.description,\n        }\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n\n        if self.platform:\n            item_list.append(f\"{ErrorAttrKey.PLATFORM}={self.platform.value}\")\n        if self.description:\n            item_list.append(f\"{ErrorAttrKey.DESCRIPTION}={self.description}\")\n        if self.__reusable_name is not None:\n            item_list.append(f\"{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}\")\n        if self.__fs_encoding:\n            item_list.append(f\"{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}\")\n        if self.__byte_count is not None:\n            item_list.append(f\"{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}\")\n\n        if item_list:\n            header += \": \"\n\n        return header + \", \".join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n\n        super().__init__(args, **kwargs)\n\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n\n        super().__init__(args, **kwargs)\n"
  },
  "GT_src_dict": {
    "pathvalidate/_symbol.py": {
      "validate_symbol": {
        "code": "def validate_symbol(text: str) -> None:\n    \"\"\"Verifies the presence of invalid symbols in the given text.\n\nArgs:\n    text (str): The input text to validate for invalid symbols.\n\nRaises:\n    InvalidCharError: If any invalid symbol(s) are found in the `text`.\n\nDependencies:\n    - __RE_SYMBOL: A regular expression compiled from a combination of `ascii_symbols`\n      and `unprintable_ascii_chars`, defined as a global constant. This regex is used to\n      detect invalid characters in the input text.\n    - to_str: A function imported from `._common` that ensures the input is treated as a string.\"\"\"\n    '\\n    Verifying whether symbol(s) included in the ``text`` or not.\\n\\n    Args:\\n        text:\\n            Input text to validate.\\n\\n    Raises:\\n        ValidationError (ErrorReason.INVALID_CHARACTER):\\n            If symbol(s) included in the ``text``.\\n    '\n    match_list = __RE_SYMBOL.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f'invalid symbols found: {match_list}')",
        "docstring": "Verifies the presence of invalid symbols in the given text.\n\nArgs:\n    text (str): The input text to validate for invalid symbols.\n\nRaises:\n    InvalidCharError: If any invalid symbol(s) are found in the `text`.\n\nDependencies:\n    - __RE_SYMBOL: A regular expression compiled from a combination of `ascii_symbols`\n      and `unprintable_ascii_chars`, defined as a global constant. This regex is used to\n      detect invalid characters in the input text.\n    - to_str: A function imported from `._common` that ensures the input is treated as a string.",
        "signature": "def validate_symbol(text: str) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "replace_symbol": {
        "code": "def replace_symbol(text: str, replacement_text: str='', exclude_symbols: Sequence[str]=[], is_replace_consecutive_chars: bool=False, is_strip: bool=False) -> str:\n    \"\"\"Replace all specified symbols in the given text with a replacement string.\n\nThis function utilizes regular expressions to identify symbols based on predefined criteria, specifically those defined in the `ascii_symbols` and `unprintable_ascii_chars` constants imported from the `_common` module. The symbols to exclude from replacement can be specified through the `exclude_symbols` parameter. If `is_replace_consecutive_chars` is set to `True`, consecutive occurrences of the `replacement_text` will be condensed into a single instance. If `is_strip` is `True`, leading and trailing occurrences of the `replacement_text` will be removed from the result.\n\nArgs:\n    text (str): The input string where symbols will be replaced.\n    replacement_text (str, optional): The string to replace symbols with; defaults to an empty string.\n    exclude_symbols (Sequence[str], optional): A list of symbols that will not be replaced.\n    is_replace_consecutive_chars (bool, optional): If True, consecutive replacement_text occurrences are reduced to one; defaults to False.\n    is_strip (bool, optional): If True, remove leading and trailing replacement_text from the result; defaults to False.\n\nReturns:\n    str: The modified string with symbols replaced according to the specified parameters.\n\nRaises:\n    TypeError: If the input text is not a string.\"\"\"\n    '\\n    Replace all of the symbols in the ``text``.\\n\\n    Args:\\n        text:\\n            Input text.\\n        replacement_text:\\n            Replacement text.\\n        exclude_symbols:\\n            Symbols that were excluded from the replacement.\\n        is_replace_consecutive_chars:\\n            If |True|, replace consecutive multiple ``replacement_text`` characters\\n            to a single character.\\n        is_strip:\\n            If |True|, strip ``replacement_text`` from the beginning/end of the replacement text.\\n\\n    Returns:\\n        A replacement string.\\n\\n    Example:\\n\\n        :ref:`example-sanitize-symbol`\\n    '\n    if exclude_symbols:\n        regexp = re.compile('[{}]'.format(re.escape(''.join(set(ascii_symbols + unprintable_ascii_chars) - set(exclude_symbols)))), re.UNICODE)\n    else:\n        regexp = __RE_SYMBOL\n    try:\n        new_text = regexp.sub(replacement_text, to_str(text))\n    except TypeError:\n        raise TypeError('text must be a string')\n    if not replacement_text:\n        return new_text\n    if is_replace_consecutive_chars:\n        new_text = re.sub(f'{re.escape(replacement_text)}+', replacement_text, new_text)\n    if is_strip:\n        new_text = new_text.strip(replacement_text)\n    return new_text",
        "docstring": "Replace all specified symbols in the given text with a replacement string.\n\nThis function utilizes regular expressions to identify symbols based on predefined criteria, specifically those defined in the `ascii_symbols` and `unprintable_ascii_chars` constants imported from the `_common` module. The symbols to exclude from replacement can be specified through the `exclude_symbols` parameter. If `is_replace_consecutive_chars` is set to `True`, consecutive occurrences of the `replacement_text` will be condensed into a single instance. If `is_strip` is `True`, leading and trailing occurrences of the `replacement_text` will be removed from the result.\n\nArgs:\n    text (str): The input string where symbols will be replaced.\n    replacement_text (str, optional): The string to replace symbols with; defaults to an empty string.\n    exclude_symbols (Sequence[str], optional): A list of symbols that will not be replaced.\n    is_replace_consecutive_chars (bool, optional): If True, consecutive replacement_text occurrences are reduced to one; defaults to False.\n    is_strip (bool, optional): If True, remove leading and trailing replacement_text from the result; defaults to False.\n\nReturns:\n    str: The modified string with symbols replaced according to the specified parameters.\n\nRaises:\n    TypeError: If the input text is not a string.",
        "signature": "def replace_symbol(text: str, replacement_text: str='', exclude_symbols: Sequence[str]=[], is_replace_consecutive_chars: bool=False, is_strip: bool=False) -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "pathvalidate/_common.py": {
      "validate_unprintable_char": {
        "code": "def validate_unprintable_char(text: str) -> None:\n    \"\"\"Raises an `InvalidCharError` if the given `text` contains any unprintable ASCII characters.\n\nParameters:\n    text (str): The string to validate for unprintable characters.\n\nReturns:\n    None\n\nRaises:\n    InvalidCharError: If any unprintable character is found in `text`.\n\nThis function utilizes the `__RE_UNPRINTABLE_CHARS` regular expression, which is defined in the context of this module to match unprintable ASCII characters. It calls the helper function `to_str(text)` to ensure that the input is converted to a string before validation.\"\"\"\n    from .error import InvalidCharError\n    match_list = __RE_UNPRINTABLE_CHARS.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f'unprintable character found: {match_list}')",
        "docstring": "Raises an `InvalidCharError` if the given `text` contains any unprintable ASCII characters.\n\nParameters:\n    text (str): The string to validate for unprintable characters.\n\nReturns:\n    None\n\nRaises:\n    InvalidCharError: If any unprintable character is found in `text`.\n\nThis function utilizes the `__RE_UNPRINTABLE_CHARS` regular expression, which is defined in the context of this module to match unprintable ASCII characters. It calls the helper function `to_str(text)` to ensure that the input is converted to a string before validation.",
        "signature": "def validate_unprintable_char(text: str) -> None:",
        "type": "Function",
        "class_signature": null
      }
    },
    "pathvalidate/error.py": {
      "ValidationError.reason": {
        "code": "    def reason(self) -> ErrorReason:\n        \"\"\"@property\ndef reason(self) -> ErrorReason:\"\"\"\n        '\\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\\n        '\n        return self.__reason",
        "docstring": "@property\ndef reason(self) -> ErrorReason:",
        "signature": "def reason(self) -> ErrorReason:",
        "type": "Method",
        "class_signature": "class ValidationError(ValueError):"
      }
    }
  },
  "dependency_dict": {
    "pathvalidate/_symbol.py:validate_symbol": {
      "pathvalidate/_common.py": {
        "to_str": {
          "code": "def to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n    return name",
          "docstring": "",
          "signature": "def to_str(name: PathType) -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "pathvalidate/error.py": {
        "InvalidCharError.__init__": {
          "code": "    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)",
          "docstring": "",
          "signature": "def __init__(self, *args, **kwargs) -> None:",
          "type": "Method",
          "class_signature": "class InvalidCharError(ValidationError):"
        }
      }
    },
    "pathvalidate/_symbol.py:replace_symbol": {
      "pathvalidate/_common.py": {
        "to_str": {
          "code": "def to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n    return name",
          "docstring": "",
          "signature": "def to_str(name: PathType) -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pathvalidate/_common.py:validate_unprintable_char": {
      "pathvalidate/_common.py": {
        "to_str": {
          "code": "def to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n    return name",
          "docstring": "",
          "signature": "def to_str(name: PathType) -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "pathvalidate/error.py": {
        "InvalidCharError.__init__": {
          "code": "    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)",
          "docstring": "",
          "signature": "def __init__(self, *args, **kwargs) -> None:",
          "type": "Method",
          "class_signature": "class InvalidCharError(ValidationError):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: pathvalidate-test_symbol\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pathvalidate/\n    \u251c\u2500\u2500 _common.py\n    \u2502   \u2514\u2500\u2500 validate_unprintable_char\n    \u251c\u2500\u2500 _symbol.py\n    \u2502   \u251c\u2500\u2500 replace_symbol\n    \u2502   \u2514\u2500\u2500 validate_symbol\n    \u2514\u2500\u2500 error.py\n        \u2514\u2500\u2500 ValidationError.reason\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module provides functionality for validating and sanitizing strings by ensuring proper handling of symbols and unprintable characters. It enables developers to validate strings against a set of acceptable characters, identify invalid or non-printable characters, and replace unwanted symbols with customizable alternatives while supporting options like consecutive replacement and trimming. By addressing issues related to malformed or non-compliant strings, the module helps developers enforce naming conventions, enhance data integrity, and maintain compatibility with file systems or external systems that impose character restrictions. It streamlines the process of managing string data for safe and consistent usage in applications.\n\n## FILE 1: pathvalidate/_symbol.py\n\n- FUNCTION NAME: replace_symbol\n  - SIGNATURE: def replace_symbol(text: str, replacement_text: str='', exclude_symbols: Sequence[str]=[], is_replace_consecutive_chars: bool=False, is_strip: bool=False) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nReplace all specified symbols in the given text with a replacement string.\n\nThis function utilizes regular expressions to identify symbols based on predefined criteria, specifically those defined in the `ascii_symbols` and `unprintable_ascii_chars` constants imported from the `_common` module. The symbols to exclude from replacement can be specified through the `exclude_symbols` parameter. If `is_replace_consecutive_chars` is set to `True`, consecutive occurrences of the `replacement_text` will be condensed into a single instance. If `is_strip` is `True`, leading and trailing occurrences of the `replacement_text` will be removed from the result.\n\nArgs:\n    text (str): The input string where symbols will be replaced.\n    replacement_text (str, optional): The string to replace symbols with; defaults to an empty string.\n    exclude_symbols (Sequence[str], optional): A list of symbols that will not be replaced.\n    is_replace_consecutive_chars (bool, optional): If True, consecutive replacement_text occurrences are reduced to one; defaults to False.\n    is_strip (bool, optional): If True, remove leading and trailing replacement_text from the result; defaults to False.\n\nReturns:\n    str: The modified string with symbols replaced according to the specified parameters.\n\nRaises:\n    TypeError: If the input text is not a string.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n\n- FUNCTION NAME: validate_symbol\n  - SIGNATURE: def validate_symbol(text: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nVerifies the presence of invalid symbols in the given text.\n\nArgs:\n    text (str): The input text to validate for invalid symbols.\n\nRaises:\n    InvalidCharError: If any invalid symbol(s) are found in the `text`.\n\nDependencies:\n    - __RE_SYMBOL: A regular expression compiled from a combination of `ascii_symbols`\n      and `unprintable_ascii_chars`, defined as a global constant. This regex is used to\n      detect invalid characters in the input text.\n    - to_str: A function imported from `._common` that ensures the input is treated as a string.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/error.py:InvalidCharError:__init__\n\n## FILE 2: pathvalidate/_common.py\n\n- FUNCTION NAME: validate_unprintable_char\n  - SIGNATURE: def validate_unprintable_char(text: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nRaises an `InvalidCharError` if the given `text` contains any unprintable ASCII characters.\n\nParameters:\n    text (str): The string to validate for unprintable characters.\n\nReturns:\n    None\n\nRaises:\n    InvalidCharError: If any unprintable character is found in `text`.\n\nThis function utilizes the `__RE_UNPRINTABLE_CHARS` regular expression, which is defined in the context of this module to match unprintable ASCII characters. It calls the helper function `to_str(text)` to ensure that the input is converted to a string before validation.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/error.py:InvalidCharError:__init__\n\n## FILE 3: pathvalidate/error.py\n\n- CLASS METHOD: ValidationError.reason\n  - CLASS SIGNATURE: class ValidationError(ValueError):\n  - SIGNATURE: def reason(self) -> ErrorReason:\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef reason(self) -> ErrorReason:\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pathvalidate/_symbol.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport re\nfrom typing import Sequence\nfrom ._common import ascii_symbols, to_str, unprintable_ascii_chars\nfrom .error import InvalidCharError\n__RE_SYMBOL = re.compile('[{}]'.format(re.escape(''.join(ascii_symbols + unprintable_ascii_chars))), re.UNICODE)",
    "pathvalidate/_common.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport ntpath\nimport platform\nimport re\nimport string\nimport sys\nfrom pathlib import PurePath\nfrom typing import Any, List, Optional\nfrom ._const import Platform\nfrom ._types import PathType, PlatformType\n_re_whitespaces = re.compile('^[\\\\s]+$')\n\ndef validate_pathtype(text: PathType, allow_whitespaces: bool=False, error_msg: Optional[str]=None) -> None:\n    from .error import ErrorReason, ValidationError\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n    raise TypeError(f'text must be a string: actual={type(text)}')\n\ndef to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n    return name\n\ndef is_nt_abspath(value: str) -> bool:\n    ver_info = sys.version_info[:2]\n    if ver_info <= (3, 10):\n        if value.startswith('\\\\\\\\'):\n            return True\n    elif ver_info >= (3, 13):\n        return ntpath.isabs(value)\n    drive, _tail = ntpath.splitdrive(value)\n    return ntpath.isabs(value) and len(drive) > 0\n\ndef is_null_string(value: Any) -> bool:\n    if value is None:\n        return True\n    try:\n        return len(value.strip()) == 0\n    except AttributeError:\n        return False\n\ndef _is_not_null_string(value: Any) -> bool:\n    try:\n        return len(value.strip()) > 0\n    except AttributeError:\n        return False\n\ndef _get_unprintable_ascii_chars() -> List[str]:\n    return [chr(c) for c in range(128) if chr(c) not in string.printable]\nunprintable_ascii_chars = tuple(_get_unprintable_ascii_chars())\n\ndef _get_ascii_symbols() -> List[str]:\n    symbol_list: List[str] = []\n    for i in range(128):\n        c = chr(i)\n        if c in unprintable_ascii_chars or c in string.digits + string.ascii_letters:\n            continue\n        symbol_list.append(c)\n    return symbol_list\nascii_symbols = tuple(_get_ascii_symbols())\n__RE_UNPRINTABLE_CHARS = re.compile('[{}]'.format(re.escape(''.join(unprintable_ascii_chars))), re.UNICODE)\n__RE_ANSI_ESCAPE = re.compile('(?:\\\\x1B[@-Z\\\\\\\\-_]|[\\\\x80-\\\\x9A\\\\x9C-\\\\x9F]|(?:\\\\x1B\\\\[|\\\\x9B)[0-?]*[ -/]*[@-~])')\n\ndef replace_unprintable_char(text: str, replacement_text: str='') -> str:\n    try:\n        return __RE_UNPRINTABLE_CHARS.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError('text must be a string')\n\ndef replace_ansi_escape(text: str, replacement_text: str='') -> str:\n    try:\n        return __RE_ANSI_ESCAPE.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError('text must be a string')\n\ndef normalize_platform(name: Optional[PlatformType]) -> Platform:\n    if isinstance(name, Platform):\n        return name\n    if not name:\n        return Platform.UNIVERSAL\n    platform_str = name.strip().casefold()\n    if platform_str == 'posix':\n        return Platform.POSIX\n    if platform_str == 'auto':\n        platform_str = platform.system().casefold()\n    if platform_str in ['linux']:\n        return Platform.LINUX\n    if platform_str and platform_str.startswith('win'):\n        return Platform.WINDOWS\n    if platform_str in ['mac', 'macos', 'darwin']:\n        return Platform.MACOS\n    return Platform.UNIVERSAL\n\ndef findall_to_str(match: List[Any]) -> str:\n    return ', '.join([repr(text) for text in match])\n\ndef truncate_str(text: str, encoding: str, max_bytes: int) -> str:\n    str_bytes = text.encode(encoding)\n    str_bytes = str_bytes[:max_bytes]\n    return str_bytes.decode(encoding, 'ignore')",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport enum\nfrom typing import Dict, Optional\nfrom ._const import Platform\n\ndef _to_error_code(code: int) -> str:\n    return f'PV{code:04d}'\n\nclass ErrorAttrKey:\n    BYTE_COUNT = 'byte_count'\n    DESCRIPTION = 'description'\n    FS_ENCODING = 'fs_encoding'\n    PLATFORM = 'platform'\n    REASON = 'reason'\n    RESERVED_NAME = 'reserved_name'\n    REUSABLE_NAME = 'reusable_name'\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n    NULL_NAME = (_to_error_code(1001), 'NULL_NAME', 'the value must not be an empty string')\n    RESERVED_NAME = (_to_error_code(1002), 'RESERVED_NAME', 'found a reserved name by a platform')\n    INVALID_CHARACTER = (_to_error_code(1100), 'INVALID_CHARACTER', 'invalid characters found')\n    INVALID_LENGTH = (_to_error_code(1101), 'INVALID_LENGTH', 'found an invalid string length')\n    FOUND_ABS_PATH = (_to_error_code(1200), 'FOUND_ABS_PATH', 'found an absolute path where must be a relative path')\n    MALFORMED_ABS_PATH = (_to_error_code(1201), 'MALFORMED_ABS_PATH', 'found a malformed absolute path')\n    INVALID_AFTER_SANITIZE = (_to_error_code(2000), 'INVALID_AFTER_SANITIZE', 'found invalid value after sanitizing')\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f'[{self.__code}] {self.__description}'\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f'{ErrorAttrKey.REASON} must be specified')\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, '')\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n        slog: Dict[str, str] = {'code': self.reason.code, ErrorAttrKey.DESCRIPTION: self.reason.description}\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n        if self.platform:\n            item_list.append(f'{ErrorAttrKey.PLATFORM}={self.platform.value}')\n        if self.description:\n            item_list.append(f'{ErrorAttrKey.DESCRIPTION}={self.description}')\n        if self.__reusable_name is not None:\n            item_list.append(f'{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}')\n        if self.__fs_encoding:\n            item_list.append(f'{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}')\n        if self.__byte_count is not None:\n            item_list.append(f'{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}')\n        if item_list:\n            header += ': '\n        return header + ', '.join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n        super().__init__(args, **kwargs)\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n        super().__init__(args, **kwargs)\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n        super().__init__(args, **kwargs)\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n        super().__init__(args, **kwargs)"
  },
  "call_tree": {
    "test/test_symbol.py:Test_validate_symbol:test_normal": {
      "pathvalidate/_symbol.py:validate_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_validate_symbol:test_exception_invalid_char": {
      "pathvalidate/_symbol.py:validate_symbol": {
        "pathvalidate/_common.py:to_str": {},
        "pathvalidate/error.py:InvalidCharError:__init__": {
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      },
      "pathvalidate/error.py:ValidationError:reason": {}
    },
    "test/test_symbol.py:Test_replace_symbol:test_normal": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_replace_symbol:test_normal_exclude_symbols": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_replace_symbol:test_normal_consecutive": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_replace_symbol:test_abnormal": {
      "pathvalidate/_symbol.py:replace_symbol": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_validate_unprintable_char:test_normal": {
      "pathvalidate/_common.py:validate_unprintable_char": {
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_symbol.py:Test_validate_unprintable_char:test_exception_invalid_char": {
      "pathvalidate/_common.py:validate_unprintable_char": {
        "pathvalidate/_common.py:to_str": {},
        "pathvalidate/error.py:InvalidCharError:__init__": {
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      },
      "pathvalidate/error.py:ValidationError:reason": {}
    }
  }
}