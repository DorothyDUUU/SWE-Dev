{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_type_constant",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/type_annotations/test_type_constant.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\n\nclass TestTypeConstant:\n    def setup_method(self) -> None:\n        self.result = TypeConstant(\"value\")\n\n    def test_init(self) -> None:\n        assert self.result.value == \"value\"\n        assert hash(self.result)\n\n    def test_render(self) -> None:\n        assert self.result.render() == \"'value'\"\n        assert TypeConstant(TypeConstant.Ellipsis).render() == \"...\"\n\n    def test_get_import_record(self) -> None:\n        assert len(self.result.get_import_records()) == 0\n\n    def test_copy(self) -> None:\n        assert self.result.copy().value == \"value\"\n\n    def test_is_type(self) -> None:\n        assert not self.result.is_dict()\n        assert not self.result.is_list()\n\n    def test_compare(self) -> None:\n        assert self.result == TypeConstant(\"value\")\n        assert self.result != TypeConstant(\"other\")\n        assert self.result > TypeConstant(\"aaa\")\n\n        with pytest.raises(BuildInternalError):\n            assert self.result == \"value\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n",
    "mypy_boto3_builder/type_annotations/type_constant.py": "\"\"\"\nWrapper for constant like `False` or `\"test\"`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass EllipsisType:\n    \"\"\"\n    Placeholder for `...`.\n    \"\"\"\n\n\nValueType = str | int | float | EllipsisType | None\n\n\nclass TypeConstant(FakeAnnotation):\n    \"\"\"\n    Wrapper for constant like `False` or `\"test\"`.\n\n    Arguments:\n        value -- Constant value.\n    \"\"\"\n\n    Ellipsis: Final[EllipsisType] = EllipsisType()\n\n    def __init__(self, value: ValueType) -> None:\n        self.value: ValueType = value\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.value is self.Ellipsis:\n            return \"...\"\n\n        return repr(self.value)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.value)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the FakeAnnotation instance based on its string representation for sorting purposes. This method uses the `get_sort_key` method to retrieve a consistent string that represents the instance, ensuring that two instances with equivalent annotations yield the same hash value. The returned hash integer facilitates the use of FakeAnnotation instances in hash-based collections like sets and dictionaries.\"\"\"\n        '\\n        Calculate hash value based on string render.\\n        '\n        return hash(self.get_sort_key())",
        "docstring": "Calculate a hash value for the FakeAnnotation instance based on its string representation for sorting purposes. This method uses the `get_sort_key` method to retrieve a consistent string that represents the instance, ensuring that two instances with equivalent annotations yield the same hash value. The returned hash integer facilitates the use of FakeAnnotation instances in hash-based collections like sets and dictionaries.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Determines if two `FakeAnnotation` instances are equal based on their string representation.\n\nParameters:\n- other (object): The object to compare with the current instance. It is expected to be an instance of `FakeAnnotation`.\n\nReturns:\n- bool: Returns `True` if the string representations (obtained from `get_sort_key()`) of both instances are equal. If `other` is not an instance of `FakeAnnotation`, raises a `BuildInternalError`.\n\nDependencies:\n- `BuildInternalError`: An exception raised if the `other` parameter is not a `FakeAnnotation`. This error indicates a misuse of the comparison operation.\n- `get_sort_key()`: A method used to retrieve a string representation of the `FakeAnnotation` instances for comparison.\"\"\"\n        '\\n        Whether two annotations are equal.\\n        '\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()",
        "docstring": "Determines if two `FakeAnnotation` instances are equal based on their string representation.\n\nParameters:\n- other (object): The object to compare with the current instance. It is expected to be an instance of `FakeAnnotation`.\n\nReturns:\n- bool: Returns `True` if the string representations (obtained from `get_sort_key()`) of both instances are equal. If `other` is not an instance of `FakeAnnotation`, raises a `BuildInternalError`.\n\nDependencies:\n- `BuildInternalError`: An exception raised if the `other` parameter is not a `FakeAnnotation`. This error indicates a misuse of the comparison operation.\n- `get_sort_key()`: A method used to retrieve a string representation of the `FakeAnnotation` instances for comparison.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.__gt__": {
        "code": "    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"Compare two instances of `FakeAnnotation` for sorting purposes by evaluating their sort keys. \n\nParameters:\n- `other` (FakeAnnotation): The other `FakeAnnotation` instance to compare against.\n\nReturns:\n- bool: True if the current instance's sort key is greater than that of the other instance, False otherwise. \n\nThis method relies on the `get_sort_key()` method to obtain a string representation of the annotations, which defines the criteria for comparison. It raises a TypeError if `other` is not an instance of `FakeAnnotation`, ensuring that only valid comparisons are made.\"\"\"\n        '\\n        Compare two annotations for sorting.\\n        '\n        return self.get_sort_key() > other.get_sort_key()",
        "docstring": "Compare two instances of `FakeAnnotation` for sorting purposes by evaluating their sort keys. \n\nParameters:\n- `other` (FakeAnnotation): The other `FakeAnnotation` instance to compare against.\n\nReturns:\n- bool: True if the current instance's sort key is greater than that of the other instance, False otherwise. \n\nThis method relies on the `get_sort_key()` method to obtain a string representation of the annotations, which defines the criteria for comparison. It raises a TypeError if `other` is not an instance of `FakeAnnotation`, ensuring that only valid comparisons are made.",
        "signature": "def __gt__(self: Self, other: 'FakeAnnotation') -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.get_sort_key": {
        "code": "    def get_sort_key(self) -> str:\n        \"\"\"Get a string representation of the annotation to be used as a sort key. This method leverages the `__str__` method of the class to obtain a string representation of the current `FakeAnnotation` instance, thereby facilitating annotation comparison and sorting in other methods. It does not take any parameters and returns a string. This output is primarily used in comparison operations, such as equality checks and ordering, as defined by the `__eq__` and `__gt__` methods of the `FakeAnnotation` class.\"\"\"\n        '\\n        Get string to sort annotations.\\n        '\n        return str(self)",
        "docstring": "Get a string representation of the annotation to be used as a sort key. This method leverages the `__str__` method of the class to obtain a string representation of the current `FakeAnnotation` instance, thereby facilitating annotation comparison and sorting in other methods. It does not take any parameters and returns a string. This output is primarily used in comparison operations, such as equality checks and ordering, as defined by the `__eq__` and `__gt__` methods of the `FakeAnnotation` class.",
        "signature": "def get_sort_key(self) -> str:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.__str__": {
        "code": "    def __str__(self) -> str:\n        \"\"\"Render the string representation of a type annotation as a valid Python statement.\n\nThis method overrides the default string representation for instances of the FakeAnnotation class and calls the abstract method `render()`, which is intended to generate an appropriate string format for the specific type annotation. The output string is used for displaying the annotation in a manner consistent with Python syntax.\n\nReturns:\n    str: A valid Python statement representing the type annotation.\n\nDependencies:\n    This method relies on the abstract `render()` method defined in the class, which concrete subclasses must implement to provide their specific string representation.\"\"\"\n        '\\n        Render annotation usage as a valid Python statement.\\n        '\n        return self.render()",
        "docstring": "Render the string representation of a type annotation as a valid Python statement.\n\nThis method overrides the default string representation for instances of the FakeAnnotation class and calls the abstract method `render()`, which is intended to generate an appropriate string format for the specific type annotation. The output string is used for displaying the annotation in a manner consistent with Python syntax.\n\nReturns:\n    str: A valid Python statement representing the type annotation.\n\nDependencies:\n    This method relies on the abstract `render()` method defined in the class, which concrete subclasses must implement to provide their specific string representation.",
        "signature": "def __str__(self) -> str:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation._get_import_records": {
        "code": "    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Get import records required for using the type annotation.\n\nThis method retrieves a set of `ImportRecord` objects that are necessary for the proper usage of the type annotation represented by the instance. By default, it returns an empty set, indicating that no imports are needed. Subclasses of `FakeAnnotation` should override this method to provide specific import records relevant to their type annotations.\n\nReturns:\n    set[ImportRecord]: A set of import records that should be included for the type annotation.\n\nDependencies:\n    - ImportRecord: This class is imported from `mypy_boto3_builder.import_helpers.import_record` and represents the details about the import required for type annotations.\"\"\"\n        '\\n        Get import record required for using type annotation.\\n        '\n        return set()",
        "docstring": "Get import records required for using the type annotation.\n\nThis method retrieves a set of `ImportRecord` objects that are necessary for the proper usage of the type annotation represented by the instance. By default, it returns an empty set, indicating that no imports are needed. Subclasses of `FakeAnnotation` should override this method to provide specific import records relevant to their type annotations.\n\nReturns:\n    set[ImportRecord]: A set of import records that should be included for the type annotation.\n\nDependencies:\n    - ImportRecord: This class is imported from `mypy_boto3_builder.import_helpers.import_record` and represents the details about the import required for type annotations.",
        "signature": "def _get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.get_import_records": {
        "code": "    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Retrieve all import records necessary for utilizing the type annotation represented by the instance. This method calls the private `_get_import_records()` method to obtain a set of import records related to the type annotation. It filters out any records sourced from built-in modules, as determined by the `is_builtins()` method of the `source` attribute of each `ImportRecord`. The method returns a set of `ImportRecord` instances that may be used to manage type imports required for type checking and code generation.\"\"\"\n        '\\n        Get all import records required for using type annotation.\\n        '\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}",
        "docstring": "Retrieve all import records necessary for utilizing the type annotation represented by the instance. This method calls the private `_get_import_records()` method to obtain a set of import records related to the type annotation. It filters out any records sourced from built-in modules, as determined by the `is_builtins()` method of the `source` attribute of each `ImportRecord`. The method returns a set of `ImportRecord` instances that may be used to manage type imports required for type checking and code generation.",
        "signature": "def get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.is_dict": {
        "code": "    def is_dict(self) -> bool:\n        \"\"\"Determine whether the type annotation represented by this instance is a dictionary type, specifically `Dict` or `TypedDict`.\n\nParameters:\n    None\n\nReturns:\n    bool: Always returns False, indicating that the current instance does not represent a dictionary type.\n\nThis method is part of the `FakeAnnotation` class which serves as a base for all type annotation wrappers. It is designed to be overridden in subclasses that specifically represent dictionary types. The method does not use any constants or external variables; its sole purpose is to provide a default implementation that can be utilized or extended by subclasses that define dictionary type annotations.\"\"\"\n        '\\n        Whether type annotation is `Dict` or `TypedDict`.\\n        '\n        return False",
        "docstring": "Determine whether the type annotation represented by this instance is a dictionary type, specifically `Dict` or `TypedDict`.\n\nParameters:\n    None\n\nReturns:\n    bool: Always returns False, indicating that the current instance does not represent a dictionary type.\n\nThis method is part of the `FakeAnnotation` class which serves as a base for all type annotation wrappers. It is designed to be overridden in subclasses that specifically represent dictionary types. The method does not use any constants or external variables; its sole purpose is to provide a default implementation that can be utilized or extended by subclasses that define dictionary type annotations.",
        "signature": "def is_dict(self) -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.is_list": {
        "code": "    def is_list(self) -> bool:\n        \"\"\"Determine if the type annotation represented by the instance is a `List`.\n\nThis method does not take any parameters and returns a boolean value. The default implementation returns `False`, indicating that the annotation is not a `List`. Subclasses of `FakeAnnotation` that represent `List` types should override this method to return `True`. This method allows for type checking within the type annotation hierarchy without additional side effects.\"\"\"\n        '\\n        Whether type annotation is `List`.\\n        '\n        return False",
        "docstring": "Determine if the type annotation represented by the instance is a `List`.\n\nThis method does not take any parameters and returns a boolean value. The default implementation returns `False`, indicating that the annotation is not a `List`. Subclasses of `FakeAnnotation` that represent `List` types should override this method to return `True`. This method allows for type checking within the type annotation hierarchy without additional side effects.",
        "signature": "def is_list(self) -> bool:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.copy": {
        "code": "    def copy(self: Self) -> Self:\n        \"\"\"Create a shallow copy of the type annotation wrapper.\n\nThis method uses the `copy.copy` function from the Python standard library to replicate the instance of the `FakeAnnotation` class. It does not take any parameters and returns a new instance that is a copy of the current object. The copy retains the same state as the original but is a distinct object in memory.\n\nThis method is intended for use when an independent instance of a type annotation wrapper is needed without modifying the original. It directly interacts with the `copy` module, which is imported at the beginning of the file.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return copy.copy(self)",
        "docstring": "Create a shallow copy of the type annotation wrapper.\n\nThis method uses the `copy.copy` function from the Python standard library to replicate the instance of the `FakeAnnotation` class. It does not take any parameters and returns a new instance that is a copy of the current object. The copy retains the same state as the original but is a distinct object in memory.\n\nThis method is intended for use when an independent instance of a type annotation wrapper is needed without modifying the original. It directly interacts with the `copy` module, which is imported at the beginning of the file.",
        "signature": "def copy(self: Self) -> Self:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_constant.py": {
      "TypeConstant.__init__": {
        "code": "    def __init__(self, value: ValueType) -> None:\n        \"\"\"Initialize a `TypeConstant` instance.\n\nParameters:\n    value (ValueType): The constant value to be wrapped. This can be a string, integer, float, an instance of `EllipsisType`, or `None`. The `ValueType` is defined in the class scope to encompass these types.\n\nAttributes:\n    value (ValueType): Stores the provided constant value for the instance.\n    \nThis constructor sets the `value` attribute to the given input, enabling further rendering or manipulation of the constant through other methods in the `TypeConstant` class.\"\"\"\n        self.value: ValueType = value",
        "docstring": "Initialize a `TypeConstant` instance.\n\nParameters:\n    value (ValueType): The constant value to be wrapped. This can be a string, integer, float, an instance of `EllipsisType`, or `None`. The `ValueType` is defined in the class scope to encompass these types.\n\nAttributes:\n    value (ValueType): Stores the provided constant value for the instance.\n    \nThis constructor sets the `value` attribute to the given input, enabling further rendering or manipulation of the constant through other methods in the `TypeConstant` class.",
        "signature": "def __init__(self, value: ValueType) -> None:",
        "type": "Method",
        "class_signature": "class TypeConstant(FakeAnnotation):"
      },
      "TypeConstant.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render a string representation of the constant value held by the TypeConstant instance.\n\nThe method checks if the value is an instance of the Ellipsis constant, defined as `self.Ellipsis`, which represents the Python ellipsis (`...`). If the value matches, it returns `\"...\"`. Otherwise, it uses the built-in `repr()` function to return a string representation of the constant value. The value can be of types defined in `ValueType`, which include `str`, `int`, `float`, `EllipsisType`, or `None`.\n\nReturns:\n    str: A valid Python code representation of the constant value.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        if self.value is self.Ellipsis:\n            return '...'\n        return repr(self.value)",
        "docstring": "Render a string representation of the constant value held by the TypeConstant instance.\n\nThe method checks if the value is an instance of the Ellipsis constant, defined as `self.Ellipsis`, which represents the Python ellipsis (`...`). If the value matches, it returns `\"...\"`. Otherwise, it uses the built-in `repr()` function to return a string representation of the constant value. The value can be of types defined in `ValueType`, which include `str`, `int`, `float`, `EllipsisType`, or `None`.\n\nReturns:\n    str: A valid Python code representation of the constant value.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeConstant(FakeAnnotation):"
      },
      "TypeConstant.__copy__": {
        "code": "    def __copy__(self) -> Self:\n        \"\"\"Create a copy of the TypeConstant instance.\n\nThis method returns a new instance of TypeConstant that has the same value as the original instance. The value is assigned to `self.value`, which represents the constant value wrapped by the TypeConstant. \n\nReturns:\n    TypeConstant: A new instance that is a copy of the current TypeConstant.\n\nThis method interacts with the `TypeConstant` class's `value` attribute, which can be of types defined in the ValueType union, and effectively allows for the duplication of constant values for further manipulation or usage.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return self.__class__(self.value)",
        "docstring": "Create a copy of the TypeConstant instance.\n\nThis method returns a new instance of TypeConstant that has the same value as the original instance. The value is assigned to `self.value`, which represents the constant value wrapped by the TypeConstant. \n\nReturns:\n    TypeConstant: A new instance that is a copy of the current TypeConstant.\n\nThis method interacts with the `TypeConstant` class's `value` attribute, which can be of types defined in the ValueType union, and effectively allows for the duplication of constant values for further manipulation or usage.",
        "signature": "def __copy__(self) -> Self:",
        "type": "Method",
        "class_signature": "class TypeConstant(FakeAnnotation):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:_get_import_records": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {},
    "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__copy__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__eq__": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation": {},
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__gt__": {}
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_type_constant\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 fake_annotation.py\n        \u2502   \u251c\u2500\u2500 FakeAnnotation\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__eq__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__gt__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__hash__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.__str__\n        \u2502   \u251c\u2500\u2500 FakeAnnotation._get_import_records\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.copy\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.get_import_records\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.get_sort_key\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.is_dict\n        \u2502   \u2514\u2500\u2500 FakeAnnotation.is_list\n        \u2514\u2500\u2500 type_constant.py\n            \u251c\u2500\u2500 TypeConstant.__copy__\n            \u251c\u2500\u2500 TypeConstant.__init__\n            \u2514\u2500\u2500 TypeConstant.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is responsible for validating and ensuring the correctness of the `TypeConstant` class, which is a utility for representing and handling immutable constant type annotations in the software's type-safe architecture. It provides capabilities to verify core attributes, render constants into their string representations, compare them for equality, and identify their type-specific properties. By offering robust testing for these functionalities, the module ensures the reliability of a critical building block in type annotation management, reducing potential errors for developers working with strongly-typed constructs and improving maintainability in systems reliant on precise type handling.\n\n## FILE 1: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.__hash__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the FakeAnnotation instance based on its string representation for sorting purposes. This method uses the `get_sort_key` method to retrieve a consistent string that represents the instance, ensuring that two instances with equivalent annotations yield the same hash value. The returned hash integer facilitates the use of FakeAnnotation instances in hash-based collections like sets and dictionaries.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.__gt__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two instances of `FakeAnnotation` for sorting purposes by evaluating their sort keys. \n\nParameters:\n- `other` (FakeAnnotation): The other `FakeAnnotation` instance to compare against.\n\nReturns:\n- bool: True if the current instance's sort key is greater than that of the other instance, False otherwise. \n\nThis method relies on the `get_sort_key()` method to obtain a string representation of the annotations, which defines the criteria for comparison. It raises a TypeError if `other` is not an instance of `FakeAnnotation`, ensuring that only valid comparisons are made.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.__str__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __str__(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the string representation of a type annotation as a valid Python statement.\n\nThis method overrides the default string representation for instances of the FakeAnnotation class and calls the abstract method `render()`, which is intended to generate an appropriate string format for the specific type annotation. The output string is used for displaying the annotation in a manner consistent with Python syntax.\n\nReturns:\n    str: A valid Python statement representing the type annotation.\n\nDependencies:\n    This method relies on the abstract `render()` method defined in the class, which concrete subclasses must implement to provide their specific string representation.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.get_sort_key\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_sort_key(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet a string representation of the annotation to be used as a sort key. This method leverages the `__str__` method of the class to obtain a string representation of the current `FakeAnnotation` instance, thereby facilitating annotation comparison and sorting in other methods. It does not take any parameters and returns a string. This output is primarily used in comparison operations, such as equality checks and ordering, as defined by the `__eq__` and `__gt__` methods of the `FakeAnnotation` class.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.is_dict\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def is_dict(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine whether the type annotation represented by this instance is a dictionary type, specifically `Dict` or `TypedDict`.\n\nParameters:\n    None\n\nReturns:\n    bool: Always returns False, indicating that the current instance does not represent a dictionary type.\n\nThis method is part of the `FakeAnnotation` class which serves as a base for all type annotation wrappers. It is designed to be overridden in subclasses that specifically represent dictionary types. The method does not use any constants or external variables; its sole purpose is to provide a default implementation that can be utilized or extended by subclasses that define dictionary type annotations.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.__eq__\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if two `FakeAnnotation` instances are equal based on their string representation.\n\nParameters:\n- other (object): The object to compare with the current instance. It is expected to be an instance of `FakeAnnotation`.\n\nReturns:\n- bool: Returns `True` if the string representations (obtained from `get_sort_key()`) of both instances are equal. If `other` is not an instance of `FakeAnnotation`, raises a `BuildInternalError`.\n\nDependencies:\n- `BuildInternalError`: An exception raised if the `other` parameter is not a `FakeAnnotation`. This error indicates a misuse of the comparison operation.\n- `get_sort_key()`: A method used to retrieve a string representation of the `FakeAnnotation` instances for comparison.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.is_list\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def is_list(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the type annotation represented by the instance is a `List`.\n\nThis method does not take any parameters and returns a boolean value. The default implementation returns `False`, indicating that the annotation is not a `List`. Subclasses of `FakeAnnotation` that represent `List` types should override this method to return `True`. This method allows for type checking within the type annotation hierarchy without additional side effects.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.copy\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def copy(self: Self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a shallow copy of the type annotation wrapper.\n\nThis method uses the `copy.copy` function from the Python standard library to replicate the instance of the `FakeAnnotation` class. It does not take any parameters and returns a new instance that is a copy of the current object. The copy retains the same state as the original but is a distinct object in memory.\n\nThis method is intended for use when an independent instance of a type annotation wrapper is needed without modifying the original. It directly interacts with the `copy` module, which is imported at the beginning of the file.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.get_import_records\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve all import records necessary for utilizing the type annotation represented by the instance. This method calls the private `_get_import_records()` method to obtain a set of import records related to the type annotation. It filters out any records sourced from built-in modules, as determined by the `is_builtins()` method of the `source` attribute of each `ImportRecord`. The method returns a set of `ImportRecord` instances that may be used to manage type imports required for type checking and code generation.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation._get_import_records\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def _get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet import records required for using the type annotation.\n\nThis method retrieves a set of `ImportRecord` objects that are necessary for the proper usage of the type annotation represented by the instance. By default, it returns an empty set, indicating that no imports are needed. Subclasses of `FakeAnnotation` should override this method to provide specific import records relevant to their type annotations.\n\nReturns:\n    set[ImportRecord]: A set of import records that should be included for the type annotation.\n\nDependencies:\n    - ImportRecord: This class is imported from `mypy_boto3_builder.import_helpers.import_record` and represents the details about the import required for type annotations.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/type_constant.py\n\n- CLASS METHOD: TypeConstant.__copy__\n  - CLASS SIGNATURE: class TypeConstant(FakeAnnotation):\n  - SIGNATURE: def __copy__(self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a copy of the TypeConstant instance.\n\nThis method returns a new instance of TypeConstant that has the same value as the original instance. The value is assigned to `self.value`, which represents the constant value wrapped by the TypeConstant. \n\nReturns:\n    TypeConstant: A new instance that is a copy of the current TypeConstant.\n\nThis method interacts with the `TypeConstant` class's `value` attribute, which can be of types defined in the ValueType union, and effectively allows for the duplication of constant values for further manipulation or usage.\n\"\"\"\n```\n\n- CLASS METHOD: TypeConstant.render\n  - CLASS SIGNATURE: class TypeConstant(FakeAnnotation):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender a string representation of the constant value held by the TypeConstant instance.\n\nThe method checks if the value is an instance of the Ellipsis constant, defined as `self.Ellipsis`, which represents the Python ellipsis (`...`). If the value matches, it returns `\"...\"`. Otherwise, it uses the built-in `repr()` function to return a string representation of the constant value. The value can be of types defined in `ValueType`, which include `str`, `int`, `float`, `EllipsisType`, or `None`.\n\nReturns:\n    str: A valid Python code representation of the constant value.\n\"\"\"\n```\n\n- CLASS METHOD: TypeConstant.__init__\n  - CLASS SIGNATURE: class TypeConstant(FakeAnnotation):\n  - SIGNATURE: def __init__(self, value: ValueType) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a `TypeConstant` instance.\n\nParameters:\n    value (ValueType): The constant value to be wrapped. This can be a string, integer, float, an instance of `EllipsisType`, or `None`. The `ValueType` is defined in the class scope to encompass these types.\n\nAttributes:\n    value (ValueType): Stores the provided constant value for the instance.\n    \nThis constructor sets the `value` attribute to the given input, enabling further rendering or manipulation of the constant through other methods in the `TypeConstant` class.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()",
    "mypy_boto3_builder/type_annotations/type_constant.py": "\"\"\"\nWrapper for constant like `False` or `\"test\"`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import Final, Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass EllipsisType:\n    \"\"\"\n    Placeholder for `...`.\n    \"\"\"\nValueType = str | int | float | EllipsisType | None\n\nclass TypeConstant(FakeAnnotation):\n    \"\"\"\n    Wrapper for constant like `False` or `\"test\"`.\n\n    Arguments:\n        value -- Constant value.\n    \"\"\"\n    Ellipsis: Final[EllipsisType] = EllipsisType()"
  },
  "call_tree": {
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:setup_method": {
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {}
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_init": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__hash__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {}
          }
        }
      }
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_render": {
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {},
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {}
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_get_import_record": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:_get_import_records": {}
      }
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_copy": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__copy__": {
          "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {}
        }
      }
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_is_type": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:is_dict": {},
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:is_list": {}
    },
    "tests/type_annotations/test_type_constant.py:TestTypeConstant:test_compare": {
      "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:__init__": {},
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__eq__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation": {},
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {}
          }
        }
      },
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__gt__": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_sort_key": {
          "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:__str__": {
            "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {}
          }
        }
      }
    }
  }
}