{
  "dir_path": "/app/casbin",
  "package_name": "casbin",
  "sample_name": "casbin-test_fast_enforcer",
  "src_dir": "casbin/",
  "test_dir": "tests/",
  "test_file": "tests/test_fast_enforcer.py",
  "test_code": "# Copyright 2023 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport time\nfrom typing import Sequence\nfrom unittest import TestCase\n\nimport casbin\nfrom casbin import FastPolicy\n\n\ndef get_examples(path):\n    examples_path = os.path.split(os.path.realpath(__file__))[0] + \"/../examples/\"\n    return os.path.abspath(examples_path + path)\n\n\nclass TestCaseBase(TestCase):\n    def get_enforcer(self, model=None, adapter=None, cache_key_order: Sequence[int] = None):\n        return casbin.FastEnforcer(\n            model,\n            adapter,\n            cache_key_order=cache_key_order,\n        )\n\n\nclass TestFastEnforcer(TestCaseBase):\n    def test_performance(self) -> None:\n        e1 = self.get_enforcer(\n            get_examples(\"performance/rbac_with_pattern_large_scale_model.conf\"),\n            get_examples(\"performance/rbac_with_pattern_large_scale_policy.csv\"),\n        )\n        e2 = self.get_enforcer(\n            get_examples(\"performance/rbac_with_pattern_large_scale_model.conf\"),\n            get_examples(\"performance/rbac_with_pattern_large_scale_policy.csv\"),\n            [2, 1],\n        )\n        s_e1 = time.perf_counter()\n        e1.enforce(\"alice\", \"data1\", \"read\")\n        t_e1 = time.perf_counter() - s_e1\n        s_e2 = time.perf_counter()\n        e2.enforce(\"alice\", \"data1\", \"read\")\n        t_e2 = time.perf_counter() - s_e2\n        assert t_e1 > t_e2 * 5\n\n    def test_creates_proper_policy(self) -> None:\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n            [2, 1],\n        )\n        self.assertIsInstance(e.model.model[\"p\"][\"p\"].policy, FastPolicy)\n\n    def test_initializes_model(self) -> None:\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n            [2, 1],\n        )\n        self.assertEqual(\n            list(e.model.model[\"p\"][\"p\"].policy),\n            [\n                [\"alice\", \"data1\", \"read\"],\n                [\"bob\", \"data2\", \"write\"],\n            ],\n        )\n\n    def test_able_to_clear_policy(self) -> None:\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n            [2, 1],\n        )\n\n        e.clear_policy()\n\n        self.assertIsInstance(e.model.model[\"p\"][\"p\"].policy, FastPolicy)\n        self.assertEqual(list(e.model.model[\"p\"][\"p\"].policy), [])\n\n    def test_able_to_enforce_rule(self) -> None:\n        e = self.get_enforcer(\n            get_examples(\"basic_model.conf\"),\n            get_examples(\"basic_policy.csv\"),\n            [2, 1],\n        )\n\n        self.assertTrue(e.enforce(\"alice\", \"data1\", \"read\"))\n        self.assertFalse(e.enforce(\"alice2\", \"data1\", \"read\"))\n",
  "GT_file_code": {
    "casbin/core_enforcer.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\nimport logging\n\nfrom casbin.effect import Effector, get_effector, effect_to_bool\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist import Adapter\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.rbac import default_role_manager\nfrom casbin.util import generate_g_function, SimpleEval, util, generate_conditional_g_function\nfrom casbin.util.log import configure_logging, disabled_logging\n\n\nclass EnforceContext:\n    \"\"\"\n    EnforceContext is used as the first element of the parameter \"rvals\" in method \"enforce\"\n    \"\"\"\n\n    def __init__(self, rtype: str, ptype: str, etype: str, mtype: str):\n        self.rtype: str = rtype\n        self.ptype: str = ptype\n        self.etype: str = etype\n        self.mtype: str = mtype\n\n\nclass CoreEnforcer:\n    \"\"\"CoreEnforcer defines the core functionality of an enforcer.\"\"\"\n\n    model_path = \"\"\n    model = None\n    fm = None\n    eft = None\n\n    adapter = None\n    watcher = None\n    rm_map = None\n    cond_rm_map = None\n\n    enabled = False\n    auto_save = False\n    auto_build_role_links = False\n    auto_notify_watcher = False\n\n    def __init__(self, model=None, adapter=None, enable_log=False):\n        self.logger = logging.getLogger(\"casbin.enforcer\")\n        if isinstance(model, str):\n            if isinstance(adapter, str):\n                self.init_with_file(model, adapter)\n            else:\n                self.init_with_adapter(model, adapter)\n                pass\n        else:\n            if isinstance(adapter, str):\n                raise RuntimeError(\"Invalid parameters for enforcer.\")\n            else:\n                self.init_with_model_and_adapter(model, adapter)\n\n        if enable_log:\n            configure_logging()\n        else:\n            disabled_logging()\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_adapter(self, model_path, adapter=None):\n        \"\"\"initializes an enforcer with a database adapter.\"\"\"\n        m = self.new_model(model_path)\n        self.init_with_model_and_adapter(m, adapter)\n\n        self.model_path = model_path\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n\n        if not isinstance(m, Model) or adapter is not None and not isinstance(adapter, Adapter):\n            raise RuntimeError(\"Invalid parameters for enforcer.\")\n\n        self.adapter = adapter\n\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n        self._initialize()\n\n        # Do not initialize the full policy when using a filtered adapter\n        if self.adapter and not self.is_filtered():\n            self.load_policy()\n\n    def _initialize(self):\n        self.rm_map = dict()\n        self.cond_rm_map = dict()\n        self.eft = get_effector(self.model[\"e\"][\"e\"].value)\n        self.watcher = None\n\n        self.enabled = True\n        self.auto_save = True\n        self.auto_build_role_links = True\n        self.auto_notify_watcher = True\n\n        self.init_rm_map()\n\n    @staticmethod\n    def new_model(path=\"\", text=\"\"):\n        \"\"\"creates a model.\"\"\"\n\n        m = Model()\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n\n        return m\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n\n        self.model = self.new_model()\n        self.model.load_model(self.model_path)\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n\n        return self.model\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n\n        self.model = m\n        self.fm = FunctionMap.load_function_map()\n\n    def get_adapter(self):\n        \"\"\"gets the current adapter.\"\"\"\n\n        return self.adapter\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n\n        self.adapter = adapter\n\n    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher.\"\"\"\n\n        self.watcher = watcher\n        pass\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        return self.rm_map[\"g\"]\n\n    def get_named_role_manager(self, ptype):\n        if ptype in self.rm_map.keys():\n            return self.rm_map.get(ptype)\n        raise ValueError(\"ptype not found\")\n\n    def set_role_manager(self, rm):\n        \"\"\"sets the current role manager.\"\"\"\n        self.rm_map[\"g\"] = rm\n\n    def set_named_role_manager(self, ptype, rm):\n        self.rm_map[ptype] = rm\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        self.eft = eft\n\n    def clear_policy(self):\n        \"\"\"clears all policy.\"\"\"\n\n        self.model.clear_policy()\n\n    def init_rm_map(self):\n        if \"g\" in self.model.keys():\n            for ptype in self.model[\"g\"]:\n                assertion = self.model[\"g\"][ptype]\n                if ptype in self.rm_map:\n                    rm = self.rm_map[ptype]\n                    rm.clear()\n                    continue\n\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) == 0:\n                    assertion.rm = default_role_manager.RoleManager(10)\n                    self.rm_map[ptype] = assertion.rm\n\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) != 0:\n                    assertion.cond_rm = default_role_manager.ConditionalRoleManager(10)\n                    self.cond_rm_map[ptype] = assertion.cond_rm\n\n                if len(assertion.tokens) > 2:\n                    if len(assertion.params_tokens) == 0:\n                        assertion.rm = default_role_manager.DomainManager(10)\n                        self.rm_map[ptype] = assertion.rm\n                    else:\n                        assertion.cond_rm = default_role_manager.ConditionalDomainManager(10)\n                        self.cond_rm_map[ptype] = assertion.cond_rm\n\n    def load_policy(self):\n        \"\"\"reloads the policy from file/database.\"\"\"\n        need_to_rebuild = False\n        new_model = copy.deepcopy(self.model)\n        new_model.clear_policy()\n\n        try:\n            self.adapter.load_policy(new_model)\n\n            new_model.sort_policies_by_subject_hierarchy()\n\n            new_model.sort_policies_by_priority()\n\n            new_model.print_policy()\n\n            if self.auto_build_role_links:\n                need_to_rebuild = True\n                for rm in self.rm_map.values():\n                    rm.clear()\n                if len(self.rm_map) != 0:\n                    new_model.build_role_links(self.rm_map)\n\n                for crm in self.cond_rm_map.values():\n                    crm.clear()\n                if len(self.cond_rm_map) != 0:\n                    new_model.build_conditional_role_links(self.cond_rm_map)\n\n            self.model = new_model\n\n        except Exception as e:\n            if self.auto_build_role_links and need_to_rebuild:\n                self.build_role_links()\n\n            raise e\n\n    def load_filtered_policy(self, filter):\n        \"\"\"reloads a filtered policy from file/database.\"\"\"\n        self.model.clear_policy()\n\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        self.adapter.load_filtered_policy(self.model, filter)\n\n        self.model.sort_policies_by_priority()\n\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def load_increment_filtered_policy(self, filter):\n        \"\"\"LoadIncrementalFilteredPolicy append a filtered policy from file/database.\"\"\"\n        if not hasattr(self.adapter, \"is_filtered\"):\n            raise ValueError(\"filtered policies are not supported by this adapter\")\n\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n\n        return hasattr(self.adapter, \"is_filtered\") and self.adapter.is_filtered()\n\n    def save_policy(self):\n        if self.is_filtered():\n            raise RuntimeError(\"cannot save a filtered policy\")\n\n        self.adapter.save_policy(self.model)\n\n        if self.watcher:\n            if callable(getattr(self.watcher, \"update_for_save_policy\", None)):\n                self.watcher.update_for_save_policy(self.model)\n            else:\n                self.watcher.update()\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n\n        self.enabled = enabled\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        self.auto_save = auto_save\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        self.auto_build_role_links = auto_build_role_links\n\n    def enable_auto_notify_watcher(self, auto_notify_watcher):\n        \"\"\"controls whether to save a policy rule automatically notify the watcher when it is added or removed.\"\"\"\n        self.auto_notify_watcher = auto_notify_watcher\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n\n        for rm in self.rm_map.values():\n            rm.clear()\n\n        self.model.build_role_links(self.rm_map)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        try:\n            self.rm_map[ptype].add_matching_func(fn)\n            return True\n        except:\n            return False\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        if ptype in self.rm_map.keys():\n            self.rm_map[ptype].add_domain_matching_func(fn)\n            return True\n\n        return False\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_link_condition_func(user, role, fn)\n            return True\n        return False\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_domain_link_condition_func(user, role, domain, fn)\n            return True\n        return False\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_link_condition_func_params(user, role, *params)\n            return True\n        return False\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_domain_link_condition_func_params(user, role, domain, *params)\n            return True\n        return False\n\n    def new_enforce_context(self, suffix: str) -> EnforceContext:\n        return EnforceContext(\n            rtype=\"r\" + suffix,\n            ptype=\"p\" + suffix,\n            etype=\"e\" + suffix,\n            mtype=\"m\" + suffix,\n        )\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        result, _ = self.enforce_ex(*rvals)\n        return result\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n\n        rtype = \"r\"\n        ptype = \"p\"\n        etype = \"e\"\n        mtype = \"m\"\n\n        if not self.enabled:\n            return [True, []]\n\n        functions = self.fm.get_functions()\n\n        if \"g\" in self.model.keys():\n            for key, ast in self.model[\"g\"].items():\n                if len(self.rm_map) != 0:\n                    functions[key] = generate_g_function(ast.rm)\n                if len(self.cond_rm_map) != 0:\n                    functions[key] = generate_conditional_g_function(ast.cond_rm)\n\n        if len(rvals) != 0:\n            if isinstance(rvals[0], EnforceContext):\n                enforce_context = rvals[0]\n                rtype = enforce_context.rtype\n                ptype = enforce_context.ptype\n                etype = enforce_context.etype\n                mtype = enforce_context.mtype\n                rvals = rvals[1:]\n\n        if \"m\" not in self.model.keys():\n            raise RuntimeError(\"model is undefined\")\n\n        if \"m\" not in self.model[\"m\"].keys():\n            raise RuntimeError(\"model is undefined\")\n\n        r_tokens = self.model[\"r\"][rtype].tokens\n        p_tokens = self.model[\"p\"][ptype].tokens\n\n        if len(r_tokens) != len(rvals):\n            raise RuntimeError(\"invalid request size\")\n\n        exp_string = self.model[\"m\"][mtype].value\n        exp_has_eval = util.has_eval(exp_string)\n        if not exp_has_eval:\n            expression = self._get_expression(exp_string, functions)\n\n        policy_effects = set()\n\n        r_parameters = dict(zip(r_tokens, rvals))\n\n        policy_len = len(self.model[\"p\"][ptype].policy)\n\n        explain_index = -1\n        if not 0 == policy_len:\n            for i, pvals in enumerate(self.model[\"p\"][ptype].policy):\n                if len(p_tokens) != len(pvals):\n                    raise RuntimeError(\"invalid policy size\")\n\n                p_parameters = dict(zip(p_tokens, pvals))\n                parameters = dict(r_parameters, **p_parameters)\n\n                if exp_has_eval:\n                    rule_names = util.get_eval_value(exp_string)\n                    rules = [util.escape_assertion(p_parameters[rule_name]) for rule_name in rule_names]\n                    exp_with_rule = util.replace_eval(exp_string, rules)\n                    expression = self._get_expression(exp_with_rule, functions)\n\n                result = expression.eval(parameters)\n\n                if isinstance(result, bool):\n                    if not result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                elif isinstance(result, float):\n                    if 0 == result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                else:\n                    raise RuntimeError(\"matcher result should be bool, int or float\")\n\n                p_eft_key = ptype + \"_eft\"\n                if p_eft_key in parameters.keys():\n                    eft = parameters[p_eft_key]\n                    if \"allow\" == eft:\n                        policy_effects.add(Effector.ALLOW)\n                    elif \"deny\" == eft:\n                        policy_effects.add(Effector.DENY)\n                    else:\n                        policy_effects.add(Effector.INDETERMINATE)\n                else:\n                    policy_effects.add(Effector.ALLOW)\n\n                if self.eft.intermediate_effect(policy_effects) != Effector.INDETERMINATE:\n                    explain_index = i\n                    break\n\n        else:\n            if exp_has_eval:\n                raise RuntimeError(\"please make sure rule exists in policy when using eval() in matcher\")\n\n            parameters = r_parameters.copy()\n\n            for token in self.model[\"p\"][ptype].tokens:\n                parameters[token] = \"\"\n\n            result = expression.eval(parameters)\n\n            if result:\n                policy_effects.add(Effector.ALLOW)\n            else:\n                policy_effects.add(Effector.INDETERMINATE)\n\n        final_effect = self.eft.final_effect(policy_effects)\n        result = effect_to_bool(final_effect)\n\n        # Log request.\n\n        req_str = \"Request: \"\n        req_str = req_str + \", \".join([str(v) for v in rvals])\n\n        req_str = req_str + \" ---> %s\" % result\n        if result:\n            self.logger.info(req_str)\n        else:\n            # leaving this in warning for now, if it's very noise this can be changed to info or debug,\n            # or change the log level\n            self.logger.warning(req_str)\n\n        explain_rule = []\n        if explain_index != -1 and explain_index < policy_len:\n            explain_rule = self.model[\"p\"][ptype].policy[explain_index]\n\n        return result, explain_rule\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches\"\"\"\n        results = []\n        for request in rvals:\n            result = self.enforce(*request)\n            results.append(result)\n        return results\n\n    @staticmethod\n    def configure_logging(logging_config=None):\n        \"\"\"configure_logging configure the default logger for casbin\"\"\"\n        configure_logging(logging_config)\n\n    @staticmethod\n    def _get_expression(expr, functions=None):\n        expr = expr.replace(\"&&\", \"and\")\n        expr = expr.replace(\"||\", \"or\")\n        expr = expr.replace(\"!\", \"not\")\n\n        return SimpleEval(expr, functions)\n",
    "casbin/model/policy_fast.py": "# Copyright 2023 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom contextlib import contextmanager\nfrom typing import Any, Container, Dict, Iterable, Iterator, Optional, Sequence, Set, cast\n\n\ndef in_cache(cache: Dict[str, Any], keys: Sequence[str]) -> Optional[Set[Sequence[str]]]:\n    if keys[0] in cache:\n        if len(keys) > 1:\n            return in_cache(cache[keys[-0]], keys[1:])\n        return cast(Set[Sequence[str]], cache[keys[0]])\n    else:\n        return None\n\n\nclass FastPolicy(Container[Sequence[str]]):\n    _cache: Dict[str, Any]\n    _current_filter: Optional[Set[Sequence[str]]]\n    _cache_key_order: Sequence[int]\n\n    def __init__(self, cache_key_order: Sequence[int]) -> None:\n        self._cache = {}\n        self._current_filter = None\n        self._cache_key_order = cache_key_order\n\n    def __iter__(self) -> Iterator[Sequence[str]]:\n        yield from self.__get_policy()\n\n    def __len__(self) -> int:\n        return len(list(self.__get_policy()))\n\n    def __contains__(self, item: object) -> bool:\n        if not isinstance(item, (list, tuple)) or len(self._cache_key_order) >= len(item):\n            return False\n        keys = [item[x] for x in self._cache_key_order]\n        exists = in_cache(self._cache, keys)\n        if not exists:\n            return False\n        return tuple(item) in exists\n\n    def __getitem__(self, item: int) -> Sequence[str]:\n        for i, entry in enumerate(self):\n            if i == item:\n                return entry\n        raise KeyError(\"No such value exists\")\n\n    def append(self, item: Sequence[str]) -> None:\n        cache = self._cache\n        keys = [item[x] for x in self._cache_key_order]\n\n        for key in keys[:-1]:\n            if key not in cache:\n                cache[key] = dict()\n            cache = cache[key]\n        if keys[-1] not in cache:\n            cache[keys[-1]] = set()\n\n        cache[keys[-1]].add(tuple(item))\n\n    def remove(self, policy: Sequence[str]) -> bool:\n        keys = [policy[x] for x in self._cache_key_order]\n        exists = in_cache(self._cache, keys)\n        if not exists:\n            return True\n\n        exists.remove(tuple(policy))\n        return True\n\n    def __get_policy(self) -> Iterable[Sequence[str]]:\n        if self._current_filter is not None:\n            return (list(x) for x in self._current_filter)\n        else:\n            return (list(v2) for v in self._cache.values() for v1 in v.values() for v2 in v1)\n\n    def apply_filter(self, *keys: str) -> None:\n        value = in_cache(self._cache, keys)\n        self._current_filter = value or set()\n\n    def clear_filter(self) -> None:\n        self._current_filter = None\n\n\n@contextmanager\ndef fast_policy_filter(policy: FastPolicy, *keys: str) -> Iterator[None]:\n    try:\n        policy.apply_filter(*keys)\n        yield\n    finally:\n        policy.clear_filter()\n",
    "casbin/fast_enforcer.py": "import logging\nfrom typing import Sequence\n\nfrom casbin.enforcer import Enforcer\nfrom casbin.model import Model, FastModel, fast_policy_filter, FunctionMap\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.util.log import configure_logging\n\n\nclass FastEnforcer(Enforcer):\n    _cache_key_order: Sequence[int] = None\n\n    def __init__(self, model=None, adapter=None, enable_log=False, cache_key_order: Sequence[int] = None):\n        self._cache_key_order = cache_key_order\n        super().__init__(model, adapter, enable_log)\n\n    def new_model(self, path=\"\", text=\"\"):\n        \"\"\"creates a model.\"\"\"\n        if self._cache_key_order is None:\n            m = Model()\n        else:\n            m = FastModel(self._cache_key_order)\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n\n        return m\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        if self._cache_key_order is None:\n            result, _ = self.enforce_ex(*rvals)\n        else:\n            keys = [rvals[x] for x in self._cache_key_order]\n            with fast_policy_filter(self.model.model[\"p\"][\"p\"].policy, *keys):\n                result, _ = self.enforce_ex(*rvals)\n\n        return result\n"
  },
  "GT_src_dict": {
    "casbin/core_enforcer.py": {
      "CoreEnforcer.clear_policy": {
        "code": "    def clear_policy(self):\n        \"\"\"Clears all policy rules from the current model of the CoreEnforcer.\n\nThis method interacts with the `model` attribute, specifically by calling the `clear_policy()` method of the Model class, which is responsible for managing policy rules. After this method is invoked, the enforcer will have no policy rules loaded, and subsequent enforcement decisions will not have any policies to evaluate against.\n\nNo input parameters are required, and this method does not return any values. Its primary side effect is the removal of all existing policies, so it should be used carefully, especially in a live environment where existing policies might be required for access control decisions.\"\"\"\n        'clears all policy.'\n        self.model.clear_policy()",
        "docstring": "Clears all policy rules from the current model of the CoreEnforcer.\n\nThis method interacts with the `model` attribute, specifically by calling the `clear_policy()` method of the Model class, which is responsible for managing policy rules. After this method is invoked, the enforcer will have no policy rules loaded, and subsequent enforcement decisions will not have any policies to evaluate against.\n\nNo input parameters are required, and this method does not return any values. Its primary side effect is the removal of all existing policies, so it should be used carefully, especially in a live environment where existing policies might be required for access control decisions.",
        "signature": "def clear_policy(self):",
        "type": "Method",
        "class_signature": "class CoreEnforcer:"
      }
    },
    "casbin/model/policy_fast.py": {
      "FastPolicy.__iter__": {
        "code": "    def __iter__(self) -> Iterator[Sequence[str]]:\n        \"\"\"Yields each policy entry stored in the FastPolicy instance.\n\nThis method retrieves the current policy entries based on the internal cache structure. It leverages the __get_policy() method to generate the sequence of policies. There are no input parameters for this method, and it returns an iterator over sequences of strings representing the policies. The method interacts with the _cache attribute, which stores the policy entries organized by a hierarchical key structure.\n\nThis method is primarily used for iterating over the policies defined in the FastPolicy instance.\"\"\"\n        yield from self.__get_policy()",
        "docstring": "Yields each policy entry stored in the FastPolicy instance.\n\nThis method retrieves the current policy entries based on the internal cache structure. It leverages the __get_policy() method to generate the sequence of policies. There are no input parameters for this method, and it returns an iterator over sequences of strings representing the policies. The method interacts with the _cache attribute, which stores the policy entries organized by a hierarchical key structure.\n\nThis method is primarily used for iterating over the policies defined in the FastPolicy instance.",
        "signature": "def __iter__(self) -> Iterator[Sequence[str]]:",
        "type": "Method",
        "class_signature": "class FastPolicy(Container[Sequence[str]]):"
      },
      "FastPolicy.__len__": {
        "code": "    def __len__(self) -> int:\n        \"\"\"Returns the number of policy entries in the FastPolicy instance. This method counts the total number of policies available by generating a list of policies using the __get_policy method. It does not take any parameters and yields an integer representing the count of policies. The __get_policy method interacts with the _cache attribute, which stores policies in a nested dictionary structure, and may return a filtered set of policies if filters are applied using apply_filter. If no filters are set, all stored policies are counted.\"\"\"\n        return len(list(self.__get_policy()))",
        "docstring": "Returns the number of policy entries in the FastPolicy instance. This method counts the total number of policies available by generating a list of policies using the __get_policy method. It does not take any parameters and yields an integer representing the count of policies. The __get_policy method interacts with the _cache attribute, which stores policies in a nested dictionary structure, and may return a filtered set of policies if filters are applied using apply_filter. If no filters are set, all stored policies are counted.",
        "signature": "def __len__(self) -> int:",
        "type": "Method",
        "class_signature": "class FastPolicy(Container[Sequence[str]]):"
      }
    },
    "casbin/fast_enforcer.py": {
      "FastEnforcer.__init__": {
        "code": "    def __init__(self, model=None, adapter=None, enable_log=False, cache_key_order: Sequence[int]=None):\n        \"\"\"Initializes a new instance of the FastEnforcer class, a subclass of the Enforcer from the Casbin library, specialized for faster policy enforcement by leveraging a specified cache key order.\n\nParameters:\n- model (optional): A model definition that specifies the access control rules.\n- adapter (optional): An adapter for persistent storage of the model and policies.\n- enable_log (bool, default: False): A flag to enable logging for debugging purposes.\n- cache_key_order (Sequence[int], optional): An ordered sequence of integer indices specifying the order of request values (sub, obj, act) to be used when caching and filtering enforcement results.\n\nThis constructor sets the class attribute _cache_key_order, which influences the behavior of the enforce method, allowing for optimized policy decision-making based on the specified order. It also calls the parent constructor, initializing the Enforcer with the provided model, adapter, and logging settings.\"\"\"\n        self._cache_key_order = cache_key_order\n        super().__init__(model, adapter, enable_log)",
        "docstring": "Initializes a new instance of the FastEnforcer class, a subclass of the Enforcer from the Casbin library, specialized for faster policy enforcement by leveraging a specified cache key order.\n\nParameters:\n- model (optional): A model definition that specifies the access control rules.\n- adapter (optional): An adapter for persistent storage of the model and policies.\n- enable_log (bool, default: False): A flag to enable logging for debugging purposes.\n- cache_key_order (Sequence[int], optional): An ordered sequence of integer indices specifying the order of request values (sub, obj, act) to be used when caching and filtering enforcement results.\n\nThis constructor sets the class attribute _cache_key_order, which influences the behavior of the enforce method, allowing for optimized policy decision-making based on the specified order. It also calls the parent constructor, initializing the Enforcer with the provided model, adapter, and logging settings.",
        "signature": "def __init__(self, model=None, adapter=None, enable_log=False, cache_key_order: Sequence[int]=None):",
        "type": "Method",
        "class_signature": "class FastEnforcer(Enforcer):"
      },
      "FastEnforcer.enforce": {
        "code": "    def enforce(self, *rvals):\n        \"\"\"Decides whether a \"subject\" can access a \"object\" with the operation \"action\". The input parameters are typically the subject (sub), object (obj), and action (act) values. If `_cache_key_order` is set to None, the method calls `enforce_ex` directly with the given parameters. Otherwise, it retrieves the relevant keys from `rvals` using the `_cache_key_order` sequence and applies a `fast_policy_filter` to improve efficiency when enforcing policies, specifically targeting the \"p\" policy defined in the model.\n\nParameters:\n- *rvals: Variable length argument list that represents the subject, object, and action for enforcing access control.\n\nReturns:\n- A boolean value indicating whether the access is granted or denied, along with additional information from `enforce_ex` (though only the boolean result is explicitly returned).\n\nDependencies:\n- The method uses `_cache_key_order`, which is defined during instantiation of the FastEnforcer class, to optimize policy enforcement. It also relies on the `fast_policy_filter` and the model\u2019s policy rules, particularly those stored in `self.model.model[\"p\"][\"p\"].policy`.\"\"\"\n        'decides whether a \"subject\" can access a \"object\" with the operation \"action\",\\n        input parameters are usually: (sub, obj, act).\\n        '\n        if self._cache_key_order is None:\n            result, _ = self.enforce_ex(*rvals)\n        else:\n            keys = [rvals[x] for x in self._cache_key_order]\n            with fast_policy_filter(self.model.model['p']['p'].policy, *keys):\n                result, _ = self.enforce_ex(*rvals)\n        return result",
        "docstring": "Decides whether a \"subject\" can access a \"object\" with the operation \"action\". The input parameters are typically the subject (sub), object (obj), and action (act) values. If `_cache_key_order` is set to None, the method calls `enforce_ex` directly with the given parameters. Otherwise, it retrieves the relevant keys from `rvals` using the `_cache_key_order` sequence and applies a `fast_policy_filter` to improve efficiency when enforcing policies, specifically targeting the \"p\" policy defined in the model.\n\nParameters:\n- *rvals: Variable length argument list that represents the subject, object, and action for enforcing access control.\n\nReturns:\n- A boolean value indicating whether the access is granted or denied, along with additional information from `enforce_ex` (though only the boolean result is explicitly returned).\n\nDependencies:\n- The method uses `_cache_key_order`, which is defined during instantiation of the FastEnforcer class, to optimize policy enforcement. It also relies on the `fast_policy_filter` and the model\u2019s policy rules, particularly those stored in `self.model.model[\"p\"][\"p\"].policy`.",
        "signature": "def enforce(self, *rvals):",
        "type": "Method",
        "class_signature": "class FastEnforcer(Enforcer):"
      }
    }
  },
  "dependency_dict": {
    "casbin/fast_enforcer.py:FastEnforcer:__init__": {
      "casbin/core_enforcer.py": {
        "CoreEnforcer.__init__": {
          "code": "    def __init__(self, model=None, adapter=None, enable_log=False):\n        self.logger = logging.getLogger('casbin.enforcer')\n        if isinstance(model, str):\n            if isinstance(adapter, str):\n                self.init_with_file(model, adapter)\n            else:\n                self.init_with_adapter(model, adapter)\n                pass\n        elif isinstance(adapter, str):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        else:\n            self.init_with_model_and_adapter(model, adapter)\n        if enable_log:\n            configure_logging()\n        else:\n            disabled_logging()",
          "docstring": "",
          "signature": "def __init__(self, model=None, adapter=None, enable_log=False):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      }
    },
    "casbin/core_enforcer.py:CoreEnforcer:clear_policy": {
      "casbin/model/model_fast.py": {
        "FastModel.clear_policy": {
          "code": "    def clear_policy(self) -> None:\n        \"\"\"clears all current policy.\"\"\"\n        super().clear_policy()\n        self.model[\"p\"][\"p\"].policy = FastPolicy(self._cache_key_order)",
          "docstring": "clears all current policy.",
          "signature": "def clear_policy(self) -> None:",
          "type": "Method",
          "class_signature": "class FastModel(Model):"
        }
      }
    },
    "casbin/model/policy_fast.py:FastPolicy:__len__": {
      "casbin/model/policy_fast.py": {
        "FastPolicy.__get_policy": {
          "code": "    def __get_policy(self) -> Iterable[Sequence[str]]:\n        if self._current_filter is not None:\n            return (list(x) for x in self._current_filter)\n        else:\n            return (list(v2) for v in self._cache.values() for v1 in v.values() for v2 in v1)",
          "docstring": "",
          "signature": "def __get_policy(self) -> Iterable[Sequence[str]]:",
          "type": "Method",
          "class_signature": "class FastPolicy(Container[Sequence[str]]):"
        }
      }
    },
    "casbin/model/policy_fast.py:FastPolicy:__iter__": {
      "casbin/model/policy_fast.py": {
        "FastPolicy.__get_policy": {
          "code": "    def __get_policy(self) -> Iterable[Sequence[str]]:\n        if self._current_filter is not None:\n            return (list(x) for x in self._current_filter)\n        else:\n            return (list(v2) for v in self._cache.values() for v1 in v.values() for v2 in v1)",
          "docstring": "",
          "signature": "def __get_policy(self) -> Iterable[Sequence[str]]:",
          "type": "Method",
          "class_signature": "class FastPolicy(Container[Sequence[str]]):"
        }
      }
    },
    "casbin/fast_enforcer.py:FastEnforcer:enforce": {
      "casbin/model/policy_fast.py": {
        "fast_policy_filter": {
          "code": "def fast_policy_filter(policy: FastPolicy, *keys: str) -> Iterator[None]:\n    try:\n        policy.apply_filter(*keys)\n        yield\n    finally:\n        policy.clear_filter()",
          "docstring": "",
          "signature": "def fast_policy_filter(policy: FastPolicy, *keys: str) -> Iterator[None]:",
          "type": "Function",
          "class_signature": null
        }
      },
      "casbin/core_enforcer.py": {
        "CoreEnforcer.enforce_ex": {
          "code": "    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n        rtype = 'r'\n        ptype = 'p'\n        etype = 'e'\n        mtype = 'm'\n        if not self.enabled:\n            return [True, []]\n        functions = self.fm.get_functions()\n        if 'g' in self.model.keys():\n            for key, ast in self.model['g'].items():\n                if len(self.rm_map) != 0:\n                    functions[key] = generate_g_function(ast.rm)\n                if len(self.cond_rm_map) != 0:\n                    functions[key] = generate_conditional_g_function(ast.cond_rm)\n        if len(rvals) != 0:\n            if isinstance(rvals[0], EnforceContext):\n                enforce_context = rvals[0]\n                rtype = enforce_context.rtype\n                ptype = enforce_context.ptype\n                etype = enforce_context.etype\n                mtype = enforce_context.mtype\n                rvals = rvals[1:]\n        if 'm' not in self.model.keys():\n            raise RuntimeError('model is undefined')\n        if 'm' not in self.model['m'].keys():\n            raise RuntimeError('model is undefined')\n        r_tokens = self.model['r'][rtype].tokens\n        p_tokens = self.model['p'][ptype].tokens\n        if len(r_tokens) != len(rvals):\n            raise RuntimeError('invalid request size')\n        exp_string = self.model['m'][mtype].value\n        exp_has_eval = util.has_eval(exp_string)\n        if not exp_has_eval:\n            expression = self._get_expression(exp_string, functions)\n        policy_effects = set()\n        r_parameters = dict(zip(r_tokens, rvals))\n        policy_len = len(self.model['p'][ptype].policy)\n        explain_index = -1\n        if not 0 == policy_len:\n            for i, pvals in enumerate(self.model['p'][ptype].policy):\n                if len(p_tokens) != len(pvals):\n                    raise RuntimeError('invalid policy size')\n                p_parameters = dict(zip(p_tokens, pvals))\n                parameters = dict(r_parameters, **p_parameters)\n                if exp_has_eval:\n                    rule_names = util.get_eval_value(exp_string)\n                    rules = [util.escape_assertion(p_parameters[rule_name]) for rule_name in rule_names]\n                    exp_with_rule = util.replace_eval(exp_string, rules)\n                    expression = self._get_expression(exp_with_rule, functions)\n                result = expression.eval(parameters)\n                if isinstance(result, bool):\n                    if not result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                elif isinstance(result, float):\n                    if 0 == result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                else:\n                    raise RuntimeError('matcher result should be bool, int or float')\n                p_eft_key = ptype + '_eft'\n                if p_eft_key in parameters.keys():\n                    eft = parameters[p_eft_key]\n                    if 'allow' == eft:\n                        policy_effects.add(Effector.ALLOW)\n                    elif 'deny' == eft:\n                        policy_effects.add(Effector.DENY)\n                    else:\n                        policy_effects.add(Effector.INDETERMINATE)\n                else:\n                    policy_effects.add(Effector.ALLOW)\n                if self.eft.intermediate_effect(policy_effects) != Effector.INDETERMINATE:\n                    explain_index = i\n                    break\n        else:\n            if exp_has_eval:\n                raise RuntimeError('please make sure rule exists in policy when using eval() in matcher')\n            parameters = r_parameters.copy()\n            for token in self.model['p'][ptype].tokens:\n                parameters[token] = ''\n            result = expression.eval(parameters)\n            if result:\n                policy_effects.add(Effector.ALLOW)\n            else:\n                policy_effects.add(Effector.INDETERMINATE)\n        final_effect = self.eft.final_effect(policy_effects)\n        result = effect_to_bool(final_effect)\n        req_str = 'Request: '\n        req_str = req_str + ', '.join([str(v) for v in rvals])\n        req_str = req_str + ' ---> %s' % result\n        if result:\n            self.logger.info(req_str)\n        else:\n            self.logger.warning(req_str)\n        explain_rule = []\n        if explain_index != -1 and explain_index < policy_len:\n            explain_rule = self.model['p'][ptype].policy[explain_index]\n        return (result, explain_rule)",
          "docstring": "decides whether a \"subject\" can access a \"object\" with the operation \"action\",\ninput parameters are usually: (sub, obj, act).\nreturn judge result with reason",
          "signature": "def enforce_ex(self, *rvals):",
          "type": "Method",
          "class_signature": "class CoreEnforcer:"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_fast_enforcer.py:TestFastEnforcer:test_able_to_clear_policy": {
      "tests/test_fast_enforcer.py:get_examples": {},
      "tests/test_fast_enforcer.py:TestCaseBase:get_enforcer": {
        "casbin/fast_enforcer.py:FastEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:__init__": {
            "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
              "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
                "casbin/fast_enforcer.py:FastEnforcer:new_model": {
                  "casbin/model/model_fast.py:FastModel:__init__": {
                    "casbin/model/policy.py:Policy:__init__": {}
                  },
                  "casbin/model/model.py:Model:load_model": {
                    "casbin/config/config.py:Config:new_config": {
                      "casbin/config/config.py:Config:__init__": {},
                      "casbin/config/config.py:Config:_parse": {}
                    },
                    "casbin/model/model.py:Model:_load_section": {
                      "casbin/model/model.py:Model:_get_key_suffix": {},
                      "casbin/model/model.py:Model:_load_assertion": {}
                    }
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                  "casbin/model/model.py:Model:Model": {},
                  "casbin/persist/adapter.py:Adapter:Adapter": {},
                  "casbin/model/model.py:Model:print_model": {
                    "casbin/model/policy.py:Policy:items": {}
                  },
                  "casbin/model/function.py:FunctionMap:load_function_map": {
                    "casbin/model/function.py:FunctionMap:__init__": {},
                    "casbin/model/function.py:FunctionMap:add_function": {}
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/effect/__init__.py:get_effector": {},
                    "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                      "casbin/model/policy.py:Policy:keys": {}
                    }
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                  "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                    "casbin/model/model_fast.py:FastModel:clear_policy": {
                      "casbin/model/policy.py:Policy:clear_policy": {},
                      "casbin/model/policy_fast.py:FastPolicy:__init__": {}
                    },
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                      "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_priority": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/policy.py:Policy:print_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    }
                  }
                }
              }
            },
            "casbin/util/log.py:disabled_logging": {}
          }
        }
      },
      "casbin/core_enforcer.py:CoreEnforcer:clear_policy": {
        "casbin/model/model_fast.py:FastModel:clear_policy": {
          "casbin/model/policy.py:Policy:clear_policy": {
            "casbin/model/policy.py:Policy:keys": {},
            "casbin/model/policy.py:Policy:__getitem__": {}
          },
          "casbin/model/policy_fast.py:FastPolicy:__init__": {}
        }
      },
      "casbin/model/policy_fast.py:FastPolicy:__len__": {
        "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
      },
      "casbin/model/policy_fast.py:FastPolicy:__iter__": {
        "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
      }
    },
    "tests/test_fast_enforcer.py:TestCaseBase:get_enforcer": {
      "casbin/fast_enforcer.py:FastEnforcer:__init__": {
        "casbin/core_enforcer.py:CoreEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
            "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
              "casbin/fast_enforcer.py:FastEnforcer:new_model": {
                "casbin/model/model.py:Model:load_model": {
                  "casbin/config/config.py:Config:new_config": {
                    "casbin/config/config.py:Config:_parse": {
                      "casbin/config/config.py:Config:_parse_buffer": {}
                    }
                  },
                  "casbin/model/model.py:Model:_load_section": {
                    "casbin/model/model.py:Model:_load_assertion": {
                      "casbin/config/config.py:Config:get": {},
                      "casbin/model/model_fast.py:FastModel:add_def": {},
                      "casbin/model/model.py:Model:add_def": {}
                    }
                  }
                }
              },
              "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                  "casbin/model/model_fast.py:FastModel:clear_policy": {
                    "casbin/model/policy.py:Policy:clear_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    }
                  },
                  "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {
                      "casbin/persist/adapter.py:load_policy_line": {}
                    }
                  },
                  "casbin/model/policy.py:Policy:build_role_links": {
                    "casbin/model/assertion.py:Assertion:build_role_links": {
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManager:add_link": {},
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManager:print_roles": {}
                    }
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                  "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:__init__": {}
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "tests/test_fast_enforcer.py:TestFastEnforcer:test_able_to_enforce_rule": {
      "tests/test_fast_enforcer.py:get_examples": {},
      "tests/test_fast_enforcer.py:TestCaseBase:get_enforcer": {
        "casbin/fast_enforcer.py:FastEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:__init__": {
            "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
              "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
                "casbin/fast_enforcer.py:FastEnforcer:new_model": {
                  "casbin/model/model_fast.py:FastModel:__init__": {
                    "casbin/model/policy.py:Policy:__init__": {}
                  },
                  "casbin/model/model.py:Model:load_model": {
                    "casbin/config/config.py:Config:new_config": {
                      "casbin/config/config.py:Config:__init__": {},
                      "casbin/config/config.py:Config:_parse": {}
                    },
                    "casbin/model/model.py:Model:_load_section": {
                      "casbin/model/model.py:Model:_get_key_suffix": {},
                      "casbin/model/model.py:Model:_load_assertion": {}
                    }
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                  "casbin/model/model.py:Model:print_model": {
                    "casbin/model/policy.py:Policy:items": {}
                  },
                  "casbin/model/function.py:FunctionMap:load_function_map": {
                    "casbin/model/function.py:FunctionMap:__init__": {},
                    "casbin/model/function.py:FunctionMap:add_function": {}
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/effect/__init__.py:get_effector": {},
                    "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                      "casbin/model/policy.py:Policy:keys": {}
                    }
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                  "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                    "casbin/model/model_fast.py:FastModel:clear_policy": {
                      "casbin/model/policy.py:Policy:clear_policy": {},
                      "casbin/model/policy_fast.py:FastPolicy:__init__": {}
                    },
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                      "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_priority": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/policy.py:Policy:print_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    }
                  }
                }
              }
            },
            "casbin/util/log.py:disabled_logging": {}
          }
        }
      },
      "casbin/fast_enforcer.py:FastEnforcer:enforce": {
        "casbin/model/policy_fast.py:fast_policy_filter": {
          "casbin/model/policy_fast.py:FastPolicy:apply_filter": {
            "casbin/model/policy_fast.py:in_cache": {
              "casbin/model/policy_fast.py:in_cache": {
                "[ignored_or_cut_off]": "..."
              }
            }
          },
          "casbin/model/policy_fast.py:FastPolicy:clear_filter": {}
        },
        "casbin/core_enforcer.py:CoreEnforcer:enforce_ex": {
          "casbin/core_enforcer.py:EnforceContext:EnforceContext": {},
          "casbin/model/function.py:FunctionMap:get_functions": {},
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {},
          "casbin/util/util.py:has_eval": {},
          "casbin/core_enforcer.py:CoreEnforcer:_get_expression": {
            "casbin/util/expression.py:SimpleEval:__init__": {}
          },
          "casbin/model/policy_fast.py:FastPolicy:__len__": {
            "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
          },
          "casbin/model/policy_fast.py:FastPolicy:__iter__": {
            "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
          },
          "casbin/util/expression.py:SimpleEval:eval": {},
          "casbin/effect/default_effectors.py:AllowOverrideEffector:intermediate_effect": {},
          "casbin/effect/default_effectors.py:AllowOverrideEffector:final_effect": {},
          "casbin/effect/__init__.py:effect_to_bool": {},
          "casbin/model/policy_fast.py:FastPolicy:__getitem__": {
            "casbin/model/policy_fast.py:FastPolicy:__iter__": {
              "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
            }
          }
        }
      }
    },
    "tests/test_fast_enforcer.py:TestFastEnforcer:test_creates_proper_policy": {
      "tests/test_fast_enforcer.py:get_examples": {},
      "tests/test_fast_enforcer.py:TestCaseBase:get_enforcer": {
        "casbin/fast_enforcer.py:FastEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:__init__": {
            "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
              "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
                "casbin/fast_enforcer.py:FastEnforcer:new_model": {
                  "casbin/model/model_fast.py:FastModel:__init__": {
                    "casbin/model/policy.py:Policy:__init__": {}
                  },
                  "casbin/model/model.py:Model:load_model": {
                    "casbin/config/config.py:Config:new_config": {
                      "casbin/config/config.py:Config:__init__": {},
                      "casbin/config/config.py:Config:_parse": {}
                    },
                    "casbin/model/model.py:Model:_load_section": {
                      "casbin/model/model.py:Model:_get_key_suffix": {},
                      "casbin/model/model.py:Model:_load_assertion": {}
                    }
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                  "casbin/model/model.py:Model:print_model": {
                    "casbin/model/policy.py:Policy:items": {}
                  },
                  "casbin/model/function.py:FunctionMap:load_function_map": {
                    "casbin/model/function.py:FunctionMap:__init__": {},
                    "casbin/model/function.py:FunctionMap:add_function": {}
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/effect/__init__.py:get_effector": {},
                    "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                      "casbin/model/policy.py:Policy:keys": {}
                    }
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                  "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                    "casbin/model/model_fast.py:FastModel:clear_policy": {
                      "casbin/model/policy.py:Policy:clear_policy": {},
                      "casbin/model/policy_fast.py:FastPolicy:__init__": {}
                    },
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                      "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_priority": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/policy.py:Policy:print_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    }
                  }
                }
              }
            },
            "casbin/util/log.py:disabled_logging": {}
          }
        }
      }
    },
    "tests/test_fast_enforcer.py:TestFastEnforcer:test_initializes_model": {
      "tests/test_fast_enforcer.py:get_examples": {},
      "tests/test_fast_enforcer.py:TestCaseBase:get_enforcer": {
        "casbin/fast_enforcer.py:FastEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:__init__": {
            "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
              "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
                "casbin/fast_enforcer.py:FastEnforcer:new_model": {
                  "casbin/model/model_fast.py:FastModel:__init__": {
                    "casbin/model/policy.py:Policy:__init__": {}
                  },
                  "casbin/model/model.py:Model:load_model": {
                    "casbin/config/config.py:Config:new_config": {
                      "casbin/config/config.py:Config:__init__": {},
                      "casbin/config/config.py:Config:_parse": {}
                    },
                    "casbin/model/model.py:Model:_load_section": {
                      "casbin/model/model.py:Model:_get_key_suffix": {},
                      "casbin/model/model.py:Model:_load_assertion": {}
                    }
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                  "casbin/model/model.py:Model:print_model": {
                    "casbin/model/policy.py:Policy:items": {}
                  },
                  "casbin/model/function.py:FunctionMap:load_function_map": {
                    "casbin/model/function.py:FunctionMap:__init__": {},
                    "casbin/model/function.py:FunctionMap:add_function": {}
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/effect/__init__.py:get_effector": {},
                    "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                      "casbin/model/policy.py:Policy:keys": {}
                    }
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                  "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                    "casbin/model/model_fast.py:FastModel:clear_policy": {
                      "casbin/model/policy.py:Policy:clear_policy": {},
                      "casbin/model/policy_fast.py:FastPolicy:__init__": {}
                    },
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                      "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_priority": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/policy.py:Policy:print_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    }
                  }
                }
              }
            },
            "casbin/util/log.py:disabled_logging": {}
          }
        }
      },
      "casbin/model/policy_fast.py:FastPolicy:__len__": {
        "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
      },
      "casbin/model/policy_fast.py:FastPolicy:__iter__": {
        "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
      }
    },
    "tests/test_fast_enforcer.py:TestFastEnforcer:test_performance": {
      "tests/test_fast_enforcer.py:get_examples": {},
      "tests/test_fast_enforcer.py:TestCaseBase:get_enforcer": {
        "casbin/fast_enforcer.py:FastEnforcer:__init__": {
          "casbin/core_enforcer.py:CoreEnforcer:__init__": {
            "casbin/core_enforcer.py:CoreEnforcer:init_with_file": {
              "casbin/persist/adapters/file_adapter.py:FileAdapter:__init__": {},
              "casbin/core_enforcer.py:CoreEnforcer:init_with_adapter": {
                "casbin/fast_enforcer.py:FastEnforcer:new_model": {
                  "casbin/model/policy.py:Policy:__init__": {},
                  "casbin/model/model.py:Model:load_model": {
                    "casbin/config/config.py:Config:new_config": {
                      "casbin/config/config.py:Config:__init__": {},
                      "casbin/config/config.py:Config:_parse": {}
                    },
                    "casbin/model/model.py:Model:_load_section": {
                      "casbin/model/model.py:Model:_get_key_suffix": {},
                      "casbin/model/model.py:Model:_load_assertion": {}
                    }
                  },
                  "casbin/model/model_fast.py:FastModel:__init__": {
                    "casbin/model/policy.py:Policy:__init__": {}
                  }
                },
                "casbin/core_enforcer.py:CoreEnforcer:init_with_model_and_adapter": {
                  "casbin/model/model.py:Model:print_model": {
                    "casbin/model/policy.py:Policy:items": {}
                  },
                  "casbin/model/function.py:FunctionMap:load_function_map": {
                    "casbin/model/function.py:FunctionMap:__init__": {},
                    "casbin/model/function.py:FunctionMap:add_function": {}
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:_initialize": {
                    "casbin/model/policy.py:Policy:__getitem__": {},
                    "casbin/effect/__init__.py:get_effector": {},
                    "casbin/core_enforcer.py:CoreEnforcer:init_rm_map": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManager:__init__": {}
                    }
                  },
                  "casbin/core_enforcer.py:CoreEnforcer:is_filtered": {},
                  "casbin/core_enforcer.py:CoreEnforcer:load_policy": {
                    "casbin/model/policy.py:Policy:clear_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/persist/adapters/file_adapter.py:FileAdapter:load_policy": {
                      "casbin/persist/adapters/file_adapter.py:FileAdapter:_load_policy_file": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_subject_hierarchy": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/model.py:Model:sort_policies_by_priority": {
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/model/policy.py:Policy:print_policy": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {}
                    },
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManager:clear": {
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:clear": {}
                    },
                    "casbin/model/policy.py:Policy:build_role_links": {
                      "casbin/model/policy.py:Policy:keys": {},
                      "casbin/model/policy.py:Policy:__getitem__": {},
                      "casbin/model/assertion.py:Assertion:build_role_links": {}
                    },
                    "casbin/model/model_fast.py:FastModel:clear_policy": {
                      "casbin/model/policy.py:Policy:clear_policy": {},
                      "casbin/model/policy_fast.py:FastPolicy:__init__": {}
                    }
                  }
                }
              }
            },
            "casbin/util/log.py:disabled_logging": {}
          }
        }
      },
      "casbin/fast_enforcer.py:FastEnforcer:enforce": {
        "casbin/core_enforcer.py:CoreEnforcer:enforce_ex": {
          "casbin/model/function.py:FunctionMap:get_functions": {},
          "casbin/model/policy.py:Policy:keys": {},
          "casbin/model/policy.py:Policy:__getitem__": {},
          "casbin/util/builtin_operators.py:generate_g_function": {},
          "casbin/util/util.py:has_eval": {},
          "casbin/core_enforcer.py:CoreEnforcer:_get_expression": {
            "casbin/util/expression.py:SimpleEval:__init__": {}
          },
          "casbin/util/expression.py:SimpleEval:eval": {
            "casbin/util/builtin_operators.py:f": {
              "casbin/rbac/default_role_manager/role_manager.py:DomainManager:has_link": {
                "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:has_link": {
                  "casbin/rbac/default_role_manager/role_manager.py:DomainManager:_get_role_manager": {
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {},
                    "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_role_manager": {
                      "casbin/rbac/default_role_manager/role_manager.py:DomainManagerBase:_get_domain": {},
                      "casbin/rbac/default_role_manager/role_manager.py:RoleManager:__init__": {},
                      "casbin/rbac/default_role_manager/role_manager.py:RoleManager:add_matching_func": {}
                    }
                  },
                  "casbin/rbac/default_role_manager/role_manager.py:RoleManager:has_link": {
                    "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_get_role": {
                      "casbin/rbac/default_role_manager/role_manager.py:Role:__init__": {},
                      "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_matching_roles": {}
                    },
                    "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_has_link": {
                      "casbin/rbac/default_role_manager/role_manager.py:RoleManager:_has_link": {
                        "[ignored_or_cut_off]": "..."
                      }
                    }
                  }
                }
              }
            }
          },
          "casbin/effect/default_effectors.py:AllowOverrideEffector:final_effect": {},
          "casbin/effect/__init__.py:effect_to_bool": {},
          "casbin/model/policy_fast.py:FastPolicy:__len__": {
            "casbin/model/policy_fast.py:FastPolicy:__get_policy": {}
          }
        },
        "casbin/model/policy_fast.py:fast_policy_filter": {
          "casbin/model/policy_fast.py:FastPolicy:apply_filter": {
            "casbin/model/policy_fast.py:in_cache": {}
          },
          "casbin/model/policy_fast.py:FastPolicy:clear_filter": {}
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: casbin-test_fast_enforcer\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 casbin/\n    \u251c\u2500\u2500 core_enforcer.py\n    \u2502   \u2514\u2500\u2500 CoreEnforcer.clear_policy\n    \u251c\u2500\u2500 fast_enforcer.py\n    \u2502   \u251c\u2500\u2500 FastEnforcer.__init__\n    \u2502   \u2514\u2500\u2500 FastEnforcer.enforce\n    \u2514\u2500\u2500 model/\n        \u2514\u2500\u2500 policy_fast.py\n            \u251c\u2500\u2500 FastPolicy.__iter__\n            \u2514\u2500\u2500 FastPolicy.__len__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module provides a high-performance implementation of a Fast Enforcer to facilitate efficient role-based access control (RBAC) and permission management using the Casbin library. It supports functionalities such as policy definition, enforcement of access rules, and runtime optimization for large-scale access control models, ensuring minimal latency during enforcement operations. Additionally, it allows dynamic management of policies, including initialization, clearing, and reloading, providing flexibility for systems with evolving permission requirements. By leveraging performance enhancements like custom caching and optimized policy handling, the module addresses the need for scalable and responsive access control mechanisms in enterprise-grade applications while simplifying integration for developers.\n\n## FILE 1: casbin/core_enforcer.py\n\n- CLASS METHOD: CoreEnforcer.clear_policy\n  - CLASS SIGNATURE: class CoreEnforcer:\n  - SIGNATURE: def clear_policy(self):\n  - DOCSTRING: \n```python\n\"\"\"\nClears all policy rules from the current model of the CoreEnforcer.\n\nThis method interacts with the `model` attribute, specifically by calling the `clear_policy()` method of the Model class, which is responsible for managing policy rules. After this method is invoked, the enforcer will have no policy rules loaded, and subsequent enforcement decisions will not have any policies to evaluate against.\n\nNo input parameters are required, and this method does not return any values. Its primary side effect is the removal of all existing policies, so it should be used carefully, especially in a live environment where existing policies might be required for access control decisions.\n\"\"\"\n```\n\n## FILE 2: casbin/model/policy_fast.py\n\n- CLASS METHOD: FastPolicy.__len__\n  - CLASS SIGNATURE: class FastPolicy(Container[Sequence[str]]):\n  - SIGNATURE: def __len__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns the number of policy entries in the FastPolicy instance. This method counts the total number of policies available by generating a list of policies using the __get_policy method. It does not take any parameters and yields an integer representing the count of policies. The __get_policy method interacts with the _cache attribute, which stores policies in a nested dictionary structure, and may return a filtered set of policies if filters are applied using apply_filter. If no filters are set, all stored policies are counted.\n\"\"\"\n```\n\n- CLASS METHOD: FastPolicy.__iter__\n  - CLASS SIGNATURE: class FastPolicy(Container[Sequence[str]]):\n  - SIGNATURE: def __iter__(self) -> Iterator[Sequence[str]]:\n  - DOCSTRING: \n```python\n\"\"\"\nYields each policy entry stored in the FastPolicy instance.\n\nThis method retrieves the current policy entries based on the internal cache structure. It leverages the __get_policy() method to generate the sequence of policies. There are no input parameters for this method, and it returns an iterator over sequences of strings representing the policies. The method interacts with the _cache attribute, which stores the policy entries organized by a hierarchical key structure.\n\nThis method is primarily used for iterating over the policies defined in the FastPolicy instance.\n\"\"\"\n```\n\n## FILE 3: casbin/fast_enforcer.py\n\n- CLASS METHOD: FastEnforcer.enforce\n  - CLASS SIGNATURE: class FastEnforcer(Enforcer):\n  - SIGNATURE: def enforce(self, *rvals):\n  - DOCSTRING: \n```python\n\"\"\"\nDecides whether a \"subject\" can access a \"object\" with the operation \"action\". The input parameters are typically the subject (sub), object (obj), and action (act) values. If `_cache_key_order` is set to None, the method calls `enforce_ex` directly with the given parameters. Otherwise, it retrieves the relevant keys from `rvals` using the `_cache_key_order` sequence and applies a `fast_policy_filter` to improve efficiency when enforcing policies, specifically targeting the \"p\" policy defined in the model.\n\nParameters:\n- *rvals: Variable length argument list that represents the subject, object, and action for enforcing access control.\n\nReturns:\n- A boolean value indicating whether the access is granted or denied, along with additional information from `enforce_ex` (though only the boolean result is explicitly returned).\n\nDependencies:\n- The method uses `_cache_key_order`, which is defined during instantiation of the FastEnforcer class, to optimize policy enforcement. It also relies on the `fast_policy_filter` and the model\u2019s policy rules, particularly those stored in `self.model.model[\"p\"][\"p\"].policy`.\n\"\"\"\n```\n\n- CLASS METHOD: FastEnforcer.__init__\n  - CLASS SIGNATURE: class FastEnforcer(Enforcer):\n  - SIGNATURE: def __init__(self, model=None, adapter=None, enable_log=False, cache_key_order: Sequence[int]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the FastEnforcer class, a subclass of the Enforcer from the Casbin library, specialized for faster policy enforcement by leveraging a specified cache key order.\n\nParameters:\n- model (optional): A model definition that specifies the access control rules.\n- adapter (optional): An adapter for persistent storage of the model and policies.\n- enable_log (bool, default: False): A flag to enable logging for debugging purposes.\n- cache_key_order (Sequence[int], optional): An ordered sequence of integer indices specifying the order of request values (sub, obj, act) to be used when caching and filtering enforcement results.\n\nThis constructor sets the class attribute _cache_key_order, which influences the behavior of the enforce method, allowing for optimized policy decision-making based on the specified order. It also calls the parent constructor, initializing the Enforcer with the provided model, adapter, and logging settings.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "casbin/core_enforcer.py": "import copy\nimport logging\nfrom casbin.effect import Effector, get_effector, effect_to_bool\nfrom casbin.model import Model, FunctionMap\nfrom casbin.persist import Adapter\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.rbac import default_role_manager\nfrom casbin.util import generate_g_function, SimpleEval, util, generate_conditional_g_function\nfrom casbin.util.log import configure_logging, disabled_logging\n\nclass EnforceContext:\n    \"\"\"\n    EnforceContext is used as the first element of the parameter \"rvals\" in method \"enforce\"\n    \"\"\"\n\n    def __init__(self, rtype: str, ptype: str, etype: str, mtype: str):\n        self.rtype: str = rtype\n        self.ptype: str = ptype\n        self.etype: str = etype\n        self.mtype: str = mtype\n\nclass CoreEnforcer:\n    \"\"\"CoreEnforcer defines the core functionality of an enforcer.\"\"\"\n    model_path = ''\n    model = None\n    fm = None\n    eft = None\n    adapter = None\n    watcher = None\n    rm_map = None\n    cond_rm_map = None\n    enabled = False\n    auto_save = False\n    auto_build_role_links = False\n    auto_notify_watcher = False\n\n    def __init__(self, model=None, adapter=None, enable_log=False):\n        self.logger = logging.getLogger('casbin.enforcer')\n        if isinstance(model, str):\n            if isinstance(adapter, str):\n                self.init_with_file(model, adapter)\n            else:\n                self.init_with_adapter(model, adapter)\n                pass\n        elif isinstance(adapter, str):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        else:\n            self.init_with_model_and_adapter(model, adapter)\n        if enable_log:\n            configure_logging()\n        else:\n            disabled_logging()\n\n    def init_with_file(self, model_path, policy_path):\n        \"\"\"initializes an enforcer with a model file and a policy file.\"\"\"\n        a = FileAdapter(policy_path)\n        self.init_with_adapter(model_path, a)\n\n    def init_with_adapter(self, model_path, adapter=None):\n        \"\"\"initializes an enforcer with a database adapter.\"\"\"\n        m = self.new_model(model_path)\n        self.init_with_model_and_adapter(m, adapter)\n        self.model_path = model_path\n\n    def init_with_model_and_adapter(self, m, adapter=None):\n        \"\"\"initializes an enforcer with a model and a database adapter.\"\"\"\n        if not isinstance(m, Model) or (adapter is not None and (not isinstance(adapter, Adapter))):\n            raise RuntimeError('Invalid parameters for enforcer.')\n        self.adapter = adapter\n        self.model = m\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n        self._initialize()\n        if self.adapter and (not self.is_filtered()):\n            self.load_policy()\n\n    def _initialize(self):\n        self.rm_map = dict()\n        self.cond_rm_map = dict()\n        self.eft = get_effector(self.model['e']['e'].value)\n        self.watcher = None\n        self.enabled = True\n        self.auto_save = True\n        self.auto_build_role_links = True\n        self.auto_notify_watcher = True\n        self.init_rm_map()\n\n    @staticmethod\n    def new_model(path='', text=''):\n        \"\"\"creates a model.\"\"\"\n        m = Model()\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n        return m\n\n    def load_model(self):\n        \"\"\"reloads the model from the model CONF file.\n        Because the policy is attached to a model, so the policy is invalidated and needs to be reloaded by calling LoadPolicy().\n        \"\"\"\n        self.model = self.new_model()\n        self.model.load_model(self.model_path)\n        self.model.print_model()\n        self.fm = FunctionMap.load_function_map()\n\n    def get_model(self):\n        \"\"\"gets the current model.\"\"\"\n        return self.model\n\n    def set_model(self, m):\n        \"\"\"sets the current model.\"\"\"\n        self.model = m\n        self.fm = FunctionMap.load_function_map()\n\n    def get_adapter(self):\n        \"\"\"gets the current adapter.\"\"\"\n        return self.adapter\n\n    def set_adapter(self, adapter):\n        \"\"\"sets the current adapter.\"\"\"\n        self.adapter = adapter\n\n    def set_watcher(self, watcher):\n        \"\"\"sets the current watcher.\"\"\"\n        self.watcher = watcher\n        pass\n\n    def get_role_manager(self):\n        \"\"\"gets the current role manager.\"\"\"\n        return self.rm_map['g']\n\n    def get_named_role_manager(self, ptype):\n        if ptype in self.rm_map.keys():\n            return self.rm_map.get(ptype)\n        raise ValueError('ptype not found')\n\n    def set_role_manager(self, rm):\n        \"\"\"sets the current role manager.\"\"\"\n        self.rm_map['g'] = rm\n\n    def set_named_role_manager(self, ptype, rm):\n        self.rm_map[ptype] = rm\n\n    def set_effector(self, eft):\n        \"\"\"sets the current effector.\"\"\"\n        self.eft = eft\n\n    def init_rm_map(self):\n        if 'g' in self.model.keys():\n            for ptype in self.model['g']:\n                assertion = self.model['g'][ptype]\n                if ptype in self.rm_map:\n                    rm = self.rm_map[ptype]\n                    rm.clear()\n                    continue\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) == 0:\n                    assertion.rm = default_role_manager.RoleManager(10)\n                    self.rm_map[ptype] = assertion.rm\n                if len(assertion.tokens) <= 2 and len(assertion.params_tokens) != 0:\n                    assertion.cond_rm = default_role_manager.ConditionalRoleManager(10)\n                    self.cond_rm_map[ptype] = assertion.cond_rm\n                if len(assertion.tokens) > 2:\n                    if len(assertion.params_tokens) == 0:\n                        assertion.rm = default_role_manager.DomainManager(10)\n                        self.rm_map[ptype] = assertion.rm\n                    else:\n                        assertion.cond_rm = default_role_manager.ConditionalDomainManager(10)\n                        self.cond_rm_map[ptype] = assertion.cond_rm\n\n    def load_policy(self):\n        \"\"\"reloads the policy from file/database.\"\"\"\n        need_to_rebuild = False\n        new_model = copy.deepcopy(self.model)\n        new_model.clear_policy()\n        try:\n            self.adapter.load_policy(new_model)\n            new_model.sort_policies_by_subject_hierarchy()\n            new_model.sort_policies_by_priority()\n            new_model.print_policy()\n            if self.auto_build_role_links:\n                need_to_rebuild = True\n                for rm in self.rm_map.values():\n                    rm.clear()\n                if len(self.rm_map) != 0:\n                    new_model.build_role_links(self.rm_map)\n                for crm in self.cond_rm_map.values():\n                    crm.clear()\n                if len(self.cond_rm_map) != 0:\n                    new_model.build_conditional_role_links(self.cond_rm_map)\n            self.model = new_model\n        except Exception as e:\n            if self.auto_build_role_links and need_to_rebuild:\n                self.build_role_links()\n            raise e\n\n    def load_filtered_policy(self, filter):\n        \"\"\"reloads a filtered policy from file/database.\"\"\"\n        self.model.clear_policy()\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.sort_policies_by_priority()\n        self.init_rm_map()\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def load_increment_filtered_policy(self, filter):\n        \"\"\"LoadIncrementalFilteredPolicy append a filtered policy from file/database.\"\"\"\n        if not hasattr(self.adapter, 'is_filtered'):\n            raise ValueError('filtered policies are not supported by this adapter')\n        self.adapter.load_filtered_policy(self.model, filter)\n        self.model.print_policy()\n        if self.auto_build_role_links:\n            self.build_role_links()\n\n    def is_filtered(self):\n        \"\"\"returns true if the loaded policy has been filtered.\"\"\"\n        return hasattr(self.adapter, 'is_filtered') and self.adapter.is_filtered()\n\n    def save_policy(self):\n        if self.is_filtered():\n            raise RuntimeError('cannot save a filtered policy')\n        self.adapter.save_policy(self.model)\n        if self.watcher:\n            if callable(getattr(self.watcher, 'update_for_save_policy', None)):\n                self.watcher.update_for_save_policy(self.model)\n            else:\n                self.watcher.update()\n\n    def enable_enforce(self, enabled=True):\n        \"\"\"changes the enforcing state of Casbin,\n        when Casbin is disabled, all access will be allowed by the Enforce() function.\n        \"\"\"\n        self.enabled = enabled\n\n    def enable_auto_save(self, auto_save):\n        \"\"\"controls whether to save a policy rule automatically to the adapter when it is added or removed.\"\"\"\n        self.auto_save = auto_save\n\n    def enable_auto_build_role_links(self, auto_build_role_links):\n        \"\"\"controls whether to rebuild the role inheritance relations when a role is added or deleted.\"\"\"\n        self.auto_build_role_links = auto_build_role_links\n\n    def enable_auto_notify_watcher(self, auto_notify_watcher):\n        \"\"\"controls whether to save a policy rule automatically notify the watcher when it is added or removed.\"\"\"\n        self.auto_notify_watcher = auto_notify_watcher\n\n    def build_role_links(self):\n        \"\"\"manually rebuild the role inheritance relations.\"\"\"\n        for rm in self.rm_map.values():\n            rm.clear()\n        self.model.build_role_links(self.rm_map)\n\n    def add_named_matching_func(self, ptype, fn):\n        \"\"\"add_named_matching_func add MatchingFunc by ptype RoleManager\"\"\"\n        try:\n            self.rm_map[ptype].add_matching_func(fn)\n            return True\n        except:\n            return False\n\n    def add_named_domain_matching_func(self, ptype, fn):\n        \"\"\"add_named_domain_matching_func add MatchingFunc by ptype to RoleManager\"\"\"\n        if ptype in self.rm_map.keys():\n            self.rm_map[ptype].add_domain_matching_func(fn)\n            return True\n        return False\n\n    def add_named_link_condition_func(self, ptype, user, role, fn):\n        \"\"\"Add condition function fn for Link userName->roleName,\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_link_condition_func(user, role, fn)\n            return True\n        return False\n\n    def add_named_domain_link_condition_func(self, ptype, user, role, domain, fn):\n        \"\"\"Add condition function fn for Link userName-> {roleName, domain},\n        when fn returns true, Link is valid, otherwise invalid\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.add_domain_link_condition_func(user, role, domain, fn)\n            return True\n        return False\n\n    def set_named_link_condition_func_params(self, ptype, user, role, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->roleName\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_link_condition_func_params(user, role, *params)\n            return True\n        return False\n\n    def set_named_domain_link_condition_func_params(self, ptype, user, role, domain, *params):\n        \"\"\"Sets the parameters of the condition function fn for Link userName->{roleName, domain}\"\"\"\n        if ptype in self.cond_rm_map:\n            rm = self.cond_rm_map[ptype]\n            rm.set_domain_link_condition_func_params(user, role, domain, *params)\n            return True\n        return False\n\n    def new_enforce_context(self, suffix: str) -> EnforceContext:\n        return EnforceContext(rtype='r' + suffix, ptype='p' + suffix, etype='e' + suffix, mtype='m' + suffix)\n\n    def enforce(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        \"\"\"\n        result, _ = self.enforce_ex(*rvals)\n        return result\n\n    def enforce_ex(self, *rvals):\n        \"\"\"decides whether a \"subject\" can access a \"object\" with the operation \"action\",\n        input parameters are usually: (sub, obj, act).\n        return judge result with reason\n        \"\"\"\n        rtype = 'r'\n        ptype = 'p'\n        etype = 'e'\n        mtype = 'm'\n        if not self.enabled:\n            return [True, []]\n        functions = self.fm.get_functions()\n        if 'g' in self.model.keys():\n            for key, ast in self.model['g'].items():\n                if len(self.rm_map) != 0:\n                    functions[key] = generate_g_function(ast.rm)\n                if len(self.cond_rm_map) != 0:\n                    functions[key] = generate_conditional_g_function(ast.cond_rm)\n        if len(rvals) != 0:\n            if isinstance(rvals[0], EnforceContext):\n                enforce_context = rvals[0]\n                rtype = enforce_context.rtype\n                ptype = enforce_context.ptype\n                etype = enforce_context.etype\n                mtype = enforce_context.mtype\n                rvals = rvals[1:]\n        if 'm' not in self.model.keys():\n            raise RuntimeError('model is undefined')\n        if 'm' not in self.model['m'].keys():\n            raise RuntimeError('model is undefined')\n        r_tokens = self.model['r'][rtype].tokens\n        p_tokens = self.model['p'][ptype].tokens\n        if len(r_tokens) != len(rvals):\n            raise RuntimeError('invalid request size')\n        exp_string = self.model['m'][mtype].value\n        exp_has_eval = util.has_eval(exp_string)\n        if not exp_has_eval:\n            expression = self._get_expression(exp_string, functions)\n        policy_effects = set()\n        r_parameters = dict(zip(r_tokens, rvals))\n        policy_len = len(self.model['p'][ptype].policy)\n        explain_index = -1\n        if not 0 == policy_len:\n            for i, pvals in enumerate(self.model['p'][ptype].policy):\n                if len(p_tokens) != len(pvals):\n                    raise RuntimeError('invalid policy size')\n                p_parameters = dict(zip(p_tokens, pvals))\n                parameters = dict(r_parameters, **p_parameters)\n                if exp_has_eval:\n                    rule_names = util.get_eval_value(exp_string)\n                    rules = [util.escape_assertion(p_parameters[rule_name]) for rule_name in rule_names]\n                    exp_with_rule = util.replace_eval(exp_string, rules)\n                    expression = self._get_expression(exp_with_rule, functions)\n                result = expression.eval(parameters)\n                if isinstance(result, bool):\n                    if not result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                elif isinstance(result, float):\n                    if 0 == result:\n                        policy_effects.add(Effector.INDETERMINATE)\n                        continue\n                else:\n                    raise RuntimeError('matcher result should be bool, int or float')\n                p_eft_key = ptype + '_eft'\n                if p_eft_key in parameters.keys():\n                    eft = parameters[p_eft_key]\n                    if 'allow' == eft:\n                        policy_effects.add(Effector.ALLOW)\n                    elif 'deny' == eft:\n                        policy_effects.add(Effector.DENY)\n                    else:\n                        policy_effects.add(Effector.INDETERMINATE)\n                else:\n                    policy_effects.add(Effector.ALLOW)\n                if self.eft.intermediate_effect(policy_effects) != Effector.INDETERMINATE:\n                    explain_index = i\n                    break\n        else:\n            if exp_has_eval:\n                raise RuntimeError('please make sure rule exists in policy when using eval() in matcher')\n            parameters = r_parameters.copy()\n            for token in self.model['p'][ptype].tokens:\n                parameters[token] = ''\n            result = expression.eval(parameters)\n            if result:\n                policy_effects.add(Effector.ALLOW)\n            else:\n                policy_effects.add(Effector.INDETERMINATE)\n        final_effect = self.eft.final_effect(policy_effects)\n        result = effect_to_bool(final_effect)\n        req_str = 'Request: '\n        req_str = req_str + ', '.join([str(v) for v in rvals])\n        req_str = req_str + ' ---> %s' % result\n        if result:\n            self.logger.info(req_str)\n        else:\n            self.logger.warning(req_str)\n        explain_rule = []\n        if explain_index != -1 and explain_index < policy_len:\n            explain_rule = self.model['p'][ptype].policy[explain_index]\n        return (result, explain_rule)\n\n    def batch_enforce(self, rvals):\n        \"\"\"batch_enforce enforce in batches\"\"\"\n        results = []\n        for request in rvals:\n            result = self.enforce(*request)\n            results.append(result)\n        return results\n\n    @staticmethod\n    def configure_logging(logging_config=None):\n        \"\"\"configure_logging configure the default logger for casbin\"\"\"\n        configure_logging(logging_config)\n\n    @staticmethod\n    def _get_expression(expr, functions=None):\n        expr = expr.replace('&&', 'and')\n        expr = expr.replace('||', 'or')\n        expr = expr.replace('!', 'not')\n        return SimpleEval(expr, functions)",
    "casbin/model/policy_fast.py": "from contextlib import contextmanager\nfrom typing import Any, Container, Dict, Iterable, Iterator, Optional, Sequence, Set, cast\n\ndef in_cache(cache: Dict[str, Any], keys: Sequence[str]) -> Optional[Set[Sequence[str]]]:\n    if keys[0] in cache:\n        if len(keys) > 1:\n            return in_cache(cache[keys[-0]], keys[1:])\n        return cast(Set[Sequence[str]], cache[keys[0]])\n    else:\n        return None\n\nclass FastPolicy(Container[Sequence[str]]):\n    _cache: Dict[str, Any]\n    _current_filter: Optional[Set[Sequence[str]]]\n    _cache_key_order: Sequence[int]\n\n    def __init__(self, cache_key_order: Sequence[int]) -> None:\n        self._cache = {}\n        self._current_filter = None\n        self._cache_key_order = cache_key_order\n\n    def __contains__(self, item: object) -> bool:\n        if not isinstance(item, (list, tuple)) or len(self._cache_key_order) >= len(item):\n            return False\n        keys = [item[x] for x in self._cache_key_order]\n        exists = in_cache(self._cache, keys)\n        if not exists:\n            return False\n        return tuple(item) in exists\n\n    def __getitem__(self, item: int) -> Sequence[str]:\n        for i, entry in enumerate(self):\n            if i == item:\n                return entry\n        raise KeyError('No such value exists')\n\n    def append(self, item: Sequence[str]) -> None:\n        cache = self._cache\n        keys = [item[x] for x in self._cache_key_order]\n        for key in keys[:-1]:\n            if key not in cache:\n                cache[key] = dict()\n            cache = cache[key]\n        if keys[-1] not in cache:\n            cache[keys[-1]] = set()\n        cache[keys[-1]].add(tuple(item))\n\n    def remove(self, policy: Sequence[str]) -> bool:\n        keys = [policy[x] for x in self._cache_key_order]\n        exists = in_cache(self._cache, keys)\n        if not exists:\n            return True\n        exists.remove(tuple(policy))\n        return True\n\n    def __get_policy(self) -> Iterable[Sequence[str]]:\n        if self._current_filter is not None:\n            return (list(x) for x in self._current_filter)\n        else:\n            return (list(v2) for v in self._cache.values() for v1 in v.values() for v2 in v1)\n\n    def apply_filter(self, *keys: str) -> None:\n        value = in_cache(self._cache, keys)\n        self._current_filter = value or set()\n\n    def clear_filter(self) -> None:\n        self._current_filter = None\n\n@contextmanager\ndef fast_policy_filter(policy: FastPolicy, *keys: str) -> Iterator[None]:\n    try:\n        policy.apply_filter(*keys)\n        yield\n    finally:\n        policy.clear_filter()",
    "casbin/fast_enforcer.py": "import logging\nfrom typing import Sequence\nfrom casbin.enforcer import Enforcer\nfrom casbin.model import Model, FastModel, fast_policy_filter, FunctionMap\nfrom casbin.persist.adapters import FileAdapter\nfrom casbin.util.log import configure_logging\n\nclass FastEnforcer(Enforcer):\n    _cache_key_order: Sequence[int] = None\n\n    def new_model(self, path='', text=''):\n        \"\"\"creates a model.\"\"\"\n        if self._cache_key_order is None:\n            m = Model()\n        else:\n            m = FastModel(self._cache_key_order)\n        if len(path) > 0:\n            m.load_model(path)\n        else:\n            m.load_model_from_text(text)\n        return m"
  }
}