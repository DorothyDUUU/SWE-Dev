{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_markdown",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/utils/test_markdown.py",
  "test_code": "from mypy_boto3_builder.utils.markdown import Header, TableOfContents, fix_pypi_headers\n\n\nclass TestTableOfContents:\n    def test_render(self) -> None:\n        toc = TableOfContents(\n            [\n                Header(\"a\", 1),\n                Header(\"b\", 3),\n                Header(\"c\", 6),\n            ],\n        )\n        assert toc.render() == \"- [a](#a)\\n    - [b](#b)\"\n\n\nclass TestMarkdown:\n    def test_fix_pypi_headers(self) -> None:\n        assert (\n            fix_pypi_headers(\"# a\\ntest\\n## b\\n## c\\ntest2\")\n            == '<a id=\"a\"></a>\\n\\n# a\\ntest\\n<a id=\"b\"></a>\\n\\n## b\\n<a id=\"c\"></a>\\n\\n## c\\ntest2'\n        )\n        assert fix_pypi_headers(\"# a\\n```## b```\") == '<a id=\"a\"></a>\\n\\n# a\\n```## b```'\n",
  "GT_file_code": {
    "mypy_boto3_builder/utils/markdown.py": "\"\"\"\nUtils for markdown rendering.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable\nfrom typing import Self\n\nfrom mypy_boto3_builder.utils.strings import get_anchor_link\n\n\nclass Header:\n    \"\"\"\n    Markdown header.\n\n    Arguments:\n        title -- Header title\n        level -- Header level, 1-6\n    \"\"\"\n\n    def __init__(self, title: str, level: int) -> None:\n        self.title: str = title\n        self.level: int = level\n\n    @property\n    def anchor(self) -> str:\n        \"\"\"\n        Anchor link for title.\n        \"\"\"\n        return get_anchor_link(self.title)\n\n    def render(self) -> str:\n        \"\"\"\n        Render menu item to string.\n        \"\"\"\n        indent = \"  \" * (self.level - 1)\n        return f\"{indent}- [{self.title}](#{self.anchor})\"\n\n\nclass TableOfContents:\n    \"\"\"\n    MarkDown Table of Contents.\n\n    Arguments:\n        headers -- List of headers\n    \"\"\"\n\n    def __init__(self, headers: Iterable[Header]) -> None:\n        self.headers: list[Header] = list(headers)\n\n    @classmethod\n    def parse(cls, text: str) -> Self:\n        \"\"\"\n        Parse table of Contents for MarkDown text.\n\n        Arguments:\n            text -- MarkDown text.\n        \"\"\"\n        headers: list[Header] = []\n        in_codeblock = False\n        for line in text.splitlines():\n            if line.startswith(\"```\"):\n                in_codeblock = not in_codeblock\n            if in_codeblock:\n                continue\n            if not line.startswith(\"#\"):\n                continue\n\n            level, title = line.split(\" \", 1)\n            headers.append(Header(title.strip(), len(level)))\n\n        return cls(headers)\n\n    def render(self, max_level: int = 3) -> str:\n        \"\"\"\n        Render ToC to string.\n        \"\"\"\n        result: list[str] = []\n        for header in self.headers:\n            if header.level > max_level:\n                continue\n            result.append(header.render())\n        return \"\\n\".join(result)\n\n\ndef fix_pypi_headers(text: str) -> str:\n    \"\"\"\n    Parse table of Contents for MarkDown text.\n\n    Arguments:\n        text -- MarkDown text.\n    \"\"\"\n    result: list[str] = []\n    in_codeblock = False\n    for line in text.splitlines():\n        if line.startswith(\"```\"):\n            in_codeblock = not in_codeblock\n        if in_codeblock:\n            result.append(line)\n            continue\n        if not line.startswith(\"#\"):\n            result.append(line)\n            continue\n\n        level, title = line.split(\" \", 1)\n        header = Header(title.strip(), len(level))\n        result.append(f'<a id=\"{header.anchor}\"></a>\\n\\n{line}')\n\n    return \"\\n\".join(result)\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/utils/markdown.py": {
      "Header.__init__": {
        "code": "    def __init__(self, title: str, level: int) -> None:\n        \"\"\"Initialize a Markdown header with a title and level.\n\nParameters:\n    title (str): The title of the header, which will be used for rendering and creating an anchor link.\n    level (int): The level of the header, ranging from 1 to 6, defining its hierarchy in Markdown.\n\nThis constructor does not return a value. It sets the instance attributes `self.title` and `self.level`, which are used in other methods of the `Header` class, such as `render` and `anchor`. The `level` attribute is crucial for determining the indentation in the rendered output of the header in the Table of Contents.\"\"\"\n        self.title: str = title\n        self.level: int = level",
        "docstring": "Initialize a Markdown header with a title and level.\n\nParameters:\n    title (str): The title of the header, which will be used for rendering and creating an anchor link.\n    level (int): The level of the header, ranging from 1 to 6, defining its hierarchy in Markdown.\n\nThis constructor does not return a value. It sets the instance attributes `self.title` and `self.level`, which are used in other methods of the `Header` class, such as `render` and `anchor`. The `level` attribute is crucial for determining the indentation in the rendered output of the header in the Table of Contents.",
        "signature": "def __init__(self, title: str, level: int) -> None:",
        "type": "Method",
        "class_signature": "class Header:"
      },
      "TableOfContents.__init__": {
        "code": "    def __init__(self, headers: Iterable[Header]) -> None:\n        \"\"\"Initialize a TableOfContents instance with a list of headers.\n\nArgs:\n    headers (Iterable[Header]): An iterable collection of Header objects, which represent the different markdown headers in the document. Each Header object encapsulates a title and its corresponding level, helping in the construction of a structured table of contents.\n\nAttributes:\n    headers (list[Header]): A list that stores the Header objects provided during the initialization, allowing further processing and rendering of the table of contents.\n\nThis constructor is dependent on the Header class defined in this module, which is used to create individual header items for the table of contents.\"\"\"\n        self.headers: list[Header] = list(headers)",
        "docstring": "Initialize a TableOfContents instance with a list of headers.\n\nArgs:\n    headers (Iterable[Header]): An iterable collection of Header objects, which represent the different markdown headers in the document. Each Header object encapsulates a title and its corresponding level, helping in the construction of a structured table of contents.\n\nAttributes:\n    headers (list[Header]): A list that stores the Header objects provided during the initialization, allowing further processing and rendering of the table of contents.\n\nThis constructor is dependent on the Header class defined in this module, which is used to create individual header items for the table of contents.",
        "signature": "def __init__(self, headers: Iterable[Header]) -> None:",
        "type": "Method",
        "class_signature": "class TableOfContents:"
      },
      "TableOfContents.render": {
        "code": "    def render(self, max_level: int=3) -> str:\n        \"\"\"Render the Table of Contents (ToC) as a markdown string.\n\nParameters:\n    max_level (int): The maximum header level to include in the ToC. Default is 3.\n\nReturns:\n    str: A markdown formatted string representing the ToC, including only headers \n    up to the specified maximum level.\n\nThis method iterates through the `headers` attribute, which is a list of `Header` \nobjects initialized in the constructor. It checks the level of each header against \nthe `max_level` parameter, and if it is within the limit, it calls the `render` \nmethod of the `Header` class to generate the appropriate markdown format for that \nheader. The resulting string is a concatenation of all valid header lines, \njoined by newline characters.\"\"\"\n        '\\n        Render ToC to string.\\n        '\n        result: list[str] = []\n        for header in self.headers:\n            if header.level > max_level:\n                continue\n            result.append(header.render())\n        return '\\n'.join(result)",
        "docstring": "Render the Table of Contents (ToC) as a markdown string.\n\nParameters:\n    max_level (int): The maximum header level to include in the ToC. Default is 3.\n\nReturns:\n    str: A markdown formatted string representing the ToC, including only headers \n    up to the specified maximum level.\n\nThis method iterates through the `headers` attribute, which is a list of `Header` \nobjects initialized in the constructor. It checks the level of each header against \nthe `max_level` parameter, and if it is within the limit, it calls the `render` \nmethod of the `Header` class to generate the appropriate markdown format for that \nheader. The resulting string is a concatenation of all valid header lines, \njoined by newline characters.",
        "signature": "def render(self, max_level: int=3) -> str:",
        "type": "Method",
        "class_signature": "class TableOfContents:"
      },
      "fix_pypi_headers": {
        "code": "def fix_pypi_headers(text: str) -> str:\n    \"\"\"Parse and fix headers in Markdown text by adding HTML anchor tags while preserving the original structure. \n\nParameters:\n    text (str): The input Markdown text containing headers and possibly code blocks.\n\nReturns:\n    str: The modified Markdown text with added anchor tags for each header.\n\nThis function uses the `Header` class to create anchor links based on header titles, leveraging the `get_anchor_link` utility to generate proper link identifiers. It identifies code blocks to ensure headers within them remain unchanged.\"\"\"\n    '\\n    Parse table of Contents for MarkDown text.\\n\\n    Arguments:\\n        text -- MarkDown text.\\n    '\n    result: list[str] = []\n    in_codeblock = False\n    for line in text.splitlines():\n        if line.startswith('```'):\n            in_codeblock = not in_codeblock\n        if in_codeblock:\n            result.append(line)\n            continue\n        if not line.startswith('#'):\n            result.append(line)\n            continue\n        level, title = line.split(' ', 1)\n        header = Header(title.strip(), len(level))\n        result.append(f'<a id=\"{header.anchor}\"></a>\\n\\n{line}')\n    return '\\n'.join(result)",
        "docstring": "Parse and fix headers in Markdown text by adding HTML anchor tags while preserving the original structure. \n\nParameters:\n    text (str): The input Markdown text containing headers and possibly code blocks.\n\nReturns:\n    str: The modified Markdown text with added anchor tags for each header.\n\nThis function uses the `Header` class to create anchor links based on header titles, leveraging the `get_anchor_link` utility to generate proper link identifiers. It identifies code blocks to ensure headers within them remain unchanged.",
        "signature": "def fix_pypi_headers(text: str) -> str:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/utils/markdown.py:TableOfContents:render": {
      "mypy_boto3_builder/utils/markdown.py": {
        "Header.render": {
          "code": "    def render(self) -> str:\n        \"\"\"\n        Render menu item to string.\n        \"\"\"\n        indent = '  ' * (self.level - 1)\n        return f'{indent}- [{self.title}](#{self.anchor})'",
          "docstring": "Render menu item to string.",
          "signature": "def render(self) -> str:",
          "type": "Method",
          "class_signature": "class Header:"
        }
      }
    },
    "mypy_boto3_builder/utils/markdown.py:fix_pypi_headers": {
      "mypy_boto3_builder/utils/markdown.py": {
        "Header.anchor": {
          "code": "    def anchor(self) -> str:\n        \"\"\"\n        Anchor link for title.\n        \"\"\"\n        return get_anchor_link(self.title)",
          "docstring": "Anchor link for title.",
          "signature": "def anchor(self) -> str:",
          "type": "Method",
          "class_signature": "class Header:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_markdown\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 utils/\n        \u2514\u2500\u2500 markdown.py\n            \u251c\u2500\u2500 Header.__init__\n            \u251c\u2500\u2500 TableOfContents.__init__\n            \u251c\u2500\u2500 TableOfContents.render\n            \u2514\u2500\u2500 fix_pypi_headers\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides utilities for managing and enhancing Markdown content, specifically tailored for use cases involving PyPI documentation or similar structured outputs. It enables the generation and rendering of dynamic Table of Contents sections based on defined headers, ensuring clear navigation and organization of Markdown documents. Additionally, it offers functionality to process and modify Markdown headers to comply with PyPI's formatting requirements, such as inserting anchor tags for improved accessibility and compatibility. This module simplifies the creation of well-structured, standardized documentation, reducing the manual effort required for developers and enhancing the end-user experience with consistent formatting and navigable content.\n\n## FILE 1: mypy_boto3_builder/utils/markdown.py\n\n- CLASS METHOD: TableOfContents.__init__\n  - CLASS SIGNATURE: class TableOfContents:\n  - SIGNATURE: def __init__(self, headers: Iterable[Header]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TableOfContents instance with a list of headers.\n\nArgs:\n    headers (Iterable[Header]): An iterable collection of Header objects, which represent the different markdown headers in the document. Each Header object encapsulates a title and its corresponding level, helping in the construction of a structured table of contents.\n\nAttributes:\n    headers (list[Header]): A list that stores the Header objects provided during the initialization, allowing further processing and rendering of the table of contents.\n\nThis constructor is dependent on the Header class defined in this module, which is used to create individual header items for the table of contents.\n\"\"\"\n```\n\n- CLASS METHOD: Header.__init__\n  - CLASS SIGNATURE: class Header:\n  - SIGNATURE: def __init__(self, title: str, level: int) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Markdown header with a title and level.\n\nParameters:\n    title (str): The title of the header, which will be used for rendering and creating an anchor link.\n    level (int): The level of the header, ranging from 1 to 6, defining its hierarchy in Markdown.\n\nThis constructor does not return a value. It sets the instance attributes `self.title` and `self.level`, which are used in other methods of the `Header` class, such as `render` and `anchor`. The `level` attribute is crucial for determining the indentation in the rendered output of the header in the Table of Contents.\n\"\"\"\n```\n\n- CLASS METHOD: TableOfContents.render\n  - CLASS SIGNATURE: class TableOfContents:\n  - SIGNATURE: def render(self, max_level: int=3) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the Table of Contents (ToC) as a markdown string.\n\nParameters:\n    max_level (int): The maximum header level to include in the ToC. Default is 3.\n\nReturns:\n    str: A markdown formatted string representing the ToC, including only headers \n    up to the specified maximum level.\n\nThis method iterates through the `headers` attribute, which is a list of `Header` \nobjects initialized in the constructor. It checks the level of each header against \nthe `max_level` parameter, and if it is within the limit, it calls the `render` \nmethod of the `Header` class to generate the appropriate markdown format for that \nheader. The resulting string is a concatenation of all valid header lines, \njoined by newline characters.\n\"\"\"\n```\n\n- FUNCTION NAME: fix_pypi_headers\n  - SIGNATURE: def fix_pypi_headers(text: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nParse and fix headers in Markdown text by adding HTML anchor tags while preserving the original structure. \n\nParameters:\n    text (str): The input Markdown text containing headers and possibly code blocks.\n\nReturns:\n    str: The modified Markdown text with added anchor tags for each header.\n\nThis function uses the `Header` class to create anchor links based on header titles, leveraging the `get_anchor_link` utility to generate proper link identifiers. It identifies code blocks to ensure headers within them remain unchanged.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/markdown.py:Header:__init__\n    - mypy_boto3_builder/utils/markdown.py:Header:anchor\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/utils/markdown.py": "\"\"\"\nUtils for markdown rendering.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable\nfrom typing import Self\nfrom mypy_boto3_builder.utils.strings import get_anchor_link\n\nclass Header:\n    \"\"\"\n    Markdown header.\n\n    Arguments:\n        title -- Header title\n        level -- Header level, 1-6\n    \"\"\"\n\n    @property\n    def anchor(self) -> str:\n        \"\"\"\n        Anchor link for title.\n        \"\"\"\n        return get_anchor_link(self.title)\n\n    def render(self) -> str:\n        \"\"\"\n        Render menu item to string.\n        \"\"\"\n        indent = '  ' * (self.level - 1)\n        return f'{indent}- [{self.title}](#{self.anchor})'\n\nclass TableOfContents:\n    \"\"\"\n    MarkDown Table of Contents.\n\n    Arguments:\n        headers -- List of headers\n    \"\"\"\n\n    @classmethod\n    def parse(cls, text: str) -> Self:\n        \"\"\"\n        Parse table of Contents for MarkDown text.\n\n        Arguments:\n            text -- MarkDown text.\n        \"\"\"\n        headers: list[Header] = []\n        in_codeblock = False\n        for line in text.splitlines():\n            if line.startswith('```'):\n                in_codeblock = not in_codeblock\n            if in_codeblock:\n                continue\n            if not line.startswith('#'):\n                continue\n            level, title = line.split(' ', 1)\n            headers.append(Header(title.strip(), len(level)))\n        return cls(headers)"
  },
  "call_tree": {
    "tests/utils/test_markdown.py:TestTableOfContents:test_render": {
      "mypy_boto3_builder/utils/markdown.py:Header:__init__": {},
      "mypy_boto3_builder/utils/markdown.py:TableOfContents:__init__": {},
      "mypy_boto3_builder/utils/markdown.py:TableOfContents:render": {
        "mypy_boto3_builder/utils/markdown.py:Header:render": {
          "mypy_boto3_builder/utils/markdown.py:Header:anchor": {
            "mypy_boto3_builder/utils/strings.py:get_anchor_link": {}
          }
        }
      }
    },
    "tests/utils/test_markdown.py:TestMarkdown:test_fix_pypi_headers": {
      "mypy_boto3_builder/utils/markdown.py:fix_pypi_headers": {
        "mypy_boto3_builder/utils/markdown.py:Header:__init__": {},
        "mypy_boto3_builder/utils/markdown.py:Header:anchor": {
          "mypy_boto3_builder/utils/strings.py:get_anchor_link": {}
        }
      }
    }
  }
}