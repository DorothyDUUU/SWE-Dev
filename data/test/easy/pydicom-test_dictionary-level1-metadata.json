{
  "dir_path": "/app/pydicom",
  "package_name": "pydicom",
  "sample_name": "pydicom-test_dictionary",
  "src_dir": "pydicom/src/pydicom/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_dictionary.py",
  "test_code": "# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n\"\"\"Test for datadict.py\"\"\"\n\nimport pytest\n\nfrom pydicom import DataElement\nfrom pydicom.dataset import Dataset\nfrom pydicom.datadict import (\n    keyword_for_tag,\n    dictionary_description,\n    dictionary_has_tag,\n    repeater_has_tag,\n    repeater_has_keyword,\n    get_private_entry,\n    dictionary_VM,\n    private_dictionary_VR,\n    private_dictionary_VM,\n    add_private_dict_entries,\n    add_private_dict_entry,\n    _dictionary_vr_fast,\n)\nfrom pydicom.datadict import add_dict_entry, add_dict_entries\nfrom .test_util import save_private_dict\n\n\nclass TestDict:\n    def test_tag_not_found(self):\n        \"\"\"dicom_dictionary: CleanName returns blank string for unknown tag\"\"\"\n        assert \"\" == keyword_for_tag(0x99991111)\n\n    def test_repeaters(self):\n        \"\"\"dicom_dictionary: Tags with \"x\" return correct dict info........\"\"\"\n        assert \"Transform Label\" == dictionary_description(0x280400)\n        assert \"Rows For Nth Order Coefficients\" == dictionary_description(0x280410)\n\n    def test_dict_has_tag(self):\n        \"\"\"Test dictionary_has_tag\"\"\"\n        assert dictionary_has_tag(0x00100010)\n        assert not dictionary_has_tag(0x11110010)\n        assert dictionary_has_tag(\"PatientName\")\n        assert not dictionary_has_tag(\"PatientMane\")\n\n    def test_repeater_has_tag(self):\n        \"\"\"Test repeater_has_tag\"\"\"\n        assert repeater_has_tag(0x60000010)\n        assert repeater_has_tag(0x60020010)\n        assert not repeater_has_tag(0x00100010)\n\n    def test_repeater_has_keyword(self):\n        \"\"\"Test repeater_has_keyword\"\"\"\n        assert repeater_has_keyword(\"OverlayData\")\n        assert not repeater_has_keyword(\"PixelData\")\n\n    def test_get_private_entry(self):\n        \"\"\"Test get_private_entry\"\"\"\n        # existing entry\n        entry = get_private_entry((0x0903, 0x0011), \"GEIIS PACS\")\n        assert \"US\" == entry[0]  # VR\n        assert \"1\" == entry[1]  # VM\n        assert \"Significant Flag\" == entry[2]  # name\n        assert not entry[3]  # is retired\n\n        # existing entry in another slot\n        entry = get_private_entry((0x0903, 0x1011), \"GEIIS PACS\")\n        assert \"Significant Flag\" == entry[2]  # name\n\n        # non-existing entry\n        with pytest.raises(KeyError):\n            get_private_entry((0x0903, 0x0011), \"Nonexisting\")\n        with pytest.raises(KeyError):\n            get_private_entry((0x0903, 0x0091), \"GEIIS PACS\")\n\n    def test_add_entry(self):\n        \"\"\"dicom_dictionary: Can add and use a single dictionary entry\"\"\"\n        add_dict_entry(0x10021001, \"UL\", \"TestOne\", \"Test One\")\n        add_dict_entry(0x10021002, \"DS\", \"TestTwo\", \"Test Two\", VM=\"3\")\n        ds = Dataset()\n        ds.TestOne = 42\n        ds.TestTwo = [\"1\", \"2\", \"3\"]\n\n    def test_add_entry_raises_for_private_tag(self):\n        with pytest.raises(\n            ValueError, match='Private tags cannot be added using \"add_dict_entries\"'\n        ):\n            add_dict_entry(0x10011101, \"DS\", \"Test One\", \"Test One\")\n\n    def test_add_entries(self):\n        \"\"\"dicom_dictionary: add and use a dict of new dictionary entries\"\"\"\n        new_dict_items = {\n            0x10021001: (\"UL\", \"1\", \"Test One\", \"\", \"TestOne\"),\n            0x10021002: (\"DS\", \"3\", \"Test Two\", \"\", \"TestTwo\"),\n        }\n        add_dict_entries(new_dict_items)\n        ds = Dataset()\n        ds.TestOne = 42\n        ds.TestTwo = [\"1\", \"2\", \"3\"]\n\n    def test_add_entries_raises_for_private_tags(self):\n        new_dict_items = {\n            0x10021001: (\"UL\", \"1\", \"Test One\", \"\", \"TestOne\"),\n            0x10011002: (\"DS\", \"3\", \"Test Two\", \"\", \"TestTwo\"),\n        }\n        with pytest.raises(\n            ValueError, match='Private tags cannot be added using \"add_dict_entries\"'\n        ):\n            add_dict_entries(new_dict_items)\n\n    def test_add_private_entry(self):\n        with save_private_dict():\n            add_private_dict_entry(\"ACME 3.1\", 0x10011101, \"DS\", \"Test One\", \"3\")\n            entry = get_private_entry((0x1001, 0x0001), \"ACME 3.1\")\n            assert \"DS\" == entry[0]  # VR\n            assert \"3\" == entry[1]  # VM\n            assert \"Test One\" == entry[2]  # description\n\n    def test_add_private_entry_raises_for_non_private_tag(self):\n        msg = (\n            r\"Non-private tags cannot be added using \"\n            r\"'add_private_dict_entries\\(\\)' \\- use \"\n            r\"'add_dict_entries\\(\\)' instead\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            add_private_dict_entry(\"ACME 3.1\", 0x10021101, \"DS\", \"Test One\")\n\n    def test_add_private_entries(self):\n        \"\"\"dicom_dictionary: add and use a dict of new dictionary entries\"\"\"\n        new_dict_items = {\n            0x10011001: (\n                \"SH\",\n                \"1\",\n                \"Test One\",\n            ),\n            0x10011002: (\"DS\", \"3\", \"Test Two\", \"\", \"TestTwo\"),\n        }\n        add_private_dict_entries(\"ACME 3.1\", new_dict_items)\n        ds = Dataset()\n        ds[0x10010010] = DataElement(0x10010010, \"LO\", \"ACME 3.1\")\n        ds[0x10011001] = DataElement(0x10011001, \"SH\", \"Test\")\n        ds[0x10011002] = DataElement(0x10011002, \"DS\", \"1\\\\2\\\\3\")\n\n        assert \"Test\" == ds[0x10011001].value\n        assert [1, 2, 3] == ds[0x10011002].value\n\n    def test_add_private_entries_raises_for_non_private_tags(self):\n        new_dict_items = {\n            0x10021001: (\"UL\", \"1\", \"Test One\", \"\", \"TestOne\"),\n            0x10011002: (\"DS\", \"3\", \"Test Two\", \"\", \"TestTwo\"),\n        }\n        msg = (\n            r\"Non-private tags cannot be added using \"\n            r\"'add_private_dict_entries\\(\\)' \\- use \"\n            r\"'add_dict_entries\\(\\)' instead\"\n        )\n        with pytest.raises(ValueError, match=msg):\n            add_private_dict_entries(\"ACME 3.1\", new_dict_items)\n\n    def test_dictionary_VM(self):\n        \"\"\"Test dictionary_VM\"\"\"\n        assert dictionary_VM(0x00000000) == \"1\"\n        assert dictionary_VM(0x00081163) == \"2\"\n        assert dictionary_VM(0x0000901) == \"1-n\"\n        assert dictionary_VM(0x00041141) == \"1-8\"\n        assert dictionary_VM(0x00080008) == \"2-n\"\n        assert dictionary_VM(0x00080309) == \"1-3\"\n        assert dictionary_VM(0x00081162) == \"3-3n\"\n\n    def test_private_dict_VR(self):\n        \"\"\"Test private_dictionary_VR\"\"\"\n        assert private_dictionary_VR(0x00090000, \"ACUSON\") == \"IS\"\n\n    def test_private_dict_VM(self):\n        \"\"\"Test private_dictionary_VM\"\"\"\n        assert private_dictionary_VM(0x00090000, \"ACUSON\") == \"1\"\n\n    def test_dictionary_vr_fast(self):\n        \"\"\"Test _dictionary_vr_fast().\"\"\"\n        assert _dictionary_vr_fast(0x00100010) == \"PN\"\n        assert _dictionary_vr_fast(0x60000010) == \"US\"  # masked\n        msg = r\"Tag \\(0009,0003\\) not found in DICOM dictionary\"\n        with pytest.raises(KeyError, match=msg):\n            _dictionary_vr_fast(0x00090003)\n\n        msg = r\"Tag \\(50F1,0010\\) not found in DICOM dictionary\"\n        with pytest.raises(KeyError, match=msg):\n            _dictionary_vr_fast(0x50F10010)\n",
  "GT_file_code": {
    "modified_testcases/test_util.py": "# Copyright 2008-2021 pydicom authors. See LICENSE file for details.\n\"\"\"Test suite for util functions\"\"\"\nimport copy\nfrom contextlib import contextmanager\nfrom io import BytesIO\nimport os\n\nimport pytest\n\nfrom pydicom import config, dcmread, Dataset, Sequence\nfrom pydicom import filereader\nfrom pydicom._private_dict import private_dictionaries\nfrom pydicom.data import get_testdata_file\nfrom pydicom.dataelem import DataElement\nfrom pydicom.tag import Tag\nfrom pydicom.uid import (\n    ImplicitVRLittleEndian,\n    ExplicitVRBigEndian,\n    ExplicitVRLittleEndian,\n)\nfrom pydicom.util import fixer\nfrom pydicom.util import hexutil\nfrom pydicom.util.codify import (\n    camel_to_underscore,\n    tag_repr,\n    default_name_filter,\n    code_imports,\n    code_dataelem,\n    code_dataset,\n    main as codify_main,\n    code_file_from_dataset,\n)\nfrom pydicom.util.dump import (\n    print_character,\n    filedump,\n    datadump,\n    hexdump,\n    pretty_print,\n)\nfrom pydicom.util.hexutil import hex2bytes, bytes2hex\nfrom pydicom.util.leanread import dicomfile\n\nhave_numpy = True\ntry:\n    import numpy\nexcept ImportError:\n    have_numpy = False\n\ntest_dir = os.path.dirname(__file__)\nraw_hex_module = os.path.join(test_dir, \"_write_stds.py\")\nraw_hex_code = open(raw_hex_module, \"rb\").read()\n\n\n# For Python >=3.11, this can be imported from contextlib\n@contextmanager\ndef chdir(new_dir):\n    import os\n\n    old_dir = os.getcwd()\n    try:\n        os.chdir(new_dir)\n        yield\n    finally:\n        os.chdir(old_dir)\n\n\nclass TestCodify:\n    \"\"\"Test the utils.codify module\"\"\"\n\n    def test_camel_to_underscore(self):\n        \"\"\"Test utils.codify.camel_to_underscore\"\"\"\n        input_str = [\"TheNameToConvert\", \"Some12Variable_Name\"]\n        output_str = [\"the_name_to_convert\", \"some12_variable__name\"]\n        for in_str, out_str in zip(input_str, output_str):\n            assert out_str == camel_to_underscore(in_str)\n\n    def test_tag_repr(self):\n        \"\"\"Test utils.codify.tag_repr\"\"\"\n        input_tag = [0x00000000, 0x00100010, 0x7FE00010, 0x11110001]\n        output_str = [\n            \"(0x0000, 0x0000)\",\n            \"(0x0010, 0x0010)\",\n            \"(0x7FE0, 0x0010)\",\n            \"(0x1111, 0x0001)\",\n        ]\n        for tag, out_str in zip(input_tag, output_str):\n            assert out_str == tag_repr(Tag(tag))\n\n    def test_default_name_filter(self):\n        \"\"\"Test utils.codify.default_name_filter\"\"\"\n        input_keyword = [\"ControlPointSet\", \"ReferenceDataSet\", \"FractionGroupThing\"]\n        output_str = [\"cp_set\", \"ref_data_set\", \"frxn_gp_thing\"]\n        for in_str, out_str in zip(input_keyword, output_str):\n            assert out_str == default_name_filter(in_str)\n\n    def test_code_imports(self):\n        \"\"\"Test utils.codify.code_imports\"\"\"\n        out = [\"import pydicom\"]\n        out.append(\"from pydicom.dataset import Dataset, FileMetaDataset\")\n        out.append(\"from pydicom.sequence import Sequence\")\n        assert \"\\n\".join(out) == code_imports()\n\n    def test_code_dataelem_standard(self):\n        \"\"\"Test utils.codify.code_dataelem for standard element\"\"\"\n        # Element keyword in data dictionary\n        input_elem = [\n            DataElement(0x00100010, \"PN\", \"CITIZEN\"),\n            DataElement(0x0008010C, \"UI\", \"1.1.2.3.4.5\"),\n            DataElement(0x00080301, \"US\", 1200),\n        ]\n        out_str = [\n            \"ds.PatientName = 'CITIZEN'\",\n            \"ds.CodingSchemeUID = '1.1.2.3.4.5'\",\n            \"ds.PrivateGroupReference = 1200\",\n        ]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem)\n\n    def test_code_dataelem_exclude_size(self):\n        \"\"\"Test utils.codify.code_dataelem exclude_size param\"\"\"\n        input_elem = [\n            DataElement(0x00100010, \"OB\", b\"CITIZEN\"),\n            DataElement(0x0008010C, \"UI\", \"1.1\"),\n            DataElement(0x00200011, \"IS\", 3),\n        ]\n        # Fails\n        # DataElement(0x00080301, 'US', 1200)]\n        out_str = [\n            \"ds.PatientName = # XXX Array of 7 bytes excluded\",\n            \"ds.CodingSchemeUID = '1.1'\",\n            \"ds.SeriesNumber = '3'\",\n        ]\n        # Fails\n        # \"ds.PrivateGroupReference = 1200\"]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem, exclude_size=4)\n\n    def test_code_dataelem_private(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        # Element keyword not in data dictionary\n        input_elem = [\n            DataElement(0x00111010, \"PN\", \"CITIZEN\"),\n            DataElement(0x0081010C, \"UI\", \"1.1.2.3.4.5\"),\n            DataElement(0x11110301, \"US\", 1200),\n        ]\n        out_str = [\n            \"ds.add_new((0x0011, 0x1010), 'PN', 'CITIZEN')\",\n            \"ds.add_new((0x0081, 0x010C), 'UI', '1.1.2.3.4.5')\",\n            \"ds.add_new((0x1111, 0x0301), 'US', 1200)\",\n        ]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem)\n\n    def test_code_dataelem_sequence(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        # ControlPointSequence\n        elem = DataElement(0x300A0111, \"SQ\", [])\n        out = \"\\n# Control Point Sequence\\n\"\n        out += \"cp_sequence = Sequence()\\n\"\n        out += \"ds.ControlPointSequence = cp_sequence\"\n        assert out == code_dataelem(elem)\n\n    def test_code_sequence(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        # ControlPointSequence\n        elem = DataElement(0x300A0111, \"SQ\", [])\n        elem.value.append(Dataset())\n        elem.value[0].PatientID = \"1234\"\n        out = (\n            \"\\n\"\n            \"# Control Point Sequence\\n\"\n            \"cp_sequence = Sequence()\\n\"\n            \"ds.ControlPointSequence = cp_sequence\\n\"\n            \"\\n\"\n            \"# Control Point Sequence: Control Point 1\\n\"\n            \"cp1 = Dataset()\\n\"\n            \"cp_sequence.append(cp1)\\n\"\n            \"cp1.PatientID = '1234'\"\n        )\n\n        assert out == code_dataelem(elem)\n\n    def test_codify_recurring_keyword(self):\n        \"\"\"Test utils.codify.code_dataset with same keyword nested\"\"\"\n        # Create fake Dataset with repeated DICOM keyword nested\n        # (0040,A730)  Content Sequence  1 item(s) ----\n        #    (0040,A040) Value Type                          CS: 'CODE'\n        #    (0040,A730)  Content Sequence  1 item(s) ----\n        #       (0040,A040) Value Type                          CS: 'CODE'\n\n        ds = Dataset()\n        ds.ContentSequence = seq1 = Sequence()\n        seq1.append(Dataset())\n        seq1[0].ValueType = \"CODE\"\n        seq1[0].ContentSequence = seq2 = Sequence()\n        seq2.append(Dataset())\n        seq2[0].ValueType = \"CODE_1\"\n        ds_code = code_dataset(ds)\n\n        # normal 1st use of var name\n        assert \"content1.ValueType = 'CODE'\" in ds_code\n\n        # Nested item of same name should have subscript\n        assert \"content1_1.ValueType = 'CODE_1'\" in ds_code\n\n    def test_code_file(self, capsys):\n        \"\"\"Test utils.codify.code_file\"\"\"\n        filename = get_testdata_file(\"rtplan.dcm\")\n        args = [filename]\n        codify_main(100, args)\n        out, err = capsys.readouterr()\n        assert r\"rtplan_from_codify.dcm\" in out\n\n    def test_code_file_save_as(self, capsys):\n        \"\"\"Test utils.codify.code_file\"\"\"\n        filename = get_testdata_file(\"rtplan.dcm\")\n        args = [\"--save-as\", r\"c:\\temp\\testout.dcm\", filename]\n        codify_main(100, args)\n        out, err = capsys.readouterr()\n        assert r\"c:\\temp\\testout.dcm\" in out\n\n    def test_code_file_deflated(self, capsys):\n        \"\"\"Test utils.codify.code_file with a deflated dataset\"\"\"\n        filename = get_testdata_file(\"image_dfl.dcm\")\n        args = [filename]\n        codify_main(100, args)\n        out, err = capsys.readouterr()\n        assert r\"image_dfl_from_codify.dcm\" in out\n\n    def test_code_relative_filename(self, capsys):\n        \"\"\"Test utils.codify.code_file with a relative path that doesn't exist\"\"\"\n        # regression test for #1865\n        args = [\"XXxUN_sequenceXX.dcm\"]  # file that doesn't exist\n        with pytest.raises(SystemExit):\n            codify_main(100, args)\n\n    def test_code_dataelem_at(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        elem = DataElement(0x00000901, \"AT\", (0x1234, 0x5678))\n        out = \"ds.OffendingElement = (0x1234, 0x5678)\"\n        assert out == code_dataelem(elem)\n\n\nclass TestDump:\n    \"\"\"Test the utils.dump module\"\"\"\n\n    def test_print_character(self):\n        \"\"\"Test utils.dump.print_character\"\"\"\n        assert print_character(0x30) == \"0\"\n        assert print_character(0x31) == \"1\"\n        assert print_character(0x39) == \"9\"\n        assert print_character(0x41) == \"A\"\n        assert print_character(0x5A) == \"Z\"\n        assert print_character(0x61) == \"a\"\n        assert print_character(0x7A) == \"z\"\n        assert print_character(0x00) == \".\"\n\n    def test_filedump(self):\n        \"\"\"Test utils.dump.filedump\"\"\"\n        p = get_testdata_file(\"CT_small.dcm\")\n        s = filedump(p, start_address=500, stop_address=1000)\n\n        assert (\n            \"000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........\"\n        ) not in s\n        assert (\n            \"1F4  2E 31 2E 31 2E 31 2E 31 2E 32 30 30 34 30 31 31  .1.1.1.1.2004011\"\n        ) in s\n\n    def test_datadump(self):\n        \"\"\"Test utils.dump.datadump\"\"\"\n        p = get_testdata_file(\"CT_small.dcm\")\n        with open(p, \"rb\") as f:\n            s = datadump(f.read(), 500, 1000)\n\n        assert (\n            \"1F4  2E 31 2E 31 2E 31 2E 31 2E 32 30 30 34 30 31 31  .1.1.1.1.2004011\"\n        ) in s\n\n    def test_hexdump(self):\n        \"\"\"Test utils.dump.hexdump\"\"\"\n        # Default\n        p = get_testdata_file(\"CT_small.dcm\")\n        with open(p, \"rb\") as f:\n            s = hexdump(f)\n\n        assert (\n            \"0000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........\"\n        ) in s\n        assert (\n            \"0170  41 4C 5C 50 52 49 4D 41 52 59 5C 41 58 49 41 4C  AL.PRIMARY.AXIAL\"\n        ) in s\n        assert (\"9920  08 00 00 00 00 00                                ......\") in s\n\n        # `stop_address` parameter\n        with open(p, \"rb\") as f:\n            s = hexdump(f, stop_address=1000)\n\n        assert (\n            \"000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........\"\n        ) in s\n        assert (\n            \"170  41 4C 5C 50 52 49 4D 41 52 59 5C 41 58 49 41 4C  AL.PRIMARY.AXIAL\"\n        ) in s\n        assert (\n            \"9920  08 00 00 00 00 00                                ......\"\n        ) not in s\n\n        # `show_address` parameter\n        with open(p, \"rb\") as f:\n            s = hexdump(f, show_address=False, stop_address=1000)\n\n        assert (\n            \"49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........\"\n        ) in s\n        assert (\n            \"000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........\"\n        ) not in s\n\n        # `start_address` parameter\n        with open(p, \"rb\") as f:\n            s = hexdump(f, start_address=500, stop_address=1000)\n\n        assert (\n            \"000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........\"\n        ) not in s\n        assert (\n            \"1F4  2E 31 2E 31 2E 31 2E 31 2E 32 30 30 34 30 31 31  .1.1.1.1.2004011\"\n        ) in s\n\n    def test_pretty_print(self, capsys):\n        \"\"\"Test utils.dump.pretty_print\"\"\"\n        ds = get_testdata_file(\"CT_small.dcm\", read=True)\n        pretty_print(ds)\n\n        s = capsys.readouterr().out\n        assert (\"(0008,0005) Specific Character Set              CS: 'ISO_IR 100'\") in s\n        assert (\"(0010,1002) Other Patient IDs Sequence -- 2 item(s)\") in s\n        assert (\"  (0010,0022) Type of Patient ID                  CS: 'TEXT'\") in s\n        assert (\n            \"(FFFC,FFFC) Data Set Trailing Padding           OB: Array of \"\n            \"126 elements\"\n        ) in s\n\n\nclass TestHexUtil:\n    \"\"\"Test the utils.hexutil module\"\"\"\n\n    def test_hex_to_bytes(self):\n        \"\"\"Test utils.hexutil.hex2bytes\"\"\"\n        hexstring = \"00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\"\n        bytestring = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\"\n        assert hex2bytes(hexstring) == bytestring\n\n        hexstring = \"00 10 20 30 40 50 60 70 80 90 A0 B0 C0 D0 E0 F0\"\n        bytestring = b\"\\x00\\x10\\x20\\x30\\x40\\x50\\x60\\x70\\x80\\x90\\xA0\\xB0\\xC0\\xD0\\xE0\\xF0\"\n        assert hex2bytes(hexstring) == bytestring\n\n        hexstring = b\"00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\"\n        bytestring = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\"\n        assert hex2bytes(hexstring) == bytestring\n\n        with pytest.raises(TypeError):\n            hex2bytes(0x1234)\n\n    def test_bytes_to_hex(self):\n        \"\"\"Test utils.hexutil.hex2bytes\"\"\"\n        hexstring = \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\"\n        bytestring = b\"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0A\\x0B\\x0C\\x0D\\x0E\\x0F\"\n        assert bytes2hex(bytestring) == hexstring\n\n        hexstring = \"00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0\"\n        bytestring = b\"\\x00\\x10\\x20\\x30\\x40\\x50\\x60\\x70\\x80\\x90\\xA0\\xB0\\xC0\\xD0\\xE0\\xF0\"\n        assert bytes2hex(bytestring) == hexstring\n\n\nclass TestDataElementCallbackTests:\n    def setup_method(self):\n        # Set up a dataset with commas in one item instead of backslash\n        namespace = {}\n        exec(raw_hex_code, {}, namespace)\n        ds_bytes = hexutil.hex2bytes(namespace[\"impl_LE_deflen_std_hex\"])\n        # Change \"2\\4\\8\\16\" to \"2,4,8,16\"\n        ds_bytes = ds_bytes.replace(\n            b\"\\x32\\x5c\\x34\\x5c\\x38\\x5c\\x31\\x36\", b\"\\x32\\x2c\\x34\\x2c\\x38\\x2c\\x31\\x36\"\n        )\n        self.ds_bytes = ds_bytes\n\n        self.bytesio = BytesIO(ds_bytes)\n\n    def teardown_method(self):\n        config.reset_data_element_callback()\n\n    def test_bad_separator(self, enforce_valid_values):\n        \"\"\"Ensure that unchanged bad separator does raise an error...\"\"\"\n        ds = filereader.read_dataset(\n            self.bytesio, is_little_endian=True, is_implicit_VR=True\n        )\n        contour = ds.ROIContourSequence[0].ContourSequence[0]\n        with pytest.raises(ValueError):\n            getattr(contour, \"ContourData\")\n\n    def test_impl_vr_comma(self):\n        \"\"\"util.fix_separator: Able to replace comma in Implicit VR dataset..\"\"\"\n        fixer.fix_separator(b\",\", for_VRs=[\"DS\", \"IS\"], process_unknown_VRs=False)\n        ds = filereader.read_dataset(\n            self.bytesio, is_little_endian=True, is_implicit_VR=True\n        )\n        got = ds.ROIContourSequence[0].ContourSequence[0].ContourData\n        expected = [2.0, 4.0, 8.0, 16.0]\n        if have_numpy and config.use_DS_numpy:\n            assert numpy.allclose(expected, got)\n        else:\n            assert expected == got\n\n    def test_null_value_for_fixed_vr(self):\n        # Wipe first Contour Data, mark as length 0\n        null_ds_bytes = self.ds_bytes.replace(b\"\\x08\\x00\\x00\\x00\", b\"\\x00\\x00\\x00\\x00\")\n        contour_data = b\"\\x32\\x2c\\x34\\x2c\\x38\\x2c\\x31\\x36\"\n        null_ds_bytes = null_ds_bytes.replace(contour_data, b\"\")\n        fixer.fix_separator(b\",\", for_VRs=[\"DS\", \"IS\"], process_unknown_VRs=False)\n        ds = filereader.read_dataset(\n            BytesIO(null_ds_bytes), is_little_endian=True, is_implicit_VR=True\n        )\n\n        assert ds.ROIContourSequence[0].ContourSequence[0].ContourData is None\n\n    def test_space_delimiter(self):\n        # Change \"32\\64\\128\\196\" to \"32 64 128 196\", keeping the trailing space\n        existing = b\"\\x33\\x32\\x5c\\x36\\x34\\x5c\\x31\\x32\\x38\\x5c\\x31\\x39\\x36\\x20\"\n        spaced = b\"\\x33\\x32\\x20\\x36\\x34\\x20\\x31\\x32\\x38\\x20\\x31\\x39\\x36\\x20\"\n        space_ds_bytes = self.ds_bytes.replace(existing, spaced)\n        fixer.fix_separator(b\" \", for_VRs=[\"DS\", \"IS\"], process_unknown_VRs=False)\n        ds = filereader.read_dataset(\n            BytesIO(space_ds_bytes), is_little_endian=True, is_implicit_VR=True\n        )\n        got = ds.ROIContourSequence[0].ContourSequence[1].ContourData\n\n        expected = [32.0, 64.0, 128.0, 196.0]\n        if have_numpy and config.use_DS_numpy:\n            assert numpy.allclose(expected, got)\n        else:\n            assert expected == got\n\n    @pytest.mark.filterwarnings(\"ignore:Unknown DICOM tag\")\n    def test_process_unknown_vr(self):\n        bad_vr_bytes = self.ds_bytes\n        # tag (0900,0010), length 4, value \"1,2\"\n        bad_vr_bytes += b\"\\x00\\x09\\x10\\x00\\x04\\x00\\x00\\x00\\x31\\x2c\\x32\\x20\"\n        fixer.fix_separator(b\",\", for_VRs=[\"DS\", \"IS\"], process_unknown_VRs=True)\n        ds = filereader.read_dataset(\n            BytesIO(bad_vr_bytes), is_little_endian=True, is_implicit_VR=True\n        )\n\n        msg = (\n            r\"VR lookup failed for the raw element with tag \\(0900,0010\\) - setting \"\n            \"VR to 'UN'\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            got = ds.get((0x0900, 0x0010))\n            assert got.value == b\"1\\\\2 \"\n\n        # with process_unknown_VRs=False, unknown VR separator is not replaced\n        fixer.fix_separator(b\",\", for_VRs=[\"DS\", \"IS\"], process_unknown_VRs=False)\n        ds = filereader.read_dataset(\n            BytesIO(bad_vr_bytes), is_little_endian=True, is_implicit_VR=True\n        )\n\n        msg = (\n            r\"VR lookup failed for the raw element with tag \\(0900,0010\\) - setting \"\n            \"VR to 'UN'\"\n        )\n        with pytest.warns(UserWarning, match=msg):\n            got = ds.get((0x0900, 0x0010))\n            assert got.value == b\"1,2 \"\n\n\nclass TestLeanRead:\n    def test_explicit_little(self):\n        p = get_testdata_file(\"CT_small.dcm\")\n        ds = dcmread(p)\n        assert ds.file_meta.TransferSyntaxUID == ExplicitVRLittleEndian\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            for elem in ds:\n                if elem[0] == (0x7FE0, 0x0010):\n                    assert elem[2] == 32768\n\n    def test_implicit_little(self):\n        p = get_testdata_file(\"MR_small_implicit.dcm\")\n        ds = dcmread(p)\n        assert ds.file_meta.TransferSyntaxUID == ImplicitVRLittleEndian\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            for elem in ds:\n                if elem[0] == (0x7FE0, 0x0010):\n                    assert elem[2] == 8192\n\n    def test_explicit_big(self):\n        p = get_testdata_file(\"MR_small_bigendian.dcm\")\n        ds = dcmread(p)\n        assert ds.file_meta.TransferSyntaxUID == ExplicitVRBigEndian\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            for elem in ds:\n                if elem[0] == (0x7FE0, 0x0010):\n                    assert elem[2] == 8192\n\n    def test_no_tsyntax(self):\n        p = get_testdata_file(\"meta_missing_tsyntax.dcm\")\n        ds = dcmread(p)\n        assert \"TransferSyntaxUID\" not in ds.file_meta\n        msg = \"No transfer syntax in file meta info\"\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            with pytest.raises(NotImplementedError, match=msg):\n                for elem in ds:\n                    pass\n\n    def test_no_meta(self):\n        p = get_testdata_file(\"no_meta.dcm\")\n        msg = \"No transfer syntax in file meta info\"\n        with dicomfile(p) as ds:\n            assert ds.preamble is None\n            with pytest.raises(NotImplementedError, match=msg):\n                for elem in ds:\n                    pass\n\n    def test_UN_sequence(self):\n        p = get_testdata_file(\"UN_sequence.dcm\")\n        msg = \"This reader does not handle undefined length except for SQ\"\n        with dicomfile(p) as ds:\n            with pytest.raises(NotImplementedError, match=msg):\n                for elem in ds:\n                    pass\n\n\n@contextmanager\ndef save_private_dict():\n    saved_private_dict = copy.deepcopy(private_dictionaries)\n    try:\n        yield\n    finally:\n        private_dictionaries.clear()\n        private_dictionaries.update(saved_private_dict)\n"
  },
  "GT_src_dict": {
    "modified_testcases/test_util.py": {
      "save_private_dict": {
        "code": "def save_private_dict():\n    \"\"\"Context manager to temporarily save and restore the private dictionaries used by pydicom. This function creates a deep copy of the global `private_dictionaries` before entering the execution context, allowing changes to the private dictionaries within the context to be safely reverted afterward.\n\nNo parameters are accepted, and the function does not return a value. However, it affects the state of the `private_dictionaries` global variable by clearing its current contents and restoring them upon exiting the context. This ensures that any changes made during the context (such as adding or modifying private tags) do not persist outside of it, preserving the integrity of the private dictionaries across different parts of the application.\"\"\"\n    saved_private_dict = copy.deepcopy(private_dictionaries)\n    try:\n        yield\n    finally:\n        private_dictionaries.clear()\n        private_dictionaries.update(saved_private_dict)",
        "docstring": "Context manager to temporarily save and restore the private dictionaries used by pydicom. This function creates a deep copy of the global `private_dictionaries` before entering the execution context, allowing changes to the private dictionaries within the context to be safely reverted afterward.\n\nNo parameters are accepted, and the function does not return a value. However, it affects the state of the `private_dictionaries` global variable by clearing its current contents and restoring them upon exiting the context. This ensures that any changes made during the context (such as adding or modifying private tags) do not persist outside of it, preserving the integrity of the private dictionaries across different parts of the application.",
        "signature": "def save_private_dict():",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: pydicom-test_dictionary\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 modified_testcases/\n    \u2514\u2500\u2500 test_util.py\n        \u2514\u2500\u2500 save_private_dict\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module serves as a utility for managing and interacting with DICOM (Digital Imaging and Communications in Medicine) data dictionaries, which define metadata associated with medical imaging datasets. It provides functionality to query, manipulate, and extend the DICOM dictionary by adding or retrieving entries, validating tags or keywords, and accessing or modifying private dictionary-specific metadata. Features include support for identifying valid standard and private tags, mapping tags to relevant attributes such as Value Representations (VR) and Value Multiplicity (VM), and adding custom entries to enhance dataset compatibility. By enabling seamless handling and extension of DICOM metadata, the module simplifies the integration of custom tags and ensures compliance with DICOM standards, supporting developers in building robust medical imaging applications.\n\n## FILE 1: modified_testcases/test_util.py\n\n- FUNCTION NAME: save_private_dict\n  - SIGNATURE: def save_private_dict():\n  - DOCSTRING: \n```python\n\"\"\"\nContext manager to temporarily save and restore the private dictionaries used by pydicom. This function creates a deep copy of the global `private_dictionaries` before entering the execution context, allowing changes to the private dictionaries within the context to be safely reverted afterward.\n\nNo parameters are accepted, and the function does not return a value. However, it affects the state of the `private_dictionaries` global variable by clearing its current contents and restoring them upon exiting the context. This ensures that any changes made during the context (such as adding or modifying private tags) do not persist outside of it, preserving the integrity of the private dictionaries across different parts of the application.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "modified_testcases/test_util.py": "\"\"\"Test suite for util functions\"\"\"\nimport copy\nfrom contextlib import contextmanager\nfrom io import BytesIO\nimport os\nimport pytest\nfrom pydicom import config, dcmread, Dataset, Sequence\nfrom pydicom import filereader\nfrom pydicom._private_dict import private_dictionaries\nfrom pydicom.data import get_testdata_file\nfrom pydicom.dataelem import DataElement\nfrom pydicom.tag import Tag\nfrom pydicom.uid import ImplicitVRLittleEndian, ExplicitVRBigEndian, ExplicitVRLittleEndian\nfrom pydicom.util import fixer\nfrom pydicom.util import hexutil\nfrom pydicom.util.codify import camel_to_underscore, tag_repr, default_name_filter, code_imports, code_dataelem, code_dataset, main as codify_main, code_file_from_dataset\nfrom pydicom.util.dump import print_character, filedump, datadump, hexdump, pretty_print\nfrom pydicom.util.hexutil import hex2bytes, bytes2hex\nfrom pydicom.util.leanread import dicomfile\nhave_numpy = True\ntry:\n    import numpy\nexcept ImportError:\n    have_numpy = False\ntest_dir = os.path.dirname(__file__)\nraw_hex_module = os.path.join(test_dir, '_write_stds.py')\nraw_hex_code = open(raw_hex_module, 'rb').read()\n\n@contextmanager\ndef chdir(new_dir):\n    import os\n    old_dir = os.getcwd()\n    try:\n        os.chdir(new_dir)\n        yield\n    finally:\n        os.chdir(old_dir)\n\nclass TestCodify:\n    \"\"\"Test the utils.codify module\"\"\"\n\n    def test_camel_to_underscore(self):\n        \"\"\"Test utils.codify.camel_to_underscore\"\"\"\n        input_str = ['TheNameToConvert', 'Some12Variable_Name']\n        output_str = ['the_name_to_convert', 'some12_variable__name']\n        for in_str, out_str in zip(input_str, output_str):\n            assert out_str == camel_to_underscore(in_str)\n\n    def test_tag_repr(self):\n        \"\"\"Test utils.codify.tag_repr\"\"\"\n        input_tag = [0, 1048592, 2145386512, 286326785]\n        output_str = ['(0x0000, 0x0000)', '(0x0010, 0x0010)', '(0x7FE0, 0x0010)', '(0x1111, 0x0001)']\n        for tag, out_str in zip(input_tag, output_str):\n            assert out_str == tag_repr(Tag(tag))\n\n    def test_default_name_filter(self):\n        \"\"\"Test utils.codify.default_name_filter\"\"\"\n        input_keyword = ['ControlPointSet', 'ReferenceDataSet', 'FractionGroupThing']\n        output_str = ['cp_set', 'ref_data_set', 'frxn_gp_thing']\n        for in_str, out_str in zip(input_keyword, output_str):\n            assert out_str == default_name_filter(in_str)\n\n    def test_code_imports(self):\n        \"\"\"Test utils.codify.code_imports\"\"\"\n        out = ['import pydicom']\n        out.append('from pydicom.dataset import Dataset, FileMetaDataset')\n        out.append('from pydicom.sequence import Sequence')\n        assert '\\n'.join(out) == code_imports()\n\n    def test_code_dataelem_standard(self):\n        \"\"\"Test utils.codify.code_dataelem for standard element\"\"\"\n        input_elem = [DataElement(1048592, 'PN', 'CITIZEN'), DataElement(524556, 'UI', '1.1.2.3.4.5'), DataElement(525057, 'US', 1200)]\n        out_str = [\"ds.PatientName = 'CITIZEN'\", \"ds.CodingSchemeUID = '1.1.2.3.4.5'\", 'ds.PrivateGroupReference = 1200']\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem)\n\n    def test_code_dataelem_exclude_size(self):\n        \"\"\"Test utils.codify.code_dataelem exclude_size param\"\"\"\n        input_elem = [DataElement(1048592, 'OB', b'CITIZEN'), DataElement(524556, 'UI', '1.1'), DataElement(2097169, 'IS', 3)]\n        out_str = ['ds.PatientName = # XXX Array of 7 bytes excluded', \"ds.CodingSchemeUID = '1.1'\", \"ds.SeriesNumber = '3'\"]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem, exclude_size=4)\n\n    def test_code_dataelem_private(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        input_elem = [DataElement(1118224, 'PN', 'CITIZEN'), DataElement(8454412, 'UI', '1.1.2.3.4.5'), DataElement(286327553, 'US', 1200)]\n        out_str = [\"ds.add_new((0x0011, 0x1010), 'PN', 'CITIZEN')\", \"ds.add_new((0x0081, 0x010C), 'UI', '1.1.2.3.4.5')\", \"ds.add_new((0x1111, 0x0301), 'US', 1200)\"]\n        for elem, out in zip(input_elem, out_str):\n            assert out == code_dataelem(elem)\n\n    def test_code_dataelem_sequence(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        elem = DataElement(805962001, 'SQ', [])\n        out = '\\n# Control Point Sequence\\n'\n        out += 'cp_sequence = Sequence()\\n'\n        out += 'ds.ControlPointSequence = cp_sequence'\n        assert out == code_dataelem(elem)\n\n    def test_code_sequence(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        elem = DataElement(805962001, 'SQ', [])\n        elem.value.append(Dataset())\n        elem.value[0].PatientID = '1234'\n        out = \"\\n# Control Point Sequence\\ncp_sequence = Sequence()\\nds.ControlPointSequence = cp_sequence\\n\\n# Control Point Sequence: Control Point 1\\ncp1 = Dataset()\\ncp_sequence.append(cp1)\\ncp1.PatientID = '1234'\"\n        assert out == code_dataelem(elem)\n\n    def test_codify_recurring_keyword(self):\n        \"\"\"Test utils.codify.code_dataset with same keyword nested\"\"\"\n        ds = Dataset()\n        ds.ContentSequence = seq1 = Sequence()\n        seq1.append(Dataset())\n        seq1[0].ValueType = 'CODE'\n        seq1[0].ContentSequence = seq2 = Sequence()\n        seq2.append(Dataset())\n        seq2[0].ValueType = 'CODE_1'\n        ds_code = code_dataset(ds)\n        assert \"content1.ValueType = 'CODE'\" in ds_code\n        assert \"content1_1.ValueType = 'CODE_1'\" in ds_code\n\n    def test_code_file(self, capsys):\n        \"\"\"Test utils.codify.code_file\"\"\"\n        filename = get_testdata_file('rtplan.dcm')\n        args = [filename]\n        codify_main(100, args)\n        out, err = capsys.readouterr()\n        assert 'rtplan_from_codify.dcm' in out\n\n    def test_code_file_save_as(self, capsys):\n        \"\"\"Test utils.codify.code_file\"\"\"\n        filename = get_testdata_file('rtplan.dcm')\n        args = ['--save-as', 'c:\\\\temp\\\\testout.dcm', filename]\n        codify_main(100, args)\n        out, err = capsys.readouterr()\n        assert 'c:\\\\temp\\\\testout.dcm' in out\n\n    def test_code_file_deflated(self, capsys):\n        \"\"\"Test utils.codify.code_file with a deflated dataset\"\"\"\n        filename = get_testdata_file('image_dfl.dcm')\n        args = [filename]\n        codify_main(100, args)\n        out, err = capsys.readouterr()\n        assert 'image_dfl_from_codify.dcm' in out\n\n    def test_code_relative_filename(self, capsys):\n        \"\"\"Test utils.codify.code_file with a relative path that doesn't exist\"\"\"\n        args = ['XXxUN_sequenceXX.dcm']\n        with pytest.raises(SystemExit):\n            codify_main(100, args)\n\n    def test_code_dataelem_at(self):\n        \"\"\"Test utils.codify.code_dataelem\"\"\"\n        elem = DataElement(2305, 'AT', (4660, 22136))\n        out = 'ds.OffendingElement = (0x1234, 0x5678)'\n        assert out == code_dataelem(elem)\n\nclass TestDump:\n    \"\"\"Test the utils.dump module\"\"\"\n\n    def test_print_character(self):\n        \"\"\"Test utils.dump.print_character\"\"\"\n        assert print_character(48) == '0'\n        assert print_character(49) == '1'\n        assert print_character(57) == '9'\n        assert print_character(65) == 'A'\n        assert print_character(90) == 'Z'\n        assert print_character(97) == 'a'\n        assert print_character(122) == 'z'\n        assert print_character(0) == '.'\n\n    def test_filedump(self):\n        \"\"\"Test utils.dump.filedump\"\"\"\n        p = get_testdata_file('CT_small.dcm')\n        s = filedump(p, start_address=500, stop_address=1000)\n        assert '000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........' not in s\n        assert '1F4  2E 31 2E 31 2E 31 2E 31 2E 32 30 30 34 30 31 31  .1.1.1.1.2004011' in s\n\n    def test_datadump(self):\n        \"\"\"Test utils.dump.datadump\"\"\"\n        p = get_testdata_file('CT_small.dcm')\n        with open(p, 'rb') as f:\n            s = datadump(f.read(), 500, 1000)\n        assert '1F4  2E 31 2E 31 2E 31 2E 31 2E 32 30 30 34 30 31 31  .1.1.1.1.2004011' in s\n\n    def test_hexdump(self):\n        \"\"\"Test utils.dump.hexdump\"\"\"\n        p = get_testdata_file('CT_small.dcm')\n        with open(p, 'rb') as f:\n            s = hexdump(f)\n        assert '0000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........' in s\n        assert '0170  41 4C 5C 50 52 49 4D 41 52 59 5C 41 58 49 41 4C  AL.PRIMARY.AXIAL' in s\n        assert '9920  08 00 00 00 00 00                                ......' in s\n        with open(p, 'rb') as f:\n            s = hexdump(f, stop_address=1000)\n        assert '000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........' in s\n        assert '170  41 4C 5C 50 52 49 4D 41 52 59 5C 41 58 49 41 4C  AL.PRIMARY.AXIAL' in s\n        assert '9920  08 00 00 00 00 00                                ......' not in s\n        with open(p, 'rb') as f:\n            s = hexdump(f, show_address=False, stop_address=1000)\n        assert '49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........' in s\n        assert '000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........' not in s\n        with open(p, 'rb') as f:\n            s = hexdump(f, start_address=500, stop_address=1000)\n        assert '000  49 49 2A 00 54 18 08 00 00 00 00 00 00 00 00 00  II*.T...........' not in s\n        assert '1F4  2E 31 2E 31 2E 31 2E 31 2E 32 30 30 34 30 31 31  .1.1.1.1.2004011' in s\n\n    def test_pretty_print(self, capsys):\n        \"\"\"Test utils.dump.pretty_print\"\"\"\n        ds = get_testdata_file('CT_small.dcm', read=True)\n        pretty_print(ds)\n        s = capsys.readouterr().out\n        assert \"(0008,0005) Specific Character Set              CS: 'ISO_IR 100'\" in s\n        assert '(0010,1002) Other Patient IDs Sequence -- 2 item(s)' in s\n        assert \"  (0010,0022) Type of Patient ID                  CS: 'TEXT'\" in s\n        assert '(FFFC,FFFC) Data Set Trailing Padding           OB: Array of 126 elements' in s\n\nclass TestHexUtil:\n    \"\"\"Test the utils.hexutil module\"\"\"\n\n    def test_hex_to_bytes(self):\n        \"\"\"Test utils.hexutil.hex2bytes\"\"\"\n        hexstring = '00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F'\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f'\n        assert hex2bytes(hexstring) == bytestring\n        hexstring = '00 10 20 30 40 50 60 70 80 90 A0 B0 C0 D0 E0 F0'\n        bytestring = b'\\x00\\x10 0@P`p\\x80\\x90\\xa0\\xb0\\xc0\\xd0\\xe0\\xf0'\n        assert hex2bytes(hexstring) == bytestring\n        hexstring = b'00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F'\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f'\n        assert hex2bytes(hexstring) == bytestring\n        with pytest.raises(TypeError):\n            hex2bytes(4660)\n\n    def test_bytes_to_hex(self):\n        \"\"\"Test utils.hexutil.hex2bytes\"\"\"\n        hexstring = '00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f'\n        bytestring = b'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f'\n        assert bytes2hex(bytestring) == hexstring\n        hexstring = '00 10 20 30 40 50 60 70 80 90 a0 b0 c0 d0 e0 f0'\n        bytestring = b'\\x00\\x10 0@P`p\\x80\\x90\\xa0\\xb0\\xc0\\xd0\\xe0\\xf0'\n        assert bytes2hex(bytestring) == hexstring\n\nclass TestDataElementCallbackTests:\n\n    def setup_method(self):\n        namespace = {}\n        exec(raw_hex_code, {}, namespace)\n        ds_bytes = hexutil.hex2bytes(namespace['impl_LE_deflen_std_hex'])\n        ds_bytes = ds_bytes.replace(b'2\\\\4\\\\8\\\\16', b'2,4,8,16')\n        self.ds_bytes = ds_bytes\n        self.bytesio = BytesIO(ds_bytes)\n\n    def teardown_method(self):\n        config.reset_data_element_callback()\n\n    def test_bad_separator(self, enforce_valid_values):\n        \"\"\"Ensure that unchanged bad separator does raise an error...\"\"\"\n        ds = filereader.read_dataset(self.bytesio, is_little_endian=True, is_implicit_VR=True)\n        contour = ds.ROIContourSequence[0].ContourSequence[0]\n        with pytest.raises(ValueError):\n            getattr(contour, 'ContourData')\n\n    def test_impl_vr_comma(self):\n        \"\"\"util.fix_separator: Able to replace comma in Implicit VR dataset..\"\"\"\n        fixer.fix_separator(b',', for_VRs=['DS', 'IS'], process_unknown_VRs=False)\n        ds = filereader.read_dataset(self.bytesio, is_little_endian=True, is_implicit_VR=True)\n        got = ds.ROIContourSequence[0].ContourSequence[0].ContourData\n        expected = [2.0, 4.0, 8.0, 16.0]\n        if have_numpy and config.use_DS_numpy:\n            assert numpy.allclose(expected, got)\n        else:\n            assert expected == got\n\n    def test_null_value_for_fixed_vr(self):\n        null_ds_bytes = self.ds_bytes.replace(b'\\x08\\x00\\x00\\x00', b'\\x00\\x00\\x00\\x00')\n        contour_data = b'2,4,8,16'\n        null_ds_bytes = null_ds_bytes.replace(contour_data, b'')\n        fixer.fix_separator(b',', for_VRs=['DS', 'IS'], process_unknown_VRs=False)\n        ds = filereader.read_dataset(BytesIO(null_ds_bytes), is_little_endian=True, is_implicit_VR=True)\n        assert ds.ROIContourSequence[0].ContourSequence[0].ContourData is None\n\n    def test_space_delimiter(self):\n        existing = b'32\\\\64\\\\128\\\\196 '\n        spaced = b'32 64 128 196 '\n        space_ds_bytes = self.ds_bytes.replace(existing, spaced)\n        fixer.fix_separator(b' ', for_VRs=['DS', 'IS'], process_unknown_VRs=False)\n        ds = filereader.read_dataset(BytesIO(space_ds_bytes), is_little_endian=True, is_implicit_VR=True)\n        got = ds.ROIContourSequence[0].ContourSequence[1].ContourData\n        expected = [32.0, 64.0, 128.0, 196.0]\n        if have_numpy and config.use_DS_numpy:\n            assert numpy.allclose(expected, got)\n        else:\n            assert expected == got\n\n    @pytest.mark.filterwarnings('ignore:Unknown DICOM tag')\n    def test_process_unknown_vr(self):\n        bad_vr_bytes = self.ds_bytes\n        bad_vr_bytes += b'\\x00\\t\\x10\\x00\\x04\\x00\\x00\\x001,2 '\n        fixer.fix_separator(b',', for_VRs=['DS', 'IS'], process_unknown_VRs=True)\n        ds = filereader.read_dataset(BytesIO(bad_vr_bytes), is_little_endian=True, is_implicit_VR=True)\n        msg = \"VR lookup failed for the raw element with tag \\\\(0900,0010\\\\) - setting VR to 'UN'\"\n        with pytest.warns(UserWarning, match=msg):\n            got = ds.get((2304, 16))\n            assert got.value == b'1\\\\2 '\n        fixer.fix_separator(b',', for_VRs=['DS', 'IS'], process_unknown_VRs=False)\n        ds = filereader.read_dataset(BytesIO(bad_vr_bytes), is_little_endian=True, is_implicit_VR=True)\n        msg = \"VR lookup failed for the raw element with tag \\\\(0900,0010\\\\) - setting VR to 'UN'\"\n        with pytest.warns(UserWarning, match=msg):\n            got = ds.get((2304, 16))\n            assert got.value == b'1,2 '\n\nclass TestLeanRead:\n\n    def test_explicit_little(self):\n        p = get_testdata_file('CT_small.dcm')\n        ds = dcmread(p)\n        assert ds.file_meta.TransferSyntaxUID == ExplicitVRLittleEndian\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            for elem in ds:\n                if elem[0] == (32736, 16):\n                    assert elem[2] == 32768\n\n    def test_implicit_little(self):\n        p = get_testdata_file('MR_small_implicit.dcm')\n        ds = dcmread(p)\n        assert ds.file_meta.TransferSyntaxUID == ImplicitVRLittleEndian\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            for elem in ds:\n                if elem[0] == (32736, 16):\n                    assert elem[2] == 8192\n\n    def test_explicit_big(self):\n        p = get_testdata_file('MR_small_bigendian.dcm')\n        ds = dcmread(p)\n        assert ds.file_meta.TransferSyntaxUID == ExplicitVRBigEndian\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            for elem in ds:\n                if elem[0] == (32736, 16):\n                    assert elem[2] == 8192\n\n    def test_no_tsyntax(self):\n        p = get_testdata_file('meta_missing_tsyntax.dcm')\n        ds = dcmread(p)\n        assert 'TransferSyntaxUID' not in ds.file_meta\n        msg = 'No transfer syntax in file meta info'\n        with dicomfile(p) as ds:\n            assert ds.preamble is not None\n            with pytest.raises(NotImplementedError, match=msg):\n                for elem in ds:\n                    pass\n\n    def test_no_meta(self):\n        p = get_testdata_file('no_meta.dcm')\n        msg = 'No transfer syntax in file meta info'\n        with dicomfile(p) as ds:\n            assert ds.preamble is None\n            with pytest.raises(NotImplementedError, match=msg):\n                for elem in ds:\n                    pass\n\n    def test_UN_sequence(self):\n        p = get_testdata_file('UN_sequence.dcm')\n        msg = 'This reader does not handle undefined length except for SQ'\n        with dicomfile(p) as ds:\n            with pytest.raises(NotImplementedError, match=msg):\n                for elem in ds:\n                    pass"
  },
  "call_tree": {
    "modified_testcases/test_dictionary.py:TestDict:test_add_private_entry": {
      "modified_testcases/test_util.py:save_private_dict": {}
    }
  }
}