{
  "dir_path": "/app/num2words",
  "package_name": "num2words",
  "sample_name": "num2words-test_lv",
  "src_dir": "num2words/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_lv.py",
  "test_code": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom unittest import TestCase\n\nfrom num2words import num2words\n\n\nclass Num2WordsLVTest(TestCase):\n    def test_to_cardinal(self):\n        self.assertEqual(num2words(100, lang='lv'), 'simts')\n        self.assertEqual(num2words(101, lang='lv'), 'simtu viens')\n        self.assertEqual(num2words(110, lang='lv'), 'simts desmit')\n        self.assertEqual(num2words(115, lang='lv'), 'simts piecpadsmit')\n        self.assertEqual(num2words(123, lang='lv'), 'simts divdesmit tr\u012bs')\n        self.assertEqual(num2words(1000, lang='lv'), 't\u016bkstotis')\n        self.assertEqual(num2words(1001, lang='lv'), 't\u016bkstotis viens')\n        self.assertEqual(num2words(2012, lang='lv'),\n                         'divi t\u016bksto\u0161i divpadsmit')\n        self.assertEqual(\n            num2words(1234567890, lang='lv'),\n            'miljards divi simti tr\u012bsdesmit \u010detri miljoni pieci simti '\n            'se\u0161desmit septi\u0146i t\u016bksto\u0161i asto\u0146i simti devi\u0146desmit')\n        self.assertEqual(\n            num2words(215461407892039002157189883901676, lang='lv'),\n            'divi simti piecpadsmit nontiljoni \u010detri simti se\u0161desmit '\n            'viens oktiljons \u010detri simti septi\u0146i septiljoni asto\u0146i '\n            'simti devi\u0146desmit divi sikstiljoni tr\u012bsdesmit devi\u0146i '\n            'kvintiljoni divi kvadriljoni simts piecdesmit septi\u0146i '\n            'triljoni simts asto\u0146desmit devi\u0146i miljardi asto\u0146i simti '\n            'asto\u0146desmit tr\u012bs miljoni devi\u0146i simti viens t\u016bkstotis '\n            'se\u0161i simti septi\u0146desmit se\u0161i')\n        self.assertEqual(\n            num2words(719094234693663034822824384220291, lang='lv'),\n            'septi\u0146i simti devi\u0146padsmit nontiljoni devi\u0146desmit \u010detri '\n            'oktiljoni divi simti tr\u012bsdesmit \u010detri septiljoni se\u0161i simti '\n            'devi\u0146desmit tr\u012bs sikstiljoni se\u0161i simti se\u0161desmit tr\u012bs '\n            'kvintiljoni tr\u012bsdesmit \u010detri kvadriljoni asto\u0146i simti '\n            'divdesmit divi triljoni asto\u0146i simti divdesmit \u010detri '\n            'miljardi tr\u012bs simti asto\u0146desmit \u010detri miljoni divi simti '\n            'divdesmit t\u016bksto\u0161i divi simti devi\u0146desmit viens')\n        self.assertEqual(\n            num2words(-5000, lang='lv'),\n            'm\u012bnus pieci t\u016bksto\u0161i',\n        )\n        self.assertEqual(\n            num2words(-5000.22, lang='lv'),\n            'm\u012bnus pieci t\u016bksto\u0161i komats divdesmit divi',\n        )\n        self.assertEqual(\n            num2words(10.02, lang='lv'),\n            \"desmit komats nulle divi\"\n        )\n        self.assertEqual(\n            num2words(15.007, lang='lv'),\n            \"piecpadsmit komats nulle nulle septi\u0146i\"\n        )\n\n        self.assertEqual(num2words(0, lang='lv'), 'nulle')\n        self.assertEqual(num2words(5, lang='lv'), \"pieci\")\n        self.assertEqual(num2words(15, lang='lv'), \"piecpadsmit\")\n        self.assertEqual(num2words(154, lang='lv'), \"simts piecdesmit \u010detri\")\n        self.assertEqual(num2words(101, lang='lv'), \"simtu viens\")\n        self.assertEqual(\n            num2words(1135, lang='lv'), \"t\u016bkstotis simts tr\u012bsdesmit pieci\"\n        )\n        self.assertEqual(\n            num2words(418531, lang='lv'),\n            \"\u010detri simti asto\u0146padsmit t\u016bksto\u0161i pieci simti tr\u012bsdesmit viens\"\n        )\n        self.assertEqual(\n            num2words(1000139, lang='lv'),\n            \"miljons simts tr\u012bsdesmit devi\u0146i\"\n        )\n\n    def test_to_ordinal(self):\n        # @TODO: implement to_ordinal\n        with self.assertRaises(NotImplementedError):\n            num2words(1, lang='lv', to='ordinal')\n\n    def test_to_currency(self):\n        self.assertEqual(\n            num2words(1.0, lang='lv', to='currency', currency='EUR'),\n            \"viens eiro, nulle centu\"\n        )\n        self.assertEqual(\n            num2words(1.0, lang='lv', to='currency', currency='LVL'),\n            \"viens lats, nulle sant\u012bmu\"\n        )\n        self.assertEqual(\n            num2words(1234.56, lang='lv', to='currency', currency='EUR'),\n            \"t\u016bkstotis divi simti tr\u012bsdesmit \u010detri eiro, piecdesmit se\u0161i centi\"\n        )\n        self.assertEqual(\n            num2words(1234.56, lang='lv', to='currency', currency='LVL'),\n            \"t\u016bkstotis divi simti tr\u012bsdesmit \u010detri lati, \"\n            \"piecdesmit se\u0161i sant\u012bmi\"\n        )\n\n        self.assertEqual(\n            num2words(10111, lang='lv', to='currency', separator=' un',\n                      currency='EUR'),\n            \"simtu viens eiro un vienpadsmit centi\"\n        )\n        self.assertEqual(\n            num2words(10121, lang='lv', to='currency', separator=' un',\n                      currency='LVL'),\n            \"simtu viens lats un divdesmit viens sant\u012bms\"\n        )\n        self.assertEqual(\n            num2words(-1251985, lang='lv', to='currency', cents=False,\n                      currency='EUR'),\n            \"m\u012bnus divpadsmit t\u016bksto\u0161i pieci simti devi\u0146padsmit eiro,\"\n            \" 85 centi\"\n        )\n        self.assertEqual(\n            num2words('38.4', lang='lv', to='currency', separator=' un',\n                      cents=False, currency='EUR'),\n            \"tr\u012bsdesmit asto\u0146i eiro un 40 centi\"\n        )\n\n        # EUR legal form\n        self.assertEqual(\n            num2words('38.4', lang='lv', to='currency', separator=' un',\n                      cents=False, currency='EUR_LEGAL'),\n            \"tr\u012bsdesmit asto\u0146i euro un 40 centi\"\n        )\n\n        self.assertEqual(\n            num2words('38.4', lang='lv', to='currency', separator=' un',\n                      cents=False, currency='USD', adjective=False),\n            \"tr\u012bsdesmit asto\u0146i dol\u0101ri un 40 centi\"\n        )\n\n        self.assertEqual(\n            num2words('38.4', lang='lv', to='currency', separator=' un',\n                      cents=False, currency='USD', adjective=True),\n            \"tr\u012bsdesmit asto\u0146i ASV dol\u0101ri un 40 centi\"\n        )\n\n    def test_fractions(self):\n        self.assertEqual(num2words(5.2, lang='lv'), \"pieci komats divi\")\n        self.assertEqual(\n            num2words(561.42, lang='lv'),\n            \"pieci simti se\u0161desmit viens komats \u010detrdesmit divi\"\n        )\n",
  "GT_file_code": {
    "num2words/__init__.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom . import (lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE,\n               lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN,\n               lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR,\n               lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR,\n               lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID,\n               lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT,\n               lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR,\n               lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE,\n               lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI)\n\nCONVERTER_CLASSES = {\n    'am': lang_AM.Num2Word_AM(),\n    'ar': lang_AR.Num2Word_AR(),\n    'az': lang_AZ.Num2Word_AZ(),\n    'be': lang_BE.Num2Word_BE(),\n    'bn': lang_BN.Num2Word_BN(),\n    'ca': lang_CA.Num2Word_CA(),\n    'ce': lang_CE.Num2Word_CE(),\n    'cy': lang_CY.Num2Word_CY(),\n    'cz': lang_CZ.Num2Word_CZ(),\n    'en': lang_EN.Num2Word_EN(),\n    'en_IN': lang_EN_IN.Num2Word_EN_IN(),\n    'en_NG': lang_EN_NG.Num2Word_EN_NG(),\n    'fa': lang_FA.Num2Word_FA(),\n    'fr': lang_FR.Num2Word_FR(),\n    'fr_CH': lang_FR_CH.Num2Word_FR_CH(),\n    'fr_BE': lang_FR_BE.Num2Word_FR_BE(),\n    'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(),\n    'de': lang_DE.Num2Word_DE(),\n    'fi': lang_FI.Num2Word_FI(),\n    'eo': lang_EO.Num2Word_EO(),\n    'es': lang_ES.Num2Word_ES(),\n    'es_CO': lang_ES_CO.Num2Word_ES_CO(),\n    'es_CR': lang_ES_CR.Num2Word_ES_CR(),\n    'es_GT': lang_ES_GT.Num2Word_ES_GT(),\n    'es_NI': lang_ES_NI.Num2Word_ES_NI(),\n    'es_VE': lang_ES_VE.Num2Word_ES_VE(),\n    'id': lang_ID.Num2Word_ID(),\n    'ja': lang_JA.Num2Word_JA(),\n    'kn': lang_KN.Num2Word_KN(),\n    'ko': lang_KO.Num2Word_KO(),\n    'kz': lang_KZ.Num2Word_KZ(),\n    'lt': lang_LT.Num2Word_LT(),\n    'lv': lang_LV.Num2Word_LV(),\n    'pl': lang_PL.Num2Word_PL(),\n    'ro': lang_RO.Num2Word_RO(),\n    'ru': lang_RU.Num2Word_RU(),\n    'sk': lang_SK.Num2Word_SK(),\n    'sl': lang_SL.Num2Word_SL(),\n    'sr': lang_SR.Num2Word_SR(),\n    'sv': lang_SV.Num2Word_SV(),\n    'no': lang_NO.Num2Word_NO(),\n    'dk': lang_DK.Num2Word_DK(),\n    'pt': lang_PT.Num2Word_PT(),\n    'pt_BR': lang_PT_BR.Num2Word_PT_BR(),\n    'he': lang_HE.Num2Word_HE(),\n    'it': lang_IT.Num2Word_IT(),\n    'vi': lang_VI.Num2Word_VI(),\n    'tg': lang_TG.Num2Word_TG(),\n    'th': lang_TH.Num2Word_TH(),\n    'tr': lang_TR.Num2Word_TR(),\n    'nl': lang_NL.Num2Word_NL(),\n    'uk': lang_UK.Num2Word_UK(),\n    'te': lang_TE.Num2Word_TE(),\n    'tet': lang_TET.Num2Word_TET(),\n    'hu': lang_HU.Num2Word_HU(),\n    'is': lang_IS.Num2Word_IS(),\n}\n\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']\n\n\ndef num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    # We try the full language first\n    if lang not in CONVERTER_CLASSES:\n        # ... and then try only the first 2 letters\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n\n    # backwards compatible\n    if ordinal:\n        to = 'ordinal'\n\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)\n"
  },
  "GT_src_dict": {
    "num2words/__init__.py": {
      "num2words": {
        "code": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    \"\"\"Converts a number into its word representation in the specified language and format.\n\nParameters:\n- number (int, float, or str): The number to be converted into words. If a string is provided, it will be parsed into a number.\n- ordinal (bool, optional): If True, converts the number to its ordinal form. Defaults to False.\n- lang (str, optional): The language code for conversion (e.g., 'en', 'fr'). Defaults to 'en'. Supports both full language codes and two-letter prefixes.\n- to (str, optional): Specifies the type of conversion. Options include 'cardinal', 'ordinal', 'ordinal_num', 'year', and 'currency'. Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments passed to the conversion method.\n\nReturns:\n- str: The word representation of the number in the specified language and format.\n\nDependencies:\nThis function relies on the CONVERTER_CLASSES dictionary, which maps language codes to specific converter instances. The CONVERTES_TYPES list defines valid conversion types. If the specified language or type is not supported, a NotImplementedError is raised.\"\"\"\n    if lang not in CONVERTER_CLASSES:\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n    if ordinal:\n        to = 'ordinal'\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)",
        "docstring": "Converts a number into its word representation in the specified language and format.\n\nParameters:\n- number (int, float, or str): The number to be converted into words. If a string is provided, it will be parsed into a number.\n- ordinal (bool, optional): If True, converts the number to its ordinal form. Defaults to False.\n- lang (str, optional): The language code for conversion (e.g., 'en', 'fr'). Defaults to 'en'. Supports both full language codes and two-letter prefixes.\n- to (str, optional): Specifies the type of conversion. Options include 'cardinal', 'ordinal', 'ordinal_num', 'year', and 'currency'. Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments passed to the conversion method.\n\nReturns:\n- str: The word representation of the number in the specified language and format.\n\nDependencies:\nThis function relies on the CONVERTER_CLASSES dictionary, which maps language codes to specific converter instances. The CONVERTES_TYPES list defines valid conversion types. If the specified language or type is not supported, a NotImplementedError is raised.",
        "signature": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "num2words/__init__.py:num2words": {
      "num2words/lang_LV.py": {
        "Num2Word_LV.to_cardinal": {
          "code": "    def to_cardinal(self, number):\n        n = str(number).replace(',', '.')\n        base_str, n = self.parse_minus(n)\n        if '.' in n:\n            left, right = n.split('.')\n            leading_zero_count = len(right) - len(right.lstrip('0'))\n            decimal_part = ((ZERO[0] + ' ') * leading_zero_count +\n                            self._int2word(int(right)))\n            return '%s%s %s %s' % (\n                base_str,\n                self._int2word(int(left)),\n                self.pointword,\n                decimal_part\n            )\n        else:\n            return \"%s%s\" % (base_str, self._int2word(int(n)))",
          "docstring": "",
          "signature": "def to_cardinal(self, number):",
          "type": "Method",
          "class_signature": "class Num2Word_LV(Num2Word_Base):"
        },
        "Num2Word_LV.to_ordinal": {
          "code": "    def to_ordinal(self, number):\n        raise NotImplementedError()",
          "docstring": "",
          "signature": "def to_ordinal(self, number):",
          "type": "Method",
          "class_signature": "class Num2Word_LV(Num2Word_Base):"
        }
      },
      "num2words/base.py": {
        "Num2Word_Base.str_to_number": {
          "code": "    def str_to_number(self, value):\n        return Decimal(value)",
          "docstring": "",
          "signature": "def str_to_number(self, value):",
          "type": "Method",
          "class_signature": "class Num2Word_Base(object):"
        },
        "Num2Word_Base.to_currency": {
          "code": "    def to_currency(self, val, currency='EUR', cents=True, separator=',',\n                    adjective=False):\n        \"\"\"\n        Args:\n            val: Numeric value\n            currency (str): Currency code\n            cents (bool): Verbose cents\n            separator (str): Cent separator\n            adjective (bool): Prefix currency name with adjective\n        Returns:\n            str: Formatted string\n\n        \"\"\"\n        left, right, is_negative = parse_currency_parts(val)\n\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n\n        except KeyError:\n            raise NotImplementedError(\n                'Currency code \"%s\" not implemented for \"%s\"' %\n                (currency, self.__class__.__name__))\n\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n\n        minus_str = \"%s \" % self.negword.strip() if is_negative else \"\"\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) \\\n            if cents else self._cents_terse(right, currency)\n\n        return u'%s%s %s%s %s %s' % (\n            minus_str,\n            money_str,\n            self.pluralize(left, cr1),\n            separator,\n            cents_str,\n            self.pluralize(right, cr2)\n        )",
          "docstring": "Args:\n    val: Numeric value\n    currency (str): Currency code\n    cents (bool): Verbose cents\n    separator (str): Cent separator\n    adjective (bool): Prefix currency name with adjective\nReturns:\n    str: Formatted string",
          "signature": "def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):",
          "type": "Method",
          "class_signature": "class Num2Word_Base(object):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: num2words-test_lv\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 num2words/\n    \u2514\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 num2words\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality to convert numerical values into their corresponding word representations in Latvian, enabling support for cardinal numbers, fractions, currencies, and other numeric formats. It offers features such as converting integers, decimals, and negative values into words, as well as handling currency conversions with language-specific notation and formatting. By automating the generation of text-based representations of numbers in Latvian, the module addresses the challenge of manually coding locale-specific number-to-word conversions, ensuring consistency and accuracy in numeric translations for applications requiring linguistic precision, such as financial reports, localization, or educational tools.\n\n## FILE 1: num2words/__init__.py\n\n- FUNCTION NAME: num2words\n  - SIGNATURE: def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a number into its word representation in the specified language and format.\n\nParameters:\n- number (int, float, or str): The number to be converted into words. If a string is provided, it will be parsed into a number.\n- ordinal (bool, optional): If True, converts the number to its ordinal form. Defaults to False.\n- lang (str, optional): The language code for conversion (e.g., 'en', 'fr'). Defaults to 'en'. Supports both full language codes and two-letter prefixes.\n- to (str, optional): Specifies the type of conversion. Options include 'cardinal', 'ordinal', 'ordinal_num', 'year', and 'currency'. Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments passed to the conversion method.\n\nReturns:\n- str: The word representation of the number in the specified language and format.\n\nDependencies:\nThis function relies on the CONVERTER_CLASSES dictionary, which maps language codes to specific converter instances. The CONVERTES_TYPES list defines valid conversion types. If the specified language or type is not supported, a NotImplementedError is raised.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - num2words/lang_LV.py:Num2Word_LV:to_ordinal\n    - num2words/base.py:Num2Word_Base:str_to_number\n    - num2words/lang_LV.py:Num2Word_LV:to_cardinal\n    - num2words/base.py:Num2Word_Base:to_currency\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "num2words/__init__.py": "from __future__ import unicode_literals\nfrom . import lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE, lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN, lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR, lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR, lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID, lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT, lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR, lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE, lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI\nCONVERTER_CLASSES = {'am': lang_AM.Num2Word_AM(), 'ar': lang_AR.Num2Word_AR(), 'az': lang_AZ.Num2Word_AZ(), 'be': lang_BE.Num2Word_BE(), 'bn': lang_BN.Num2Word_BN(), 'ca': lang_CA.Num2Word_CA(), 'ce': lang_CE.Num2Word_CE(), 'cy': lang_CY.Num2Word_CY(), 'cz': lang_CZ.Num2Word_CZ(), 'en': lang_EN.Num2Word_EN(), 'en_IN': lang_EN_IN.Num2Word_EN_IN(), 'en_NG': lang_EN_NG.Num2Word_EN_NG(), 'fa': lang_FA.Num2Word_FA(), 'fr': lang_FR.Num2Word_FR(), 'fr_CH': lang_FR_CH.Num2Word_FR_CH(), 'fr_BE': lang_FR_BE.Num2Word_FR_BE(), 'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(), 'de': lang_DE.Num2Word_DE(), 'fi': lang_FI.Num2Word_FI(), 'eo': lang_EO.Num2Word_EO(), 'es': lang_ES.Num2Word_ES(), 'es_CO': lang_ES_CO.Num2Word_ES_CO(), 'es_CR': lang_ES_CR.Num2Word_ES_CR(), 'es_GT': lang_ES_GT.Num2Word_ES_GT(), 'es_NI': lang_ES_NI.Num2Word_ES_NI(), 'es_VE': lang_ES_VE.Num2Word_ES_VE(), 'id': lang_ID.Num2Word_ID(), 'ja': lang_JA.Num2Word_JA(), 'kn': lang_KN.Num2Word_KN(), 'ko': lang_KO.Num2Word_KO(), 'kz': lang_KZ.Num2Word_KZ(), 'lt': lang_LT.Num2Word_LT(), 'lv': lang_LV.Num2Word_LV(), 'pl': lang_PL.Num2Word_PL(), 'ro': lang_RO.Num2Word_RO(), 'ru': lang_RU.Num2Word_RU(), 'sk': lang_SK.Num2Word_SK(), 'sl': lang_SL.Num2Word_SL(), 'sr': lang_SR.Num2Word_SR(), 'sv': lang_SV.Num2Word_SV(), 'no': lang_NO.Num2Word_NO(), 'dk': lang_DK.Num2Word_DK(), 'pt': lang_PT.Num2Word_PT(), 'pt_BR': lang_PT_BR.Num2Word_PT_BR(), 'he': lang_HE.Num2Word_HE(), 'it': lang_IT.Num2Word_IT(), 'vi': lang_VI.Num2Word_VI(), 'tg': lang_TG.Num2Word_TG(), 'th': lang_TH.Num2Word_TH(), 'tr': lang_TR.Num2Word_TR(), 'nl': lang_NL.Num2Word_NL(), 'uk': lang_UK.Num2Word_UK(), 'te': lang_TE.Num2Word_TE(), 'tet': lang_TET.Num2Word_TET(), 'hu': lang_HU.Num2Word_HU(), 'is': lang_IS.Num2Word_IS()}\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']"
  },
  "call_tree": {
    "modified_testcases/test_lv.py:Num2WordsLVTest:test_fractions": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_LV.py:Num2Word_LV:to_cardinal": {
          "num2words/base.py:Num2Word_Base:parse_minus": {},
          "num2words/lang_LV.py:Num2Word_LV:_int2word": {
            "num2words/utils.py:splitbyx": {},
            "num2words/utils.py:get_digits": {}
          }
        }
      }
    },
    "modified_testcases/test_lv.py:Num2WordsLVTest:test_to_cardinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_LV.py:Num2Word_LV:to_cardinal": {
          "num2words/base.py:Num2Word_Base:parse_minus": {},
          "num2words/lang_LV.py:Num2Word_LV:_int2word": {
            "num2words/utils.py:splitbyx": {},
            "num2words/utils.py:get_digits": {},
            "num2words/lang_LV.py:Num2Word_LV:pluralize": {}
          }
        }
      }
    },
    "modified_testcases/test_lv.py:Num2WordsLVTest:test_to_currency": {
      "num2words/__init__.py:num2words": {
        "num2words/base.py:Num2Word_Base:to_currency": {
          "num2words/currency.py:parse_currency_parts": {},
          "num2words/base.py:Num2Word_Base:_money_verbose": {
            "num2words/lang_LV.py:Num2Word_LV:to_cardinal": {
              "num2words/base.py:Num2Word_Base:parse_minus": {},
              "num2words/lang_LV.py:Num2Word_LV:_int2word": {
                "num2words/utils.py:splitbyx": {},
                "num2words/utils.py:get_digits": {},
                "num2words/lang_LV.py:Num2Word_LV:pluralize": {}
              }
            }
          },
          "num2words/base.py:Num2Word_Base:_cents_verbose": {
            "num2words/lang_LV.py:Num2Word_LV:to_cardinal": {
              "num2words/base.py:Num2Word_Base:parse_minus": {},
              "num2words/lang_LV.py:Num2Word_LV:_int2word": {
                "num2words/utils.py:splitbyx": {},
                "num2words/utils.py:get_digits": {}
              }
            }
          },
          "num2words/lang_LV.py:Num2Word_LV:pluralize": {},
          "num2words/base.py:Num2Word_Base:_cents_terse": {},
          "num2words/currency.py:prefix_currency": {}
        },
        "num2words/base.py:Num2Word_Base:str_to_number": {}
      }
    },
    "modified_testcases/test_lv.py:Num2WordsLVTest:test_to_ordinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_LV.py:Num2Word_LV:to_ordinal": {}
      }
    }
  }
}