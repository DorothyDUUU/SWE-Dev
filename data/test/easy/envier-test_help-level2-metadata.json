{
  "dir_path": "/app/envier",
  "package_name": "envier",
  "sample_name": "envier-test_help",
  "src_dir": "envier/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_help.py",
  "test_code": "from envier import Env\nfrom envier import HelpInfo\n\n\nclass GlobalConfig(Env):\n    __prefix__ = \"myapp\"\n\n    debug_mode = Env.var(\n        bool,\n        \"debug\",\n        default=False,\n        help_type=\"Boolean\",\n        help=\"Whether to enable debug logging\",\n    )\n    url = Env.var(\n        str,\n        \"url\",\n        default=\"http://localhost:5000\",\n        help_type=\"String\",\n        help=\"The URL of the application.\",\n    )\n    no_default = Env.var(\n        str,\n        \"no_default\",\n        help_type=\"Boolean\",\n        help=\"A variable with no default value, which makes it mandatory\",\n    )\n\n    class ServiceConfig(Env):\n        __item__ = __prefix__ = \"service\"\n\n        host = Env.var(\n            str,\n            \"host\",\n            default=\"localhost\",\n            help=\"The host of the service.\",\n        )\n        port = Env.var(\n            int,\n            \"port\",\n            default=3000,\n            help=\"The port of the service.\",\n        )\n\n\ndef test_help_info(monkeypatch):\n    monkeypatch.setenv(\"MYAPP_NO_DEFAULT\", \"1\")\n\n    assert GlobalConfig.help_info() == [\n        HelpInfo(\"MYAPP_DEBUG\", \"Boolean\", \"False\", \"Whether to enable debug logging.\"),\n        HelpInfo(\n            \"MYAPP_NO_DEFAULT\",\n            \"Boolean\",\n            \"\",\n            \"A variable with no default value, which makes it mandatory.\",\n        ),\n        HelpInfo(\n            \"MYAPP_URL\",\n            \"String\",\n            \"http://localhost:5000\",\n            \"The URL of the application.\",\n        ),\n    ]\n\n\ndef test_help_info_recursive(monkeypatch):\n    monkeypatch.setenv(\"MYAPP_NO_DEFAULT\", \"1\")\n\n    assert GlobalConfig.help_info(recursive=True) == [\n        HelpInfo(\"MYAPP_DEBUG\", \"Boolean\", \"False\", \"Whether to enable debug logging.\"),\n        HelpInfo(\n            \"MYAPP_NO_DEFAULT\",\n            \"Boolean\",\n            \"\",\n            \"A variable with no default value, which makes it mandatory.\",\n        ),\n        HelpInfo(\n            \"MYAPP_URL\",\n            \"String\",\n            \"http://localhost:5000\",\n            \"The URL of the application.\",\n        ),\n        HelpInfo(\"MYAPP_SERVICE_HOST\", \"str\", \"localhost\", \"The host of the service.\"),\n        HelpInfo(\"MYAPP_SERVICE_PORT\", \"int\", \"3000\", \"The port of the service.\"),\n    ]\n",
  "GT_file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\n\nclass NoDefaultType(object):\n    def __str__(self):\n        return \"\"\n\n\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\n\n\nT = t.TypeVar(\"T\")\nK = t.TypeVar(\"K\")\nV = t.TypeVar(\"V\")\n\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple(\"HelpInfo\", (\"name\", \"type\", \"default\", \"help\"))\n\n\ndef _normalized(name: str) -> str:\n    return name.upper().replace(\".\", \"_\").rstrip(\"_\")\n\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, \"__origin__\"):\n        return isinstance(value, _type.__args__)  # type: ignore[attr-defined,union-attr]\n\n    return isinstance(value, _type)  # type: ignore[arg-type]\n\n\nclass EnvVariable(t.Generic[T]):\n    def __init__(\n        self,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> None:\n        if hasattr(type, \"__origin__\") and type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            if not isinstance(default, type.__args__):  # type: ignore[attr-defined,union-attr]\n                raise TypeError(\n                    \"default must be either of these types {}\".format(type.__args__)  # type: ignore[attr-defined,union-attr]\n                )\n        elif default is not NoDefault and not isinstance(default, type):  # type: ignore[arg-type]\n            raise TypeError(\"default must be of type {}\".format(type))\n\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n\n        self._full_name = _normalized(name)  # Will be set by the EnvMeta metaclass\n\n    @property\n    def full_name(self) -> str:\n        return f\"_{self._full_name}\" if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: \"Env\") -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(\n                T,\n                _type(  # type: ignore[operator]\n                    collection if self.map is None else map(self.map, collection)  # type: ignore[arg-type]\n                ),\n            )\n        elif _type is dict:\n            d = dict(\n                _.split(env.__value_separator__, 1)\n                for _ in raw.split(env.__item_separator__)\n            )\n            if self.map is not None:\n                d = dict(self.map(*_) for _ in d.items())\n            return t.cast(T, d)\n\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f\"cannot cast {raw} to {self.type}\"\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: \"Env\", prefix: str) -> T:\n        source = env.source\n\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f\"_{full_deprecated_name}\"\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = (\n                        \" in version %s\" % deprecated_when\n                        if deprecated_when is not None\n                        else \"\"\n                    )\n                    removed_when_message = (\n                        \" and will be removed in version %s\" % removed_when\n                        if removed_when is not None\n                        else \"\"\n                    )\n                    warnings.warn(\n                        \"%s has been deprecated%s%s. Use %s instead\"\n                        % (\n                            full_deprecated_name,\n                            deprecated_when_message,\n                            removed_when_message,\n                            full_name,\n                        ),\n                        DeprecationWarning,\n                    )\n                    break\n\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n\n            raise KeyError(\n                \"Mandatory environment variable {} is not set\".format(full_name)\n            )\n\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError(\n                    \"parser returned type {} instead of {}\".format(\n                        type(parsed), self.type\n                    )\n                )\n            return parsed\n\n        if hasattr(self.type, \"__origin__\") and self.type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            for ot in self.type.__args__:  # type: ignore[attr-defined,union-attr]\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n\n        return self._cast(self.type, raw, env)\n\n    def __call__(self, env: \"Env\", prefix: str) -> T:\n        value = self._retrieve(env, prefix)\n\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f\"Invalid value for environment variable {self.full_name}: {e}\"\n                raise ValueError(msg)\n\n        return value\n\n\nclass DerivedVariable(t.Generic[T]):\n    def __init__(self, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: \"Env\") -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError(\n                \"derivation returned type {} instead of {}\".format(\n                    type(value), self.type\n                )\n            )\n        return value\n\n\nclass EnvMeta(type):\n    def __new__(\n        cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]\n    ) -> t.Any:\n        env = t.cast(\"Env\", super().__new__(cls, name, bases, ns))\n\n        prefix = ns.get(\"__prefix__\")\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f\"{_normalized(prefix)}_{v._full_name}\".upper()\n\n        return env\n\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n\n    __truthy__ = frozenset({\"1\", \"true\", \"yes\", \"on\"})\n    __prefix__ = \"\"\n    __item__: t.Optional[str] = None\n    __item_separator__ = \",\"\n    __value_separator__ = \":\"\n\n    def __init__(\n        self,\n        source: t.Optional[t.Dict[str, str]] = None,\n        parent: t.Optional[\"Env\"] = None,\n        dynamic: t.Optional[t.Dict[str, str]] = None,\n    ) -> None:\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = (\n            {k.upper(): v.upper() for k, v in dynamic.items()}\n            if dynamic is not None\n            else {}\n        )\n\n        self._full_prefix: str = (\n            parent._full_prefix if parent is not None else \"\"\n        ) + _normalized(self.__prefix__)\n        if self._full_prefix and not self._full_prefix.endswith(\"_\"):\n            self._full_prefix += \"_\"\n\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    # Move the subclass to the __item__ attribute\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n\n        for n, d in derived:\n            setattr(self, n, d(self))\n\n    @classmethod\n    def var(\n        cls,\n        type: t.Type[T],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def v(\n        cls,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def der(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def items(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type[\"Env\"]]] = deque()\n        path: t.Tuple[str] = tuple()  # type: ignore[assignment]\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield (\n                        \".\".join((*path, k)),\n                        t.cast(t.Union[EnvVariable, DerivedVariable], v),\n                    )\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, \"__item__\", k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))  # type: ignore[arg-type]\n\n    @classmethod\n    def keys(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def values(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type[\"Env\"]]]:\n        \"\"\"Return the value of all the configuration items.\"\"\"\n        for _, v in cls.items(recursive, include_derived):\n            yield v\n\n    @classmethod\n    def include(\n        cls,\n        env_spec: t.Type[\"Env\"],\n        namespace: t.Optional[str] = None,\n        overwrite: bool = False,\n    ) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        # Pick only the attributes that define variables.\n        to_include = {\n            k: v\n            for k, v in env_spec.__dict__.items()\n            if isinstance(v, (EnvVariable, DerivedVariable))\n            or isinstance(v, type)\n            and issubclass(v, Env)\n        }\n\n        own_prefix = _normalized(getattr(cls, \"__prefix__\", \"\"))\n\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError(\"Namespace already in use: {}\".format(namespace))\n\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n            return None\n\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError(\"Configuration clashes detected: {}\".format(overlap))\n\n        other_prefix = getattr(env_spec, \"__prefix__\", \"\")\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1 :]  # noqa\n                    if own_prefix:\n                        v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n    @classmethod\n    def help_info(\n        cls, recursive: bool = False, include_private: bool = False\n    ) -> t.List[HelpInfo]:\n        \"\"\"Extract the help information from the class.\n\n        Returns a list of all the environment variables declared by the class.\n        The format of each entry is a t.Tuple consisting of the variable name (in\n        double backtics quotes), the type, the default value, and the help text.\n\n        Set ``recursive`` to ``True`` to include variables from nested Env\n        classes.\n\n        Set ``include_private`` to ``True`` to include variables that are\n        marked as private (i.e. their name starts with an underscore).\n        \"\"\"\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted(\n                (_ for _ in config.values() if isinstance(_, EnvVariable)),\n                key=lambda v: v.name,\n            )\n\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n\n                # Add a period at the end if necessary.\n                help_message = v.help.strip() if v.help is not None else \"\"\n                if help_message and not help_message.endswith(\".\"):\n                    help_message += \".\"\n\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__  # type: ignore[attr-defined]\n                    except AttributeError:\n                        # typing.t.Union[<type>, NoneType]\n                        help_type = v.type.__args__[0].__name__  # type: ignore[attr-defined]\n\n                private_prefix = \"_\" if v.private else \"\"\n\n                entries.append(\n                    HelpInfo(\n                        f\"{private_prefix}{full_prefix}{_normalized(v.name)}\",\n                        help_type,  # type: ignore[attr-defined]\n                        (\n                            v.help_default\n                            if v.help_default is not None\n                            else str(v.default)\n                        ),\n                        help_message,\n                    )\n                )\n\n        configs = [(\"\", cls)]\n\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and not new_prefix.endswith(\"_\"):\n                new_prefix += \"_\"\n            add_entries(new_prefix, config)\n\n            if not recursive:\n                break\n\n            subconfigs = sorted(\n                (\n                    (new_prefix, v)\n                    for k, v in config.__dict__.items()\n                    if isinstance(v, type) and issubclass(v, Env) and k != \"parent\"\n                ),\n                key=lambda _: _[1].__prefix__,\n            )\n\n            configs[0:0] = subconfigs  # DFS\n\n        return entries\n"
  },
  "GT_src_dict": {
    "envier/env.py": {
      "_normalized": {
        "code": "def _normalized(name: str) -> str:\n    \"\"\"Normalize the given variable name by converting it to uppercase, replacing dots with underscores, and removing any trailing underscores.\n\nParameters:\n- name (str): The input string representing a variable name that needs normalization.\n\nReturns:\n- str: The normalized version of the input variable name.\n\nThis function is primarily used in the context of processing environment variable names within the `EnvVariable` and `Env` classes, where consistent naming conventions are necessary for variable retrieval and management.\"\"\"\n    return name.upper().replace('.', '_').rstrip('_')",
        "docstring": "Normalize the given variable name by converting it to uppercase, replacing dots with underscores, and removing any trailing underscores.\n\nParameters:\n- name (str): The input string representing a variable name that needs normalization.\n\nReturns:\n- str: The normalized version of the input variable name.\n\nThis function is primarily used in the context of processing environment variable names within the `EnvVariable` and `Env` classes, where consistent naming conventions are necessary for variable retrieval and management.",
        "signature": "def _normalized(name: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "EnvVariable.__init__": {
        "code": "    def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:\n        \"\"\"Initialize an instance of the `EnvVariable` class, which represents an environment variable with type safety and optional metadata.\n\nParameters:\n- `type` (Union[object, Type[T]]): The expected type of the environment variable, which may include a union of types.\n- `name` (str): The name of the environment variable.\n- `parser` (Optional[Callable[[str], T]]): A function to convert the raw string value to the specified type.\n- `validator` (Optional[Callable[[T], None]]): A function to validate the parsed value.\n- `map` (Optional[MapType]): A mapping function for transforming values, applicable for collection types.\n- `default` (Union[T, NoDefaultType]): The default value to use if the environment variable is not set; defaults to `NoDefault`.\n- `deprecations` (Optional[List[DeprecationInfo]]): A list of tuples containing deprecated variable information.\n- `private` (bool): A flag indicating if the variable should be treated as private; defaults to `False`.\n- `help` (Optional[str]): Help text describing the variable's purpose.\n- `help_type` (Optional[str]): A description of the variable type for documentation purposes.\n- `help_default` (Optional[str]): A description of the default value for documentation purposes.\n\nRaises:\n- `TypeError`: If the `default` value does not match the expected type defined by `type`.\n\nAttributes initialized:\n- `self.type`, `self.name`, `self.parser`, `self.validator`, `self.map`, `self.default`, `self.deprecations`, `self.private`, `self.help`, `self.help_type`, `self.help_default`: Store the corresponding parameters passed to the initializer.\n- `self._full_name`: A normalized version of the variable name, intended for consistent internal representation, generated using the `_normalized` function.\n\nConstants:\n- `NoDefault`: An instance of `NoDefaultType` indicating the absence of a default value, used to distinguish between set and unset default values during initialization.\"\"\"\n        if hasattr(type, '__origin__') and type.__origin__ is t.Union:\n            if not isinstance(default, type.__args__):\n                raise TypeError('default must be either of these types {}'.format(type.__args__))\n        elif default is not NoDefault and (not isinstance(default, type)):\n            raise TypeError('default must be of type {}'.format(type))\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n        self._full_name = _normalized(name)",
        "docstring": "Initialize an instance of the `EnvVariable` class, which represents an environment variable with type safety and optional metadata.\n\nParameters:\n- `type` (Union[object, Type[T]]): The expected type of the environment variable, which may include a union of types.\n- `name` (str): The name of the environment variable.\n- `parser` (Optional[Callable[[str], T]]): A function to convert the raw string value to the specified type.\n- `validator` (Optional[Callable[[T], None]]): A function to validate the parsed value.\n- `map` (Optional[MapType]): A mapping function for transforming values, applicable for collection types.\n- `default` (Union[T, NoDefaultType]): The default value to use if the environment variable is not set; defaults to `NoDefault`.\n- `deprecations` (Optional[List[DeprecationInfo]]): A list of tuples containing deprecated variable information.\n- `private` (bool): A flag indicating if the variable should be treated as private; defaults to `False`.\n- `help` (Optional[str]): Help text describing the variable's purpose.\n- `help_type` (Optional[str]): A description of the variable type for documentation purposes.\n- `help_default` (Optional[str]): A description of the default value for documentation purposes.\n\nRaises:\n- `TypeError`: If the `default` value does not match the expected type defined by `type`.\n\nAttributes initialized:\n- `self.type`, `self.name`, `self.parser`, `self.validator`, `self.map`, `self.default`, `self.deprecations`, `self.private`, `self.help`, `self.help_type`, `self.help_default`: Store the corresponding parameters passed to the initializer.\n- `self._full_name`: A normalized version of the variable name, intended for consistent internal representation, generated using the `_normalized` function.\n\nConstants:\n- `NoDefault`: An instance of `NoDefaultType` indicating the absence of a default value, used to distinguish between set and unset default values during initialization.",
        "signature": "def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:",
        "type": "Method",
        "class_signature": "class EnvVariable(t.Generic[T]):"
      },
      "EnvMeta.__new__": {
        "code": "    def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:\n        \"\"\"Creates a new instance of the Env class, initializing it with environment variable mappings and applying a prefix to the variable names if specified.\n\nParameters:\n- cls: The class that is being created.\n- name: The name of the class being created.\n- bases: A tuple containing the base classes from which the class is derived.\n- ns: A dictionary containing the namespace (attributes and methods) defined in the class.\n\nReturns:\n- An instance of the Env class, properly configured with environment variable mappings.\n\nSide Effects:\n- If a `__prefix__` attribute is defined in the class namespace, it normalizes the prefix and updates the `_full_name` attribute of each `EnvVariable` instance using `_normalized()` function to ensure consistent naming format. The `_normalized()` function creates a formatted string by converting dots to underscores and changing the string to uppercase.\n\nDependencies:\n- Relies on the `EnvVariable` class to handle the environment variable definitions, which are retrieved using the `values()` method of the Env class.\n- Uses the `os` module to access environment variables indirectly through the `Env` class.\"\"\"\n        env = t.cast('Env', super().__new__(cls, name, bases, ns))\n        prefix = ns.get('__prefix__')\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f'{_normalized(prefix)}_{v._full_name}'.upper()\n        return env",
        "docstring": "Creates a new instance of the Env class, initializing it with environment variable mappings and applying a prefix to the variable names if specified.\n\nParameters:\n- cls: The class that is being created.\n- name: The name of the class being created.\n- bases: A tuple containing the base classes from which the class is derived.\n- ns: A dictionary containing the namespace (attributes and methods) defined in the class.\n\nReturns:\n- An instance of the Env class, properly configured with environment variable mappings.\n\nSide Effects:\n- If a `__prefix__` attribute is defined in the class namespace, it normalizes the prefix and updates the `_full_name` attribute of each `EnvVariable` instance using `_normalized()` function to ensure consistent naming format. The `_normalized()` function creates a formatted string by converting dots to underscores and changing the string to uppercase.\n\nDependencies:\n- Relies on the `EnvVariable` class to handle the environment variable definitions, which are retrieved using the `values()` method of the Env class.\n- Uses the `os` module to access environment variables indirectly through the `Env` class.",
        "signature": "def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:",
        "type": "Method",
        "class_signature": "class EnvMeta(type):"
      },
      "Env.var": {
        "code": "    def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        \"\"\"Register an environment variable within the Env class.\n\nThis class method creates an instance of EnvVariable, which represents an environment variable that can be configured, validated, and parsed. The variable is associated with a name and type, and it allows for additional processing through optional parameters such as parser and validator.\n\nParameters:\n- type (t.Type[T]): The expected type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (t.Optional[t.Callable[[str], T]]): An optional function to parse the raw string value into the expected type.\n- validator (t.Optional[t.Callable[[T], None]]): An optional function to validate the parsed value.\n- map (t.Optional[MapType]): An optional mapping function for modifying the value(s).\n- default (t.Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault for required variables.\n- deprecations (t.Optional[t.List[DeprecationInfo]]): Optional list of tuples containing deprecation information for the variable.\n- private (bool): If True, the variable name will be private (prefixed with an underscore).\n- help (t.Optional[str]): Optional help text describing the variable.\n- help_type (t.Optional[str]): Optional description of the variable's type for help documentation.\n- help_default (t.Optional[str]): Optional description of the default value for help documentation.\n\nReturns:\n- EnvVariable[T]: An instance of the EnvVariable class configured with the given parameters.\n\nThis method plays a crucial role in creating and managing environment variables in subclasses of Env and relies on other components like EnvVariable and the _normalized function for proper name formatting.\"\"\"\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)",
        "docstring": "Register an environment variable within the Env class.\n\nThis class method creates an instance of EnvVariable, which represents an environment variable that can be configured, validated, and parsed. The variable is associated with a name and type, and it allows for additional processing through optional parameters such as parser and validator.\n\nParameters:\n- type (t.Type[T]): The expected type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (t.Optional[t.Callable[[str], T]]): An optional function to parse the raw string value into the expected type.\n- validator (t.Optional[t.Callable[[T], None]]): An optional function to validate the parsed value.\n- map (t.Optional[MapType]): An optional mapping function for modifying the value(s).\n- default (t.Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault for required variables.\n- deprecations (t.Optional[t.List[DeprecationInfo]]): Optional list of tuples containing deprecation information for the variable.\n- private (bool): If True, the variable name will be private (prefixed with an underscore).\n- help (t.Optional[str]): Optional help text describing the variable.\n- help_type (t.Optional[str]): Optional description of the variable's type for help documentation.\n- help_default (t.Optional[str]): Optional description of the default value for help documentation.\n\nReturns:\n- EnvVariable[T]: An instance of the EnvVariable class configured with the given parameters.\n\nThis method plays a crucial role in creating and managing environment variables in subclasses of Env and relies on other components like EnvVariable and the _normalized function for proper name formatting.",
        "signature": "def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      },
      "Env.values": {
        "code": "    def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:\n        \"\"\"Return an iterator over the values of all configuration items defined in the class.\n\nParameters:\n    recursive (bool): If True, include values from nested Env classes as well. Defaults to False.\n    include_derived (bool): If True, also include derived variables in the output. Defaults to False.\n\nReturns:\n    t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type[\"Env\"]]]: An iterator yielding the values of configuration items, which can include instances of EnvVariable, DerivedVariable, or subclasses of Env itself.\n\nThis method relies on the `cls.items` method to retrieve the configuration items, iterating over and yielding their corresponding values. The inclusion of derived variables and recursion into nested Env classes is determined by the method parameters, allowing for flexible extraction of configuration data.\"\"\"\n        'Return the value of all the configuration items.'\n        for _, v in cls.items(recursive, include_derived):\n            yield v",
        "docstring": "Return an iterator over the values of all configuration items defined in the class.\n\nParameters:\n    recursive (bool): If True, include values from nested Env classes as well. Defaults to False.\n    include_derived (bool): If True, also include derived variables in the output. Defaults to False.\n\nReturns:\n    t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type[\"Env\"]]]: An iterator yielding the values of configuration items, which can include instances of EnvVariable, DerivedVariable, or subclasses of Env itself.\n\nThis method relies on the `cls.items` method to retrieve the configuration items, iterating over and yielding their corresponding values. The inclusion of derived variables and recursion into nested Env classes is determined by the method parameters, allowing for flexible extraction of configuration data.",
        "signature": "def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      },
      "Env.help_info": {
        "code": "    def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:\n        \"\"\"Extracts help information for environment variables declared in the Env class.\n\nParameters:\n- recursive (bool): If True, includes environment variables from nested Env subclasses. Defaults to False.\n- include_private (bool): If True, includes variables marked as private (starting with an underscore). Defaults to False.\n\nReturns:\n- List[HelpInfo]: A list of HelpInfo tuples, each containing the variable name (formatted for display), its type, the default value, and a help message.\n\nThe method relies on the EnvVariable class, which represents environment variables within the Env class, and uses the _normalized helper function to format names. The help messages consider whether variables are private based on their naming convention and aggregate data for both declared and derived variables.\"\"\"\n        'Extract the help information from the class.\\n\\n        Returns a list of all the environment variables declared by the class.\\n        The format of each entry is a t.Tuple consisting of the variable name (in\\n        double backtics quotes), the type, the default value, and the help text.\\n\\n        Set ``recursive`` to ``True`` to include variables from nested Env\\n        classes.\\n\\n        Set ``include_private`` to ``True`` to include variables that are\\n        marked as private (i.e. their name starts with an underscore).\\n        '\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted((_ for _ in config.values() if isinstance(_, EnvVariable)), key=lambda v: v.name)\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n                help_message = v.help.strip() if v.help is not None else ''\n                if help_message and (not help_message.endswith('.')):\n                    help_message += '.'\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__\n                    except AttributeError:\n                        help_type = v.type.__args__[0].__name__\n                private_prefix = '_' if v.private else ''\n                entries.append(HelpInfo(f'{private_prefix}{full_prefix}{_normalized(v.name)}', help_type, v.help_default if v.help_default is not None else str(v.default), help_message))\n        configs = [('', cls)]\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and (not new_prefix.endswith('_')):\n                new_prefix += '_'\n            add_entries(new_prefix, config)\n            if not recursive:\n                break\n            subconfigs = sorted(((new_prefix, v) for k, v in config.__dict__.items() if isinstance(v, type) and issubclass(v, Env) and (k != 'parent')), key=lambda _: _[1].__prefix__)\n            configs[0:0] = subconfigs\n        return entries",
        "docstring": "Extracts help information for environment variables declared in the Env class.\n\nParameters:\n- recursive (bool): If True, includes environment variables from nested Env subclasses. Defaults to False.\n- include_private (bool): If True, includes variables marked as private (starting with an underscore). Defaults to False.\n\nReturns:\n- List[HelpInfo]: A list of HelpInfo tuples, each containing the variable name (formatted for display), its type, the default value, and a help message.\n\nThe method relies on the EnvVariable class, which represents environment variables within the Env class, and uses the _normalized helper function to format names. The help messages consider whether variables are private based on their naming convention and aggregate data for both declared and derived variables.",
        "signature": "def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: envier-test_help\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 envier/\n    \u2514\u2500\u2500 env.py\n        \u251c\u2500\u2500 Env.add_entries\n        \u251c\u2500\u2500 Env.help_info\n        \u251c\u2500\u2500 Env.values\n        \u251c\u2500\u2500 Env.var\n        \u251c\u2500\u2500 EnvMeta.__new__\n        \u251c\u2500\u2500 EnvVariable.__init__\n        \u2514\u2500\u2500 _normalized\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates configuration management for an application by providing a structured mechanism to define and access environment variables. It allows developers to declare configurations with type safety, default values, and detailed help descriptions, making application settings explicit and easier to manage. The module supports hierarchical configuration through nested structures, enabling complex multi-component environments to be handled efficiently. By dynamically pulling required settings from environment variables, it simplifies the process of managing environment-specific configurations while ensuring mandatory variables are explicitly defined, reducing runtime errors and improving maintainability.\n\n## FILE 1: envier/env.py\n\n- CLASS METHOD: Env.var\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n  - DOCSTRING: \n```python\n\"\"\"\nRegister an environment variable within the Env class.\n\nThis class method creates an instance of EnvVariable, which represents an environment variable that can be configured, validated, and parsed. The variable is associated with a name and type, and it allows for additional processing through optional parameters such as parser and validator.\n\nParameters:\n- type (t.Type[T]): The expected type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (t.Optional[t.Callable[[str], T]]): An optional function to parse the raw string value into the expected type.\n- validator (t.Optional[t.Callable[[T], None]]): An optional function to validate the parsed value.\n- map (t.Optional[MapType]): An optional mapping function for modifying the value(s).\n- default (t.Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault for required variables.\n- deprecations (t.Optional[t.List[DeprecationInfo]]): Optional list of tuples containing deprecation information for the variable.\n- private (bool): If True, the variable name will be private (prefixed with an underscore).\n- help (t.Optional[str]): Optional help text describing the variable.\n- help_type (t.Optional[str]): Optional description of the variable's type for help documentation.\n- help_default (t.Optional[str]): Optional description of the default value for help documentation.\n\nReturns:\n- EnvVariable[T]: An instance of the EnvVariable class configured with the given parameters.\n\nThis method plays a crucial role in creating and managing environment variables in subclasses of Env and relies on other components like EnvVariable and the _normalized function for proper name formatting.\n\"\"\"\n```\n\n- CLASS METHOD: EnvMeta.__new__\n  - CLASS SIGNATURE: class EnvMeta(type):\n  - SIGNATURE: def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:\n  - DOCSTRING: \n```python\n\"\"\"\nCreates a new instance of the Env class, initializing it with environment variable mappings and applying a prefix to the variable names if specified.\n\nParameters:\n- cls: The class that is being created.\n- name: The name of the class being created.\n- bases: A tuple containing the base classes from which the class is derived.\n- ns: A dictionary containing the namespace (attributes and methods) defined in the class.\n\nReturns:\n- An instance of the Env class, properly configured with environment variable mappings.\n\nSide Effects:\n- If a `__prefix__` attribute is defined in the class namespace, it normalizes the prefix and updates the `_full_name` attribute of each `EnvVariable` instance using `_normalized()` function to ensure consistent naming format. The `_normalized()` function creates a formatted string by converting dots to underscores and changing the string to uppercase.\n\nDependencies:\n- Relies on the `EnvVariable` class to handle the environment variable definitions, which are retrieved using the `values()` method of the Env class.\n- Uses the `os` module to access environment variables indirectly through the `Env` class.\n\"\"\"\n```\n\n- CLASS METHOD: Env.values\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn an iterator over the values of all configuration items defined in the class.\n\nParameters:\n    recursive (bool): If True, include values from nested Env classes as well. Defaults to False.\n    include_derived (bool): If True, also include derived variables in the output. Defaults to False.\n\nReturns:\n    t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type[\"Env\"]]]: An iterator yielding the values of configuration items, which can include instances of EnvVariable, DerivedVariable, or subclasses of Env itself.\n\nThis method relies on the `cls.items` method to retrieve the configuration items, iterating over and yielding their corresponding values. The inclusion of derived variables and recursion into nested Env classes is determined by the method parameters, allowing for flexible extraction of configuration data.\n\"\"\"\n```\n\n- CLASS METHOD: Env.help_info\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts help information for environment variables declared in the Env class.\n\nParameters:\n- recursive (bool): If True, includes environment variables from nested Env subclasses. Defaults to False.\n- include_private (bool): If True, includes variables marked as private (starting with an underscore). Defaults to False.\n\nReturns:\n- List[HelpInfo]: A list of HelpInfo tuples, each containing the variable name (formatted for display), its type, the default value, and a help message.\n\nThe method relies on the EnvVariable class, which represents environment variables within the Env class, and uses the _normalized helper function to format names. The help messages consider whether variables are private based on their naming convention and aggregate data for both declared and derived variables.\n\"\"\"\n```\n\n- FUNCTION NAME: _normalized\n  - SIGNATURE: def _normalized(name: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nNormalize the given variable name by converting it to uppercase, replacing dots with underscores, and removing any trailing underscores.\n\nParameters:\n- name (str): The input string representing a variable name that needs normalization.\n\nReturns:\n- str: The normalized version of the input variable name.\n\nThis function is primarily used in the context of processing environment variable names within the `EnvVariable` and `Env` classes, where consistent naming conventions are necessary for variable retrieval and management.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - envier/env.py:EnvMeta:__new__\n    - envier/env.py:Env:help_info\n\n- CLASS METHOD: EnvVariable.__init__\n  - CLASS SIGNATURE: class EnvVariable(t.Generic[T]):\n  - SIGNATURE: def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the `EnvVariable` class, which represents an environment variable with type safety and optional metadata.\n\nParameters:\n- `type` (Union[object, Type[T]]): The expected type of the environment variable, which may include a union of types.\n- `name` (str): The name of the environment variable.\n- `parser` (Optional[Callable[[str], T]]): A function to convert the raw string value to the specified type.\n- `validator` (Optional[Callable[[T], None]]): A function to validate the parsed value.\n- `map` (Optional[MapType]): A mapping function for transforming values, applicable for collection types.\n- `default` (Union[T, NoDefaultType]): The default value to use if the environment variable is not set; defaults to `NoDefault`.\n- `deprecations` (Optional[List[DeprecationInfo]]): A list of tuples containing deprecated variable information.\n- `private` (bool): A flag indicating if the variable should be treated as private; defaults to `False`.\n- `help` (Optional[str]): Help text describing the variable's purpose.\n- `help_type` (Optional[str]): A description of the variable type for documentation purposes.\n- `help_default` (Optional[str]): A description of the default value for documentation purposes.\n\nRaises:\n- `TypeError`: If the `default` value does not match the expected type defined by `type`.\n\nAttributes initialized:\n- `self.type`, `self.name`, `self.parser`, `self.validator`, `self.map`, `self.default`, `self.deprecations`, `self.private`, `self.help`, `self.help_type`, `self.help_default`: Store the corresponding parameters passed to the initializer.\n- `self._full_name`: A normalized version of the variable name, intended for consistent internal representation, generated using the `_normalized` function.\n\nConstants:\n- `NoDefault`: An instance of `NoDefaultType` indicating the absence of a default value, used to distinguish between set and unset default values during initialization.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\nclass NoDefaultType(object):\n\n    def __str__(self):\n        return ''\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\nT = t.TypeVar('T')\nK = t.TypeVar('K')\nV = t.TypeVar('V')\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple('HelpInfo', ('name', 'type', 'default', 'help'))\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, '__origin__'):\n        return isinstance(value, _type.__args__)\n    return isinstance(value, _type)\n\nclass EnvVariable(t.Generic[T]):\n\n    @property\n    def full_name(self) -> str:\n        return f'_{self._full_name}' if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: 'Env') -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(T, _type(collection if self.map is None else map(self.map, collection)))\n        elif _type is dict:\n            d = dict((_.split(env.__value_separator__, 1) for _ in raw.split(env.__item_separator__)))\n            if self.map is not None:\n                d = dict((self.map(*_) for _ in d.items()))\n            return t.cast(T, d)\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f'cannot cast {raw} to {self.type}'\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: 'Env', prefix: str) -> T:\n        source = env.source\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f'_{full_deprecated_name}'\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = ' in version %s' % deprecated_when if deprecated_when is not None else ''\n                    removed_when_message = ' and will be removed in version %s' % removed_when if removed_when is not None else ''\n                    warnings.warn('%s has been deprecated%s%s. Use %s instead' % (full_deprecated_name, deprecated_when_message, removed_when_message, full_name), DeprecationWarning)\n                    break\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n            raise KeyError('Mandatory environment variable {} is not set'.format(full_name))\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError('parser returned type {} instead of {}'.format(type(parsed), self.type))\n            return parsed\n        if hasattr(self.type, '__origin__') and self.type.__origin__ is t.Union:\n            for ot in self.type.__args__:\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n        return self._cast(self.type, raw, env)\n\n    def __call__(self, env: 'Env', prefix: str) -> T:\n        value = self._retrieve(env, prefix)\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f'Invalid value for environment variable {self.full_name}: {e}'\n                raise ValueError(msg)\n        return value\n\nclass DerivedVariable(t.Generic[T]):\n\n    def __init__(self, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: 'Env') -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError('derivation returned type {} instead of {}'.format(type(value), self.type))\n        return value\n\nclass EnvMeta(type):\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n    __truthy__ = frozenset({'1', 'true', 'yes', 'on'})\n    __prefix__ = ''\n    __item__: t.Optional[str] = None\n    __item_separator__ = ','\n    __value_separator__ = ':'\n\n    def __init__(self, source: t.Optional[t.Dict[str, str]]=None, parent: t.Optional['Env']=None, dynamic: t.Optional[t.Dict[str, str]]=None) -> None:\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = {k.upper(): v.upper() for k, v in dynamic.items()} if dynamic is not None else {}\n        self._full_prefix: str = (parent._full_prefix if parent is not None else '') + _normalized(self.__prefix__)\n        if self._full_prefix and (not self._full_prefix.endswith('_')):\n            self._full_prefix += '_'\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n        for n, d in derived:\n            setattr(self, n, d(self))\n\n    @classmethod\n    def v(cls, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)\n\n    @classmethod\n    def der(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def items(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type['Env']]] = deque()\n        path: t.Tuple[str] = tuple()\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield ('.'.join((*path, k)), t.cast(t.Union[EnvVariable, DerivedVariable], v))\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, '__item__', k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))\n\n    @classmethod\n    def keys(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def include(cls, env_spec: t.Type['Env'], namespace: t.Optional[str]=None, overwrite: bool=False) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        to_include = {k: v for k, v in env_spec.__dict__.items() if isinstance(v, (EnvVariable, DerivedVariable)) or (isinstance(v, type) and issubclass(v, Env))}\n        own_prefix = _normalized(getattr(cls, '__prefix__', ''))\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError('Namespace already in use: {}'.format(namespace))\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f'{own_prefix}_{v._full_name}'\n            return None\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError('Configuration clashes detected: {}'.format(overlap))\n        other_prefix = getattr(env_spec, '__prefix__', '')\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1:]\n                    if own_prefix:\n                        v._full_name = f'{own_prefix}_{v._full_name}'"
  },
  "call_tree": {
    "modified_testcases/test_help.py:ServiceConfig:GlobalConfig": {
      "envier/env.py:Env:var": {
        "envier/env.py:EnvVariable:__init__": {
          "envier/env.py:_normalized": {}
        }
      },
      "modified_testcases/test_help.py:ServiceConfig:ServiceConfig": {
        "envier/env.py:Env:var": {
          "envier/env.py:EnvVariable:__init__": {
            "envier/env.py:_normalized": {}
          }
        }
      },
      "envier/env.py:EnvMeta:__new__": {
        "envier/env.py:Env:values": {
          "envier/env.py:Env:items": {}
        },
        "envier/env.py:_normalized": {}
      }
    },
    "modified_testcases/test_help.py:test_help_info": {
      "envier/env.py:Env:help_info": {
        "envier/env.py:_normalized": {},
        "envier/env.py:Env:add_entries": {
          "envier/env.py:EnvVariable:EnvVariable": {},
          "envier/env.py:Env:values": {
            "envier/env.py:Env:items": {}
          },
          "envier/env.py:_normalized": {},
          "envier/env.py:NoDefaultType:__str__": {}
        }
      }
    },
    "modified_testcases/test_help.py:test_help_info_recursive": {
      "envier/env.py:Env:help_info": {
        "envier/env.py:_normalized": {},
        "envier/env.py:Env:add_entries": {
          "envier/env.py:Env:values": {
            "envier/env.py:Env:items": {}
          },
          "envier/env.py:_normalized": {},
          "envier/env.py:NoDefaultType:__str__": {}
        }
      }
    }
  }
}