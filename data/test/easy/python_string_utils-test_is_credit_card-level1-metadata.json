{
  "dir_path": "/app/python_string_utils",
  "package_name": "python_string_utils",
  "sample_name": "python_string_utils-test_is_credit_card",
  "src_dir": "string_utils/",
  "test_dir": "tests/",
  "test_file": "tests/test_is_credit_card.py",
  "test_code": "from unittest import TestCase\n\nfrom string_utils import is_credit_card\n\n\nclass IsCreditCardTestCase(TestCase):\n    # numbers generated by: http://www.getcreditcardnumbers.com\n    sample_cards = {\n        'VISA': [\n            '4929108461099666',\n            '4485341431836919',\n            '4929383875909178',\n            '4024007178235312',\n            '4929943872251997'\n        ],\n        'MASTERCARD': [\n            '5593685744413543',\n            '5299068126557657',\n            '5519706741220334',\n            '5349375673926726',\n            '5536077751185034'\n        ],\n        'DISCOVER': [\n            '6011738421556670',\n            '6011902207467698',\n            '6011066039342048',\n            '6011084365330958',\n            '6011417613048024'\n        ],\n        'AMERICAN_EXPRESS': [\n            '378255041294558',\n            '344411347420469',\n            '376197548847524',\n            '348870102379192',\n            '340073988128712'\n        ],\n        'JCB': [\n            '3528968052436214',\n            '213140714369305',\n            '180095242210070',\n            '213122809097983',\n            '213181044765010'\n        ],\n        'DINERS_CLUB': [\n            '30161673137117',\n            '38476920787395',\n            '38652978387607',\n            '36802519893181',\n            '30347192978103'\n        ]\n    }\n\n    def test_should_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card(0))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_credit_card({'a': 1}))\n\n    def test_string_cannot_be_empty(self):\n        self.assertFalse(is_credit_card(''))\n        self.assertFalse(is_credit_card(' '))\n\n    def test_string_cannot_contain_letters(self):\n        self.assertFalse(is_credit_card('not a credit card for sure'))\n\n    def test_numbers_in_string_should_be_15_at_least(self):\n        self.assertFalse(is_credit_card('1' * 14))\n\n    def test_should_accept_any_valid_card_number_if_type_is_not_specified(self):\n        for card_type in self.sample_cards:\n            for card_number in self.sample_cards[card_type]:\n                self.assertTrue(is_credit_card(card_number), 'Invalid card: %s (%s)' % (card_number, card_type))\n\n    def test_should_validate_only_specific_card_type_if_specified(self):\n        for card_type in self.sample_cards:\n            for card_number in self.sample_cards[card_type]:\n                self.assertTrue(\n                    is_credit_card(card_number, card_type=card_type),\n                    'Invalid card: %s (%s)' % (card_number, card_type)\n                )\n                other_cards = self.sample_cards.copy()\n                del other_cards[card_type]\n                for other_card in other_cards:\n                    self.assertFalse(\n                        is_credit_card(card_number, card_type=other_card),\n                        'Card %s should not be a valid %s' % (card_number, other_card)\n                    )\n\n    def test_cannot_provide_unsupported_card_type(self):\n        self.assertRaises(KeyError, lambda: is_credit_card(self.sample_cards['VISA'][0], card_type='FOO_CARD'))\n",
  "GT_file_code": {
    "string_utils/validation.py": "# -*- coding: utf-8 -*-\n\n# public api to export\n__all__ = [\n    'is_string',\n    'is_full_string',\n    'is_number',\n    'is_integer',\n    'is_decimal',\n    'is_url',\n    'is_email',\n    'is_credit_card',\n    'is_camel_case',\n    'is_snake_case',\n    'is_json',\n    'is_uuid',\n    'is_ip_v4',\n    'is_ip_v6',\n    'is_ip',\n    'is_isbn_10',\n    'is_isbn_13',\n    'is_isbn',\n    'is_palindrome',\n    'is_pangram',\n    'is_isogram',\n    'is_slug',\n    'contains_html',\n    'words_count',\n]\n\nimport json\nimport string\nfrom typing import Any, Optional, List\n\nfrom ._regex import *\nfrom .errors import InvalidInputError\n\n\n# PRIVATE API\n\n\nclass __ISBNChecker:\n    def __init__(self, input_string: str, normalize: bool = True):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string.replace('-', '') if normalize else input_string\n\n    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False\n\n    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False\n\n\n# PUBLIC API\n\ndef is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)\n\n\ndef is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''\n\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None\n\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string\n\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string\n\n\n# Full url example:\n# scheme://username:password@www.domain.com:8042/folder/subfolder/file.extension?param=value&param2=value2#hash\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n\n    return valid\n\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False\n\n\ndef is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys()))\n            )\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n\n    return False\n\n\ndef is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None\n\n\ndef is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False\n\n\ndef is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False\n\n\ndef is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None\n\n\ndef is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True\n\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None\n\n\ndef is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    return is_ip_v6(input_string) or is_ip_v4(input_string)\n\n\ndef is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\\\n    False otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if ignore_spaces:\n        input_string = SPACES_RE.sub('', input_string)\n\n    string_len = len(input_string)\n\n    # Traverse the string one char at step, and for each step compares the\n    # \"head_char\" (the one on the left of the string) to the \"tail_char\" (the one on the right).\n    # In this way we avoid to manipulate the whole string in advance if not necessary and provide a faster\n    # algorithm which can scale very well for long strings.\n    for index in range(string_len):\n        head_char = input_string[index]\n        tail_char = input_string[string_len - index - 1]\n\n        if ignore_case:\n            head_char = head_char.lower()\n            tail_char = tail_char.lower()\n\n        if head_char != tail_char:\n            return False\n\n    return True\n\n\ndef is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))\n\n\ndef is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)\n\n\ndef is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None\n\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None\n\n\ndef words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))\n\n\ndef is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_10()\n\n\ndef is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13()\n\n\ndef is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()\n"
  },
  "GT_src_dict": {
    "string_utils/validation.py": {
      "is_credit_card": {
        "code": "def is_credit_card(input_string: Any, card_type: str=None) -> bool:\n    \"\"\"Checks if a given string is a valid credit card number. It can validate against a specific card type (such as VISA, MASTERCARD, etc.) if provided; otherwise, it returns true for any valid credit card type from the predefined known types.\n\n:param input_string: The string representation of the credit card number to check.\n:type input_string: str\n:param card_type: An optional parameter specifying the type of credit card to validate against. Default is None, allowing for any known card type.\n:type card_type: str\n:return: True if the credit card number is valid, false otherwise.\n\nThis function relies on the `CREDIT_CARDS` constant, which is a dictionary containing regex patterns for different credit card types, facilitating type-specific validation. If the `card_type` is not found in `CREDIT_CARDS`, a KeyError is raised. The function first checks if the input is a non-empty string; if not, it returns false.\"\"\"\n    '\\n    Checks if a string is a valid credit card number.\\n    If card type is provided then it checks against that specific type only,\\n    otherwise any known credit card number will be accepted.\\n\\n    Supported card types are the following:\\n\\n    - VISA\\n    - MASTERCARD\\n    - AMERICAN_EXPRESS\\n    - DINERS_CLUB\\n    - DISCOVER\\n    - JCB\\n\\n    :param input_string: String to check.\\n    :type input_string: str\\n    :param card_type: Card type. Default to None (any card).\\n    :type card_type: str\\n\\n    :return: True if credit card, false otherwise.\\n    '\n    if not is_full_string(input_string):\n        return False\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError('Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys())))\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n    return False",
        "docstring": "Checks if a given string is a valid credit card number. It can validate against a specific card type (such as VISA, MASTERCARD, etc.) if provided; otherwise, it returns true for any valid credit card type from the predefined known types.\n\n:param input_string: The string representation of the credit card number to check.\n:type input_string: str\n:param card_type: An optional parameter specifying the type of credit card to validate against. Default is None, allowing for any known card type.\n:type card_type: str\n:return: True if the credit card number is valid, false otherwise.\n\nThis function relies on the `CREDIT_CARDS` constant, which is a dictionary containing regex patterns for different credit card types, facilitating type-specific validation. If the `card_type` is not found in `CREDIT_CARDS`, a KeyError is raised. The function first checks if the input is a non-empty string; if not, it returns false.",
        "signature": "def is_credit_card(input_string: Any, card_type: str=None) -> bool:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "string_utils/validation.py:is_credit_card": {
      "string_utils/validation.py": {
        "is_full_string": {
          "code": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''",
          "docstring": "Check if a string is not empty (it must contains at least one non space character).\n\n*Examples:*\n\n>>> is_full_string(None) # returns false\n>>> is_full_string('') # returns false\n>>> is_full_string(' ') # returns false\n>>> is_full_string('hello') # returns true\n\n:param input_string: String to check.\n:type input_string: str\n:return: True if not empty, false otherwise.",
          "signature": "def is_full_string(input_string: Any) -> bool:",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: python_string_utils-test_is_credit_card\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 string_utils/\n    \u2514\u2500\u2500 validation.py\n        \u2514\u2500\u2500 is_credit_card\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate whether a given string is a valid credit card number and optionally verify its adherence to a specified card type. It supports multiple card providers, including VISA, MasterCard, Discover, American Express, JCB, and Diners Club, ensuring comprehensive coverage for common card types. The module provides functionality to handle various input edge cases, such as non-string inputs, invalid formats, or unsupported card types, enhancing robustness in card validation. By offering precise and reliable credit card validation, this module simplifies identifying and filtering valid card numbers for developers, reducing implementation errors and improving the security of applications that process credit card information.\n\n## FILE 1: string_utils/validation.py\n\n- FUNCTION NAME: is_credit_card\n  - SIGNATURE: def is_credit_card(input_string: Any, card_type: str=None) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if a given string is a valid credit card number. It can validate against a specific card type (such as VISA, MASTERCARD, etc.) if provided; otherwise, it returns true for any valid credit card type from the predefined known types.\n\n:param input_string: The string representation of the credit card number to check.\n:type input_string: str\n:param card_type: An optional parameter specifying the type of credit card to validate against. Default is None, allowing for any known card type.\n:type card_type: str\n:return: True if the credit card number is valid, false otherwise.\n\nThis function relies on the `CREDIT_CARDS` constant, which is a dictionary containing regex patterns for different credit card types, facilitating type-specific validation. If the `card_type` is not found in `CREDIT_CARDS`, a KeyError is raised. The function first checks if the input is a non-empty string; if not, it returns false.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - string_utils/validation.py:is_full_string\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "string_utils/validation.py": "__all__ = ['is_string', 'is_full_string', 'is_number', 'is_integer', 'is_decimal', 'is_url', 'is_email', 'is_credit_card', 'is_camel_case', 'is_snake_case', 'is_json', 'is_uuid', 'is_ip_v4', 'is_ip_v6', 'is_ip', 'is_isbn_10', 'is_isbn_13', 'is_isbn', 'is_palindrome', 'is_pangram', 'is_isogram', 'is_slug', 'contains_html', 'words_count']\nimport json\nimport string\nfrom typing import Any, Optional, List\nfrom ._regex import *\nfrom .errors import InvalidInputError\n\nclass __ISBNChecker:\n\n    def __init__(self, input_string: str, normalize: bool=True):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n        self.input_string = input_string.replace('-', '') if normalize else input_string\n\n    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if index % 2 == 0 else 3\n                    product += int(digit) * weight\n                return product % 10 == 0\n            except ValueError:\n                pass\n        return False\n\n    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n                return product % 11 == 0\n            except ValueError:\n                pass\n        return False\n\ndef is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)\n\ndef is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n    return NUMBER_RE.match(input_string) is not None\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]]=None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    valid = URL_RE.match(input_string) is not None\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n    return valid\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n    try:\n        head, tail = input_string.split('@')\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n        return EMAIL_RE.match(head + '@' + tail) is not None\n    except ValueError:\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n        return False\n\ndef is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None\n\ndef is_snake_case(input_string: Any, separator: str='_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {'_': SNAKE_CASE_TEST_RE, '-': SNAKE_CASE_TEST_DASH_RE}\n        re_template = '([a-z]+\\\\d*{sign}[a-z\\\\d{sign}]*|{sign}+[a-z\\\\d]+[a-z\\\\d{sign}]*)'\n        r = re_map.get(separator, re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE))\n        return r.match(input_string) is not None\n    return False\n\ndef is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n    return False\n\ndef is_uuid(input_string: Any, allow_hex: bool=False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    s = str(input_string)\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n    return UUID_RE.match(s) is not None\n\ndef is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n    for token in input_string.split('.'):\n        if not 0 <= int(token) <= 255:\n            return False\n    return True\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None\n\ndef is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    return is_ip_v6(input_string) or is_ip_v4(input_string)\n\ndef is_palindrome(input_string: Any, ignore_spaces: bool=False, ignore_case: bool=False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),    False otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    if ignore_spaces:\n        input_string = SPACES_RE.sub('', input_string)\n    string_len = len(input_string)\n    for index in range(string_len):\n        head_char = input_string[index]\n        tail_char = input_string[string_len - index - 1]\n        if ignore_case:\n            head_char = head_char.lower()\n            tail_char = tail_char.lower()\n        if head_char != tail_char:\n            return False\n    return True\n\ndef is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))\n\ndef is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)\n\ndef is_slug(input_string: Any, separator: str='-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    rex = '^([a-z\\\\d]+' + re.escape(separator) + '*?)*[a-z\\\\d]$'\n    return re.match(rex, input_string) is not None\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n    return HTML_RE.search(input_string) is not None\n\ndef words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n    return len(WORDS_COUNT_RE.findall(input_string))\n\ndef is_isbn_10(input_string: str, normalize: bool=True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_10()\n\ndef is_isbn_13(input_string: str, normalize: bool=True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13()\n\ndef is_isbn(input_string: str, normalize: bool=True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()"
  },
  "call_tree": {
    "tests/test_is_credit_card.py:IsCreditCardTestCase:test_cannot_provide_unsupported_card_type": {
      "string_utils/validation.py:is_credit_card": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_credit_card.py:IsCreditCardTestCase:test_numbers_in_string_should_be_15_at_least": {
      "string_utils/validation.py:is_credit_card": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_credit_card.py:IsCreditCardTestCase:test_should_accept_any_valid_card_number_if_type_is_not_specified": {
      "string_utils/validation.py:is_credit_card": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_credit_card.py:IsCreditCardTestCase:test_should_return_false_for_non_string_objects": {
      "string_utils/validation.py:is_credit_card": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_credit_card.py:IsCreditCardTestCase:test_should_validate_only_specific_card_type_if_specified": {
      "string_utils/validation.py:is_credit_card": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_credit_card.py:IsCreditCardTestCase:test_string_cannot_be_empty": {
      "string_utils/validation.py:is_credit_card": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_credit_card.py:IsCreditCardTestCase:test_string_cannot_contain_letters": {
      "string_utils/validation.py:is_credit_card": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    }
  }
}