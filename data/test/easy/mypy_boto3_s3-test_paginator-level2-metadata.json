{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_paginator",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/structures/test_paginator.py",
  "test_code": "from mypy_boto3_builder.service_name import ServiceNameCatalog\nfrom mypy_boto3_builder.structures.paginator import Paginator\n\n\nclass TestPaginator:\n    paginator: Paginator\n\n    def setup_method(self) -> None:\n        self.paginator = Paginator(\n            name=\"name\",\n            operation_name=\"my_operation_name\",\n            service_name=ServiceNameCatalog.s3,\n            paginator_name=\"paginator_name\",\n        )\n\n    def test_init(self) -> None:\n        assert self.paginator.name == \"name\"\n        assert self.paginator.operation_name == \"my_operation_name\"\n        assert self.paginator.service_name == ServiceNameCatalog.s3\n\n    def test_boto3_doc_link(self) -> None:\n        assert (\n            self.paginator.boto3_doc_link\n            == \"https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3/paginator/paginator_name.html#S3.Paginator.paginator_name\"\n        )\n\n    def test_get_client_method(self) -> None:\n        result = self.paginator.get_client_method()\n        assert result.name == \"get_paginator\"\n        assert result.return_type.name == \"name\"  # type: ignore\n        assert result.arguments[1].type_annotation.children == {\"my_operation_name\"}  # type: ignore\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n",
    "mypy_boto3_builder/structures/argument.py": "\"\"\"\nMethod or function argument.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nfrom collections.abc import Iterator\nfrom typing import Final, Literal, Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\n\nclass Argument:\n    \"\"\"\n    Method or function argument.\n\n    Arguments:\n        name -- Argument name.\n        type_annotation -- Argument type annotation.\n        value -- Default argument value.\n        prefix -- Used for starargs.\n    \"\"\"\n\n    SELF_NAME: Final = \"self\"\n    CLS_NAME: Final = \"cls\"\n    KW_NAME: Final = \"*\"\n    FIRST_NAMES: Final = {SELF_NAME, CLS_NAME}\n\n    def __init__(\n        self,\n        name: str,\n        type_annotation: FakeAnnotation | None,\n        default: TypeConstant | None = None,\n        prefix: Literal[\"*\", \"**\", \"\"] = \"\",\n    ) -> None:\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal[\"*\", \"**\", \"\"] = prefix\n\n    def render(self) -> str:\n        \"\"\"\n        Render argument to a string.\n        \"\"\"\n        default_suffix = f\" = {self.default.render()}\" if self.default is not None else \"\"\n        if not self.type_annotation:\n            return f\"{self.name}{default_suffix}\"\n\n        return f\"{self.name}: {self.type_annotation.render()}{default_suffix}\"\n\n    @classmethod\n    def self(cls) -> Self:\n        \"\"\"\n        Create `self` argument.\n        \"\"\"\n        return cls(name=cls.SELF_NAME, type_annotation=None)\n\n    @classmethod\n    def kwflag(cls) -> Self:\n        \"\"\"\n        Create `*` keywords separator.\n        \"\"\"\n        return cls(name=cls.KW_NAME, type_annotation=None)\n\n    def is_kwflag(self) -> bool:\n        \"\"\"\n        Whether argument is a `*` keywords separator.\n        \"\"\"\n        return self.name == \"*\"\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations.\n        \"\"\"\n        if self.type_annotation is not None:\n            yield from self.type_annotation.iterate_types()\n        if self.default is not None:\n            yield from self.default.iterate_types()\n\n    @property\n    def required(self) -> bool:\n        \"\"\"\n        Whether argument does not have a default value and is required.\n        \"\"\"\n        return self.default is None\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return self.__class__(\n            name=self.name,\n            type_annotation=self.type_annotation.copy() if self.type_annotation else None,\n            default=self.default.copy() if self.default else None,\n            prefix=self.prefix,\n        )\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n",
    "mypy_boto3_builder/structures/paginator.py": "\"\"\"\nBoto3 client Paginator.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom botocore.paginate import Paginator as BotocorePaginator\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\n\n\n@functools.total_ordering\nclass Paginator(ClassRecord):\n    \"\"\"\n    Boto3 client Paginator.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        paginator_name: str,\n        operation_name: str,\n        service_name: ServiceName,\n    ) -> None:\n        super().__init__(\n            name=name,\n            bases=[ExternalImport.from_class(BotocorePaginator)],\n        )\n        self.operation_name = operation_name\n        self.paginator_name = paginator_name\n        self.service_name = service_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Hash paginators by name.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort paginators by name.\n        \"\"\"\n        return self.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, Paginator):\n            raise BuildInternalError(f\"{other} is not Paginator\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            f\"{self.service_name.boto3_doc_link_parent}\"\n            f\"/paginator/{self.paginator_name}.html\"\n            f\"#{self.service_name.class_name}.Paginator.{self.paginator_name}\"\n        )\n\n    def get_client_method(self) -> Method:\n        \"\"\"\n        Get `get_paginator` method for `Client`.\n        \"\"\"\n        return Method(\n            name=\"get_paginator\",\n            decorators=[Type.overload],\n            docstring=self.docstring,\n            arguments=[\n                Argument.self(),\n                Argument(\n                    \"operation_name\",\n                    TypeLiteral(f\"{self.name}Name\", [self.operation_name]),\n                ),\n            ],\n            return_type=ExternalImport(\n                source=ImportString(\"\", ServiceModuleName.paginator.value),\n                name=self.name,\n            ),\n        )\n",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def __init__(self, name: str, children: Iterable[str]) -> None:\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError(\"Literal should have children\")\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.inline:\n            children = \", \".join([repr(i) for i in sorted(self.children)])\n            return f\"Literal[{children}]\"\n\n        return self.name\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation(\"Literal\").get_import_records()\n\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation(\"Literal\").get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError(\"Use add_literal_child function.\")\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path(\"common/literal.py.jinja2\"), {\"literal\": self})\n",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import ClassVar, Final, Literal\n\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n\n__all__ = (\n    \"ServiceName\",\n    \"ServiceNameCatalog\",\n)\n\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n\n    ALL: Final = \"all\"\n    UPDATED: Final = \"updated\"\n    ESSENTIAL: Final = \"essential\"\n    LATEST: Final = \"latest\"\n\n    ESSENTIAL_NAMES: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n    CONDA_FORGE_AVAILABLE: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str = \"\") -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f\"<ServiceName {self.name} {self.class_name}>\"\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace(\"-\", \"_\")\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace(\"-\", \"_\")\n        if is_reserved(name):\n            return f\"{name}_\"\n\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}\"\n        )\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )\n\n    @staticmethod\n    def get_md_doc_link(\n        file: Literal[\n            \"client\",\n            \"service_resource\",\n            \"waiters\",\n            \"paginators\",\n            \"type_defs\",\n            \"literals\",\n        ],\n        *parts: str,\n    ) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f\"./{file}.md\"\n        if not parts:\n            return link\n        anchor = \"\".join([get_anchor_link(part) for part in parts])\n        return f\"{link}#{anchor}\"\n\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n\n    all = ServiceName(\"__all\", \"__all\")\n    ec2 = ServiceName(\"ec2\", \"EC2\")\n    iam = ServiceName(\"iam\", \"IAM\")\n    s3 = ServiceName(\"s3\", \"S3\")\n    rds = ServiceName(\"rds\", \"RDS\")\n    cloudwatch = ServiceName(\"cloudwatch\", \"CloudWatch\")\n    opsworks = ServiceName(\"opsworks\", \"OpsWorks\")\n    sns = ServiceName(\"sns\", \"SNS\")\n    glacier = ServiceName(\"glacier\", \"Glacier\")\n    dynamodb = ServiceName(\"dynamodb\", \"DynamoDB\")\n    sqs = ServiceName(\"sqs\", \"SQS\")\n    cloudformation = ServiceName(\"cloudformation\", \"CloudFormation\")\n    cloudsearchdomain = ServiceName(\"cloudsearchdomain\", \"CloudSearchDomain\")\n    logs = ServiceName(\"logs\", \"CloudWatchLogs\")\n    lambda_ = ServiceName(\"lambda\", \"Lambda\")\n    stepfunctions = ServiceName(\"stepfunctions\", \"SFN\")\n    old_redshift_serverless = ServiceName(\n        \"redshift-serverless\",\n        \"RedshiftServerless\",\n        \"redshiftserverless\",\n    )\n    old_ssm_sap = ServiceName(\"ssm-sap\", \"SsmSap\", \"ssmsap\")\n\n    ITEMS: ClassVar[dict[str, ServiceName]] = {\n        ec2.boto3_name: ec2,\n        iam.boto3_name: iam,\n        s3.boto3_name: s3,\n        rds.boto3_name: rds,\n        cloudwatch.boto3_name: cloudwatch,\n        opsworks.boto3_name: opsworks,\n        sns.boto3_name: sns,\n        glacier.boto3_name: glacier,\n        dynamodb.boto3_name: dynamodb,\n        sqs.boto3_name: sqs,\n        cloudformation.boto3_name: cloudformation,\n        cloudsearchdomain.boto3_name: cloudsearchdomain,\n        logs.boto3_name: logs,\n        lambda_.boto3_name: lambda_,\n        old_redshift_serverless.boto3_name: old_redshift_serverless,\n        old_ssm_sap.boto3_name: old_ssm_sap,\n    }\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name\n",
    "mypy_boto3_builder/structures/function.py": "\"\"\"\nModule-level function.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\n\n\nclass Function:\n    \"\"\"\n    Module-level function.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        arguments: Iterable[Argument],\n        return_type: FakeAnnotation,\n        *,\n        docstring: str = \"\",\n        decorators: Iterable[FakeAnnotation] = (),\n        body_lines: Iterable[str] = (),\n        type_ignore: bool = False,\n        is_async: bool = False,\n        boto3_doc_link: str = \"\",\n    ) -> None:\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        if not self._boto3_doc_link:\n            raise BuildInternalError(f\"{self.name} has no boto3_doc_link\")\n        return self._boto3_doc_link\n\n    def set_boto3_doc_link(self, link: str) -> None:\n        \"\"\"\n        Set link to boto3 docs.\n        \"\"\"\n        self._boto3_doc_link = link\n\n    def has_boto3_doc_link(self) -> bool:\n        \"\"\"\n        Whether boto3_doc_link is set.\n        \"\"\"\n        return bool(self._boto3_doc_link)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Represent as a valid Python function signature.\n        \"\"\"\n        return (\n            f\"{'async ' if self.is_async else ''}def\"\n            f\" {self.name}({', '.join(argument.render() for argument in self.arguments)}) ->\"\n            f\" {self.return_type.render()}\"\n        )\n\n    @property\n    def short_docstring(self) -> str:\n        \"\"\"\n        Docstring without documentation links.\n        \"\"\"\n        if not self.docstring:\n            return self.docstring\n\n        short_docstring = self.docstring.strip().split(\"\\n\\n\")[0]\n        if short_docstring.startswith(\"[\"):\n            return \"\"\n        return short_docstring\n\n    def create_request_type_annotation(self, name: str) -> None:\n        \"\"\"\n        Create and set `request_type_annotation` TypedDict based on function arguments.\n        \"\"\"\n        result = TypeTypedDict(name)\n        for argument in self.arguments:\n            if argument.is_kwflag():\n                continue\n\n            if not argument.type_annotation:\n                continue\n            result.add_attribute(\n                argument.name,\n                argument.type_annotation,\n                required=argument.required,\n            )\n\n        if not result.children:\n            return\n        self.request_type_annotation = result\n\n    def iterate_packed_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over packed arguments for KW-only functions.\n        \"\"\"\n        if not self.is_kw_only() or not self.request_type_annotation:\n            yield from self.arguments\n            return\n\n        yield Argument(\n            name=\"kwargs\",\n            type_annotation=Type.unpack(self.request_type_annotation),\n            prefix=\"**\",\n        )\n\n    @property\n    def body(self) -> str:\n        \"\"\"\n        Function body as a string.\n        \"\"\"\n        return \"\\n\".join(self.body_lines)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over required type annotations.\n        \"\"\"\n        yield from self.return_type.iterate_types()\n        for argument in self.iterate_packed_arguments():\n            yield from argument.iterate_types()\n        for decorator in self.decorators:\n            yield from decorator.iterate_types()\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract required import records.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n\n        return result\n\n    @property\n    def returns_none(self) -> bool:\n        \"\"\"\n        Whether return type is None.\n        \"\"\"\n        return self.return_type == Type.none\n\n    def is_kw_only(self) -> bool:\n        \"\"\"\n        Whether method arguments can be passed only as kwargs.\n        \"\"\"\n        if not self.has_arguments():\n            return False\n\n        first_argument = next(self.iterate_call_arguments())\n        return first_argument.is_kwflag()\n\n    def iterate_call_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over arguments that are used in function call.\n        \"\"\"\n        yield from self.arguments\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        result.extend(\n            argument.type_annotation\n            for argument in self.arguments\n            if argument.type_annotation and argument.type_annotation.get_local_types()\n        )\n        if self.return_type and self.return_type.get_local_types():\n            result.append(self.return_type)\n        return result\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return self.__class__(\n            name=self.name,\n            arguments=[i.copy() for i in self.arguments],\n            return_type=self.return_type.copy(),\n            docstring=self.docstring,\n            decorators=[i.copy() for i in self.decorators],\n            body_lines=list(self.body_lines),\n            type_ignore=self.type_ignore,\n            is_async=self.is_async,\n        )\n\n    def remove_argument(self, *names: str) -> Self:\n        \"\"\"\n        Remove argument by name or names.\n        \"\"\"\n        remove = [arg for arg in self.arguments if arg.name in names]\n\n        for argument in remove:\n            self.arguments.remove(argument)\n\n        return self\n\n    def has_arguments(self) -> bool:\n        \"\"\"\n        Whether function has arguments.\n        \"\"\"\n        return bool(self.arguments)\n",
    "mypy_boto3_builder/structures/class_record.py": "\"\"\"\nBase class for all structures that can be rendered to a class.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.attribute import Attribute\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.internal_import import InternalImport\nfrom mypy_boto3_builder.utils.strings import xform_name\n\n\nclass ClassRecord:\n    \"\"\"\n    Base class for all structures that can be rendered to a class.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        methods: Iterable[Method] = (),\n        attributes: Iterable[Attribute] = (),\n        bases: Iterable[FakeAnnotation] = (),\n        *,\n        use_alias: bool = False,\n    ) -> None:\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = \"\"\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return \"\"\n\n    @property\n    def alias_name(self) -> str:\n        \"\"\"\n        Class alias name for safe import.\n\n        Returns:\n            Name prefixed with underscore.\n        \"\"\"\n        if not self.use_alias:\n            raise StructureError(f\"Cannot get alias for {self.name} with no alias.\")\n\n        return InternalImport.get_alias(self.name)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over type annotations for methods, attributes and bases.\n        \"\"\"\n        for method in self.methods:\n            yield from method.iterate_types()\n        for attribute in self.attributes:\n            yield from attribute.iterate_types()\n        for base in self.bases:\n            yield from base.iterate_types()\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract import records from required type annotations.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n\n        return result\n\n    def get_internal_imports(self) -> set[InternalImport]:\n        \"\"\"\n        Get internal imports from methods.\n        \"\"\"\n        result: set[InternalImport] = set()\n        for method in self.methods:\n            for type_annotation in method.iterate_types():\n                if not isinstance(type_annotation, InternalImport):\n                    continue\n                result.add(type_annotation)\n\n        return result\n\n    @property\n    def variable_name(self) -> str:\n        \"\"\"\n        Variable name for an instance of this class.\n        \"\"\"\n        return xform_name(self.name)\n\n    @property\n    def method_names(self) -> list[str]:\n        \"\"\"\n        Unique method names.\n        \"\"\"\n        return sorted({i.name for i in self.methods})\n\n    def get_method(self, name: str) -> Method:\n        \"\"\"\n        Get method by name.\n        \"\"\"\n        for method in self.methods:\n            if method.name == name:\n                return method\n\n        raise StructureError(f\"Method {name} not found\")\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initializes an ImportString instance.\n\nArguments:\n    parent (str): The master module name that serves as the root of the import string.\n    *parts (str): Additional parts of the import string to be appended to the parent.\n\nRaises:\n    StructureError: If the import string would be empty or if any part includes a dot ('.'), indicating incorrect structure. \n                    Also raises if there are empty parts after non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple consisting of the parent and its associated parts, ensuring that the structure is valid and adheres to the rules defined for Python import strings.\n\nThis constructor utilizes the StructureError class to handle potential input errors related to the import string format and ensures that the combined import string is valid before storing it in the parts attribute.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initializes an ImportString instance.\n\nArguments:\n    parent (str): The master module name that serves as the root of the import string.\n    *parts (str): Additional parts of the import string to be appended to the parent.\n\nRaises:\n    StructureError: If the import string would be empty or if any part includes a dot ('.'), indicating incorrect structure. \n                    Also raises if there are empty parts after non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple consisting of the parent and its associated parts, ensuring that the structure is valid and adheres to the rules defined for Python import strings.\n\nThis constructor utilizes the StructureError class to handle potential input errors related to the import string format and ensures that the combined import string is valid before storing it in the parts attribute.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    },
    "mypy_boto3_builder/structures/argument.py": {
      "Argument.__init__": {
        "code": "    def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:\n        \"\"\"Initialize an Argument instance representing a method or function argument.\n\nParameters:\n- name (str): The name of the argument.\n- type_annotation (FakeAnnotation | None): The type annotation for the argument. It can be None if no type is specified.\n- default (TypeConstant | None, optional): The default value for the argument. Defaults to None, indicating that it is a required argument.\n- prefix (Literal[\"*\", \"**\", \"\"], optional): A prefix used for starargs to denote variable arguments. Defaults to an empty string.\n\nAttributes:\n- self.name: Stores the name of the argument.\n- self.type_annotation: Stores the type annotation, which is expected to be an instance of FakeAnnotation or None.\n- self.default: Stores the default value, which is an instance of TypeConstant or None.\n- self.prefix: A literal indicating the type of argument, which can be \"*\", \"**\", or an empty string, used for function signature rendering.\n\nThis constructor interacts with class constants such as SELF_NAME and CLS_NAME, which represent common argument names used in class methods. The class also utilizes the `render` method for formatting argument representations in string form.\"\"\"\n        self.name = name\n        self.type_annotation = type_annotation\n        self.default = default\n        self.prefix: Literal['*', '**', ''] = prefix",
        "docstring": "Initialize an Argument instance representing a method or function argument.\n\nParameters:\n- name (str): The name of the argument.\n- type_annotation (FakeAnnotation | None): The type annotation for the argument. It can be None if no type is specified.\n- default (TypeConstant | None, optional): The default value for the argument. Defaults to None, indicating that it is a required argument.\n- prefix (Literal[\"*\", \"**\", \"\"], optional): A prefix used for starargs to denote variable arguments. Defaults to an empty string.\n\nAttributes:\n- self.name: Stores the name of the argument.\n- self.type_annotation: Stores the type annotation, which is expected to be an instance of FakeAnnotation or None.\n- self.default: Stores the default value, which is an instance of TypeConstant or None.\n- self.prefix: A literal indicating the type of argument, which can be \"*\", \"**\", or an empty string, used for function signature rendering.\n\nThis constructor interacts with class constants such as SELF_NAME and CLS_NAME, which represent common argument names used in class methods. The class also utilizes the `render` method for formatting argument representations in string form.",
        "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:",
        "type": "Method",
        "class_signature": "class Argument:"
      },
      "Argument.self": {
        "code": "    def self(cls) -> Self:\n        \"\"\"Create a `self` argument instance.\n\nThis class method constructs an `Argument` instance with the name set to the constant `SELF_NAME`, which is defined as `\"self\"` in the Argument class. The type annotation for this argument is set to `None`. \n\nParameters:\n    cls: The class reference.\n\nReturns:\n    An instance of `Argument` initialized with the name `\"self\"` and a `None` type annotation.\n\nThis method is used to represent an instance method's `self` parameter in a consistent manner.\"\"\"\n        '\\n        Create `self` argument.\\n        '\n        return cls(name=cls.SELF_NAME, type_annotation=None)",
        "docstring": "Create a `self` argument instance.\n\nThis class method constructs an `Argument` instance with the name set to the constant `SELF_NAME`, which is defined as `\"self\"` in the Argument class. The type annotation for this argument is set to `None`. \n\nParameters:\n    cls: The class reference.\n\nReturns:\n    An instance of `Argument` initialized with the name `\"self\"` and a `None` type annotation.\n\nThis method is used to represent an instance method's `self` parameter in a consistent manner.",
        "signature": "def self(cls) -> Self:",
        "type": "Method",
        "class_signature": "class Argument:"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.__init__": {
        "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        \"\"\"Initializes an instance of the ExternalImport class, which serves as a wrapper for type annotations imported from third-party libraries.\n\nParameters:\n- source (ImportString): The module import string representing the source of the type annotation.\n- name (str, optional): The name of the imported type. Defaults to an empty string.\n- alias (str, optional): The local name used for the import. Defaults to an empty string.\n- safe (bool, optional): A flag indicating whether the import is wrapped in try-except for safety. Defaults to False.\n\nAttributes initialized:\n- self.source: Stores the ImportString object referring to the module.\n- self.name: Stores the name of the imported type.\n- self.alias: Stores the local alias for the import.\n- self.safe: Stores the safety flag for the import.\n\nThis constructor utilizes the ImportString type, which is defined in mypy_boto3_builder.import_helpers.import_string, to correctly manage import strings. It is a foundational part of the ExternalImport class, enabling proper handling of type annotations from external libraries.\"\"\"\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe",
        "docstring": "Initializes an instance of the ExternalImport class, which serves as a wrapper for type annotations imported from third-party libraries.\n\nParameters:\n- source (ImportString): The module import string representing the source of the type annotation.\n- name (str, optional): The name of the imported type. Defaults to an empty string.\n- alias (str, optional): The local name used for the import. Defaults to an empty string.\n- safe (bool, optional): A flag indicating whether the import is wrapped in try-except for safety. Defaults to False.\n\nAttributes initialized:\n- self.source: Stores the ImportString object referring to the module.\n- self.name: Stores the name of the imported type.\n- self.alias: Stores the local alias for the import.\n- self.safe: Stores the safety flag for the import.\n\nThis constructor utilizes the ImportString type, which is defined in mypy_boto3_builder.import_helpers.import_string, to correctly manage import strings. It is a foundational part of the ExternalImport class, enabling proper handling of type annotations from external libraries.",
        "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.from_class": {
        "code": "    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"Create an instance of ExternalImport from a given class.\n\nArgs:\n    cls: The class type of the ExternalImport instance being created.\n    obj: The class object from which to derive the import information.\n    alias: An optional local name to be used for the import (default is an empty string).\n    safe: A boolean indicating whether the import should be wrapped in try-except (default is False).\n\nReturns:\n    An instance of ExternalImport initialized with the source module's name, \n    the class name, the specified alias, and the safe import setting.\n\nRaises:\n    TypeAnnotationError: If the module of the given class object cannot be determined.\n\nThe method utilizes `inspect.getmodule()` to retrieve the module of the given class \nand constructs an ImportString using `ImportString.from_str()` with the module's name. \nThis allows encapsulation of type annotations from external libraries.\"\"\"\n        '\\n        Create an instance from an imported class.\\n\\n        Arguments:\\n            value -- Any Class.\\n            alias -- Local name.\\n            safe -- Whether import is wrapped in try-except.\\n        '\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)",
        "docstring": "Create an instance of ExternalImport from a given class.\n\nArgs:\n    cls: The class type of the ExternalImport instance being created.\n    obj: The class object from which to derive the import information.\n    alias: An optional local name to be used for the import (default is an empty string).\n    safe: A boolean indicating whether the import should be wrapped in try-except (default is False).\n\nReturns:\n    An instance of ExternalImport initialized with the source module's name, \n    the class name, the specified alias, and the safe import setting.\n\nRaises:\n    TypeAnnotationError: If the module of the given class object cannot be determined.\n\nThe method utilizes `inspect.getmodule()` to retrieve the module of the given class \nand constructs an ImportString using `ImportString.from_str()` with the module's name. \nThis allows encapsulation of type annotations from external libraries.",
        "signature": "def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/structures/paginator.py": {
      "Paginator.__init__": {
        "code": "    def __init__(self, name: str, paginator_name: str, operation_name: str, service_name: ServiceName) -> None:\n        \"\"\"Initialize a Paginator instance for Boto3 clients.\n\nParameters:\n- name (str): The name of the paginator.\n- paginator_name (str): The specific name used in Boto3 for the paginator.\n- operation_name (str): The name of the operation associated with this paginator.\n- service_name (ServiceName): An instance of ServiceName representing the AWS service this paginator is related to.\n\nThis constructor initializes the Paginator by calling the superclass's constructor with the paginator's name and the base class being Botocore's Paginator. It also sets the operation name, paginator name, and service name as attributes for further use in paginator methods and properties.\"\"\"\n        super().__init__(name=name, bases=[ExternalImport.from_class(BotocorePaginator)])\n        self.operation_name = operation_name\n        self.paginator_name = paginator_name\n        self.service_name = service_name",
        "docstring": "Initialize a Paginator instance for Boto3 clients.\n\nParameters:\n- name (str): The name of the paginator.\n- paginator_name (str): The specific name used in Boto3 for the paginator.\n- operation_name (str): The name of the operation associated with this paginator.\n- service_name (ServiceName): An instance of ServiceName representing the AWS service this paginator is related to.\n\nThis constructor initializes the Paginator by calling the superclass's constructor with the paginator's name and the base class being Botocore's Paginator. It also sets the operation name, paginator name, and service name as attributes for further use in paginator methods and properties.",
        "signature": "def __init__(self, name: str, paginator_name: str, operation_name: str, service_name: ServiceName) -> None:",
        "type": "Method",
        "class_signature": "class Paginator(ClassRecord):"
      },
      "Paginator.boto3_doc_link": {
        "code": "    def boto3_doc_link(self) -> str:\n        \"\"\"Generates a URL linking to the official AWS Boto3 documentation for the specific paginator represented by the instance.\n\nReturns:\n    str: A formatted URL string that points to the paginator's documentation page in the Boto3 docs.\n\nDependencies:\n- `self.service_name.boto3_doc_link_parent`: This attribute holds the base URL for the Boto3 documentation specific to the service associated with this paginator.\n- `self.paginator_name`: The name of the paginator used to construct the specific documentation link.\n- `self.service_name.class_name`: The class name of the service used to create the anchor reference in the documentation link.\n\nThis method provides a simple way to access the relevant documentation for the paginator defined in the class, leveraging the attributes initialized in the Paginator class.\"\"\"\n        '\\n        Link to boto3 docs.\\n        '\n        return f'{self.service_name.boto3_doc_link_parent}/paginator/{self.paginator_name}.html#{self.service_name.class_name}.Paginator.{self.paginator_name}'",
        "docstring": "Generates a URL linking to the official AWS Boto3 documentation for the specific paginator represented by the instance.\n\nReturns:\n    str: A formatted URL string that points to the paginator's documentation page in the Boto3 docs.\n\nDependencies:\n- `self.service_name.boto3_doc_link_parent`: This attribute holds the base URL for the Boto3 documentation specific to the service associated with this paginator.\n- `self.paginator_name`: The name of the paginator used to construct the specific documentation link.\n- `self.service_name.class_name`: The class name of the service used to create the anchor reference in the documentation link.\n\nThis method provides a simple way to access the relevant documentation for the paginator defined in the class, leveraging the attributes initialized in the Paginator class.",
        "signature": "def boto3_doc_link(self) -> str:",
        "type": "Method",
        "class_signature": "class Paginator(ClassRecord):"
      },
      "Paginator.get_client_method": {
        "code": "    def get_client_method(self) -> Method:\n        \"\"\"Generate the `get_paginator` method for a Boto3 client. This method allows the client to retrieve a paginator for a specific operation, defined by `operation_name`. \n\nParameters:\n- `self`: Reference to the current instance of the Paginator class.\n- `operation_name`: A string representing the name of the operation for which the paginator is being created. Its type is specified as a `TypeLiteral` that matches the paginator's name and includes the assigned `operation_name`.\n\nReturns:\n- A `Method` instance representing the `get_paginator` method, which includes the method name, decorators, documentation string, a list of arguments (including the self-reference and the operation name), and the return type as an `ExternalImport` that denotes the paginator's class, sourced from the appropriate module identified by `ServiceModuleName.paginator.value`.\n\nDependencies include:\n- `Method`, `Argument`, and `TypeLiteral`, which are imported from various modules and are used to construct the method representation, ensuring proper typing and documentation.\"\"\"\n        '\\n        Get `get_paginator` method for `Client`.\\n        '\n        return Method(name='get_paginator', decorators=[Type.overload], docstring=self.docstring, arguments=[Argument.self(), Argument('operation_name', TypeLiteral(f'{self.name}Name', [self.operation_name]))], return_type=ExternalImport(source=ImportString('', ServiceModuleName.paginator.value), name=self.name))",
        "docstring": "Generate the `get_paginator` method for a Boto3 client. This method allows the client to retrieve a paginator for a specific operation, defined by `operation_name`. \n\nParameters:\n- `self`: Reference to the current instance of the Paginator class.\n- `operation_name`: A string representing the name of the operation for which the paginator is being created. Its type is specified as a `TypeLiteral` that matches the paginator's name and includes the assigned `operation_name`.\n\nReturns:\n- A `Method` instance representing the `get_paginator` method, which includes the method name, decorators, documentation string, a list of arguments (including the self-reference and the operation name), and the return type as an `ExternalImport` that denotes the paginator's class, sourced from the appropriate module identified by `ServiceModuleName.paginator.value`.\n\nDependencies include:\n- `Method`, `Argument`, and `TypeLiteral`, which are imported from various modules and are used to construct the method representation, ensuring proper typing and documentation.",
        "signature": "def get_client_method(self) -> Method:",
        "type": "Method",
        "class_signature": "class Paginator(ClassRecord):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_literal.py": {
      "TypeLiteral.__init__": {
        "code": "    def __init__(self, name: str, children: Iterable[str]) -> None:\n        \"\"\"Initialize a TypeLiteral instance, which serves as a wrapper for `typing/typing_extensions.Literal` type annotations.\n\nParameters:\n- name (str): The name of the literal for non-inline rendering.\n- children (Iterable[str]): The literal values to be included in the annotation.\n\nRaises:\n- TypeAnnotationError: If the `children` parameter is empty, indicating that a literal must have at least one value.\n\nAttributes:\n- children (set[str]): A set of the literal values derived from the `children` parameter.\n- name (str): The name provided during initialization.\n\nThis method is essential for creating a valid TypeLiteral object, ensuring it has the necessary child values to be meaningful.\"\"\"\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError('Literal should have children')",
        "docstring": "Initialize a TypeLiteral instance, which serves as a wrapper for `typing/typing_extensions.Literal` type annotations.\n\nParameters:\n- name (str): The name of the literal for non-inline rendering.\n- children (Iterable[str]): The literal values to be included in the annotation.\n\nRaises:\n- TypeAnnotationError: If the `children` parameter is empty, indicating that a literal must have at least one value.\n\nAttributes:\n- children (set[str]): A set of the literal values derived from the `children` parameter.\n- name (str): The name provided during initialization.\n\nThis method is essential for creating a valid TypeLiteral object, ensuring it has the necessary child values to be meaningful.",
        "signature": "def __init__(self, name: str, children: Iterable[str]) -> None:",
        "type": "Method",
        "class_signature": "class TypeLiteral(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/service_name.py": {
      "ServiceName.boto3_doc_link_parent": {
        "code": "    def boto3_doc_link_parent(self) -> str:\n        \"\"\"Generate a URL linking to the parent directory of the Boto3 documentation for the specific service represented by the instance.\n\nReturns:\n    str: A URL string that leads to the parent directory of the Boto3 documentation for the service defined by the instance's `boto3_name` attribute.\n\nDependencies:\n    - `self.boto3_name`: This property returns the appropriate Boto3 service name, which is either the overridden name or the default service name defined during the initialization of the `ServiceName` instance.\"\"\"\n        '\\n        Link to boto3 docs parent directory.\\n        '\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'",
        "docstring": "Generate a URL linking to the parent directory of the Boto3 documentation for the specific service represented by the instance.\n\nReturns:\n    str: A URL string that leads to the parent directory of the Boto3 documentation for the service defined by the instance's `boto3_name` attribute.\n\nDependencies:\n    - `self.boto3_name`: This property returns the appropriate Boto3 service name, which is either the overridden name or the default service name defined during the initialization of the `ServiceName` instance.",
        "signature": "def boto3_doc_link_parent(self) -> str:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      }
    },
    "mypy_boto3_builder/structures/function.py": {
      "Function.__init__": {
        "code": "    def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:\n        \"\"\"Initialize a Function object.\n\nParameters:\n- name (str): The name of the function.\n- arguments (Iterable[Argument]): A collection of Argument objects representing the function's parameters.\n- return_type (FakeAnnotation): The type annotation for the function's return value.\n- docstring (str, optional): The documentation string for the function (default is an empty string).\n- decorators (Iterable[FakeAnnotation], optional): A collection of decorators applied to the function (default is an empty tuple).\n- body_lines (Iterable[str], optional): The lines that form the body of the function (default is an empty iterable).\n- type_ignore (bool, optional): A flag indicating if type ignoring is enabled (default is False).\n- is_async (bool, optional): A flag indicating if the function is asynchronous (default is False).\n- boto3_doc_link (str, optional): A link to the AWS Boto3 documentation specific to the function (default is an empty string).\n\nAttributes:\n- request_type_annotation (TypeTypedDict | None): A TypedDict representing the structure of the request based on the function's arguments, initialized to None.\n\nThis constructor interacts with other components such as the Argument class for defining parameters, FakeAnnotation for type annotations, and TypeTypedDict for managing structured request types.\"\"\"\n        self.name = name\n        self.arguments = list(arguments)\n        self.return_type = return_type\n        self.docstring = docstring\n        self.decorators = list(decorators)\n        self.body_lines = body_lines\n        self.type_ignore = type_ignore\n        self.request_type_annotation: TypeTypedDict | None = None\n        self.is_async = is_async\n        self._boto3_doc_link = boto3_doc_link",
        "docstring": "Initialize a Function object.\n\nParameters:\n- name (str): The name of the function.\n- arguments (Iterable[Argument]): A collection of Argument objects representing the function's parameters.\n- return_type (FakeAnnotation): The type annotation for the function's return value.\n- docstring (str, optional): The documentation string for the function (default is an empty string).\n- decorators (Iterable[FakeAnnotation], optional): A collection of decorators applied to the function (default is an empty tuple).\n- body_lines (Iterable[str], optional): The lines that form the body of the function (default is an empty iterable).\n- type_ignore (bool, optional): A flag indicating if type ignoring is enabled (default is False).\n- is_async (bool, optional): A flag indicating if the function is asynchronous (default is False).\n- boto3_doc_link (str, optional): A link to the AWS Boto3 documentation specific to the function (default is an empty string).\n\nAttributes:\n- request_type_annotation (TypeTypedDict | None): A TypedDict representing the structure of the request based on the function's arguments, initialized to None.\n\nThis constructor interacts with other components such as the Argument class for defining parameters, FakeAnnotation for type annotations, and TypeTypedDict for managing structured request types.",
        "signature": "def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:",
        "type": "Method",
        "class_signature": "class Function:"
      }
    },
    "mypy_boto3_builder/structures/class_record.py": {
      "ClassRecord.__init__": {
        "code": "    def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:\n        \"\"\"Initialize a ClassRecord instance that represents a structure that can be rendered to a class.\n\nParameters:\n- name (str): The name of the class.\n- methods (Iterable[Method], optional): A collection of Method instances associated with the class (default is an empty iterable).\n- attributes (Iterable[Attribute], optional): A collection of Attribute instances associated with the class (default is an empty iterable).\n- bases (Iterable[FakeAnnotation], optional): A collection of base classes for the class (default is an empty iterable).\n- use_alias (bool, optional): A flag indicating whether to use an alias for the class name (default is False).\n\nAttributes initialized:\n- self.name: Stores the class name.\n- self.methods: A list of Method instances, initialized from the methods parameter.\n- self.attributes: A list of Attribute instances, initialized from the attributes parameter.\n- self.bases: A list of FakeAnnotation instances, initialized from the bases parameter.\n- self.use_alias: A boolean value indicating if an alias should be used.\n- self.docstring: A string for documentation purposes, initialized as an empty string.\"\"\"\n        self.name = name\n        self.methods = list(methods)\n        self.attributes = list(attributes)\n        self.bases: list[FakeAnnotation] = list(bases)\n        self.use_alias = use_alias\n        self.docstring = ''",
        "docstring": "Initialize a ClassRecord instance that represents a structure that can be rendered to a class.\n\nParameters:\n- name (str): The name of the class.\n- methods (Iterable[Method], optional): A collection of Method instances associated with the class (default is an empty iterable).\n- attributes (Iterable[Attribute], optional): A collection of Attribute instances associated with the class (default is an empty iterable).\n- bases (Iterable[FakeAnnotation], optional): A collection of base classes for the class (default is an empty iterable).\n- use_alias (bool, optional): A flag indicating whether to use an alias for the class name (default is False).\n\nAttributes initialized:\n- self.name: Stores the class name.\n- self.methods: A list of Method instances, initialized from the methods parameter.\n- self.attributes: A list of Attribute instances, initialized from the attributes parameter.\n- self.bases: A list of FakeAnnotation instances, initialized from the bases parameter.\n- self.use_alias: A boolean value indicating if an alias should be used.\n- self.docstring: A string for documentation purposes, initialized as an empty string.",
        "signature": "def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class ClassRecord:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/structures/paginator.py:Paginator:__init__": {},
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.from_str": {
          "code": "    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))",
          "docstring": "Create from string.",
          "signature": "def from_str(cls, import_string: str) -> Self:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {},
    "mypy_boto3_builder/structures/paginator.py:Paginator:boto3_doc_link": {},
    "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {
      "mypy_boto3_builder/service_name.py": {
        "ServiceName.boto3_name": {
          "code": "    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name",
          "docstring": "Boto3 package name.",
          "signature": "def boto3_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ServiceName:"
        }
      }
    },
    "mypy_boto3_builder/structures/paginator.py:Paginator:get_client_method": {},
    "mypy_boto3_builder/structures/argument.py:Argument:self": {},
    "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:__init__": {},
    "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {},
    "mypy_boto3_builder/structures/function.py:Function:__init__": {}
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_paginator\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 import_helpers/\n    \u2502   \u2514\u2500\u2500 import_string.py\n    \u2502       \u2514\u2500\u2500 ImportString.__init__\n    \u251c\u2500\u2500 service_name.py\n    \u2502   \u2514\u2500\u2500 ServiceName.boto3_doc_link_parent\n    \u251c\u2500\u2500 structures/\n    \u2502   \u251c\u2500\u2500 argument.py\n    \u2502   \u2502   \u251c\u2500\u2500 Argument.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 Argument.self\n    \u2502   \u251c\u2500\u2500 class_record.py\n    \u2502   \u2502   \u2514\u2500\u2500 ClassRecord.__init__\n    \u2502   \u251c\u2500\u2500 function.py\n    \u2502   \u2502   \u2514\u2500\u2500 Function.__init__\n    \u2502   \u2514\u2500\u2500 paginator.py\n    \u2502       \u251c\u2500\u2500 Paginator.__init__\n    \u2502       \u251c\u2500\u2500 Paginator.boto3_doc_link\n    \u2502       \u2514\u2500\u2500 Paginator.get_client_method\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 external_import.py\n        \u2502   \u251c\u2500\u2500 ExternalImport.__init__\n        \u2502   \u2514\u2500\u2500 ExternalImport.from_class\n        \u2514\u2500\u2500 type_literal.py\n            \u2514\u2500\u2500 TypeLiteral.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and test the functionality of a paginator abstraction used for interacting with AWS services via boto3. Its primary purpose is to ensure the paginator is correctly initialized with the specified operation, service, and behavior, while also verifying key attributes such as its name, associated operation, and correct documentation references. The module provides testing capabilities to confirm that the paginator generates valid links to boto3 documentation and retrieves client methods necessary for executing paginated operations. By offering robust validation of paginator configurations, it helps developers ensure reliability and correctness in paginated service interactions, reducing the risk of errors when integrating with AWS APIs.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an ImportString instance.\n\nArguments:\n    parent (str): The master module name that serves as the root of the import string.\n    *parts (str): Additional parts of the import string to be appended to the parent.\n\nRaises:\n    StructureError: If the import string would be empty or if any part includes a dot ('.'), indicating incorrect structure. \n                    Also raises if there are empty parts after non-empty parts.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple consisting of the parent and its associated parts, ensuring that the structure is valid and adheres to the rules defined for Python import strings.\n\nThis constructor utilizes the StructureError class to handle potential input errors related to the import string format and ensures that the combined import string is valid before storing it in the parts attribute.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/structures/argument.py\n\n- CLASS METHOD: Argument.__init__\n  - CLASS SIGNATURE: class Argument:\n  - SIGNATURE: def __init__(self, name: str, type_annotation: FakeAnnotation | None, default: TypeConstant | None=None, prefix: Literal['*', '**', '']='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an Argument instance representing a method or function argument.\n\nParameters:\n- name (str): The name of the argument.\n- type_annotation (FakeAnnotation | None): The type annotation for the argument. It can be None if no type is specified.\n- default (TypeConstant | None, optional): The default value for the argument. Defaults to None, indicating that it is a required argument.\n- prefix (Literal[\"*\", \"**\", \"\"], optional): A prefix used for starargs to denote variable arguments. Defaults to an empty string.\n\nAttributes:\n- self.name: Stores the name of the argument.\n- self.type_annotation: Stores the type annotation, which is expected to be an instance of FakeAnnotation or None.\n- self.default: Stores the default value, which is an instance of TypeConstant or None.\n- self.prefix: A literal indicating the type of argument, which can be \"*\", \"**\", or an empty string, used for function signature rendering.\n\nThis constructor interacts with class constants such as SELF_NAME and CLS_NAME, which represent common argument names used in class methods. The class also utilizes the `render` method for formatting argument representations in string form.\n\"\"\"\n```\n\n- CLASS METHOD: Argument.self\n  - CLASS SIGNATURE: class Argument:\n  - SIGNATURE: def self(cls) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a `self` argument instance.\n\nThis class method constructs an `Argument` instance with the name set to the constant `SELF_NAME`, which is defined as `\"self\"` in the Argument class. The type annotation for this argument is set to `None`. \n\nParameters:\n    cls: The class reference.\n\nReturns:\n    An instance of `Argument` initialized with the name `\"self\"` and a `None` type annotation.\n\nThis method is used to represent an instance method's `self` parameter in a consistent manner.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.__init__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes an instance of the ExternalImport class, which serves as a wrapper for type annotations imported from third-party libraries.\n\nParameters:\n- source (ImportString): The module import string representing the source of the type annotation.\n- name (str, optional): The name of the imported type. Defaults to an empty string.\n- alias (str, optional): The local name used for the import. Defaults to an empty string.\n- safe (bool, optional): A flag indicating whether the import is wrapped in try-except for safety. Defaults to False.\n\nAttributes initialized:\n- self.source: Stores the ImportString object referring to the module.\n- self.name: Stores the name of the imported type.\n- self.alias: Stores the local alias for the import.\n- self.safe: Stores the safety flag for the import.\n\nThis constructor utilizes the ImportString type, which is defined in mypy_boto3_builder.import_helpers.import_string, to correctly manage import strings. It is a foundational part of the ExternalImport class, enabling proper handling of type annotations from external libraries.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.from_class\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an instance of ExternalImport from a given class.\n\nArgs:\n    cls: The class type of the ExternalImport instance being created.\n    obj: The class object from which to derive the import information.\n    alias: An optional local name to be used for the import (default is an empty string).\n    safe: A boolean indicating whether the import should be wrapped in try-except (default is False).\n\nReturns:\n    An instance of ExternalImport initialized with the source module's name, \n    the class name, the specified alias, and the safe import setting.\n\nRaises:\n    TypeAnnotationError: If the module of the given class object cannot be determined.\n\nThe method utilizes `inspect.getmodule()` to retrieve the module of the given class \nand constructs an ImportString using `ImportString.from_str()` with the module's name. \nThis allows encapsulation of type annotations from external libraries.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/structures/paginator.py\n\n- CLASS METHOD: Paginator.__init__\n  - CLASS SIGNATURE: class Paginator(ClassRecord):\n  - SIGNATURE: def __init__(self, name: str, paginator_name: str, operation_name: str, service_name: ServiceName) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Paginator instance for Boto3 clients.\n\nParameters:\n- name (str): The name of the paginator.\n- paginator_name (str): The specific name used in Boto3 for the paginator.\n- operation_name (str): The name of the operation associated with this paginator.\n- service_name (ServiceName): An instance of ServiceName representing the AWS service this paginator is related to.\n\nThis constructor initializes the Paginator by calling the superclass's constructor with the paginator's name and the base class being Botocore's Paginator. It also sets the operation name, paginator name, and service name as attributes for further use in paginator methods and properties.\n\"\"\"\n```\n\n- CLASS METHOD: Paginator.boto3_doc_link\n  - CLASS SIGNATURE: class Paginator(ClassRecord):\n  - SIGNATURE: def boto3_doc_link(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a URL linking to the official AWS Boto3 documentation for the specific paginator represented by the instance.\n\nReturns:\n    str: A formatted URL string that points to the paginator's documentation page in the Boto3 docs.\n\nDependencies:\n- `self.service_name.boto3_doc_link_parent`: This attribute holds the base URL for the Boto3 documentation specific to the service associated with this paginator.\n- `self.paginator_name`: The name of the paginator used to construct the specific documentation link.\n- `self.service_name.class_name`: The class name of the service used to create the anchor reference in the documentation link.\n\nThis method provides a simple way to access the relevant documentation for the paginator defined in the class, leveraging the attributes initialized in the Paginator class.\n\"\"\"\n```\n\n- CLASS METHOD: Paginator.get_client_method\n  - CLASS SIGNATURE: class Paginator(ClassRecord):\n  - SIGNATURE: def get_client_method(self) -> Method:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate the `get_paginator` method for a Boto3 client. This method allows the client to retrieve a paginator for a specific operation, defined by `operation_name`. \n\nParameters:\n- `self`: Reference to the current instance of the Paginator class.\n- `operation_name`: A string representing the name of the operation for which the paginator is being created. Its type is specified as a `TypeLiteral` that matches the paginator's name and includes the assigned `operation_name`.\n\nReturns:\n- A `Method` instance representing the `get_paginator` method, which includes the method name, decorators, documentation string, a list of arguments (including the self-reference and the operation name), and the return type as an `ExternalImport` that denotes the paginator's class, sourced from the appropriate module identified by `ServiceModuleName.paginator.value`.\n\nDependencies include:\n- `Method`, `Argument`, and `TypeLiteral`, which are imported from various modules and are used to construct the method representation, ensuring proper typing and documentation.\n\"\"\"\n```\n\n## FILE 5: mypy_boto3_builder/type_annotations/type_literal.py\n\n- CLASS METHOD: TypeLiteral.__init__\n  - CLASS SIGNATURE: class TypeLiteral(FakeAnnotation):\n  - SIGNATURE: def __init__(self, name: str, children: Iterable[str]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeLiteral instance, which serves as a wrapper for `typing/typing_extensions.Literal` type annotations.\n\nParameters:\n- name (str): The name of the literal for non-inline rendering.\n- children (Iterable[str]): The literal values to be included in the annotation.\n\nRaises:\n- TypeAnnotationError: If the `children` parameter is empty, indicating that a literal must have at least one value.\n\nAttributes:\n- children (set[str]): A set of the literal values derived from the `children` parameter.\n- name (str): The name provided during initialization.\n\nThis method is essential for creating a valid TypeLiteral object, ensuring it has the necessary child values to be meaningful.\n\"\"\"\n```\n\n## FILE 6: mypy_boto3_builder/service_name.py\n\n- CLASS METHOD: ServiceName.boto3_doc_link_parent\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def boto3_doc_link_parent(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a URL linking to the parent directory of the Boto3 documentation for the specific service represented by the instance.\n\nReturns:\n    str: A URL string that leads to the parent directory of the Boto3 documentation for the service defined by the instance's `boto3_name` attribute.\n\nDependencies:\n    - `self.boto3_name`: This property returns the appropriate Boto3 service name, which is either the overridden name or the default service name defined during the initialization of the `ServiceName` instance.\n\"\"\"\n```\n\n## FILE 7: mypy_boto3_builder/structures/function.py\n\n- CLASS METHOD: Function.__init__\n  - CLASS SIGNATURE: class Function:\n  - SIGNATURE: def __init__(self, name: str, arguments: Iterable[Argument], return_type: FakeAnnotation, *, docstring: str='', decorators: Iterable[FakeAnnotation]=(), body_lines: Iterable[str]=(), type_ignore: bool=False, is_async: bool=False, boto3_doc_link: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Function object.\n\nParameters:\n- name (str): The name of the function.\n- arguments (Iterable[Argument]): A collection of Argument objects representing the function's parameters.\n- return_type (FakeAnnotation): The type annotation for the function's return value.\n- docstring (str, optional): The documentation string for the function (default is an empty string).\n- decorators (Iterable[FakeAnnotation], optional): A collection of decorators applied to the function (default is an empty tuple).\n- body_lines (Iterable[str], optional): The lines that form the body of the function (default is an empty iterable).\n- type_ignore (bool, optional): A flag indicating if type ignoring is enabled (default is False).\n- is_async (bool, optional): A flag indicating if the function is asynchronous (default is False).\n- boto3_doc_link (str, optional): A link to the AWS Boto3 documentation specific to the function (default is an empty string).\n\nAttributes:\n- request_type_annotation (TypeTypedDict | None): A TypedDict representing the structure of the request based on the function's arguments, initialized to None.\n\nThis constructor interacts with other components such as the Argument class for defining parameters, FakeAnnotation for type annotations, and TypeTypedDict for managing structured request types.\n\"\"\"\n```\n\n## FILE 8: mypy_boto3_builder/structures/class_record.py\n\n- CLASS METHOD: ClassRecord.__init__\n  - CLASS SIGNATURE: class ClassRecord:\n  - SIGNATURE: def __init__(self, name: str, methods: Iterable[Method]=(), attributes: Iterable[Attribute]=(), bases: Iterable[FakeAnnotation]=(), *, use_alias: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ClassRecord instance that represents a structure that can be rendered to a class.\n\nParameters:\n- name (str): The name of the class.\n- methods (Iterable[Method], optional): A collection of Method instances associated with the class (default is an empty iterable).\n- attributes (Iterable[Attribute], optional): A collection of Attribute instances associated with the class (default is an empty iterable).\n- bases (Iterable[FakeAnnotation], optional): A collection of base classes for the class (default is an empty iterable).\n- use_alias (bool, optional): A flag indicating whether to use an alias for the class name (default is False).\n\nAttributes initialized:\n- self.name: Stores the class name.\n- self.methods: A list of Method instances, initialized from the methods parameter.\n- self.attributes: A list of Attribute instances, initialized from the attributes parameter.\n- self.bases: A list of FakeAnnotation instances, initialized from the bases parameter.\n- self.use_alias: A boolean value indicating if an alias should be used.\n- self.docstring: A string for documentation purposes, initialized as an empty string.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return '.'.join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY",
    "mypy_boto3_builder/structures/argument.py": "\"\"\"\nMethod or function argument.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nfrom collections.abc import Iterator\nfrom typing import Final, Literal, Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_constant import TypeConstant\n\nclass Argument:\n    \"\"\"\n    Method or function argument.\n\n    Arguments:\n        name -- Argument name.\n        type_annotation -- Argument type annotation.\n        value -- Default argument value.\n        prefix -- Used for starargs.\n    \"\"\"\n    SELF_NAME: Final = 'self'\n    CLS_NAME: Final = 'cls'\n    KW_NAME: Final = '*'\n    FIRST_NAMES: Final = {SELF_NAME, CLS_NAME}\n\n    def render(self) -> str:\n        \"\"\"\n        Render argument to a string.\n        \"\"\"\n        default_suffix = f' = {self.default.render()}' if self.default is not None else ''\n        if not self.type_annotation:\n            return f'{self.name}{default_suffix}'\n        return f'{self.name}: {self.type_annotation.render()}{default_suffix}'\n\n    @classmethod\n    def kwflag(cls) -> Self:\n        \"\"\"\n        Create `*` keywords separator.\n        \"\"\"\n        return cls(name=cls.KW_NAME, type_annotation=None)\n\n    def is_kwflag(self) -> bool:\n        \"\"\"\n        Whether argument is a `*` keywords separator.\n        \"\"\"\n        return self.name == '*'\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations.\n        \"\"\"\n        if self.type_annotation is not None:\n            yield from self.type_annotation.iterate_types()\n        if self.default is not None:\n            yield from self.default.iterate_types()\n\n    @property\n    def required(self) -> bool:\n        \"\"\"\n        Whether argument does not have a default value and is required.\n        \"\"\"\n        return self.default is None\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy argument.\n        \"\"\"\n        return self.__class__(name=self.name, type_annotation=self.type_annotation.copy() if self.type_annotation else None, default=self.default.copy() if self.default else None, prefix=self.prefix)",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe",
    "mypy_boto3_builder/structures/paginator.py": "\"\"\"\nBoto3 client Paginator.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom botocore.paginate import Paginator as BotocorePaginator\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.structures.class_record import ClassRecord\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\n\n@functools.total_ordering\nclass Paginator(ClassRecord):\n    \"\"\"\n    Boto3 client Paginator.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Hash paginators by name.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort paginators by name.\n        \"\"\"\n        return self.name\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, Paginator):\n            raise BuildInternalError(f'{other} is not Paginator')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.inline:\n            children = ', '.join([repr(i) for i in sorted(self.children)])\n            return f'Literal[{children}]'\n        return self.name\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation('Literal').get_import_records()\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation('Literal').get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError('Use add_literal_child function.')\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path('common/literal.py.jinja2'), {'literal': self})",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import ClassVar, Final, Literal\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n__all__ = ('ServiceName', 'ServiceNameCatalog')\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n    ALL: Final = 'all'\n    UPDATED: Final = 'updated'\n    ESSENTIAL: Final = 'essential'\n    LATEST: Final = 'latest'\n    ESSENTIAL_NAMES: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n    CONDA_FORGE_AVAILABLE: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f'<ServiceName {self.name} {self.class_name}>'\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace('-', '_')\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace('-', '_')\n        if is_reserved(name):\n            return f'{name}_'\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}'\n\n    @staticmethod\n    def get_md_doc_link(file: Literal['client', 'service_resource', 'waiters', 'paginators', 'type_defs', 'literals'], *parts: str) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f'./{file}.md'\n        if not parts:\n            return link\n        anchor = ''.join([get_anchor_link(part) for part in parts])\n        return f'{link}#{anchor}'\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n    all = ServiceName('__all', '__all')\n    ec2 = ServiceName('ec2', 'EC2')\n    iam = ServiceName('iam', 'IAM')\n    s3 = ServiceName('s3', 'S3')\n    rds = ServiceName('rds', 'RDS')\n    cloudwatch = ServiceName('cloudwatch', 'CloudWatch')\n    opsworks = ServiceName('opsworks', 'OpsWorks')\n    sns = ServiceName('sns', 'SNS')\n    glacier = ServiceName('glacier', 'Glacier')\n    dynamodb = ServiceName('dynamodb', 'DynamoDB')\n    sqs = ServiceName('sqs', 'SQS')\n    cloudformation = ServiceName('cloudformation', 'CloudFormation')\n    cloudsearchdomain = ServiceName('cloudsearchdomain', 'CloudSearchDomain')\n    logs = ServiceName('logs', 'CloudWatchLogs')\n    lambda_ = ServiceName('lambda', 'Lambda')\n    stepfunctions = ServiceName('stepfunctions', 'SFN')\n    old_redshift_serverless = ServiceName('redshift-serverless', 'RedshiftServerless', 'redshiftserverless')\n    old_ssm_sap = ServiceName('ssm-sap', 'SsmSap', 'ssmsap')\n    ITEMS: ClassVar[dict[str, ServiceName]] = {ec2.boto3_name: ec2, iam.boto3_name: iam, s3.boto3_name: s3, rds.boto3_name: rds, cloudwatch.boto3_name: cloudwatch, opsworks.boto3_name: opsworks, sns.boto3_name: sns, glacier.boto3_name: glacier, dynamodb.boto3_name: dynamodb, sqs.boto3_name: sqs, cloudformation.boto3_name: cloudformation, cloudsearchdomain.boto3_name: cloudsearchdomain, logs.boto3_name: logs, lambda_.boto3_name: lambda_, old_redshift_serverless.boto3_name: old_redshift_serverless, old_ssm_sap.boto3_name: old_ssm_sap}\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name",
    "mypy_boto3_builder/structures/function.py": "\"\"\"\nModule-level function.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.argument import Argument\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\n\nclass Function:\n    \"\"\"\n    Module-level function.\n    \"\"\"\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        if not self._boto3_doc_link:\n            raise BuildInternalError(f'{self.name} has no boto3_doc_link')\n        return self._boto3_doc_link\n\n    def set_boto3_doc_link(self, link: str) -> None:\n        \"\"\"\n        Set link to boto3 docs.\n        \"\"\"\n        self._boto3_doc_link = link\n\n    def has_boto3_doc_link(self) -> bool:\n        \"\"\"\n        Whether boto3_doc_link is set.\n        \"\"\"\n        return bool(self._boto3_doc_link)\n\n    def __repr__(self) -> str:\n        \"\"\"\n        Represent as a valid Python function signature.\n        \"\"\"\n        return f'{('async ' if self.is_async else '')}def {self.name}({', '.join((argument.render() for argument in self.arguments))}) -> {self.return_type.render()}'\n\n    @property\n    def short_docstring(self) -> str:\n        \"\"\"\n        Docstring without documentation links.\n        \"\"\"\n        if not self.docstring:\n            return self.docstring\n        short_docstring = self.docstring.strip().split('\\n\\n')[0]\n        if short_docstring.startswith('['):\n            return ''\n        return short_docstring\n\n    def create_request_type_annotation(self, name: str) -> None:\n        \"\"\"\n        Create and set `request_type_annotation` TypedDict based on function arguments.\n        \"\"\"\n        result = TypeTypedDict(name)\n        for argument in self.arguments:\n            if argument.is_kwflag():\n                continue\n            if not argument.type_annotation:\n                continue\n            result.add_attribute(argument.name, argument.type_annotation, required=argument.required)\n        if not result.children:\n            return\n        self.request_type_annotation = result\n\n    def iterate_packed_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over packed arguments for KW-only functions.\n        \"\"\"\n        if not self.is_kw_only() or not self.request_type_annotation:\n            yield from self.arguments\n            return\n        yield Argument(name='kwargs', type_annotation=Type.unpack(self.request_type_annotation), prefix='**')\n\n    @property\n    def body(self) -> str:\n        \"\"\"\n        Function body as a string.\n        \"\"\"\n        return '\\n'.join(self.body_lines)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over required type annotations.\n        \"\"\"\n        yield from self.return_type.iterate_types()\n        for argument in self.iterate_packed_arguments():\n            yield from argument.iterate_types()\n        for decorator in self.decorators:\n            yield from decorator.iterate_types()\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract required import records.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n        return result\n\n    @property\n    def returns_none(self) -> bool:\n        \"\"\"\n        Whether return type is None.\n        \"\"\"\n        return self.return_type == Type.none\n\n    def is_kw_only(self) -> bool:\n        \"\"\"\n        Whether method arguments can be passed only as kwargs.\n        \"\"\"\n        if not self.has_arguments():\n            return False\n        first_argument = next(self.iterate_call_arguments())\n        return first_argument.is_kwflag()\n\n    def iterate_call_arguments(self) -> Iterator[Argument]:\n        \"\"\"\n        Iterate over arguments that are used in function call.\n        \"\"\"\n        yield from self.arguments\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        result.extend((argument.type_annotation for argument in self.arguments if argument.type_annotation and argument.type_annotation.get_local_types()))\n        if self.return_type and self.return_type.get_local_types():\n            result.append(self.return_type)\n        return result\n\n    def copy(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return copy.copy(self)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Deep copy function.\n        \"\"\"\n        return self.__class__(name=self.name, arguments=[i.copy() for i in self.arguments], return_type=self.return_type.copy(), docstring=self.docstring, decorators=[i.copy() for i in self.decorators], body_lines=list(self.body_lines), type_ignore=self.type_ignore, is_async=self.is_async)\n\n    def remove_argument(self, *names: str) -> Self:\n        \"\"\"\n        Remove argument by name or names.\n        \"\"\"\n        remove = [arg for arg in self.arguments if arg.name in names]\n        for argument in remove:\n            self.arguments.remove(argument)\n        return self\n\n    def has_arguments(self) -> bool:\n        \"\"\"\n        Whether function has arguments.\n        \"\"\"\n        return bool(self.arguments)",
    "mypy_boto3_builder/structures/class_record.py": "\"\"\"\nBase class for all structures that can be rendered to a class.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.structures.attribute import Attribute\nfrom mypy_boto3_builder.structures.method import Method\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.internal_import import InternalImport\nfrom mypy_boto3_builder.utils.strings import xform_name\n\nclass ClassRecord:\n    \"\"\"\n    Base class for all structures that can be rendered to a class.\n    \"\"\"\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return ''\n\n    @property\n    def alias_name(self) -> str:\n        \"\"\"\n        Class alias name for safe import.\n\n        Returns:\n            Name prefixed with underscore.\n        \"\"\"\n        if not self.use_alias:\n            raise StructureError(f'Cannot get alias for {self.name} with no alias.')\n        return InternalImport.get_alias(self.name)\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over type annotations for methods, attributes and bases.\n        \"\"\"\n        for method in self.methods:\n            yield from method.iterate_types()\n        for attribute in self.attributes:\n            yield from attribute.iterate_types()\n        for base in self.bases:\n            yield from base.iterate_types()\n\n    def get_required_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Extract import records from required type annotations.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        for type_annotation in self.iterate_types():\n            result.update(type_annotation.get_import_records())\n        return result\n\n    def get_internal_imports(self) -> set[InternalImport]:\n        \"\"\"\n        Get internal imports from methods.\n        \"\"\"\n        result: set[InternalImport] = set()\n        for method in self.methods:\n            for type_annotation in method.iterate_types():\n                if not isinstance(type_annotation, InternalImport):\n                    continue\n                result.add(type_annotation)\n        return result\n\n    @property\n    def variable_name(self) -> str:\n        \"\"\"\n        Variable name for an instance of this class.\n        \"\"\"\n        return xform_name(self.name)\n\n    @property\n    def method_names(self) -> list[str]:\n        \"\"\"\n        Unique method names.\n        \"\"\"\n        return sorted({i.name for i in self.methods})\n\n    def get_method(self, name: str) -> Method:\n        \"\"\"\n        Get method by name.\n        \"\"\"\n        for method in self.methods:\n            if method.name == name:\n                return method\n        raise StructureError(f'Method {name} not found')"
  },
  "call_tree": {
    "tests/structures/test_paginator.py:TestPaginator:setup_method": {
      "mypy_boto3_builder/structures/paginator.py:Paginator:__init__": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        },
        "mypy_boto3_builder/structures/class_record.py:ClassRecord:__init__": {}
      }
    },
    "tests/structures/test_paginator.py:TestPaginator:test_boto3_doc_link": {
      "mypy_boto3_builder/structures/paginator.py:Paginator:boto3_doc_link": {
        "mypy_boto3_builder/service_name.py:ServiceName:boto3_doc_link_parent": {
          "mypy_boto3_builder/service_name.py:ServiceName:boto3_name": {}
        }
      }
    },
    "tests/structures/test_paginator.py:TestPaginator:test_get_client_method": {
      "mypy_boto3_builder/structures/paginator.py:Paginator:get_client_method": {
        "mypy_boto3_builder/structures/argument.py:Argument:self": {
          "mypy_boto3_builder/structures/argument.py:Argument:__init__": {}
        },
        "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:__init__": {},
        "mypy_boto3_builder/structures/argument.py:Argument:__init__": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {},
        "mypy_boto3_builder/structures/function.py:Function:__init__": {}
      }
    }
  }
}