{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_main",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/test_main.py",
  "test_code": "import sys\nfrom unittest.mock import MagicMock, patch\n\nfrom mypy_boto3_builder.main import get_available_service_names, get_selected_service_names, main\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.utils.botocore_changelog import BotocoreChangelog\n\n\nclass TestMain:\n    def test_get_selected_service_names(self) -> None:\n        assert [\n            i.name\n            for i in get_selected_service_names(\n                [\"s3\", \"ec2\"],\n                [ServiceName(\"ec2\", \"EC2\"), ServiceName(\"other\", \"Other\")],\n            )\n        ] == [\"ec2\"]\n        assert [\n            i.name\n            for i in get_selected_service_names(\n                [\"all\", \"ec2\"],\n                [ServiceName(\"ec2\", \"EC2\"), ServiceName(\"other\", \"Other\")],\n            )\n        ] == [\"ec2\", \"other\"]\n        assert get_selected_service_names([\"s3\", \"ec2\"], []) == []\n        with patch.object(BotocoreChangelog, \"fetch_updated\") as fetch_updated_mock:\n            fetch_updated_mock.return_value = [\"ecs\"]\n            assert [\n                i.name\n                for i in get_selected_service_names(\n                    [\"updated\", \"ec2\"],\n                    [\n                        ServiceName(\"ec2\", \"EC2\"),\n                        ServiceName(\"ecs\", \"ECS\"),\n                        ServiceName(\"other\", \"Other\"),\n                    ],\n                )\n            ] == [\"ec2\", \"ecs\"]\n\n    def test_get_available_service_names(self) -> None:\n        session_mock = MagicMock()\n        session_mock.get_available_services.return_value = [\"s3\", \"ec2\", \"unsupported\"]\n        session_mock.get_service_data.return_value = {\n            \"metadata\": {\"serviceAbbreviation\": \"Amazon S3\", \"serviceId\": \"s3\"},\n        }\n        assert len(get_available_service_names(session_mock)) == 3\n\n    @patch(\"mypy_boto3_builder.main.get_available_service_names\")\n    @patch(\"mypy_boto3_builder.main.Boto3Generator\")\n    @patch.object(sys, \"argv\", [\"-o\", \"/tmp\", \"-b\", \"1.2.3.post4\"])  # noqa: S108\n    def test_main(\n        self,\n        Boto3GeneratorMock: MagicMock,\n        get_available_service_names_mock: MagicMock,\n    ) -> None:\n        main()\n        Boto3GeneratorMock().generate_product.assert_called()\n",
  "GT_file_code": {
    "mypy_boto3_builder/main.py": "\"\"\"\nMain entrypoint for builder.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport datetime\nimport sys\nimport warnings\nfrom collections.abc import Iterable, Sequence\n\nfrom botocore.session import Session as BotocoreSession\n\nfrom mypy_boto3_builder.cli_parser import CLINamespace, parse_args\nfrom mypy_boto3_builder.constants import BUILDER_REPO_URL, PACKAGE_NAME\nfrom mypy_boto3_builder.enums.product import Product, ProductLibrary\nfrom mypy_boto3_builder.generators.aioboto3_generator import AioBoto3Generator\nfrom mypy_boto3_builder.generators.aiobotocore_generator import AioBotocoreGenerator\nfrom mypy_boto3_builder.generators.base_generator import BaseGenerator\nfrom mypy_boto3_builder.generators.boto3_generator import Boto3Generator\nfrom mypy_boto3_builder.jinja_manager import JinjaManager\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\nfrom mypy_boto3_builder.utils.boto3_utils import get_boto3_session, get_botocore_session\nfrom mypy_boto3_builder.utils.botocore_changelog import BotocoreChangelog\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, get_botocore_class_name, get_copyright\nfrom mypy_boto3_builder.utils.type_checks import (\n    is_literal,\n    is_type_def,\n    is_type_parent,\n    is_typed_dict,\n    is_union,\n)\nfrom mypy_boto3_builder.utils.version import get_builder_version\nfrom mypy_boto3_builder.utils.version_getters import get_botocore_version\n\n\ndef get_selected_service_names(\n    selected: Iterable[str],\n    available: Iterable[ServiceName],\n) -> list[ServiceName]:\n    \"\"\"\n    Get a list of selected service names.\n\n    Supports `updated` to select only services updated in currect `boto3` release.\n    Supports `all` to select all available service names.\n\n    Arguments:\n        selected -- Selected service names as strings.\n        available -- All ServiceNames available in current boto3 release.\n\n    Returns:\n        A list of selected ServiceNames.\n    \"\"\"\n    logger = get_logger()\n    available_map = {i.name: i for i in available}\n    result: list[ServiceName] = []\n    selected_service_names = list(selected)\n    botocore_version = get_botocore_version()\n    if ServiceName.ALL in selected_service_names:\n        return list(available)\n    if ServiceName.UPDATED in selected_service_names:\n        selected_service_names.remove(ServiceName.UPDATED)\n        updated_service_names = BotocoreChangelog().fetch_updated(botocore_version)\n        selected_service_names.extend(\n            service_name_str\n            for service_name_str in updated_service_names\n            if service_name_str in available_map\n        )\n    if ServiceName.ESSENTIAL in selected_service_names:\n        selected_service_names.remove(ServiceName.ESSENTIAL)\n        selected_service_names.extend(\n            service_name_str\n            for service_name_str in available_map\n            if service_name_str in ServiceName.ESSENTIAL_NAMES\n        )\n\n    for service_name_str in selected_service_names:\n        if service_name_str not in available_map:\n            logger.info(f\"Service {service_name_str} is not provided by botocore, skipping\")\n            continue\n        result.append(available_map[service_name_str])\n\n    return result\n\n\ndef get_available_service_names(session: BotocoreSession) -> list[ServiceName]:\n    \"\"\"\n    Get a list of boto3 supported service names.\n\n    Arguments:\n        session -- Boto3 session\n\n    Returns:\n        A list of supported services.\n    \"\"\"\n    available_services = session.get_available_services()\n    result: list[ServiceName] = []\n    for name in available_services:\n        service_data = session.get_service_data(name)\n        metadata = service_data[\"metadata\"]\n        class_name = get_botocore_class_name(metadata)\n        service_name = ServiceNameCatalog.add(name, class_name)\n        result.append(service_name)\n    return result\n\n\ndef get_generator_cls(product: Product) -> type[BaseGenerator]:\n    \"\"\"\n    Get Generator class for a product.\n    \"\"\"\n    library = product.get_library()\n    match library:\n        case ProductLibrary.boto3:\n            return Boto3Generator\n        case ProductLibrary.aiobotocore:\n            return AioBotocoreGenerator\n        case ProductLibrary.aioboto3:\n            return AioBoto3Generator\n\n\ndef generate_product(\n    product: Product,\n    args: CLINamespace,\n    service_names: Sequence[ServiceName],\n    master_service_names: Sequence[ServiceName],\n) -> None:\n    \"\"\"\n    Generate a selected product.\n\n    Arguments:\n        product -- Product to generate\n        args -- CLI namespace\n        service_names -- Selected service names\n        master_service_names -- Service names included in master\n    \"\"\"\n    generator_cls = get_generator_cls(product)\n    generator = generator_cls(\n        service_names=service_names,\n        master_service_names=master_service_names,\n        config=args,\n        version=args.build_version,\n        cleanup=True,\n    )\n    generator.generate_product(product.get_type())\n    generator.cleanup_temporary_files()\n\n\ndef initialize_jinja_manager() -> None:\n    \"\"\"\n    Initialize Jinja manager with globals.\n    \"\"\"\n    jinja_manager = JinjaManager.singleton()\n    jinja_manager.update_globals(\n        builder_version=get_builder_version(),\n        current_year=str(datetime.datetime.now(datetime.timezone.utc).year),\n        get_anchor_link=get_anchor_link,\n        len=len,\n        sorted=sorted,\n        repr=repr,\n        builder_package_name=PACKAGE_NAME,\n        builder_repo_url=BUILDER_REPO_URL,\n        copyright=get_copyright(),\n        is_typed_dict=is_typed_dict,\n        is_union=is_union,\n        is_literal=is_literal,\n        is_type_def=is_type_def,\n        is_type_parent=is_type_parent,\n    )\n\n\ndef run(args: CLINamespace) -> None:\n    \"\"\"\n    Run builder.\n    \"\"\"\n    # FIXME: suppress botocore endpoint warning\n    warnings.filterwarnings(\"ignore\", category=FutureWarning, module=\"botocore.client\")\n\n    logger = get_logger(level=args.log_level)\n\n    initialize_jinja_manager()\n    session = get_boto3_session()\n\n    args.output_path.mkdir(exist_ok=True, parents=True)\n    available_service_names = get_available_service_names(get_botocore_session(session))\n\n    logger.info(f\"{len(available_service_names)} supported botocore services discovered\")\n    if args.list_services:\n        for service_name in available_service_names:\n            sys.stdout.write(\n                f\"- {service_name.name} : {service_name.class_name}\"\n                f\" {service_name.boto3_doc_link}\\n\",\n            )\n        return\n\n    service_names = get_selected_service_names(args.service_names, available_service_names)\n    master_service_names = service_names if args.partial_overload else available_service_names\n\n    for product in args.products:\n        logger.info(f\"Generating {product} product\")\n        generate_product(product, args, service_names, master_service_names)\n\n    logger.info(\"Completed\")\n\n\ndef main() -> None:\n    \"\"\"\n    CLI entrypoint.\n    \"\"\"\n    args = parse_args(sys.argv[1:])\n    run(args)\n\n\nif __name__ == \"__main__\":\n    main()\n",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import ClassVar, Final, Literal\n\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n\n__all__ = (\n    \"ServiceName\",\n    \"ServiceNameCatalog\",\n)\n\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n\n    ALL: Final = \"all\"\n    UPDATED: Final = \"updated\"\n    ESSENTIAL: Final = \"essential\"\n    LATEST: Final = \"latest\"\n\n    ESSENTIAL_NAMES: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n    CONDA_FORGE_AVAILABLE: Final = {\n        \"ec2\",\n        \"rds\",\n        \"s3\",\n        \"lambda\",\n        \"sqs\",\n        \"cloudformation\",\n        \"dynamodb\",\n    }\n\n    def __init__(self, name: str, class_name: str, override_boto3_name: str = \"\") -> None:\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f\"<ServiceName {self.name} {self.class_name}>\"\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace(\"-\", \"_\")\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace(\"-\", \"_\")\n        if is_reserved(name):\n            return f\"{name}_\"\n\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}\"\n        )\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return (\n            \"https://boto3.amazonaws.com/v1/documentation/api/\"\n            f\"latest/reference/services/{self.boto3_name}\"\n        )\n\n    @staticmethod\n    def get_md_doc_link(\n        file: Literal[\n            \"client\",\n            \"service_resource\",\n            \"waiters\",\n            \"paginators\",\n            \"type_defs\",\n            \"literals\",\n        ],\n        *parts: str,\n    ) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f\"./{file}.md\"\n        if not parts:\n            return link\n        anchor = \"\".join([get_anchor_link(part) for part in parts])\n        return f\"{link}#{anchor}\"\n\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n\n    all = ServiceName(\"__all\", \"__all\")\n    ec2 = ServiceName(\"ec2\", \"EC2\")\n    iam = ServiceName(\"iam\", \"IAM\")\n    s3 = ServiceName(\"s3\", \"S3\")\n    rds = ServiceName(\"rds\", \"RDS\")\n    cloudwatch = ServiceName(\"cloudwatch\", \"CloudWatch\")\n    opsworks = ServiceName(\"opsworks\", \"OpsWorks\")\n    sns = ServiceName(\"sns\", \"SNS\")\n    glacier = ServiceName(\"glacier\", \"Glacier\")\n    dynamodb = ServiceName(\"dynamodb\", \"DynamoDB\")\n    sqs = ServiceName(\"sqs\", \"SQS\")\n    cloudformation = ServiceName(\"cloudformation\", \"CloudFormation\")\n    cloudsearchdomain = ServiceName(\"cloudsearchdomain\", \"CloudSearchDomain\")\n    logs = ServiceName(\"logs\", \"CloudWatchLogs\")\n    lambda_ = ServiceName(\"lambda\", \"Lambda\")\n    stepfunctions = ServiceName(\"stepfunctions\", \"SFN\")\n    old_redshift_serverless = ServiceName(\n        \"redshift-serverless\",\n        \"RedshiftServerless\",\n        \"redshiftserverless\",\n    )\n    old_ssm_sap = ServiceName(\"ssm-sap\", \"SsmSap\", \"ssmsap\")\n\n    ITEMS: ClassVar[dict[str, ServiceName]] = {\n        ec2.boto3_name: ec2,\n        iam.boto3_name: iam,\n        s3.boto3_name: s3,\n        rds.boto3_name: rds,\n        cloudwatch.boto3_name: cloudwatch,\n        opsworks.boto3_name: opsworks,\n        sns.boto3_name: sns,\n        glacier.boto3_name: glacier,\n        dynamodb.boto3_name: dynamodb,\n        sqs.boto3_name: sqs,\n        cloudformation.boto3_name: cloudformation,\n        cloudsearchdomain.boto3_name: cloudsearchdomain,\n        logs.boto3_name: logs,\n        lambda_.boto3_name: lambda_,\n        old_redshift_serverless.boto3_name: old_redshift_serverless,\n        old_ssm_sap.boto3_name: old_ssm_sap,\n    }\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/main.py": {
      "get_selected_service_names": {
        "code": "def get_selected_service_names(selected: Iterable[str], available: Iterable[ServiceName]) -> list[ServiceName]:\n    \"\"\"Retrieve and validate a list of selected AWS service names based on user input and available services.\n\nThis function allows users to select service names from a list, incorporating special options like 'updated' to include services that have changed in the current boto3 release and 'all' to select all available services. It interacts with the `BotocoreChangelog` to fetch updated service names and utilizes a mapping of available services for validation.\n\nParameters:\n- selected (Iterable[str]): A collection of service names as strings, which may include special identifiers like 'all', 'updated', and 'essential'.\n- available (Iterable[ServiceName]): A collection of all available service names defined in the current boto3 release.\n\nReturns:\n- list[ServiceName]: A list of validated service names selected according to user input.\n\nConstants and dependencies:\n- `ServiceName`: An enum that contains special service identifiers and maps to actual service names.\n- `get_logger()`: A utility function for logging information, warnings, or errors.\n- `get_botocore_version()`: Retrieves the current version of the Botocore library to check for updated services.\n- `BotocoreChangelog`: A utility that fetches recently updated services based on the current Botocore version, ensuring that the function can provide the most relevant and up-to-date service names.\"\"\"\n    '\\n    Get a list of selected service names.\\n\\n    Supports `updated` to select only services updated in currect `boto3` release.\\n    Supports `all` to select all available service names.\\n\\n    Arguments:\\n        selected -- Selected service names as strings.\\n        available -- All ServiceNames available in current boto3 release.\\n\\n    Returns:\\n        A list of selected ServiceNames.\\n    '\n    logger = get_logger()\n    available_map = {i.name: i for i in available}\n    result: list[ServiceName] = []\n    selected_service_names = list(selected)\n    botocore_version = get_botocore_version()\n    if ServiceName.ALL in selected_service_names:\n        return list(available)\n    if ServiceName.UPDATED in selected_service_names:\n        selected_service_names.remove(ServiceName.UPDATED)\n        updated_service_names = BotocoreChangelog().fetch_updated(botocore_version)\n        selected_service_names.extend((service_name_str for service_name_str in updated_service_names if service_name_str in available_map))\n    if ServiceName.ESSENTIAL in selected_service_names:\n        selected_service_names.remove(ServiceName.ESSENTIAL)\n        selected_service_names.extend((service_name_str for service_name_str in available_map if service_name_str in ServiceName.ESSENTIAL_NAMES))\n    for service_name_str in selected_service_names:\n        if service_name_str not in available_map:\n            logger.info(f'Service {service_name_str} is not provided by botocore, skipping')\n            continue\n        result.append(available_map[service_name_str])\n    return result",
        "docstring": "Retrieve and validate a list of selected AWS service names based on user input and available services.\n\nThis function allows users to select service names from a list, incorporating special options like 'updated' to include services that have changed in the current boto3 release and 'all' to select all available services. It interacts with the `BotocoreChangelog` to fetch updated service names and utilizes a mapping of available services for validation.\n\nParameters:\n- selected (Iterable[str]): A collection of service names as strings, which may include special identifiers like 'all', 'updated', and 'essential'.\n- available (Iterable[ServiceName]): A collection of all available service names defined in the current boto3 release.\n\nReturns:\n- list[ServiceName]: A list of validated service names selected according to user input.\n\nConstants and dependencies:\n- `ServiceName`: An enum that contains special service identifiers and maps to actual service names.\n- `get_logger()`: A utility function for logging information, warnings, or errors.\n- `get_botocore_version()`: Retrieves the current version of the Botocore library to check for updated services.\n- `BotocoreChangelog`: A utility that fetches recently updated services based on the current Botocore version, ensuring that the function can provide the most relevant and up-to-date service names.",
        "signature": "def get_selected_service_names(selected: Iterable[str], available: Iterable[ServiceName]) -> list[ServiceName]:",
        "type": "Function",
        "class_signature": null
      },
      "get_available_service_names": {
        "code": "def get_available_service_names(session: BotocoreSession) -> list[ServiceName]:\n    \"\"\"Retrieve a list of supported Amazon Web Services (AWS) from the provided Boto3 session.\n\nArgs:\n    session (BotocoreSession): An established Boto3 session used to access AWS services.\n\nReturns:\n    list[ServiceName]: A list of ServiceName objects representing the AWS services supported by the current Boto3 session.\n\nThis function interacts with the Botocore API to fetch the available services and their metadata. It utilizes the `ServiceNameCatalog` to register each service's name and class name based on the metadata obtained. The utility function `get_botocore_class_name` is called to extract the class name from the service's metadata. The data obtained is directly dependent on the Boto3 session passed to the function.\"\"\"\n    '\\n    Get a list of boto3 supported service names.\\n\\n    Arguments:\\n        session -- Boto3 session\\n\\n    Returns:\\n        A list of supported services.\\n    '\n    available_services = session.get_available_services()\n    result: list[ServiceName] = []\n    for name in available_services:\n        service_data = session.get_service_data(name)\n        metadata = service_data['metadata']\n        class_name = get_botocore_class_name(metadata)\n        service_name = ServiceNameCatalog.add(name, class_name)\n        result.append(service_name)\n    return result",
        "docstring": "Retrieve a list of supported Amazon Web Services (AWS) from the provided Boto3 session.\n\nArgs:\n    session (BotocoreSession): An established Boto3 session used to access AWS services.\n\nReturns:\n    list[ServiceName]: A list of ServiceName objects representing the AWS services supported by the current Boto3 session.\n\nThis function interacts with the Botocore API to fetch the available services and their metadata. It utilizes the `ServiceNameCatalog` to register each service's name and class name based on the metadata obtained. The utility function `get_botocore_class_name` is called to extract the class name from the service's metadata. The data obtained is directly dependent on the Boto3 session passed to the function.",
        "signature": "def get_available_service_names(session: BotocoreSession) -> list[ServiceName]:",
        "type": "Function",
        "class_signature": null
      },
      "main": {
        "code": "def main() -> None:\n    \"\"\"CLI entrypoint for the builder application. This function parses command-line arguments using `parse_args` and subsequently calls the `run` function with the parsed arguments. It serves as the main entry point for executing the builder, managing the flow from receiving user input to initiating the generation process for AWS SDK clients. The `args` parameter contains all command-line arguments, including service names and product types to generate. This function has no return value and directly interacts with the overall functionality of the application by trigger operations based on the user input.\"\"\"\n    '\\n    CLI entrypoint.\\n    '\n    args = parse_args(sys.argv[1:])\n    run(args)",
        "docstring": "CLI entrypoint for the builder application. This function parses command-line arguments using `parse_args` and subsequently calls the `run` function with the parsed arguments. It serves as the main entry point for executing the builder, managing the flow from receiving user input to initiating the generation process for AWS SDK clients. The `args` parameter contains all command-line arguments, including service names and product types to generate. This function has no return value and directly interacts with the overall functionality of the application by trigger operations based on the user input.",
        "signature": "def main() -> None:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/service_name.py": {
      "ServiceName.__init__": {
        "code": "    def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n        \"\"\"Initialize a ServiceName instance, representing a Boto3 service.\n\nParameters:\n- name (str): The name of the service, typically corresponding to the service's identifier in Boto3 (e.g., 'ec2').\n- class_name (str): The name of the service's class, used for referencing in the code (e.g., 'EC2').\n- override_boto3_name (str, optional): An optional name to override the default Boto3 service name. Defaults to an empty string.\n\nAttributes:\n- self.name: Stores the service name.\n- self.class_name: Stores the service class name.\n- self.boto3_version: Initialized with the class-level constant LATEST, indicating the latest version of the service.\n- self.override_boto3_name: Stores the optional overridden Boto3 service name if provided.\n\nThe purpose of this constructor is to create a structured representation of a Boto3 service that can be used throughout the ServiceNameCatalog and other system components.\"\"\"\n        self.name = name\n        self.class_name = class_name\n        self.boto3_version = self.LATEST\n        self.override_boto3_name = override_boto3_name",
        "docstring": "Initialize a ServiceName instance, representing a Boto3 service.\n\nParameters:\n- name (str): The name of the service, typically corresponding to the service's identifier in Boto3 (e.g., 'ec2').\n- class_name (str): The name of the service's class, used for referencing in the code (e.g., 'EC2').\n- override_boto3_name (str, optional): An optional name to override the default Boto3 service name. Defaults to an empty string.\n\nAttributes:\n- self.name: Stores the service name.\n- self.class_name: Stores the service class name.\n- self.boto3_version: Initialized with the class-level constant LATEST, indicating the latest version of the service.\n- self.override_boto3_name: Stores the optional overridden Boto3 service name if provided.\n\nThe purpose of this constructor is to create a structured representation of a Boto3 service that can be used throughout the ServiceNameCatalog and other system components.",
        "signature": "def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:",
        "type": "Method",
        "class_signature": "class ServiceName:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/main.py:get_selected_service_names": {
      "mypy_boto3_builder/utils/botocore_changelog.py": {
        "BotocoreChangelog.__init__": {
          "code": "    def __init__(self) -> None:\n        self._changelog: str = \"\"",
          "docstring": "",
          "signature": "def __init__(self) -> None:",
          "type": "Method",
          "class_signature": "class BotocoreChangelog:"
        }
      },
      "mypy_boto3_builder/utils/version_getters.py": {
        "get_botocore_version": {
          "code": "def get_botocore_version() -> str:\n    \"\"\"\n    Get botocore package version.\n    \"\"\"\n    try:\n        from botocore import __version__ as version  # noqa: PLC0415\n    except ImportError as e:\n        raise BuildEnvError(\"botocore is not installed\") from e\n    return f\"{version}\"",
          "docstring": "Get botocore package version.",
          "signature": "def get_botocore_version() -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/logger.py": {
        "get_logger": {
          "code": "def get_logger(level: int | None = None, name: str = LOGGER_NAME) -> logging.Logger:\n    \"\"\"\n    Get Logger instance.\n\n    Arguments:\n        level -- Log level.\n\n    Returns:\n        Overriden Logger.\n    \"\"\"\n    logger = logging.getLogger(name)\n    if not logger.handlers:\n        stream_handler = logging.StreamHandler()\n        formatter = logging.Formatter(\n            \"%(asctime)s %(name)s: %(levelname)-7s %(message)s\",\n            datefmt=\"%H:%M:%S\",\n        )\n        stream_handler.setFormatter(formatter)\n        stream_handler.setLevel(level or logging.NOTSET)\n        logger.addHandler(stream_handler)\n\n    if level is not None:\n        logger.setLevel(level)\n        for handler in logger.handlers:\n            handler.setLevel(level)\n\n    return logger",
          "docstring": "Get Logger instance.\n\nArguments:\n    level -- Log level.\n\nReturns:\n    Overriden Logger.",
          "signature": "def get_logger(level: int | None=None, name: str=LOGGER_NAME) -> logging.Logger:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "mypy_boto3_builder/main.py:get_available_service_names": {
      "mypy_boto3_builder/utils/strings.py": {
        "get_botocore_class_name": {
          "code": "def get_botocore_class_name(metadata: dict[str, str]) -> str:\n    \"\"\"\n    Get Botocore class name from Service metadata.\n    \"\"\"\n    service_model = MagicMock()\n    service_model.service_name = metadata.get(\"serviceId\", \"\")\n    service_model.metadata = metadata\n    name = get_service_module_name(service_model)\n    return capitalize(name)",
          "docstring": "Get Botocore class name from Service metadata.",
          "signature": "def get_botocore_class_name(metadata: dict[str, str]) -> str:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/service_name.py": {
        "ServiceNameCatalog.add": {
          "code": "    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name",
          "docstring": "Add new ServiceName to catalog or modify existing one.\n\nReturns:\n    New ServiceName or modified if it exists.",
          "signature": "def add(cls, name: str, class_name: str) -> ServiceName:",
          "type": "Method",
          "class_signature": "class ServiceNameCatalog:"
        }
      }
    },
    "mypy_boto3_builder/main.py:main": {
      "mypy_boto3_builder/main.py": {
        "run": {
          "code": "def run(args: CLINamespace) -> None:\n    \"\"\"\n    Run builder.\n    \"\"\"\n    warnings.filterwarnings('ignore', category=FutureWarning, module='botocore.client')\n    logger = get_logger(level=args.log_level)\n    initialize_jinja_manager()\n    session = get_boto3_session()\n    args.output_path.mkdir(exist_ok=True, parents=True)\n    available_service_names = get_available_service_names(get_botocore_session(session))\n    logger.info(f'{len(available_service_names)} supported botocore services discovered')\n    if args.list_services:\n        for service_name in available_service_names:\n            sys.stdout.write(f'- {service_name.name} : {service_name.class_name} {service_name.boto3_doc_link}\\n')\n        return\n    service_names = get_selected_service_names(args.service_names, available_service_names)\n    master_service_names = service_names if args.partial_overload else available_service_names\n    for product in args.products:\n        logger.info(f'Generating {product} product')\n        generate_product(product, args, service_names, master_service_names)\n    logger.info('Completed')",
          "docstring": "Run builder.",
          "signature": "def run(args: CLINamespace) -> None:",
          "type": "Function",
          "class_signature": null
        }
      },
      "mypy_boto3_builder/cli_parser.py": {
        "parse_args": {
          "code": "def parse_args(args: Sequence[str]) -> CLINamespace:\n    \"\"\"\n    Parse CLI arguments.\n\n    Returns:\n        Argument parser.\n    \"\"\"\n    version = get_builder_version()\n\n    parser = argparse.ArgumentParser(\n        PROG_NAME,\n        description=\"Builder for boto3-stubs and types-aiobotocore.\",\n    )\n    parser.add_argument(\"-d\", \"--debug\", action=\"store_true\", help=\"Show debug messages\")\n    parser.add_argument(\n        \"-b\",\n        \"--build-version\",\n        help=\"Set custom output version, otherwise smart versioning is used.\",\n    )\n    parser.add_argument(\"-V\", \"--version\", action=\"version\", version=version)\n    parser.add_argument(\n        \"--product\",\n        dest=\"products\",\n        type=Product,\n        action=EnumListAction,\n        metavar=\"PRODUCT\",\n        nargs=\"+\",\n        default=(Product.boto3, Product.boto3_services),\n        help=\"Package to generate (default: boto3 boto3-stubs)\",\n    )\n    parser.add_argument(\n        \"--skip-published\",\n        action=\"store_true\",\n        help=\"Skip packages that are already on PyPI\",\n    )\n    parser.add_argument(\n        \"--no-smart-version\",\n        action=\"store_true\",\n        help=(\n            \"Disable version bump based od last PyPI version. \"\n            \"Set this flag to run packages build in offline mode. \"\n            \"skip-published flag is ignored in this case.\"\n        ),\n    )\n    parser.add_argument(\n        \"--download-static-stubs\",\n        action=\"store_true\",\n        help=\"Download static stubs from GitHub repositories instead of using built-in files.\",\n    )\n    parser.add_argument(\n        \"--panic\",\n        action=\"store_true\",\n        help=\"Raise exception on logger warning and above\",\n    )\n    parser.add_argument(\n        \"output_path\",\n        metavar=\"OUTPUT_PATH\",\n        help=\"Output path\",\n        type=get_absolute_path,\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--services\",\n        dest=\"service_names\",\n        nargs=\"*\",\n        metavar=\"NAME\",\n        help=(\n            \"List of AWS services, by default all services are used.\"\n            \" Use `updated` to build only services updated in the release.\"\n            \" Use `essential` to build only essential services.\"\n            \" Use `all` to build all services. (default: all)\"\n        ),\n        default=(ServiceName.ALL,),\n    )\n    parser.add_argument(\n        \"--partial-overload\",\n        action=\"store_true\",\n        help=\"Build boto3-stubs client/service overload only for selected services\",\n    )\n    parser.add_argument(\n        \"--installed\",\n        action=\"store_true\",\n        help=\"Generate already installed packages for typings directory.\",\n    )\n    parser.add_argument(\n        \"--list-services\",\n        action=\"store_true\",\n        help=\"List supported boto3 service names.\",\n    )\n    result = parser.parse_args(args)\n\n    return CLINamespace(\n        log_level=logging.DEBUG if result.debug else logging.INFO,\n        output_path=result.output_path,\n        service_names=result.service_names,\n        products=result.products,\n        build_version=result.build_version,\n        installed=result.installed,\n        list_services=result.list_services,\n        partial_overload=result.partial_overload,\n        skip_published=result.skip_published,\n        disable_smart_version=result.no_smart_version,\n        download_static_stubs=result.download_static_stubs,\n    )",
          "docstring": "Parse CLI arguments.\n\nReturns:\n    Argument parser.",
          "signature": "def parse_args(args: Sequence[str]) -> CLINamespace:",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_main\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 main.py\n    \u2502   \u251c\u2500\u2500 get_available_service_names\n    \u2502   \u251c\u2500\u2500 get_selected_service_names\n    \u2502   \u2514\u2500\u2500 main\n    \u2514\u2500\u2500 service_name.py\n        \u2514\u2500\u2500 ServiceName.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the generation and management of type annotations for AWS Boto3 services by providing utilities to identify, select, and handle AWS services and their metadata. It enables users to retrieve a list of available services and filter these based on specific criteria, such as user selection, updated services, or specific service names. Additionally, the module supports a command-line-driven workflow to generate type stubs for Boto3 services, ensuring compatibility and improved type safety for developers integrating AWS services into their projects. This module addresses the challenge of manual type annotation management by automating the process, reducing development overhead, and improving reliability in applications that rely on AWS SDK interactions.\n\n## FILE 1: mypy_boto3_builder/main.py\n\n- FUNCTION NAME: get_available_service_names\n  - SIGNATURE: def get_available_service_names(session: BotocoreSession) -> list[ServiceName]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a list of supported Amazon Web Services (AWS) from the provided Boto3 session.\n\nArgs:\n    session (BotocoreSession): An established Boto3 session used to access AWS services.\n\nReturns:\n    list[ServiceName]: A list of ServiceName objects representing the AWS services supported by the current Boto3 session.\n\nThis function interacts with the Botocore API to fetch the available services and their metadata. It utilizes the `ServiceNameCatalog` to register each service's name and class name based on the metadata obtained. The utility function `get_botocore_class_name` is called to extract the class name from the service's metadata. The data obtained is directly dependent on the Boto3 session passed to the function.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/strings.py:get_botocore_class_name\n    - mypy_boto3_builder/service_name.py:ServiceNameCatalog:add\n\n- FUNCTION NAME: main\n  - SIGNATURE: def main() -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nCLI entrypoint for the builder application. This function parses command-line arguments using `parse_args` and subsequently calls the `run` function with the parsed arguments. It serves as the main entry point for executing the builder, managing the flow from receiving user input to initiating the generation process for AWS SDK clients. The `args` parameter contains all command-line arguments, including service names and product types to generate. This function has no return value and directly interacts with the overall functionality of the application by trigger operations based on the user input.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/main.py:run\n    - mypy_boto3_builder/cli_parser.py:parse_args\n\n- FUNCTION NAME: get_selected_service_names\n  - SIGNATURE: def get_selected_service_names(selected: Iterable[str], available: Iterable[ServiceName]) -> list[ServiceName]:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve and validate a list of selected AWS service names based on user input and available services.\n\nThis function allows users to select service names from a list, incorporating special options like 'updated' to include services that have changed in the current boto3 release and 'all' to select all available services. It interacts with the `BotocoreChangelog` to fetch updated service names and utilizes a mapping of available services for validation.\n\nParameters:\n- selected (Iterable[str]): A collection of service names as strings, which may include special identifiers like 'all', 'updated', and 'essential'.\n- available (Iterable[ServiceName]): A collection of all available service names defined in the current boto3 release.\n\nReturns:\n- list[ServiceName]: A list of validated service names selected according to user input.\n\nConstants and dependencies:\n- `ServiceName`: An enum that contains special service identifiers and maps to actual service names.\n- `get_logger()`: A utility function for logging information, warnings, or errors.\n- `get_botocore_version()`: Retrieves the current version of the Botocore library to check for updated services.\n- `BotocoreChangelog`: A utility that fetches recently updated services based on the current Botocore version, ensuring that the function can provide the most relevant and up-to-date service names.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/botocore_changelog.py:BotocoreChangelog:__init__\n    - mypy_boto3_builder/utils/version_getters.py:get_botocore_version\n    - mypy_boto3_builder/logger.py:get_logger\n\n## FILE 2: mypy_boto3_builder/service_name.py\n\n- CLASS METHOD: ServiceName.__init__\n  - CLASS SIGNATURE: class ServiceName:\n  - SIGNATURE: def __init__(self, name: str, class_name: str, override_boto3_name: str='') -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a ServiceName instance, representing a Boto3 service.\n\nParameters:\n- name (str): The name of the service, typically corresponding to the service's identifier in Boto3 (e.g., 'ec2').\n- class_name (str): The name of the service's class, used for referencing in the code (e.g., 'EC2').\n- override_boto3_name (str, optional): An optional name to override the default Boto3 service name. Defaults to an empty string.\n\nAttributes:\n- self.name: Stores the service name.\n- self.class_name: Stores the service class name.\n- self.boto3_version: Initialized with the class-level constant LATEST, indicating the latest version of the service.\n- self.override_boto3_name: Stores the optional overridden Boto3 service name if provided.\n\nThe purpose of this constructor is to create a structured representation of a Boto3 service that can be used throughout the ServiceNameCatalog and other system components.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/main.py": "\"\"\"\nMain entrypoint for builder.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport datetime\nimport sys\nimport warnings\nfrom collections.abc import Iterable, Sequence\nfrom botocore.session import Session as BotocoreSession\nfrom mypy_boto3_builder.cli_parser import CLINamespace, parse_args\nfrom mypy_boto3_builder.constants import BUILDER_REPO_URL, PACKAGE_NAME\nfrom mypy_boto3_builder.enums.product import Product, ProductLibrary\nfrom mypy_boto3_builder.generators.aioboto3_generator import AioBoto3Generator\nfrom mypy_boto3_builder.generators.aiobotocore_generator import AioBotocoreGenerator\nfrom mypy_boto3_builder.generators.base_generator import BaseGenerator\nfrom mypy_boto3_builder.generators.boto3_generator import Boto3Generator\nfrom mypy_boto3_builder.jinja_manager import JinjaManager\nfrom mypy_boto3_builder.logger import get_logger\nfrom mypy_boto3_builder.service_name import ServiceName, ServiceNameCatalog\nfrom mypy_boto3_builder.utils.boto3_utils import get_boto3_session, get_botocore_session\nfrom mypy_boto3_builder.utils.botocore_changelog import BotocoreChangelog\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, get_botocore_class_name, get_copyright\nfrom mypy_boto3_builder.utils.type_checks import is_literal, is_type_def, is_type_parent, is_typed_dict, is_union\nfrom mypy_boto3_builder.utils.version import get_builder_version\nfrom mypy_boto3_builder.utils.version_getters import get_botocore_version\n\ndef get_generator_cls(product: Product) -> type[BaseGenerator]:\n    \"\"\"\n    Get Generator class for a product.\n    \"\"\"\n    library = product.get_library()\n    match library:\n        case ProductLibrary.boto3:\n            return Boto3Generator\n        case ProductLibrary.aiobotocore:\n            return AioBotocoreGenerator\n        case ProductLibrary.aioboto3:\n            return AioBoto3Generator\n\ndef generate_product(product: Product, args: CLINamespace, service_names: Sequence[ServiceName], master_service_names: Sequence[ServiceName]) -> None:\n    \"\"\"\n    Generate a selected product.\n\n    Arguments:\n        product -- Product to generate\n        args -- CLI namespace\n        service_names -- Selected service names\n        master_service_names -- Service names included in master\n    \"\"\"\n    generator_cls = get_generator_cls(product)\n    generator = generator_cls(service_names=service_names, master_service_names=master_service_names, config=args, version=args.build_version, cleanup=True)\n    generator.generate_product(product.get_type())\n    generator.cleanup_temporary_files()\n\ndef initialize_jinja_manager() -> None:\n    \"\"\"\n    Initialize Jinja manager with globals.\n    \"\"\"\n    jinja_manager = JinjaManager.singleton()\n    jinja_manager.update_globals(builder_version=get_builder_version(), current_year=str(datetime.datetime.now(datetime.timezone.utc).year), get_anchor_link=get_anchor_link, len=len, sorted=sorted, repr=repr, builder_package_name=PACKAGE_NAME, builder_repo_url=BUILDER_REPO_URL, copyright=get_copyright(), is_typed_dict=is_typed_dict, is_union=is_union, is_literal=is_literal, is_type_def=is_type_def, is_type_parent=is_type_parent)\n\ndef run(args: CLINamespace) -> None:\n    \"\"\"\n    Run builder.\n    \"\"\"\n    warnings.filterwarnings('ignore', category=FutureWarning, module='botocore.client')\n    logger = get_logger(level=args.log_level)\n    initialize_jinja_manager()\n    session = get_boto3_session()\n    args.output_path.mkdir(exist_ok=True, parents=True)\n    available_service_names = get_available_service_names(get_botocore_session(session))\n    logger.info(f'{len(available_service_names)} supported botocore services discovered')\n    if args.list_services:\n        for service_name in available_service_names:\n            sys.stdout.write(f'- {service_name.name} : {service_name.class_name} {service_name.boto3_doc_link}\\n')\n        return\n    service_names = get_selected_service_names(args.service_names, available_service_names)\n    master_service_names = service_names if args.partial_overload else available_service_names\n    for product in args.products:\n        logger.info(f'Generating {product} product')\n        generate_product(product, args, service_names, master_service_names)\n    logger.info('Completed')\nif __name__ == '__main__':\n    main()",
    "mypy_boto3_builder/service_name.py": "\"\"\"\nDescription for boto3 service.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import ClassVar, Final, Literal\nfrom mypy_boto3_builder.constants import ALL\nfrom mypy_boto3_builder.utils.strings import get_anchor_link, is_reserved\n__all__ = ('ServiceName', 'ServiceNameCatalog')\n\nclass ServiceName:\n    \"\"\"\n    Description for boto3 service.\n    \"\"\"\n    ALL: Final = 'all'\n    UPDATED: Final = 'updated'\n    ESSENTIAL: Final = 'essential'\n    LATEST: Final = 'latest'\n    ESSENTIAL_NAMES: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n    CONDA_FORGE_AVAILABLE: Final = {'ec2', 'rds', 's3', 'lambda', 'sqs', 'cloudformation', 'dynamodb'}\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on service name.\n        \"\"\"\n        return hash(self.name)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Represent as string for debugging.\n        \"\"\"\n        return f'<ServiceName {self.name} {self.class_name}>'\n\n    @property\n    def underscore_name(self) -> str:\n        \"\"\"\n        Python-friendly service name.\n        \"\"\"\n        return self.name.replace('-', '_')\n\n    @property\n    def boto3_name(self) -> str:\n        \"\"\"\n        Boto3 package name.\n        \"\"\"\n        return self.override_boto3_name or self.name\n\n    @property\n    def import_name(self) -> str:\n        \"\"\"\n        Safe mudule import name.\n        \"\"\"\n        name = self.name.replace('-', '_')\n        if is_reserved(name):\n            return f'{name}_'\n        return name\n\n    @property\n    def extras_name(self) -> str:\n        \"\"\"\n        Extras name for subpackage installation.\n        \"\"\"\n        return self.name\n\n    def is_essential(self) -> bool:\n        \"\"\"\n        Whether service is included to `boto3-stubs[essential]`.\n        \"\"\"\n        return self.name in self.ESSENTIAL_NAMES\n\n    def is_conda_forge_available(self) -> bool:\n        \"\"\"\n        Whether service is available for `conda-forge`.\n        \"\"\"\n        return self.name in self.CONDA_FORGE_AVAILABLE\n\n    @property\n    def boto3_doc_link(self) -> str:\n        \"\"\"\n        Link to boto3 docs.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}.html#{self.class_name.lower()}'\n\n    @property\n    def boto3_doc_link_parent(self) -> str:\n        \"\"\"\n        Link to boto3 docs parent directory.\n        \"\"\"\n        return f'https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/{self.boto3_name}'\n\n    @staticmethod\n    def get_md_doc_link(file: Literal['client', 'service_resource', 'waiters', 'paginators', 'type_defs', 'literals'], *parts: str) -> str:\n        \"\"\"\n        Get link to MD docs with anchor.\n\n        Arguments:\n            file -- HTML file name\n            parts -- Anchor parts\n        \"\"\"\n        link = f'./{file}.md'\n        if not parts:\n            return link\n        anchor = ''.join([get_anchor_link(part) for part in parts])\n        return f'{link}#{anchor}'\n\nclass ServiceNameCatalog:\n    \"\"\"\n    Finder for botocore services by name.\n    \"\"\"\n    all = ServiceName('__all', '__all')\n    ec2 = ServiceName('ec2', 'EC2')\n    iam = ServiceName('iam', 'IAM')\n    s3 = ServiceName('s3', 'S3')\n    rds = ServiceName('rds', 'RDS')\n    cloudwatch = ServiceName('cloudwatch', 'CloudWatch')\n    opsworks = ServiceName('opsworks', 'OpsWorks')\n    sns = ServiceName('sns', 'SNS')\n    glacier = ServiceName('glacier', 'Glacier')\n    dynamodb = ServiceName('dynamodb', 'DynamoDB')\n    sqs = ServiceName('sqs', 'SQS')\n    cloudformation = ServiceName('cloudformation', 'CloudFormation')\n    cloudsearchdomain = ServiceName('cloudsearchdomain', 'CloudSearchDomain')\n    logs = ServiceName('logs', 'CloudWatchLogs')\n    lambda_ = ServiceName('lambda', 'Lambda')\n    stepfunctions = ServiceName('stepfunctions', 'SFN')\n    old_redshift_serverless = ServiceName('redshift-serverless', 'RedshiftServerless', 'redshiftserverless')\n    old_ssm_sap = ServiceName('ssm-sap', 'SsmSap', 'ssmsap')\n    ITEMS: ClassVar[dict[str, ServiceName]] = {ec2.boto3_name: ec2, iam.boto3_name: iam, s3.boto3_name: s3, rds.boto3_name: rds, cloudwatch.boto3_name: cloudwatch, opsworks.boto3_name: opsworks, sns.boto3_name: sns, glacier.boto3_name: glacier, dynamodb.boto3_name: dynamodb, sqs.boto3_name: sqs, cloudformation.boto3_name: cloudformation, cloudsearchdomain.boto3_name: cloudsearchdomain, logs.boto3_name: logs, lambda_.boto3_name: lambda_, old_redshift_serverless.boto3_name: old_redshift_serverless, old_ssm_sap.boto3_name: old_ssm_sap}\n\n    @classmethod\n    def add(cls, name: str, class_name: str) -> ServiceName:\n        \"\"\"\n        Add new ServiceName to catalog or modify existing one.\n\n        Returns:\n            New ServiceName or modified if it exists.\n        \"\"\"\n        if name in cls.ITEMS:\n            service_name = cls.ITEMS[name]\n            service_name.class_name = class_name\n            return service_name\n        service_name = ServiceName(name, class_name)\n        cls.ITEMS[name] = service_name\n        return service_name\n\n    @classmethod\n    def to_str(cls, service_name: ServiceName) -> str:\n        \"\"\"\n        Represent ServiceName as string for lookups.\n        \"\"\"\n        if service_name is cls.all:\n            return ALL\n        return service_name.name"
  },
  "call_tree": {
    "tests/test_main.py:TestMain:test_get_selected_service_names": {
      "mypy_boto3_builder/service_name.py:ServiceName:__init__": {},
      "mypy_boto3_builder/main.py:get_selected_service_names": {
        "mypy_boto3_builder/logger.py:get_logger": {},
        "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {},
        "mypy_boto3_builder/utils/botocore_changelog.py:BotocoreChangelog:__init__": {}
      }
    },
    "tests/test_main.py:TestMain:test_get_available_service_names": {
      "mypy_boto3_builder/main.py:get_available_service_names": {
        "mypy_boto3_builder/utils/strings.py:get_botocore_class_name": {
          "mypy_boto3_builder/utils/strings.py:capitalize": {}
        },
        "mypy_boto3_builder/service_name.py:ServiceNameCatalog:add": {
          "mypy_boto3_builder/service_name.py:ServiceName:__init__": {}
        }
      }
    },
    "tests/test_main.py:TestMain:test_main": {
      "mypy_boto3_builder/main.py:main": {
        "mypy_boto3_builder/cli_parser.py:parse_args": {
          "mypy_boto3_builder/utils/version.py:get_builder_version": {},
          "mypy_boto3_builder/cli_parser.py:EnumListAction:__init__": {},
          "mypy_boto3_builder/cli_parser.py:get_absolute_path": {}
        },
        "mypy_boto3_builder/main.py:run": {
          "mypy_boto3_builder/logger.py:get_logger": {},
          "mypy_boto3_builder/main.py:initialize_jinja_manager": {
            "mypy_boto3_builder/jinja_manager.py:JinjaManager:singleton": {
              "mypy_boto3_builder/jinja_manager.py:JinjaManager:__init__": {}
            },
            "mypy_boto3_builder/utils/version.py:get_builder_version": {},
            "mypy_boto3_builder/utils/strings.py:get_copyright": {},
            "mypy_boto3_builder/jinja_manager.py:JinjaManager:update_globals": {}
          },
          "mypy_boto3_builder/utils/boto3_utils.py:get_boto3_session": {},
          "mypy_boto3_builder/utils/boto3_utils.py:get_botocore_session": {},
          "mypy_boto3_builder/main.py:get_selected_service_names": {
            "mypy_boto3_builder/logger.py:get_logger": {},
            "mypy_boto3_builder/utils/version_getters.py:get_botocore_version": {}
          },
          "mypy_boto3_builder/enums/product.py:Product:__str__": {},
          "mypy_boto3_builder/main.py:generate_product": {
            "mypy_boto3_builder/main.py:get_generator_cls": {
              "mypy_boto3_builder/enums/product.py:Product:get_library": {}
            },
            "mypy_boto3_builder/enums/product.py:Product:get_type": {}
          }
        }
      }
    }
  }
}