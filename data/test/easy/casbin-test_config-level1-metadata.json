{
  "dir_path": "/app/casbin",
  "package_name": "casbin",
  "sample_name": "casbin-test_config",
  "src_dir": "casbin/",
  "test_dir": "tests/",
  "test_file": "tests/config/test_config.py",
  "test_code": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nfrom casbin.config import Config\nfrom unittest import TestCase\n\n\nclass TestConfig(TestCase):\n    def test_new_config(self):\n        path = os.path.split(os.path.realpath(__file__))[0]\n        path = os.path.abspath(path + \"/test.ini\")\n\n        config = Config.new_config(path)\n\n        # default::key\n        self.assertEqual(config.get(\"debug\"), \"true\")\n        self.assertEqual(config.get(\"url\"), \"act.wiki\")\n\n        # reids::key\n        self.assertEqual(config.get(\"redis::redis.key\"), \"push1,push2\")\n        self.assertEqual(config.get(\"mysql::mysql.dev.host\"), \"127.0.0.1\")\n        self.assertEqual(config.get(\"mysql::mysql.master.host\"), \"10.0.0.1\")\n\n        # math::key test\n        self.assertEqual(config.get(\"math::math.i64\"), \"64\")\n        self.assertEqual(config.get(\"math::math.f64\"), \"64.1\")\n\n        # other::key test\n        self.assertEqual(config.get(\"other::name\"), \"ATC\u81ea\u52a8\u5316\u6d4b\u8bd5^-^&($#\u2026\u2026#\")\n        self.assertEqual(config.get(\"other::key1\"), \"test key\")\n\n        config.set(\"other::key1\", \"new test key\")\n\n        self.assertEqual(config.get(\"other::key1\"), \"new test key\")\n\n        config.set(\"other::key1\", \"test key\")\n\n        self.assertEqual(config.get(\"multi1::name\"), \"r.sub==p.sub && r.obj==p.obj\")\n        self.assertEqual(config.get(\"multi2::name\"), \"r.sub==p.sub && r.obj==p.obj\")\n        self.assertEqual(config.get(\"multi3::name\"), \"r.sub==p.sub && r.obj==p.obj\")\n        self.assertEqual(config.get(\"multi4::name\"), \"\")\n        self.assertEqual(config.get(\"multi5::name\"), \"r.sub==p.sub && r.obj==p.obj\")\n\n        self.assertEqual(config.get_bool(\"multi5::name\"), False)\n        self.assertEqual(config.get_string(\"multi5::name\"), \"r.sub==p.sub && r.obj==p.obj\")\n        self.assertEqual(config.get_strings(\"multi5::name\"), [\"r.sub==p.sub && r.obj==p.obj\"])\n        with self.assertRaises(ValueError):\n            config.get_int(\"multi5::name\")\n        with self.assertRaises(ValueError):\n            config.get_float(\"multi5::name\")\n",
  "GT_file_code": {
    "casbin/config/config.py": "# Copyright 2021 The casbin Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom io import StringIO\n\n\nclass Config:\n    \"\"\"represents an implementation of the ConfigInterface\"\"\"\n\n    # DEFAULT_SECTION specifies the name of a section if no name provided\n    DEFAULT_SECTION = \"default\"\n    # DEFAULT_COMMENT defines what character(s) indicate a comment `#`\n    DEFAULT_COMMENT = \"#\"\n    # DEFAULT_COMMENT_SEM defines what alternate character(s) indicate a comment `;`\n    DEFAULT_COMMENT_SEM = \";\"\n    # DEFAULT_MULTI_LINE_SEPARATOR defines what character indicates a multi-line content\n    DEFAULT_MULTI_LINE_SEPARATOR = \"\\\\\"\n\n    _data = dict()\n\n    def __init__(self):\n        self._data = dict()\n\n    @staticmethod\n    def new_config(conf_name):\n        c = Config()\n        c._parse(conf_name)\n        return c\n\n    @staticmethod\n    def new_config_from_text(text):\n        c = Config()\n        f = StringIO(text)\n        c._parse_buffer(f)\n        return c\n\n    def add_config(self, section, option, value):\n        if section == \"\":\n            section = self.DEFAULT_SECTION\n\n        if section not in self._data.keys():\n            self._data[section] = {}\n\n        self._data[section][option] = value\n\n    def _parse(self, fname):\n        with open(fname, \"r\", encoding=\"utf-8\") as f:\n            self._parse_buffer(f)\n\n    def _parse_buffer(self, f):\n        section = \"\"\n        line_num = 0\n        buf = []\n        can_write = False\n        while True:\n            if can_write:\n                self._write(section, line_num, buf)\n                can_write = False\n            line_num = line_num + 1\n\n            line = f.readline()\n\n            if not line:\n                if len(buf) > 0:\n                    self._write(section, line_num, buf)\n                break\n            line = line.strip()\n\n            if \"\" == line or self.DEFAULT_COMMENT == line[0:1] or self.DEFAULT_COMMENT_SEM == line[0:1]:\n                can_write = True\n                continue\n            elif \"[\" == line[0:1] and \"]\" == line[-1]:\n                if len(buf) > 0:\n                    self._write(section, line_num, buf)\n                    can_write = False\n                section = line[1:-1]\n            else:\n                p = \"\"\n                if self.DEFAULT_MULTI_LINE_SEPARATOR == line[-1]:\n                    p = line[0:-1].strip()\n                    p = p + \" \"\n                else:\n                    p = line\n                    can_write = True\n                buf.append(p)\n\n    def _write(self, section, line_num, b):\n        buf = \"\".join(b)\n        if len(buf) <= 0:\n            return\n        option_val = buf.split(\"=\", 1)\n\n        if len(option_val) != 2:\n            raise RuntimeError(\"parse the content error : line {} , {} = ?\".format(line_num, option_val[0]))\n\n        option = option_val[0].strip()\n        value = option_val[1].strip()\n\n        self.add_config(section, option, value)\n\n        del b[:]\n\n    def get_bool(self, key):\n        \"\"\"lookups up the value using the provided key and converts the value to a bool.\"\"\"\n        return self.get(key).capitalize() == \"True\"\n\n    def get_int(self, key):\n        \"\"\"lookups up the value using the provided key and converts the value to a int\"\"\"\n        return int(self.get(key))\n\n    def get_float(self, key):\n        \"\"\"lookups up the value using the provided key and converts the value to a float\"\"\"\n        return float(self.get(key))\n\n    def get_string(self, key):\n        \"\"\"lookups up the value using the provided key and converts the value to a string\"\"\"\n        return self.get(key)\n\n    def get_strings(self, key):\n        \"\"\"lookups up the value using the provided key and converts the value to an array of string\"\"\"\n        value = self.get(key)\n        if value == \"\":\n            return None\n        return value.split(\",\")\n\n    def set(self, key, value):\n        if len(key) == 0:\n            raise RuntimeError(\"key is empty\")\n\n        keys = key.lower().split(\"::\")\n        if len(keys) >= 2:\n            section = keys[0]\n            option = keys[1]\n        else:\n            section = \"\"\n            option = keys[0]\n        self.add_config(section, option, value)\n\n    def get(self, key):\n        \"\"\"section.key or key\"\"\"\n\n        keys = key.lower().split(\"::\")\n        if len(keys) >= 2:\n            section = keys[0]\n            option = keys[1]\n        else:\n            section = self.DEFAULT_SECTION\n            option = keys[0]\n\n        if section in self._data.keys():\n            if option in self._data[section].keys():\n                return self._data[section][option]\n        return \"\"\n"
  },
  "GT_src_dict": {
    "casbin/config/config.py": {
      "Config.new_config": {
        "code": "    def new_config(conf_name):\n        \"\"\"Creates a new Config instance and parses the configuration file specified by the given name.\n\nParameters:\n    conf_name (str): The name of the configuration file to be parsed. This file should be in a readable format \n                     as expected by the `_parse` method.\n\nReturns:\n    Config: An instance of the Config class populated with the settings from the specified configuration file.\n\nThis method interacts with the `_parse` method which reads the configuration from the specified file and populates \nthe internal `_data` dictionary. The constants DEFAULT_SECTION, DEFAULT_COMMENT, DEFAULT_COMMENT_SEM, and \nDEFAULT_MULTI_LINE_SEPARATOR defined in the Config class are used to determine default behavior during parsing.\"\"\"\n        c = Config()\n        c._parse(conf_name)\n        return c",
        "docstring": "Creates a new Config instance and parses the configuration file specified by the given name.\n\nParameters:\n    conf_name (str): The name of the configuration file to be parsed. This file should be in a readable format \n                     as expected by the `_parse` method.\n\nReturns:\n    Config: An instance of the Config class populated with the settings from the specified configuration file.\n\nThis method interacts with the `_parse` method which reads the configuration from the specified file and populates \nthe internal `_data` dictionary. The constants DEFAULT_SECTION, DEFAULT_COMMENT, DEFAULT_COMMENT_SEM, and \nDEFAULT_MULTI_LINE_SEPARATOR defined in the Config class are used to determine default behavior during parsing.",
        "signature": "def new_config(conf_name):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.get_bool": {
        "code": "    def get_bool(self, key):\n        \"\"\"Retrieves the boolean value associated with the specified key from the configuration data.\n\nParameters:\n- key (str): The key to look up in the configuration. It may reference a specific section using \"section::option\" format.\n\nReturns:\n- bool: The boolean representation of the value associated with the provided key. If the value is \"True\" (case insensitive), it returns True; otherwise, it returns False.\n\nThis method relies on the Config.get() method to retrieve the configuration value as a string. It expects that the value returned from get() can be normalized using the `capitalize()` method to compare against \"True\". If the key does not exist, the method will default to returning False since an empty string comparison will yield False when evaluated as a boolean.\"\"\"\n        'lookups up the value using the provided key and converts the value to a bool.'\n        return self.get(key).capitalize() == 'True'",
        "docstring": "Retrieves the boolean value associated with the specified key from the configuration data.\n\nParameters:\n- key (str): The key to look up in the configuration. It may reference a specific section using \"section::option\" format.\n\nReturns:\n- bool: The boolean representation of the value associated with the provided key. If the value is \"True\" (case insensitive), it returns True; otherwise, it returns False.\n\nThis method relies on the Config.get() method to retrieve the configuration value as a string. It expects that the value returned from get() can be normalized using the `capitalize()` method to compare against \"True\". If the key does not exist, the method will default to returning False since an empty string comparison will yield False when evaluated as a boolean.",
        "signature": "def get_bool(self, key):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.get_int": {
        "code": "    def get_int(self, key):\n        \"\"\"Retrieves the configuration value associated with the specified key, converts it to an integer, and returns the result.\n\nParameters:\n- key (str): The key used to look up the configuration value. The key can reference an option directly by its name or include a section, formatted as \"section::option\". If no section is explicitly provided, the DEFAULT_SECTION is used, which is defined as \"default\".\n\nReturns:\n- int: The integer representation of the configuration value associated with the provided key.\n\nThis method relies on the Config.get() method to retrieve the string value. If the value cannot be converted to an integer, a ValueError will be raised.\"\"\"\n        'lookups up the value using the provided key and converts the value to a int'\n        return int(self.get(key))",
        "docstring": "Retrieves the configuration value associated with the specified key, converts it to an integer, and returns the result.\n\nParameters:\n- key (str): The key used to look up the configuration value. The key can reference an option directly by its name or include a section, formatted as \"section::option\". If no section is explicitly provided, the DEFAULT_SECTION is used, which is defined as \"default\".\n\nReturns:\n- int: The integer representation of the configuration value associated with the provided key.\n\nThis method relies on the Config.get() method to retrieve the string value. If the value cannot be converted to an integer, a ValueError will be raised.",
        "signature": "def get_int(self, key):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.get_float": {
        "code": "    def get_float(self, key):\n        \"\"\"Retrieves the value associated with the specified key from the configuration and converts it to a float.\n\nParameters:\n- key (str): The key used to look up the value in the configuration. This may be a section key (formatted as \"section::option\") or just the option if it belongs to the default section.\n\nReturns:\n- float: The value converted to a float. If the key does not exist, it defaults to returning 0.0.\n\nThis method relies on the Config.get() method to obtain the raw string value from the configuration, which is then converted to a float. The handling of sections is based on the internal structure defined in the Config class, specifically utilizing the _data dictionary that stores configuration values.\"\"\"\n        'lookups up the value using the provided key and converts the value to a float'\n        return float(self.get(key))",
        "docstring": "Retrieves the value associated with the specified key from the configuration and converts it to a float.\n\nParameters:\n- key (str): The key used to look up the value in the configuration. This may be a section key (formatted as \"section::option\") or just the option if it belongs to the default section.\n\nReturns:\n- float: The value converted to a float. If the key does not exist, it defaults to returning 0.0.\n\nThis method relies on the Config.get() method to obtain the raw string value from the configuration, which is then converted to a float. The handling of sections is based on the internal structure defined in the Config class, specifically utilizing the _data dictionary that stores configuration values.",
        "signature": "def get_float(self, key):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.get_string": {
        "code": "    def get_string(self, key):\n        \"\"\"Retrieves the configuration value associated with the specified key and returns it as a string.\n\nParameters:\n- key (str): The key used to lookup the configuration value. It may represent a specific section and option in the format 'section::option' or just 'option', in which case the DEFAULT_SECTION is used.\n\nReturns:\n- str: The configuration value as a string. If the key is not found, an empty string is returned.\n\nThis method interacts with the `get` method to obtain the corresponding value, which is stored in the `_data` attribute of the `Config` class. The `_data` dictionary organizes configuration settings by sections and options, allowing for structured access and modification of configuration data.\"\"\"\n        'lookups up the value using the provided key and converts the value to a string'\n        return self.get(key)",
        "docstring": "Retrieves the configuration value associated with the specified key and returns it as a string.\n\nParameters:\n- key (str): The key used to lookup the configuration value. It may represent a specific section and option in the format 'section::option' or just 'option', in which case the DEFAULT_SECTION is used.\n\nReturns:\n- str: The configuration value as a string. If the key is not found, an empty string is returned.\n\nThis method interacts with the `get` method to obtain the corresponding value, which is stored in the `_data` attribute of the `Config` class. The `_data` dictionary organizes configuration settings by sections and options, allowing for structured access and modification of configuration data.",
        "signature": "def get_string(self, key):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.get_strings": {
        "code": "    def get_strings(self, key):\n        \"\"\"Retrieves the value associated with the specified key from the configuration, converts it into a list of strings, and returns it.\n\nParameters:\n- key (str): The key for the value to be retrieved. It can reference a specific section and option in the format \"section::option\" or just \"option\", defaulting to the \"default\" section if no section is specified.\n\nReturns:\n- list or None: A list of strings obtained by splitting the value by commas. Returns None if the retrieved value is an empty string.\n\nThis method depends on the `get` method to retrieve the stored value for the provided key. If the key does not exist, the method returns an empty string which results in a None return value when split. The `DEFAULT_SECTION` constant, defined in the `Config` class, is used to denote the section that will be accessed if no section is provided in the key.\"\"\"\n        'lookups up the value using the provided key and converts the value to an array of string'\n        value = self.get(key)\n        if value == '':\n            return None\n        return value.split(',')",
        "docstring": "Retrieves the value associated with the specified key from the configuration, converts it into a list of strings, and returns it.\n\nParameters:\n- key (str): The key for the value to be retrieved. It can reference a specific section and option in the format \"section::option\" or just \"option\", defaulting to the \"default\" section if no section is specified.\n\nReturns:\n- list or None: A list of strings obtained by splitting the value by commas. Returns None if the retrieved value is an empty string.\n\nThis method depends on the `get` method to retrieve the stored value for the provided key. If the key does not exist, the method returns an empty string which results in a None return value when split. The `DEFAULT_SECTION` constant, defined in the `Config` class, is used to denote the section that will be accessed if no section is provided in the key.",
        "signature": "def get_strings(self, key):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.set": {
        "code": "    def set(self, key, value):\n        \"\"\"Sets a configuration option in the specified section.\n\nParameters:\n- key (str): The key to set, which may include a section name in the format \"section::option\". If no section is provided, the option is added to the default section.\n- value (str): The value to associate with the specified key.\n\nRaises:\n- RuntimeError: If the provided key is empty.\n\nThis method interacts with the `add_config` method to store the specified key-value pair in the configuration data. The class constant `DEFAULT_SECTION` is used to define the default section name when no section is specified. The `key` is split into sections and options using the \"::\" delimiter, allowing for a structured approach to configuration management.\"\"\"\n        if len(key) == 0:\n            raise RuntimeError('key is empty')\n        keys = key.lower().split('::')\n        if len(keys) >= 2:\n            section = keys[0]\n            option = keys[1]\n        else:\n            section = ''\n            option = keys[0]\n        self.add_config(section, option, value)",
        "docstring": "Sets a configuration option in the specified section.\n\nParameters:\n- key (str): The key to set, which may include a section name in the format \"section::option\". If no section is provided, the option is added to the default section.\n- value (str): The value to associate with the specified key.\n\nRaises:\n- RuntimeError: If the provided key is empty.\n\nThis method interacts with the `add_config` method to store the specified key-value pair in the configuration data. The class constant `DEFAULT_SECTION` is used to define the default section name when no section is specified. The `key` is split into sections and options using the \"::\" delimiter, allowing for a structured approach to configuration management.",
        "signature": "def set(self, key, value):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.get": {
        "code": "    def get(self, key):\n        \"\"\"Retrieves the value associated with a given key from the configuration data.\n\nParameters:\n- key (str): A string representing the key to look up, which can be in the format of \"section::option\" or just \"option\". If only \"option\" is provided, it defaults to the \"default\" section.\n\nReturns:\n- str: The value associated with the specified key, or an empty string if the key does not exist.\n\nThe method uses the class constant DEFAULT_SECTION to determine the default section if one is not specified. It accesses the internal dictionary `_data` to retrieve the value, with the structure organized by sections and options. If the specified section or option is not found, it returns an empty string.\"\"\"\n        'section.key or key'\n        keys = key.lower().split('::')\n        if len(keys) >= 2:\n            section = keys[0]\n            option = keys[1]\n        else:\n            section = self.DEFAULT_SECTION\n            option = keys[0]\n        if section in self._data.keys():\n            if option in self._data[section].keys():\n                return self._data[section][option]\n        return ''",
        "docstring": "Retrieves the value associated with a given key from the configuration data.\n\nParameters:\n- key (str): A string representing the key to look up, which can be in the format of \"section::option\" or just \"option\". If only \"option\" is provided, it defaults to the \"default\" section.\n\nReturns:\n- str: The value associated with the specified key, or an empty string if the key does not exist.\n\nThe method uses the class constant DEFAULT_SECTION to determine the default section if one is not specified. It accesses the internal dictionary `_data` to retrieve the value, with the structure organized by sections and options. If the specified section or option is not found, it returns an empty string.",
        "signature": "def get(self, key):",
        "type": "Method",
        "class_signature": "class Config:"
      }
    }
  },
  "dependency_dict": {
    "casbin/config/config.py:Config:new_config": {
      "casbin/config/config.py": {
        "Config.__init__": {
          "code": "    def __init__(self):\n        self._data = dict()",
          "docstring": "",
          "signature": "def __init__(self):",
          "type": "Method",
          "class_signature": "class Config:"
        },
        "Config._parse": {
          "code": "    def _parse(self, fname):\n        with open(fname, 'r', encoding='utf-8') as f:\n            self._parse_buffer(f)",
          "docstring": "",
          "signature": "def _parse(self, fname):",
          "type": "Method",
          "class_signature": "class Config:"
        }
      }
    },
    "casbin/config/config.py:Config:set": {
      "casbin/config/config.py": {
        "Config.add_config": {
          "code": "    def add_config(self, section, option, value):\n        if section == '':\n            section = self.DEFAULT_SECTION\n        if section not in self._data.keys():\n            self._data[section] = {}\n        self._data[section][option] = value",
          "docstring": "",
          "signature": "def add_config(self, section, option, value):",
          "type": "Method",
          "class_signature": "class Config:"
        }
      }
    },
    "casbin/config/config.py:Config:get_bool": {},
    "casbin/config/config.py:Config:get_string": {},
    "casbin/config/config.py:Config:get_strings": {},
    "casbin/config/config.py:Config:get_int": {},
    "casbin/config/config.py:Config:get_float": {}
  },
  "PRD": "# PROJECT NAME: casbin-test_config\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 casbin/\n    \u2514\u2500\u2500 config/\n        \u2514\u2500\u2500 config.py\n            \u251c\u2500\u2500 Config.get\n            \u251c\u2500\u2500 Config.get_bool\n            \u251c\u2500\u2500 Config.get_float\n            \u251c\u2500\u2500 Config.get_int\n            \u251c\u2500\u2500 Config.get_string\n            \u251c\u2500\u2500 Config.get_strings\n            \u251c\u2500\u2500 Config.new_config\n            \u2514\u2500\u2500 Config.set\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to manage and interact with configuration files, specifically enabling efficient reading, updating, and validation of configuration parameters. It provides functionality to retrieve values in various data types (e.g., booleans, strings, lists) from hierarchical configuration files, as well as to update and persist changes to these configurations. Additionally, it supports parsing and retrieving nested keys from sectioned configurations, ensuring organized and structured management of application settings. By standardizing access to configuration data, the module solves the problem of handling complex configuration structures, allowing developers to streamline application setup and maintain flexibility in environment-specific configurations.\n\n## FILE 1: casbin/config/config.py\n\n- CLASS METHOD: Config.get_int\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def get_int(self, key):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the configuration value associated with the specified key, converts it to an integer, and returns the result.\n\nParameters:\n- key (str): The key used to look up the configuration value. The key can reference an option directly by its name or include a section, formatted as \"section::option\". If no section is explicitly provided, the DEFAULT_SECTION is used, which is defined as \"default\".\n\nReturns:\n- int: The integer representation of the configuration value associated with the provided key.\n\nThis method relies on the Config.get() method to retrieve the string value. If the value cannot be converted to an integer, a ValueError will be raised.\n\"\"\"\n```\n\n- CLASS METHOD: Config.get_string\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def get_string(self, key):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the configuration value associated with the specified key and returns it as a string.\n\nParameters:\n- key (str): The key used to lookup the configuration value. It may represent a specific section and option in the format 'section::option' or just 'option', in which case the DEFAULT_SECTION is used.\n\nReturns:\n- str: The configuration value as a string. If the key is not found, an empty string is returned.\n\nThis method interacts with the `get` method to obtain the corresponding value, which is stored in the `_data` attribute of the `Config` class. The `_data` dictionary organizes configuration settings by sections and options, allowing for structured access and modification of configuration data.\n\"\"\"\n```\n\n- CLASS METHOD: Config.get\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def get(self, key):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the value associated with a given key from the configuration data.\n\nParameters:\n- key (str): A string representing the key to look up, which can be in the format of \"section::option\" or just \"option\". If only \"option\" is provided, it defaults to the \"default\" section.\n\nReturns:\n- str: The value associated with the specified key, or an empty string if the key does not exist.\n\nThe method uses the class constant DEFAULT_SECTION to determine the default section if one is not specified. It accesses the internal dictionary `_data` to retrieve the value, with the structure organized by sections and options. If the specified section or option is not found, it returns an empty string.\n\"\"\"\n```\n\n- CLASS METHOD: Config.get_strings\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def get_strings(self, key):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the value associated with the specified key from the configuration, converts it into a list of strings, and returns it.\n\nParameters:\n- key (str): The key for the value to be retrieved. It can reference a specific section and option in the format \"section::option\" or just \"option\", defaulting to the \"default\" section if no section is specified.\n\nReturns:\n- list or None: A list of strings obtained by splitting the value by commas. Returns None if the retrieved value is an empty string.\n\nThis method depends on the `get` method to retrieve the stored value for the provided key. If the key does not exist, the method returns an empty string which results in a None return value when split. The `DEFAULT_SECTION` constant, defined in the `Config` class, is used to denote the section that will be accessed if no section is provided in the key.\n\"\"\"\n```\n\n- CLASS METHOD: Config.set\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def set(self, key, value):\n  - DOCSTRING: \n```python\n\"\"\"\nSets a configuration option in the specified section.\n\nParameters:\n- key (str): The key to set, which may include a section name in the format \"section::option\". If no section is provided, the option is added to the default section.\n- value (str): The value to associate with the specified key.\n\nRaises:\n- RuntimeError: If the provided key is empty.\n\nThis method interacts with the `add_config` method to store the specified key-value pair in the configuration data. The class constant `DEFAULT_SECTION` is used to define the default section name when no section is specified. The `key` is split into sections and options using the \"::\" delimiter, allowing for a structured approach to configuration management.\n\"\"\"\n```\n\n- CLASS METHOD: Config.get_bool\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def get_bool(self, key):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the boolean value associated with the specified key from the configuration data.\n\nParameters:\n- key (str): The key to look up in the configuration. It may reference a specific section using \"section::option\" format.\n\nReturns:\n- bool: The boolean representation of the value associated with the provided key. If the value is \"True\" (case insensitive), it returns True; otherwise, it returns False.\n\nThis method relies on the Config.get() method to retrieve the configuration value as a string. It expects that the value returned from get() can be normalized using the `capitalize()` method to compare against \"True\". If the key does not exist, the method will default to returning False since an empty string comparison will yield False when evaluated as a boolean.\n\"\"\"\n```\n\n- CLASS METHOD: Config.get_float\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def get_float(self, key):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the value associated with the specified key from the configuration and converts it to a float.\n\nParameters:\n- key (str): The key used to look up the value in the configuration. This may be a section key (formatted as \"section::option\") or just the option if it belongs to the default section.\n\nReturns:\n- float: The value converted to a float. If the key does not exist, it defaults to returning 0.0.\n\nThis method relies on the Config.get() method to obtain the raw string value from the configuration, which is then converted to a float. The handling of sections is based on the internal structure defined in the Config class, specifically utilizing the _data dictionary that stores configuration values.\n\"\"\"\n```\n\n- CLASS METHOD: Config.new_config\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def new_config(conf_name):\n  - DOCSTRING: \n```python\n\"\"\"\nCreates a new Config instance and parses the configuration file specified by the given name.\n\nParameters:\n    conf_name (str): The name of the configuration file to be parsed. This file should be in a readable format \n                     as expected by the `_parse` method.\n\nReturns:\n    Config: An instance of the Config class populated with the settings from the specified configuration file.\n\nThis method interacts with the `_parse` method which reads the configuration from the specified file and populates \nthe internal `_data` dictionary. The constants DEFAULT_SECTION, DEFAULT_COMMENT, DEFAULT_COMMENT_SEM, and \nDEFAULT_MULTI_LINE_SEPARATOR defined in the Config class are used to determine default behavior during parsing.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "casbin/config/config.py": "from io import StringIO\n\nclass Config:\n    \"\"\"represents an implementation of the ConfigInterface\"\"\"\n    DEFAULT_SECTION = 'default'\n    DEFAULT_COMMENT = '#'\n    DEFAULT_COMMENT_SEM = ';'\n    DEFAULT_MULTI_LINE_SEPARATOR = '\\\\'\n    _data = dict()\n\n    def __init__(self):\n        self._data = dict()\n\n    @staticmethod\n    def new_config_from_text(text):\n        c = Config()\n        f = StringIO(text)\n        c._parse_buffer(f)\n        return c\n\n    def add_config(self, section, option, value):\n        if section == '':\n            section = self.DEFAULT_SECTION\n        if section not in self._data.keys():\n            self._data[section] = {}\n        self._data[section][option] = value\n\n    def _parse(self, fname):\n        with open(fname, 'r', encoding='utf-8') as f:\n            self._parse_buffer(f)\n\n    def _parse_buffer(self, f):\n        section = ''\n        line_num = 0\n        buf = []\n        can_write = False\n        while True:\n            if can_write:\n                self._write(section, line_num, buf)\n                can_write = False\n            line_num = line_num + 1\n            line = f.readline()\n            if not line:\n                if len(buf) > 0:\n                    self._write(section, line_num, buf)\n                break\n            line = line.strip()\n            if '' == line or self.DEFAULT_COMMENT == line[0:1] or self.DEFAULT_COMMENT_SEM == line[0:1]:\n                can_write = True\n                continue\n            elif '[' == line[0:1] and ']' == line[-1]:\n                if len(buf) > 0:\n                    self._write(section, line_num, buf)\n                    can_write = False\n                section = line[1:-1]\n            else:\n                p = ''\n                if self.DEFAULT_MULTI_LINE_SEPARATOR == line[-1]:\n                    p = line[0:-1].strip()\n                    p = p + ' '\n                else:\n                    p = line\n                    can_write = True\n                buf.append(p)\n\n    def _write(self, section, line_num, b):\n        buf = ''.join(b)\n        if len(buf) <= 0:\n            return\n        option_val = buf.split('=', 1)\n        if len(option_val) != 2:\n            raise RuntimeError('parse the content error : line {} , {} = ?'.format(line_num, option_val[0]))\n        option = option_val[0].strip()\n        value = option_val[1].strip()\n        self.add_config(section, option, value)\n        del b[:]"
  },
  "call_tree": {
    "tests/config/test_config.py:TestConfig:test_new_config": {
      "casbin/config/config.py:Config:new_config": {
        "casbin/config/config.py:Config:__init__": {},
        "casbin/config/config.py:Config:_parse": {
          "casbin/config/config.py:Config:_parse_buffer": {
            "casbin/config/config.py:Config:_write": {
              "casbin/config/config.py:Config:add_config": {}
            }
          }
        }
      },
      "casbin/config/config.py:Config:get": {},
      "casbin/config/config.py:Config:set": {
        "casbin/config/config.py:Config:add_config": {}
      },
      "casbin/config/config.py:Config:get_bool": {
        "casbin/config/config.py:Config:get": {}
      },
      "casbin/config/config.py:Config:get_string": {
        "casbin/config/config.py:Config:get": {}
      },
      "casbin/config/config.py:Config:get_strings": {
        "casbin/config/config.py:Config:get": {}
      },
      "casbin/config/config.py:Config:get_int": {
        "casbin/config/config.py:Config:get": {}
      },
      "casbin/config/config.py:Config:get_float": {
        "casbin/config/config.py:Config:get": {}
      }
    }
  }
}