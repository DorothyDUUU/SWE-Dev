{
  "dir_path": "/app/magicalimport",
  "package_name": "magicalimport",
  "sample_name": "magicalimport-test_notfound",
  "src_dir": "magicalimport/",
  "test_dir": "magicalimport/tests/",
  "test_file": "magicalimport/tests/test_notfound.py",
  "test_code": "import unittest\nimport os.path\nfrom magicalimport.compat import ModuleNotFoundError\n\nhere = os.path.dirname(os.path.abspath(__file__))\n\n\nclass ImportModuleTests(unittest.TestCase):\n    def _callFUT(self, *args, **kwargs):\n        from magicalimport import import_module\n\n        return import_module(*args, **kwargs)\n\n    def test_target_file_is_notfound(self):\n        import random\n\n        path = os.path.join(here, \"missing{}.py\".format(random.random()))\n        with self.assertRaises(ModuleNotFoundError):\n            self._callFUT(path)\n\n    def test_target_module_is_notfound(self):\n        import random\n\n        path = os.path.join(here, \"missing{}\".format(random.random()))\n        with self.assertRaises(ModuleNotFoundError):\n            self._callFUT(path)\n\n\nclass ImportSymbolTests(unittest.TestCase):\n    def _callFUT(self, *args, **kwargs):\n        from magicalimport import import_symbol\n\n        kwargs[\"silent\"] = True\n        return import_symbol(*args, **kwargs)\n\n    def test_target_file_is_notfound(self):\n        import random\n\n        path = os.path.join(here, \"missing{}.py:foo\".format(random.random()))\n        with self.assertRaises(ModuleNotFoundError):\n            self._callFUT(path)\n\n    def test_target_module_is_notfound(self):\n        import random\n\n        path = os.path.join(here, \"missing{}:foo\".format(random.random()))\n        with self.assertRaises(ModuleNotFoundError):\n            self._callFUT(path)\n\n    def test_target_module_has_not_member(self):\n        with self.assertRaises(ImportError) as c:\n            self._callFUT(\"collections:foo\")\n\n    def test_target_file_has_not_member(self):\n        import os.path\n\n        path = os.path.join(here, \"../../examples/a/b/c/foo.py\")\n        self.assertTrue(os.path.exists(path))\n\n        with self.assertRaises(ImportError):\n            self._callFUT(\"{}:foo\".format(path))\n",
  "GT_file_code": {
    "magicalimport/__init__.py": "import logging\nimport os.path\nimport sys\nfrom magicalimport.compat import ModuleNotFoundError\nfrom magicalimport.compat import FileNotFoundError\nfrom magicalimport.compat import _create_module\nfrom magicalimport.compat import import_module as import_module_original\n\nlogger = logging.getLogger(__name__)\n\n\ndef expose_all_members(module, globals_=None, _depth=2):\n    members = {k: v for k, v in module.__dict__.items() if not k.startswith(\"_\")}\n    return expose_members(module, members, globals_=globals_, _depth=_depth)\n\n\ndef expose_members(module, members, globals_=None, _depth=1):\n    if globals_ is None:\n        frame = sys._getframe(_depth)  # xxx: black magic\n        globals_ = frame.f_globals\n    globals_.update({k: module.__dict__[k] for k in members})\n    return globals_\n\n\ndef _module_id_from_path(path):\n    logger.debug(\"\t-> %s (path)\", path)\n\n    dirname = os.path.dirname(path)\n    basename = os.path.basename(path)\n\n    module_id = \"{}.{}\".format(dirname.replace(\"/\", \"_\"), basename.rsplit(\".py\", 1)[0])\n    logger.debug(\"\t<- %s (module_id)\", module_id)\n    return module_id\n\n\n_FAILED = set()  # singleton\n\n\ndef import_from_physical_path(path, as_=None, here=None, _depth=1, cwd=True):\n    global _FAILED\n\n    if here is None:\n        if cwd:\n            here = os.getcwd()\n        elif _depth > 0:\n            frame = sys._getframe(_depth)  # xxx: black magic\n            here = frame.f_globals[\"__file__\"]\n        else:\n            raise ValueError(\n                \"invalid option found _depth={}, cwd={}\".format(_depth, cwd)\n            )\n    if here is not None:\n        here = here if os.path.isdir(here) else os.path.dirname(here)\n        here = os.path.abspath(here)\n        path = os.path.join(here, path)\n\n    path = os.path.normpath(os.path.abspath(path))\n\n    module_id = as_ or _module_id_from_path(path)\n    if module_id in sys.modules:\n        return sys.modules[module_id]\n\n    guess_path = path.replace(\"/__init__.py\", \"\")\n\n    if as_ is None:\n        for sys_path in sys.path:\n            if not guess_path.startswith(sys_path):\n                continue\n\n            guessed_module = (\n                guess_path[len(sys_path) :]\n                .lstrip(\"/\")\n                .rsplit(\".py\", 1)[0]\n                .replace(\"/\", \".\")\n            )\n            if guessed_module in _FAILED:\n                continue\n\n            try:\n                m = import_module_original(guessed_module)\n                return m\n            except ModuleNotFoundError:\n                _FAILED.add(guessed_module)\n            except ImportError as e:\n                if ImportError.__module__ != ModuleNotFoundError.__module__:\n                    if str(e).startswith(\"No module named\"):\n                        _FAILED.add(guessed_module)\n                        continue\n                raise\n\n    if \".\" in module_id and as_ is None:\n        parent_module_id = module_id.rsplit(\".\")[0]\n        if parent_module_id not in sys.modules:\n            init_py = os.path.join(os.path.dirname(path), \"__init__.py\")\n            if os.path.exists(init_py):\n                _create_module(parent_module_id, init_py)\n            else:\n                # TODO: don't have to create __init__.py\n                try:\n                    with open(init_py, \"w\"):\n                        pass\n                    _create_module(parent_module_id, init_py)\n                    # # xxx: using fake module as parent module\n                    # import magicalimport._fake as fake_module\n\n                    # parent_module = _create_module(parent_module_id, fake_module.__file__)\n                    # parent_module.__file__ = init_py\n                except PermissionError as e:\n                    module_id = module_id.replace(\".\", \"_\")\n                    logger.warn(\n                        \"open %s, cannot accessable (%r). new module_id is %r\",\n                        init_py,\n                        e,\n                        module_id,\n                    )\n    try:\n        return _create_module(module_id, path)\n    except (FileNotFoundError, OSError) as e:\n        raise ModuleNotFoundError(e)\n\n\ndef import_module(module_path, here=None, sep=\":\", _depth=2, cwd=True):\n    _, ext = os.path.splitext(module_path)\n    if ext == \".py\":\n        m = import_from_physical_path(module_path, here=here, _depth=_depth, cwd=cwd)\n        logger.debug(\"import module %s\", m)\n        return m\n    else:\n        try:\n            return import_module_original(module_path)\n        except ImportError as e:\n            if ImportError.__module__ == ModuleNotFoundError.__module__:\n                raise\n            raise ModuleNotFoundError(e)\n\n\ndef import_symbol(sym, here=None, sep=\":\", ns=None, silent=False, _depth=3, cwd=True):\n    if ns is not None and sep not in sym:\n        sym = \"{}{}{}\".format(ns, sep, sym)\n    module_path, fn_name = sym.rsplit(sep, 2)\n    try:\n        module = import_module(module_path, here=here, sep=sep, _depth=_depth, cwd=cwd)\n    except (\n        ImportError,\n        ModuleNotFoundError,\n    ) as e:  # ModuleNotFoundError is subclass of ImportError\n        if not silent:\n            sys.stderr.write(\"could not import {!r}\\n{}\\n\".format(sym, e))\n        raise\n    try:\n        return getattr(module, fn_name)\n    except AttributeError as e:\n        if not silent:\n            sys.stderr.write(\"could not import {!r}\\n{}\\n\".format(sym, e))\n        raise ImportError(e)\n"
  },
  "GT_src_dict": {
    "magicalimport/__init__.py": {
      "import_module": {
        "code": "def import_module(module_path, here=None, sep=':', _depth=2, cwd=True):\n    \"\"\"Imports a Python module from a specified path. If the path points to a Python file (.py), it uses the `import_from_physical_path` function to load the module from its physical location. If the path does not have a .py extension, it tries to import the module using the original import mechanism. \n\nParameters:\n- module_path (str): The path to the module to be imported, which can be a relative or absolute path.\n- here (str, optional): The directory from which to resolve the module path. If not provided, the current working directory or the caller's file path will be used, depending on the value of `cwd`.\n- sep (str, optional): The separator used to distinguish between the module and the component names in the module path (default is ':').\n- _depth (int, optional): The stack depth to determine the calling frame for the `here` path (default is 2).\n- cwd (bool, optional): A flag indicating whether to use the current working directory if `here` is not provided (default is True).\n\nReturns:\n- Module: The imported module object.\n\nRaises:\n- ModuleNotFoundError: If the module cannot be found or imported, including due to an ImportError.\n\nDependencies:\n- The function utilizes `import_from_physical_path` for file-based imports and `import_module_original` for standard module imports. It also utilizes a logger to provide debug information when modules are imported.\"\"\"\n    _, ext = os.path.splitext(module_path)\n    if ext == '.py':\n        m = import_from_physical_path(module_path, here=here, _depth=_depth, cwd=cwd)\n        logger.debug('import module %s', m)\n        return m\n    else:\n        try:\n            return import_module_original(module_path)\n        except ImportError as e:\n            if ImportError.__module__ == ModuleNotFoundError.__module__:\n                raise\n            raise ModuleNotFoundError(e)",
        "docstring": "Imports a Python module from a specified path. If the path points to a Python file (.py), it uses the `import_from_physical_path` function to load the module from its physical location. If the path does not have a .py extension, it tries to import the module using the original import mechanism. \n\nParameters:\n- module_path (str): The path to the module to be imported, which can be a relative or absolute path.\n- here (str, optional): The directory from which to resolve the module path. If not provided, the current working directory or the caller's file path will be used, depending on the value of `cwd`.\n- sep (str, optional): The separator used to distinguish between the module and the component names in the module path (default is ':').\n- _depth (int, optional): The stack depth to determine the calling frame for the `here` path (default is 2).\n- cwd (bool, optional): A flag indicating whether to use the current working directory if `here` is not provided (default is True).\n\nReturns:\n- Module: The imported module object.\n\nRaises:\n- ModuleNotFoundError: If the module cannot be found or imported, including due to an ImportError.\n\nDependencies:\n- The function utilizes `import_from_physical_path` for file-based imports and `import_module_original` for standard module imports. It also utilizes a logger to provide debug information when modules are imported.",
        "signature": "def import_module(module_path, here=None, sep=':', _depth=2, cwd=True):",
        "type": "Function",
        "class_signature": null
      },
      "import_symbol": {
        "code": "def import_symbol(sym, here=None, sep=':', ns=None, silent=False, _depth=3, cwd=True):\n    \"\"\"Imports a symbol (attribute or function) from a specified module using a given symbol string. The symbol string can reference modules and their attributes in a flexible format, allowing for namespacing.\n\nParameters:\n- sym (str): The symbol string specifying the module path and the attribute to import, using the specified separator (default is \":\").\n- here (str, optional): The base directory to resolve relative paths from. Defaults to None.\n- sep (str, optional): The separator used in the symbol string to distinguish between the module and the attribute. Defaults to \":\".\n- ns (str, optional): An optional namespace used to modify the symbol string if provided.\n- silent (bool, optional): If True, suppresses error messages to stderr when the import fails. Defaults to False.\n- _depth (int, optional): The stack frame depth to determine the calling module's context. Defaults to 3.\n- cwd (bool, optional): If True, uses the current working directory to help resolve relative imports. Defaults to True.\n\nReturns:\n- The requested attribute from the module if found; otherwise, raises ImportError.\n\nInteractions:\n- Utilizes `import_module` function to load the module specified by the symbol string. This function handles both local and standard imports.\n- The constant `ModuleNotFoundError` may be raised when the specified module cannot be found or imported. It serves as a key exception type in the error handling for import failures.\"\"\"\n    if ns is not None and sep not in sym:\n        sym = '{}{}{}'.format(ns, sep, sym)\n    module_path, fn_name = sym.rsplit(sep, 2)\n    try:\n        module = import_module(module_path, here=here, sep=sep, _depth=_depth, cwd=cwd)\n    except (ImportError, ModuleNotFoundError) as e:\n        if not silent:\n            sys.stderr.write('could not import {!r}\\n{}\\n'.format(sym, e))\n        raise\n    try:\n        return getattr(module, fn_name)\n    except AttributeError as e:\n        if not silent:\n            sys.stderr.write('could not import {!r}\\n{}\\n'.format(sym, e))\n        raise ImportError(e)",
        "docstring": "Imports a symbol (attribute or function) from a specified module using a given symbol string. The symbol string can reference modules and their attributes in a flexible format, allowing for namespacing.\n\nParameters:\n- sym (str): The symbol string specifying the module path and the attribute to import, using the specified separator (default is \":\").\n- here (str, optional): The base directory to resolve relative paths from. Defaults to None.\n- sep (str, optional): The separator used in the symbol string to distinguish between the module and the attribute. Defaults to \":\".\n- ns (str, optional): An optional namespace used to modify the symbol string if provided.\n- silent (bool, optional): If True, suppresses error messages to stderr when the import fails. Defaults to False.\n- _depth (int, optional): The stack frame depth to determine the calling module's context. Defaults to 3.\n- cwd (bool, optional): If True, uses the current working directory to help resolve relative imports. Defaults to True.\n\nReturns:\n- The requested attribute from the module if found; otherwise, raises ImportError.\n\nInteractions:\n- Utilizes `import_module` function to load the module specified by the symbol string. This function handles both local and standard imports.\n- The constant `ModuleNotFoundError` may be raised when the specified module cannot be found or imported. It serves as a key exception type in the error handling for import failures.",
        "signature": "def import_symbol(sym, here=None, sep=':', ns=None, silent=False, _depth=3, cwd=True):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "magicalimport/__init__.py:import_module": {
      "magicalimport/__init__.py": {
        "import_from_physical_path": {
          "code": "def import_from_physical_path(path, as_=None, here=None, _depth=1, cwd=True):\n    global _FAILED\n    if here is None:\n        if cwd:\n            here = os.getcwd()\n        elif _depth > 0:\n            frame = sys._getframe(_depth)\n            here = frame.f_globals['__file__']\n        else:\n            raise ValueError('invalid option found _depth={}, cwd={}'.format(_depth, cwd))\n    if here is not None:\n        here = here if os.path.isdir(here) else os.path.dirname(here)\n        here = os.path.abspath(here)\n        path = os.path.join(here, path)\n    path = os.path.normpath(os.path.abspath(path))\n    module_id = as_ or _module_id_from_path(path)\n    if module_id in sys.modules:\n        return sys.modules[module_id]\n    guess_path = path.replace('/__init__.py', '')\n    if as_ is None:\n        for sys_path in sys.path:\n            if not guess_path.startswith(sys_path):\n                continue\n            guessed_module = guess_path[len(sys_path):].lstrip('/').rsplit('.py', 1)[0].replace('/', '.')\n            if guessed_module in _FAILED:\n                continue\n            try:\n                m = import_module_original(guessed_module)\n                return m\n            except ModuleNotFoundError:\n                _FAILED.add(guessed_module)\n            except ImportError as e:\n                if ImportError.__module__ != ModuleNotFoundError.__module__:\n                    if str(e).startswith('No module named'):\n                        _FAILED.add(guessed_module)\n                        continue\n                raise\n    if '.' in module_id and as_ is None:\n        parent_module_id = module_id.rsplit('.')[0]\n        if parent_module_id not in sys.modules:\n            init_py = os.path.join(os.path.dirname(path), '__init__.py')\n            if os.path.exists(init_py):\n                _create_module(parent_module_id, init_py)\n            else:\n                try:\n                    with open(init_py, 'w'):\n                        pass\n                    _create_module(parent_module_id, init_py)\n                except PermissionError as e:\n                    module_id = module_id.replace('.', '_')\n                    logger.warn('open %s, cannot accessable (%r). new module_id is %r', init_py, e, module_id)\n    try:\n        return _create_module(module_id, path)\n    except (FileNotFoundError, OSError) as e:\n        raise ModuleNotFoundError(e)",
          "docstring": "",
          "signature": "def import_from_physical_path(path, as_=None, here=None, _depth=1, cwd=True):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "magicalimport/__init__.py:import_symbol": {}
  },
  "PRD": "# PROJECT NAME: magicalimport-test_notfound\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 magicalimport/\n    \u2514\u2500\u2500 __init__.py\n        \u251c\u2500\u2500 import_module\n        \u2514\u2500\u2500 import_symbol\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates dynamic importing of Python modules and symbols at runtime, offering a streamlined mechanism to handle module dependencies in a flexible and adaptive manner. It provides capabilities for importing entire modules or specific symbols by specifying file paths or module names, with added robustness through its ability to gracefully handle missing modules, files, or symbols by raising clear exceptions. This solves a critical problem for developers by enabling dynamic imports in scenarios where module paths or dependencies are not statically known, improving modularity and reducing boilerplate code in applications that require runtime flexibility or plugin-based architectures.\n\n## FILE 1: magicalimport/__init__.py\n\n- FUNCTION NAME: import_symbol\n  - SIGNATURE: def import_symbol(sym, here=None, sep=':', ns=None, silent=False, _depth=3, cwd=True):\n  - DOCSTRING: \n```python\n\"\"\"\nImports a symbol (attribute or function) from a specified module using a given symbol string. The symbol string can reference modules and their attributes in a flexible format, allowing for namespacing.\n\nParameters:\n- sym (str): The symbol string specifying the module path and the attribute to import, using the specified separator (default is \":\").\n- here (str, optional): The base directory to resolve relative paths from. Defaults to None.\n- sep (str, optional): The separator used in the symbol string to distinguish between the module and the attribute. Defaults to \":\".\n- ns (str, optional): An optional namespace used to modify the symbol string if provided.\n- silent (bool, optional): If True, suppresses error messages to stderr when the import fails. Defaults to False.\n- _depth (int, optional): The stack frame depth to determine the calling module's context. Defaults to 3.\n- cwd (bool, optional): If True, uses the current working directory to help resolve relative imports. Defaults to True.\n\nReturns:\n- The requested attribute from the module if found; otherwise, raises ImportError.\n\nInteractions:\n- Utilizes `import_module` function to load the module specified by the symbol string. This function handles both local and standard imports.\n- The constant `ModuleNotFoundError` may be raised when the specified module cannot be found or imported. It serves as a key exception type in the error handling for import failures.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - magicalimport/__init__.py:import_module\n\n- FUNCTION NAME: import_module\n  - SIGNATURE: def import_module(module_path, here=None, sep=':', _depth=2, cwd=True):\n  - DOCSTRING: \n```python\n\"\"\"\nImports a Python module from a specified path. If the path points to a Python file (.py), it uses the `import_from_physical_path` function to load the module from its physical location. If the path does not have a .py extension, it tries to import the module using the original import mechanism. \n\nParameters:\n- module_path (str): The path to the module to be imported, which can be a relative or absolute path.\n- here (str, optional): The directory from which to resolve the module path. If not provided, the current working directory or the caller's file path will be used, depending on the value of `cwd`.\n- sep (str, optional): The separator used to distinguish between the module and the component names in the module path (default is ':').\n- _depth (int, optional): The stack depth to determine the calling frame for the `here` path (default is 2).\n- cwd (bool, optional): A flag indicating whether to use the current working directory if `here` is not provided (default is True).\n\nReturns:\n- Module: The imported module object.\n\nRaises:\n- ModuleNotFoundError: If the module cannot be found or imported, including due to an ImportError.\n\nDependencies:\n- The function utilizes `import_from_physical_path` for file-based imports and `import_module_original` for standard module imports. It also utilizes a logger to provide debug information when modules are imported.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - magicalimport/__init__.py:import_from_physical_path\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "magicalimport/__init__.py": "import logging\nimport os.path\nimport sys\nfrom magicalimport.compat import ModuleNotFoundError\nfrom magicalimport.compat import FileNotFoundError\nfrom magicalimport.compat import _create_module\nfrom magicalimport.compat import import_module as import_module_original\nlogger = logging.getLogger(__name__)\n\ndef expose_all_members(module, globals_=None, _depth=2):\n    members = {k: v for k, v in module.__dict__.items() if not k.startswith('_')}\n    return expose_members(module, members, globals_=globals_, _depth=_depth)\n\ndef expose_members(module, members, globals_=None, _depth=1):\n    if globals_ is None:\n        frame = sys._getframe(_depth)\n        globals_ = frame.f_globals\n    globals_.update({k: module.__dict__[k] for k in members})\n    return globals_\n\ndef _module_id_from_path(path):\n    logger.debug('\\t-> %s (path)', path)\n    dirname = os.path.dirname(path)\n    basename = os.path.basename(path)\n    module_id = '{}.{}'.format(dirname.replace('/', '_'), basename.rsplit('.py', 1)[0])\n    logger.debug('\\t<- %s (module_id)', module_id)\n    return module_id\n_FAILED = set()\n\ndef import_from_physical_path(path, as_=None, here=None, _depth=1, cwd=True):\n    global _FAILED\n    if here is None:\n        if cwd:\n            here = os.getcwd()\n        elif _depth > 0:\n            frame = sys._getframe(_depth)\n            here = frame.f_globals['__file__']\n        else:\n            raise ValueError('invalid option found _depth={}, cwd={}'.format(_depth, cwd))\n    if here is not None:\n        here = here if os.path.isdir(here) else os.path.dirname(here)\n        here = os.path.abspath(here)\n        path = os.path.join(here, path)\n    path = os.path.normpath(os.path.abspath(path))\n    module_id = as_ or _module_id_from_path(path)\n    if module_id in sys.modules:\n        return sys.modules[module_id]\n    guess_path = path.replace('/__init__.py', '')\n    if as_ is None:\n        for sys_path in sys.path:\n            if not guess_path.startswith(sys_path):\n                continue\n            guessed_module = guess_path[len(sys_path):].lstrip('/').rsplit('.py', 1)[0].replace('/', '.')\n            if guessed_module in _FAILED:\n                continue\n            try:\n                m = import_module_original(guessed_module)\n                return m\n            except ModuleNotFoundError:\n                _FAILED.add(guessed_module)\n            except ImportError as e:\n                if ImportError.__module__ != ModuleNotFoundError.__module__:\n                    if str(e).startswith('No module named'):\n                        _FAILED.add(guessed_module)\n                        continue\n                raise\n    if '.' in module_id and as_ is None:\n        parent_module_id = module_id.rsplit('.')[0]\n        if parent_module_id not in sys.modules:\n            init_py = os.path.join(os.path.dirname(path), '__init__.py')\n            if os.path.exists(init_py):\n                _create_module(parent_module_id, init_py)\n            else:\n                try:\n                    with open(init_py, 'w'):\n                        pass\n                    _create_module(parent_module_id, init_py)\n                except PermissionError as e:\n                    module_id = module_id.replace('.', '_')\n                    logger.warn('open %s, cannot accessable (%r). new module_id is %r', init_py, e, module_id)\n    try:\n        return _create_module(module_id, path)\n    except (FileNotFoundError, OSError) as e:\n        raise ModuleNotFoundError(e)"
  },
  "call_tree": {
    "magicalimport/tests/test_notfound.py:ImportModuleTests:test_target_file_is_notfound": {
      "magicalimport/tests/test_notfound.py:ImportModuleTests:_callFUT": {
        "magicalimport/__init__.py:import_module": {
          "magicalimport/__init__.py:import_from_physical_path": {
            "magicalimport/__init__.py:_module_id_from_path": {},
            "magicalimport/compat.py:_create_module": {}
          }
        }
      }
    },
    "magicalimport/tests/test_notfound.py:ImportModuleTests:test_target_module_is_notfound": {
      "magicalimport/tests/test_notfound.py:ImportModuleTests:_callFUT": {
        "magicalimport/__init__.py:import_module": {}
      }
    },
    "magicalimport/tests/test_notfound.py:ImportSymbolTests:test_target_file_has_not_member": {
      "magicalimport/tests/test_notfound.py:ImportSymbolTests:_callFUT": {
        "magicalimport/__init__.py:import_symbol": {
          "magicalimport/__init__.py:import_module": {
            "magicalimport/__init__.py:import_from_physical_path": {
              "magicalimport/__init__.py:_module_id_from_path": {}
            }
          }
        }
      }
    },
    "magicalimport/tests/test_notfound.py:ImportSymbolTests:test_target_file_is_notfound": {
      "magicalimport/tests/test_notfound.py:ImportSymbolTests:_callFUT": {
        "magicalimport/__init__.py:import_symbol": {
          "magicalimport/__init__.py:import_module": {
            "magicalimport/__init__.py:import_from_physical_path": {
              "magicalimport/__init__.py:_module_id_from_path": {},
              "magicalimport/compat.py:_create_module": {}
            }
          }
        }
      }
    },
    "magicalimport/tests/test_notfound.py:ImportSymbolTests:test_target_module_has_not_member": {
      "magicalimport/tests/test_notfound.py:ImportSymbolTests:_callFUT": {
        "magicalimport/__init__.py:import_symbol": {
          "magicalimport/__init__.py:import_module": {}
        }
      }
    },
    "magicalimport/tests/test_notfound.py:ImportSymbolTests:test_target_module_is_notfound": {
      "magicalimport/tests/test_notfound.py:ImportSymbolTests:_callFUT": {
        "magicalimport/__init__.py:import_symbol": {
          "magicalimport/__init__.py:import_module": {}
        }
      }
    }
  }
}