{
  "dir_path": "/app/python_string_utils",
  "package_name": "python_string_utils",
  "sample_name": "python_string_utils-test_random_string",
  "src_dir": "string_utils/",
  "test_dir": "tests/",
  "test_file": "tests/test_random_string.py",
  "test_code": "from unittest import TestCase\n\nfrom string_utils.generation import random_string\n\n\nclass RandomStringTestCase(TestCase):\n    def test_throws_error_if_size_is_null(self):\n        with self.assertRaises(ValueError) as raised:\n            # noinspection PyTypeChecker\n            random_string(None)\n\n        self.assertEqual(str(raised.exception), 'size must be >= 1')\n\n    def test_throws_error_if_size_is_less_than_1(self):\n        msg = 'size must be >= 1'\n\n        with self.assertRaises(ValueError) as raised:\n            random_string(-12)\n\n        self.assertEqual(str(raised.exception), msg)\n\n        with self.assertRaises(ValueError) as raised:\n            random_string(0)\n\n        self.assertEqual(str(raised.exception), msg)\n\n    def test_returns_string_of_the_desired_size(self):\n        rs1 = random_string(2)\n        self.assertEqual(len(rs1), 2)\n        self.assertTrue(rs1.isalnum())\n\n        rs2 = random_string(9)\n        self.assertEqual(len(rs2), 9)\n        self.assertTrue(rs2.isalnum())\n\n        rs3 = random_string(36)\n        self.assertEqual(len(rs3), 36)\n        self.assertTrue(rs3.isalnum())\n\n    def test_returns_different_string_at_each_call(self):\n        count = 1000\n        strings = [random_string(9) for _ in range(count)]\n\n        self.assertEqual(len(strings), count)\n        self.assertEqual(len(set(strings)), count)\n",
  "GT_file_code": {
    "string_utils/generation.py": "# -*- coding: utf-8 -*-\n\n# public api to export\n__all__ = [\n    'uuid',\n    'random_string',\n    'secure_random_hex',\n    'roman_range',\n]\n\nimport binascii\nimport os\nimport random\nimport string\nfrom typing import Generator\nfrom uuid import uuid4\n\nfrom .manipulation import roman_encode\n\n\ndef uuid(as_hex: bool = False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n\n    if as_hex:\n        return uid.hex\n\n    return str(uid)\n\n\ndef random_string(size: int) -> str:\n    \"\"\"\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\n\n    *Example:*\n\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\n\n    :param size: Desired string size\n    :type size: int\n    :return: Random string\n    \"\"\"\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n\n    return out\n\n\ndef secure_random_hex(byte_count: int) -> str:\n    \"\"\"\n    Generates a random string using secure low level random generator (os.urandom).\n\n    **Bear in mind**: due to hex conversion, the returned string will have a size that is exactly\\\n    the double of the given `byte_count`.\n\n    *Example:*\n\n    >>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n    :param byte_count: Number of random bytes to generate\n    :type byte_count: int\n    :return: Hexadecimal string representation of generated random bytes\n    \"\"\"\n    if not isinstance(byte_count, int) or byte_count < 1:\n        raise ValueError('byte_count must be >= 1')\n\n    random_bytes = os.urandom(byte_count)\n    hex_bytes = binascii.hexlify(random_bytes)\n    hex_string = hex_bytes.decode()\n\n    return hex_string\n\n\ndef roman_range(stop: int, start: int = 1, step: int = 1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n\n    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n\n        if allow_negative:\n            arg_value = abs(arg_value)\n\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)\n\n    def generate():\n        current = start\n\n        # generate values for each step\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n\n        # last value to return\n        yield roman_encode(current)\n\n    # checks each single argument value\n    validate(stop, 'stop')\n    validate(start, 'start')\n    validate(step, 'step', allow_negative=True)\n\n    # checks if the provided configuration leads to a feasible iteration with respect to boundaries or not\n    forward_exceed = step > 0 and (start > stop or start + step > stop)\n    backward_exceed = step < 0 and (start < stop or start + step < stop)\n    if forward_exceed or backward_exceed:\n        raise OverflowError('Invalid start/stop/step configuration')\n\n    return generate()\n"
  },
  "GT_src_dict": {
    "string_utils/generation.py": {
      "random_string": {
        "code": "def random_string(size: int) -> str:\n    \"\"\"Generates a random string of specified size containing a mix of uppercase letters, lowercase letters, and digits.\n\n:param size: The desired length of the random string, must be an integer greater than or equal to 1.\n:type size: int\n:raises ValueError: If `size` is not an integer or is less than 1.\n:return: A string comprised of randomly selected characters from the set of ASCII letters and digits.\n\nDependencies:\n- Utilizes the `string` module to access `ascii_letters` (which includes both uppercase and lowercase letters) and the `digits` (which includes numeric characters).\n- Uses the `random.choice()` method to select characters randomly from the combined character set.\"\"\"\n    '\\n    Returns a string of the specified size containing random characters (uppercase/lowercase ascii letters and digits).\\n\\n    *Example:*\\n\\n    >>> random_string(9) # possible output: \"cx3QQbzYg\"\\n\\n    :param size: Desired string size\\n    :type size: int\\n    :return: Random string\\n    '\n    if not isinstance(size, int) or size < 1:\n        raise ValueError('size must be >= 1')\n    chars = string.ascii_letters + string.digits\n    buffer = [random.choice(chars) for _ in range(size)]\n    out = ''.join(buffer)\n    return out",
        "docstring": "Generates a random string of specified size containing a mix of uppercase letters, lowercase letters, and digits.\n\n:param size: The desired length of the random string, must be an integer greater than or equal to 1.\n:type size: int\n:raises ValueError: If `size` is not an integer or is less than 1.\n:return: A string comprised of randomly selected characters from the set of ASCII letters and digits.\n\nDependencies:\n- Utilizes the `string` module to access `ascii_letters` (which includes both uppercase and lowercase letters) and the `digits` (which includes numeric characters).\n- Uses the `random.choice()` method to select characters randomly from the combined character set.",
        "signature": "def random_string(size: int) -> str:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: python_string_utils-test_random_string\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 string_utils/\n    \u2514\u2500\u2500 generation.py\n        \u2514\u2500\u2500 random_string\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate and ensure the reliability of the `random_string` function, which generates alphanumeric strings of a specified length. It provides functionality for verifying that the function enforces input constraints, such as rejecting invalid sizes (e.g., null or non-positive values), while ensuring the generated strings meet the desired length and contain alphanumeric characters. Additionally, it tests the randomness of the output by confirming that multiple calls produce unique results, preventing collisions under high usage. By rigorously testing these behaviors, the module ensures the robustness and correctness of the `random_string` utility, solving potential issues for developers relying on it to generate unique identifiers, random tokens, or similar alphanumeric data.\n\n## FILE 1: string_utils/generation.py\n\n- FUNCTION NAME: random_string\n  - SIGNATURE: def random_string(size: int) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerates a random string of specified size containing a mix of uppercase letters, lowercase letters, and digits.\n\n:param size: The desired length of the random string, must be an integer greater than or equal to 1.\n:type size: int\n:raises ValueError: If `size` is not an integer or is less than 1.\n:return: A string comprised of randomly selected characters from the set of ASCII letters and digits.\n\nDependencies:\n- Utilizes the `string` module to access `ascii_letters` (which includes both uppercase and lowercase letters) and the `digits` (which includes numeric characters).\n- Uses the `random.choice()` method to select characters randomly from the combined character set.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "string_utils/generation.py": "__all__ = ['uuid', 'random_string', 'secure_random_hex', 'roman_range']\nimport binascii\nimport os\nimport random\nimport string\nfrom typing import Generator\nfrom uuid import uuid4\nfrom .manipulation import roman_encode\n\ndef uuid(as_hex: bool=False) -> str:\n    \"\"\"\n    Generated an UUID string (using `uuid.uuid4()`).\n\n    *Examples:*\n\n    >>> uuid() # possible output: '97e3a716-6b33-4ab9-9bb1-8128cb24d76b'\n    >>> uuid(as_hex=True) # possible output: '97e3a7166b334ab99bb18128cb24d76b'\n\n    :param as_hex: True to return the hex value of the UUID, False to get its default representation (default).\n    :return: uuid string.\n    \"\"\"\n    uid = uuid4()\n    if as_hex:\n        return uid.hex\n    return str(uid)\n\ndef secure_random_hex(byte_count: int) -> str:\n    \"\"\"\n    Generates a random string using secure low level random generator (os.urandom).\n\n    **Bear in mind**: due to hex conversion, the returned string will have a size that is exactly    the double of the given `byte_count`.\n\n    *Example:*\n\n    >>> secure_random_hex(9) # possible output: 'aac4cf1d1d87bd5036'\n\n    :param byte_count: Number of random bytes to generate\n    :type byte_count: int\n    :return: Hexadecimal string representation of generated random bytes\n    \"\"\"\n    if not isinstance(byte_count, int) or byte_count < 1:\n        raise ValueError('byte_count must be >= 1')\n    random_bytes = os.urandom(byte_count)\n    hex_bytes = binascii.hexlify(random_bytes)\n    hex_string = hex_bytes.decode()\n    return hex_string\n\ndef roman_range(stop: int, start: int=1, step: int=1) -> Generator:\n    \"\"\"\n    Similarly to native Python's `range()`, returns a Generator object which generates a new roman number\n    on each iteration instead of an integer.\n\n    *Example:*\n\n    >>> for n in roman_range(7): print(n)\n    >>> # prints: I, II, III, IV, V, VI, VII\n    >>> for n in roman_range(start=7, stop=1, step=-1): print(n)\n    >>> # prints: VII, VI, V, IV, III, II, I\n\n    :param stop: Number at which the generation must stop (must be <= 3999).\n    :param start: Number at which the generation must start (must be >= 1).\n    :param step: Increment of each generation step (default to 1).\n    :return: Generator of roman numbers.\n    \"\"\"\n\n    def validate(arg_value, arg_name, allow_negative=False):\n        msg = '\"{}\" must be an integer in the range 1-3999'.format(arg_name)\n        if not isinstance(arg_value, int):\n            raise ValueError(msg)\n        if allow_negative:\n            arg_value = abs(arg_value)\n        if arg_value < 1 or arg_value > 3999:\n            raise ValueError(msg)\n\n    def generate():\n        current = start\n        while current != stop:\n            yield roman_encode(current)\n            current += step\n        yield roman_encode(current)\n    validate(stop, 'stop')\n    validate(start, 'start')\n    validate(step, 'step', allow_negative=True)\n    forward_exceed = step > 0 and (start > stop or start + step > stop)\n    backward_exceed = step < 0 and (start < stop or start + step < stop)\n    if forward_exceed or backward_exceed:\n        raise OverflowError('Invalid start/stop/step configuration')\n    return generate()"
  },
  "call_tree": {
    "tests/test_random_string.py:RandomStringTestCase:test_returns_different_string_at_each_call": {
      "string_utils/generation.py:random_string": {}
    },
    "tests/test_random_string.py:RandomStringTestCase:test_returns_string_of_the_desired_size": {
      "string_utils/generation.py:random_string": {}
    },
    "tests/test_random_string.py:RandomStringTestCase:test_throws_error_if_size_is_less_than_1": {
      "string_utils/generation.py:random_string": {}
    },
    "tests/test_random_string.py:RandomStringTestCase:test_throws_error_if_size_is_null": {
      "string_utils/generation.py:random_string": {}
    }
  }
}