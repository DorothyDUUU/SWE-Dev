{
  "dir_path": "/app/uvicorn",
  "package_name": "uvicorn",
  "sample_name": "uvicorn-test_utils",
  "src_dir": "uvicorn/",
  "test_dir": "tests/",
  "test_file": "tests/protocols/test_utils.py",
  "test_code": "from __future__ import annotations\n\nimport socket\nfrom asyncio import Transport\nfrom typing import Any\n\nimport pytest\n\nfrom uvicorn.protocols.utils import get_client_addr, get_local_addr, get_remote_addr\n\n\nclass MockSocket:\n    def __init__(self, family, peername=None, sockname=None):\n        self.peername = peername\n        self.sockname = sockname\n        self.family = family\n\n    def getpeername(self):\n        return self.peername\n\n    def getsockname(self):\n        return self.sockname\n\n\nclass MockTransport(Transport):\n    def __init__(self, info: dict[str, Any]) -> None:\n        self.info = info\n\n    def get_extra_info(self, name: str, default: Any = None) -> Any:\n        return self.info.get(name)\n\n\ndef test_get_local_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, sockname=(\"::1\", 123))})\n    assert get_local_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, sockname=(\"123.45.6.7\", 123))})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, sockname=(\"127.0.0.1\", 8000))})\n        assert get_local_addr(transport) == (\"127.0.0.1\", 8000)\n\n\ndef test_get_remote_addr_with_socket():\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_IPX)})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET6, peername=(\"::1\", 123))})\n    assert get_remote_addr(transport) == (\"::1\", 123)\n\n    transport = MockTransport({\"socket\": MockSocket(family=socket.AF_INET, peername=(\"123.45.6.7\", 123))})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)\n\n    if hasattr(socket, \"AF_UNIX\"):  # pragma: no cover\n        transport = MockTransport({\"socket\": MockSocket(family=socket.AF_UNIX, peername=(\"127.0.0.1\", 8000))})\n        assert get_remote_addr(transport) == (\"127.0.0.1\", 8000)\n\n\ndef test_get_local_addr():\n    transport = MockTransport({\"sockname\": \"path/to/unix-domain-socket\"})\n    assert get_local_addr(transport) is None\n\n    transport = MockTransport({\"sockname\": (\"123.45.6.7\", 123)})\n    assert get_local_addr(transport) == (\"123.45.6.7\", 123)\n\n\ndef test_get_remote_addr():\n    transport = MockTransport({\"peername\": None})\n    assert get_remote_addr(transport) is None\n\n    transport = MockTransport({\"peername\": (\"123.45.6.7\", 123)})\n    assert get_remote_addr(transport) == (\"123.45.6.7\", 123)\n\n\n@pytest.mark.parametrize(\n    \"scope, expected_client\",\n    [({\"client\": (\"127.0.0.1\", 36000)}, \"127.0.0.1:36000\"), ({\"client\": None}, \"\")],\n    ids=[\"ip:port client\", \"None client\"],\n)\ndef test_get_client_addr(scope, expected_client):\n    assert get_client_addr(scope) == expected_client\n",
  "GT_file_code": {
    "uvicorn/protocols/utils.py": "from __future__ import annotations\n\nimport asyncio\nimport urllib.parse\n\nfrom uvicorn._types import WWWScope\n\n\nclass ClientDisconnected(OSError): ...\n\n\ndef get_remote_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        try:\n            info = socket_info.getpeername()\n            return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n        except OSError:  # pragma: no cover\n            # This case appears to inconsistently occur with uvloop\n            # bound to a unix domain socket.\n            return None\n\n    info = transport.get_extra_info(\"peername\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None\n\n\ndef get_local_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    socket_info = transport.get_extra_info(\"socket\")\n    if socket_info is not None:\n        info = socket_info.getsockname()\n\n        return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n    info = transport.get_extra_info(\"sockname\")\n    if info is not None and isinstance(info, (list, tuple)) and len(info) == 2:\n        return (str(info[0]), int(info[1]))\n    return None\n\n\ndef is_ssl(transport: asyncio.Transport) -> bool:\n    return bool(transport.get_extra_info(\"sslcontext\"))\n\n\ndef get_client_addr(scope: WWWScope) -> str:\n    client = scope.get(\"client\")\n    if not client:\n        return \"\"\n    return \"%s:%d\" % client\n\n\ndef get_path_with_query_string(scope: WWWScope) -> str:\n    path_with_query_string = urllib.parse.quote(scope[\"path\"])\n    if scope[\"query_string\"]:\n        path_with_query_string = \"{}?{}\".format(path_with_query_string, scope[\"query_string\"].decode(\"ascii\"))\n    return path_with_query_string\n"
  },
  "GT_src_dict": {
    "uvicorn/protocols/utils.py": {
      "get_remote_addr": {
        "code": "def get_remote_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    \"\"\"Retrieve the remote address (IP and port) of a given asyncio transport.\n\nParameters:\n- transport (asyncio.Transport): The transport object from which to obtain the remote address. It should represent a connection to a client.\n\nReturns:\n- tuple[str, int] | None: A tuple containing the remote IP address as a string and the port number as an integer. Returns None if the remote address cannot be determined, either due to an OSError or if the transport does not provide valid socket information.\n\nNotes:\n- The function first attempts to use the `get_extra_info(\"socket\")` method to access the underlying socket, then calls `getpeername()` to obtain the remote address.\n- If that fails, it falls back to using `get_extra_info(\"peername\")`, expecting the result to be in a list or tuple of length 2.\n- It's important to handle cases where information may not be available, specifically with regard to the async event loop used (like uvloop) which may cause inconsistencies.\"\"\"\n    socket_info = transport.get_extra_info('socket')\n    if socket_info is not None:\n        try:\n            info = socket_info.getpeername()\n            return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n        except OSError:\n            return None\n    info = transport.get_extra_info('peername')\n    if info is not None and isinstance(info, (list, tuple)) and (len(info) == 2):\n        return (str(info[0]), int(info[1]))\n    return None",
        "docstring": "Retrieve the remote address (IP and port) of a given asyncio transport.\n\nParameters:\n- transport (asyncio.Transport): The transport object from which to obtain the remote address. It should represent a connection to a client.\n\nReturns:\n- tuple[str, int] | None: A tuple containing the remote IP address as a string and the port number as an integer. Returns None if the remote address cannot be determined, either due to an OSError or if the transport does not provide valid socket information.\n\nNotes:\n- The function first attempts to use the `get_extra_info(\"socket\")` method to access the underlying socket, then calls `getpeername()` to obtain the remote address.\n- If that fails, it falls back to using `get_extra_info(\"peername\")`, expecting the result to be in a list or tuple of length 2.\n- It's important to handle cases where information may not be available, specifically with regard to the async event loop used (like uvloop) which may cause inconsistencies.",
        "signature": "def get_remote_addr(transport: asyncio.Transport) -> tuple[str, int] | None:",
        "type": "Function",
        "class_signature": null
      },
      "get_local_addr": {
        "code": "def get_local_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n    \"\"\"Retrieves the local address associated with the given asyncio transport.\n\nParameters:\n- transport (asyncio.Transport): The transport for which to obtain the local address. This transport instance provides methods to access underlying socket information.\n\nReturns:\n- tuple[str, int] | None: A tuple containing the local IP address as a string and the local port as an integer, or None if the information cannot be retrieved.\n\nThis function first attempts to get the socket information using the `get_extra_info(\"socket\")` method. If successful, it retrieves the local socket name using `getsockname()`. If that fails or if the socket information is not available, it attempts to use `get_extra_info(\"sockname\")`. The function ensures that the information returned is valid and correctly formatted.\"\"\"\n    socket_info = transport.get_extra_info('socket')\n    if socket_info is not None:\n        info = socket_info.getsockname()\n        return (str(info[0]), int(info[1])) if isinstance(info, tuple) else None\n    info = transport.get_extra_info('sockname')\n    if info is not None and isinstance(info, (list, tuple)) and (len(info) == 2):\n        return (str(info[0]), int(info[1]))\n    return None",
        "docstring": "Retrieves the local address associated with the given asyncio transport.\n\nParameters:\n- transport (asyncio.Transport): The transport for which to obtain the local address. This transport instance provides methods to access underlying socket information.\n\nReturns:\n- tuple[str, int] | None: A tuple containing the local IP address as a string and the local port as an integer, or None if the information cannot be retrieved.\n\nThis function first attempts to get the socket information using the `get_extra_info(\"socket\")` method. If successful, it retrieves the local socket name using `getsockname()`. If that fails or if the socket information is not available, it attempts to use `get_extra_info(\"sockname\")`. The function ensures that the information returned is valid and correctly formatted.",
        "signature": "def get_local_addr(transport: asyncio.Transport) -> tuple[str, int] | None:",
        "type": "Function",
        "class_signature": null
      },
      "get_client_addr": {
        "code": "def get_client_addr(scope: WWWScope) -> str:\n    \"\"\"Retrieves the client address from the provided `scope` dictionary.\n\nParameters:\n- scope (WWWScope): A dictionary-like object representing the request context, specifically expected to contain a key \"client\" with the client's address.\n\nReturns:\n- str: A string in the format \"IP:port\" representing the client's address if found; otherwise, an empty string.\n\nThis function interacts with the `scope` defined within the context of the `uvicorn` web server, which utilizes the `WWWScope` type. The expected \"client\" key should correspond to the client's address information as part of the request handling process.\"\"\"\n    client = scope.get('client')\n    if not client:\n        return ''\n    return '%s:%d' % client",
        "docstring": "Retrieves the client address from the provided `scope` dictionary.\n\nParameters:\n- scope (WWWScope): A dictionary-like object representing the request context, specifically expected to contain a key \"client\" with the client's address.\n\nReturns:\n- str: A string in the format \"IP:port\" representing the client's address if found; otherwise, an empty string.\n\nThis function interacts with the `scope` defined within the context of the `uvicorn` web server, which utilizes the `WWWScope` type. The expected \"client\" key should correspond to the client's address information as part of the request handling process.",
        "signature": "def get_client_addr(scope: WWWScope) -> str:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "uvicorn/protocols/utils.py:get_local_addr": {
      "tests/protocols/test_utils.py": {
        "MockSocket.getsockname": {
          "code": "    def getsockname(self):\n        return self.sockname",
          "docstring": "",
          "signature": "def getsockname(self):",
          "type": "Method",
          "class_signature": "class MockSocket:"
        },
        "MockTransport.get_extra_info": {
          "code": "    def get_extra_info(self, name: str, default: Any = None) -> Any:\n        return self.info.get(name)",
          "docstring": "",
          "signature": "def get_extra_info(self, name: str, default: Any=None) -> Any:",
          "type": "Method",
          "class_signature": "class MockTransport(Transport):"
        }
      }
    },
    "uvicorn/protocols/utils.py:get_remote_addr": {
      "tests/protocols/test_utils.py": {
        "MockSocket.getpeername": {
          "code": "    def getpeername(self):\n        return self.peername",
          "docstring": "",
          "signature": "def getpeername(self):",
          "type": "Method",
          "class_signature": "class MockSocket:"
        },
        "MockTransport.get_extra_info": {
          "code": "    def get_extra_info(self, name: str, default: Any = None) -> Any:\n        return self.info.get(name)",
          "docstring": "",
          "signature": "def get_extra_info(self, name: str, default: Any=None) -> Any:",
          "type": "Method",
          "class_signature": "class MockTransport(Transport):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: uvicorn-test_utils\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 uvicorn/\n    \u2514\u2500\u2500 protocols/\n        \u2514\u2500\u2500 utils.py\n            \u251c\u2500\u2500 get_client_addr\n            \u251c\u2500\u2500 get_local_addr\n            \u2514\u2500\u2500 get_remote_addr\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module facilitates the retrieval of network address information by providing utility functions to extract local and remote addresses from transport or socket objects, as well as client address details from request scopes. Its core functionality is centered around determining and standardizing address data, such as IP address and port, for various socket families, including IPv4, IPv6, and Unix domain sockets. By abstracting the complexities of accessing address information from low-level transport or socket attributes, the module simplifies address handling, reduces implementation overhead, and ensures consistent integration with networking components. This enables developers to efficiently manage connection details in server and client applications.\n\n## FILE 1: uvicorn/protocols/utils.py\n\n- FUNCTION NAME: get_remote_addr\n  - SIGNATURE: def get_remote_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the remote address (IP and port) of a given asyncio transport.\n\nParameters:\n- transport (asyncio.Transport): The transport object from which to obtain the remote address. It should represent a connection to a client.\n\nReturns:\n- tuple[str, int] | None: A tuple containing the remote IP address as a string and the port number as an integer. Returns None if the remote address cannot be determined, either due to an OSError or if the transport does not provide valid socket information.\n\nNotes:\n- The function first attempts to use the `get_extra_info(\"socket\")` method to access the underlying socket, then calls `getpeername()` to obtain the remote address.\n- If that fails, it falls back to using `get_extra_info(\"peername\")`, expecting the result to be in a list or tuple of length 2.\n- It's important to handle cases where information may not be available, specifically with regard to the async event loop used (like uvloop) which may cause inconsistencies.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/protocols/test_utils.py:MockTransport:get_extra_info\n    - tests/protocols/test_utils.py:MockSocket:getpeername\n\n- FUNCTION NAME: get_client_addr\n  - SIGNATURE: def get_client_addr(scope: WWWScope) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the client address from the provided `scope` dictionary.\n\nParameters:\n- scope (WWWScope): A dictionary-like object representing the request context, specifically expected to contain a key \"client\" with the client's address.\n\nReturns:\n- str: A string in the format \"IP:port\" representing the client's address if found; otherwise, an empty string.\n\nThis function interacts with the `scope` defined within the context of the `uvicorn` web server, which utilizes the `WWWScope` type. The expected \"client\" key should correspond to the client's address information as part of the request handling process.\n\"\"\"\n```\n\n- FUNCTION NAME: get_local_addr\n  - SIGNATURE: def get_local_addr(transport: asyncio.Transport) -> tuple[str, int] | None:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieves the local address associated with the given asyncio transport.\n\nParameters:\n- transport (asyncio.Transport): The transport for which to obtain the local address. This transport instance provides methods to access underlying socket information.\n\nReturns:\n- tuple[str, int] | None: A tuple containing the local IP address as a string and the local port as an integer, or None if the information cannot be retrieved.\n\nThis function first attempts to get the socket information using the `get_extra_info(\"socket\")` method. If successful, it retrieves the local socket name using `getsockname()`. If that fails or if the socket information is not available, it attempts to use `get_extra_info(\"sockname\")`. The function ensures that the information returned is valid and correctly formatted.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/protocols/test_utils.py:MockTransport:get_extra_info\n    - tests/protocols/test_utils.py:MockSocket:getsockname\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "uvicorn/protocols/utils.py": "from __future__ import annotations\nimport asyncio\nimport urllib.parse\nfrom uvicorn._types import WWWScope\n\nclass ClientDisconnected(OSError):\n    ...\n\ndef is_ssl(transport: asyncio.Transport) -> bool:\n    return bool(transport.get_extra_info('sslcontext'))\n\ndef get_path_with_query_string(scope: WWWScope) -> str:\n    path_with_query_string = urllib.parse.quote(scope['path'])\n    if scope['query_string']:\n        path_with_query_string = '{}?{}'.format(path_with_query_string, scope['query_string'].decode('ascii'))\n    return path_with_query_string"
  },
  "call_tree": {
    "tests/protocols/test_utils.py:test_get_local_addr_with_socket": {
      "tests/protocols/test_utils.py:MockSocket:__init__": {},
      "tests/protocols/test_utils.py:MockTransport:__init__": {},
      "uvicorn/protocols/utils.py:get_local_addr": {
        "tests/protocols/test_utils.py:MockTransport:get_extra_info": {},
        "tests/protocols/test_utils.py:MockSocket:getsockname": {}
      }
    },
    "tests/protocols/test_utils.py:test_get_remote_addr_with_socket": {
      "tests/protocols/test_utils.py:MockSocket:__init__": {},
      "tests/protocols/test_utils.py:MockTransport:__init__": {},
      "uvicorn/protocols/utils.py:get_remote_addr": {
        "tests/protocols/test_utils.py:MockTransport:get_extra_info": {},
        "tests/protocols/test_utils.py:MockSocket:getpeername": {}
      }
    },
    "tests/protocols/test_utils.py:test_get_local_addr": {
      "tests/protocols/test_utils.py:MockTransport:__init__": {},
      "uvicorn/protocols/utils.py:get_local_addr": {
        "tests/protocols/test_utils.py:MockTransport:get_extra_info": {}
      }
    },
    "tests/protocols/test_utils.py:test_get_remote_addr": {
      "tests/protocols/test_utils.py:MockTransport:__init__": {},
      "uvicorn/protocols/utils.py:get_remote_addr": {
        "tests/protocols/test_utils.py:MockTransport:get_extra_info": {}
      }
    },
    "tests/protocols/test_utils.py:test_get_client_addr": {
      "uvicorn/protocols/utils.py:get_client_addr": {}
    }
  }
}