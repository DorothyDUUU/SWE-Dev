{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_internal_import",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/type_annotations/test_internal_import.py",
  "test_code": "from mypy_boto3_builder.type_annotations.internal_import import InternalImport\n\n\nclass TestInternalImport:\n    def setup_method(self) -> None:\n        self.result = InternalImport(\"MyClass\")\n\n    def test_init(self) -> None:\n        assert self.result.name == \"MyClass\"\n\n    def test_render(self) -> None:\n        assert self.result.render() == '\"MyClass\"'\n        self.result.stringify = False\n        assert self.result.render() == \"MyClass\"\n        self.result.use_alias = True\n        assert self.result.render() == \"_MyClass\"\n\n    def test_get_import_records(self) -> None:\n        assert len(self.result.get_import_records()) == 0\n\n    def test_copy(self) -> None:\n        assert self.result.copy().name == \"MyClass\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n",
    "mypy_boto3_builder/type_annotations/internal_import.py": "\"\"\"\nWrapper for simple type annotations from this module.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass InternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for simple type annotations from this module.\n\n    Arguments:\n        name -- Import name.\n        service_name -- Service that import belongs to.\n        module_name -- Service module name.\n        stringify -- Convert type annotation to string to avoid circular deps.\n        use_alias -- Use name alias.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        service_name: ServiceName | None = None,\n        module_name: ServiceModuleName = ServiceModuleName.service_resource,\n        *,\n        stringify: bool = True,\n        use_alias: bool = False,\n    ) -> None:\n        self.name: str = name\n        self.service_name: ServiceName | None = service_name\n        self.module_name: ServiceModuleName = module_name\n        self.stringify: bool = stringify\n        self.use_alias: bool = use_alias\n\n    @staticmethod\n    def get_alias(name: str) -> str:\n        \"\"\"\n        Get import name alias.\n\n        Arguments:\n            name -- Original name.\n\n        Returns:\n            Name prefixed with underscore.\n        \"\"\"\n        return f\"_{name}\"\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        result = self.name\n        if self.use_alias:\n            result = self.get_alias(self.name)\n\n        if self.stringify:\n            return f'\"{result}\"'\n\n        return result\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            self.name,\n            self.service_name,\n            self.module_name,\n            use_alias=self.use_alias,\n            stringify=self.stringify,\n        )\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.get_import_records": {
        "code": "    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Get all import records necessary for using the type annotation represented by the instance of the FakeAnnotation subclass. This method calls the protected method `_get_import_records()` to retrieve the initial set of import records. It filters out any records that are considered built-in types using the `is_builtins()` method of the `source` attribute of `ImportRecord`. The return value is a set of `ImportRecord` instances that are not built-in, ensuring only relevant imports are collected for the type annotation.\n\nReturns:\n    set[ImportRecord]: A set of `ImportRecord` objects required for the type annotation, excluding built-in types.\"\"\"\n        '\\n        Get all import records required for using type annotation.\\n        '\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}",
        "docstring": "Get all import records necessary for using the type annotation represented by the instance of the FakeAnnotation subclass. This method calls the protected method `_get_import_records()` to retrieve the initial set of import records. It filters out any records that are considered built-in types using the `is_builtins()` method of the `source` attribute of `ImportRecord`. The return value is a set of `ImportRecord` instances that are not built-in, ensuring only relevant imports are collected for the type annotation.\n\nReturns:\n    set[ImportRecord]: A set of `ImportRecord` objects required for the type annotation, excluding built-in types.",
        "signature": "def get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.copy": {
        "code": "    def copy(self: Self) -> Self:\n        \"\"\"Create a copy of the type annotation wrapper.\n\nThis method utilizes the `copy` module's `copy` function to create a shallow copy of the current instance of the `FakeAnnotation` subclass. It ensures that the copied instance maintains the same state as the original while allowing for modifications to the copy without affecting the original.\n\nReturns:\n    Self: A new instance of the same type as the original `FakeAnnotation`.\n\nDependencies:\n    This method relies on the `copy` module, which is imported at the top of the file, and it overrides the default copying behavior to ensure that the custom attributes of the `FakeAnnotation` subclass, if any, are correctly copied.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return copy.copy(self)",
        "docstring": "Create a copy of the type annotation wrapper.\n\nThis method utilizes the `copy` module's `copy` function to create a shallow copy of the current instance of the `FakeAnnotation` subclass. It ensures that the copied instance maintains the same state as the original while allowing for modifications to the copy without affecting the original.\n\nReturns:\n    Self: A new instance of the same type as the original `FakeAnnotation`.\n\nDependencies:\n    This method relies on the `copy` module, which is imported at the top of the file, and it overrides the default copying behavior to ensure that the custom attributes of the `FakeAnnotation` subclass, if any, are correctly copied.",
        "signature": "def copy(self: Self) -> Self:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    },
    "mypy_boto3_builder/type_annotations/internal_import.py": {
      "InternalImport.__init__": {
        "code": "    def __init__(self, name: str, service_name: ServiceName | None=None, module_name: ServiceModuleName=ServiceModuleName.service_resource, *, stringify: bool=True, use_alias: bool=False) -> None:\n        \"\"\"Initialize an instance of the InternalImport class, which serves as a wrapper for type annotations within the module. This constructor accepts various parameters to specify the name of the import, the associated service name, and the module name, along with options to control stringification and alias usage.\n\nParameters:\n- name (str): The name of the import to be wrapped.\n- service_name (ServiceName | None, optional): The service that the import belongs to. This is a nullable type, allowing for the absence of a service name.\n- module_name (ServiceModuleName, optional): Specifies the module name associated with the service, defaulting to ServiceModuleName.service_resource.\n- stringify (bool, optional): When True, converts the type annotation to a string to prevent circular dependencies. Defaults to True.\n- use_alias (bool, optional): When True, uses an alias for the name by prefixing it with an underscore. Defaults to False.\n\nAttributes:\n- self.name (str): Stores the import name.\n- self.service_name (ServiceName | None): Stores the service name or None.\n- self.module_name (ServiceModuleName): Stores the module name.\n- self.stringify (bool): Controls whether to stringify the output.\n- self.use_alias (bool): Indicates if the alias should be used.\n\nThis constructor directly interacts with the defined constants and types from the `mypy_boto3_builder.enums.service_module_name` and `mypy_boto3_builder.service_name` modules, ensuring that the type annotations are meaningful within the context of the AWS service framework.\"\"\"\n        self.name: str = name\n        self.service_name: ServiceName | None = service_name\n        self.module_name: ServiceModuleName = module_name\n        self.stringify: bool = stringify\n        self.use_alias: bool = use_alias",
        "docstring": "Initialize an instance of the InternalImport class, which serves as a wrapper for type annotations within the module. This constructor accepts various parameters to specify the name of the import, the associated service name, and the module name, along with options to control stringification and alias usage.\n\nParameters:\n- name (str): The name of the import to be wrapped.\n- service_name (ServiceName | None, optional): The service that the import belongs to. This is a nullable type, allowing for the absence of a service name.\n- module_name (ServiceModuleName, optional): Specifies the module name associated with the service, defaulting to ServiceModuleName.service_resource.\n- stringify (bool, optional): When True, converts the type annotation to a string to prevent circular dependencies. Defaults to True.\n- use_alias (bool, optional): When True, uses an alias for the name by prefixing it with an underscore. Defaults to False.\n\nAttributes:\n- self.name (str): Stores the import name.\n- self.service_name (ServiceName | None): Stores the service name or None.\n- self.module_name (ServiceModuleName): Stores the module name.\n- self.stringify (bool): Controls whether to stringify the output.\n- self.use_alias (bool): Indicates if the alias should be used.\n\nThis constructor directly interacts with the defined constants and types from the `mypy_boto3_builder.enums.service_module_name` and `mypy_boto3_builder.service_name` modules, ensuring that the type annotations are meaningful within the context of the AWS service framework.",
        "signature": "def __init__(self, name: str, service_name: ServiceName | None=None, module_name: ServiceModuleName=ServiceModuleName.service_resource, *, stringify: bool=True, use_alias: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class InternalImport(FakeAnnotation):"
      },
      "InternalImport.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the type annotation to a valid Python code format for local usage.\n\nThis method constructs a string representation of the type annotation based on the `name` attribute. If the `use_alias` attribute is set to `True`, the name is prefixed with an underscore by calling the `get_alias` method. If the `stringify` attribute is `True`, the resulting name is returned as a string enclosed in quotes. Otherwise, the name is returned as-is.\n\nReturns:\n    str: A valid type annotation, either as a plain name or a quoted string, based on the `use_alias` and `stringify` settings.\n\nAttributes used:\n- `name`: The original import name provided during the initialization of the `InternalImport` instance.\n- `use_alias`: A flag that determines whether to use the alias version of the name.\n- `stringify`: A flag that controls whether the result should be returned as a quoted string.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        result = self.name\n        if self.use_alias:\n            result = self.get_alias(self.name)\n        if self.stringify:\n            return f'\"{result}\"'\n        return result",
        "docstring": "Render the type annotation to a valid Python code format for local usage.\n\nThis method constructs a string representation of the type annotation based on the `name` attribute. If the `use_alias` attribute is set to `True`, the name is prefixed with an underscore by calling the `get_alias` method. If the `stringify` attribute is `True`, the resulting name is returned as a string enclosed in quotes. Otherwise, the name is returned as-is.\n\nReturns:\n    str: A valid type annotation, either as a plain name or a quoted string, based on the `use_alias` and `stringify` settings.\n\nAttributes used:\n- `name`: The original import name provided during the initialization of the `InternalImport` instance.\n- `use_alias`: A flag that determines whether to use the alias version of the name.\n- `stringify`: A flag that controls whether the result should be returned as a quoted string.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class InternalImport(FakeAnnotation):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:render": {
      "mypy_boto3_builder/type_annotations/internal_import.py": {
        "InternalImport.get_alias": {
          "code": "    def get_alias(name: str) -> str:\n        \"\"\"\n        Get import name alias.\n\n        Arguments:\n            name -- Original name.\n\n        Returns:\n            Name prefixed with underscore.\n        \"\"\"\n        return f'_{name}'",
          "docstring": "Get import name alias.\n\nArguments:\n    name -- Original name.\n\nReturns:\n    Name prefixed with underscore.",
          "signature": "def get_alias(name: str) -> str:",
          "type": "Method",
          "class_signature": "class InternalImport(FakeAnnotation):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py": {
        "FakeAnnotation._get_import_records": {
          "code": "    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()",
          "docstring": "Get import record required for using type annotation.",
          "signature": "def _get_import_records(self) -> set[ImportRecord]:",
          "type": "Method",
          "class_signature": "class FakeAnnotation(ABC):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
      "mypy_boto3_builder/type_annotations/internal_import.py": {
        "InternalImport.__copy__": {
          "code": "    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.service_name, self.module_name, use_alias=self.use_alias, stringify=self.stringify)",
          "docstring": "Create a copy of type annotation wrapper.",
          "signature": "def __copy__(self) -> Self:",
          "type": "Method",
          "class_signature": "class InternalImport(FakeAnnotation):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_internal_import\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 fake_annotation.py\n        \u2502   \u251c\u2500\u2500 FakeAnnotation.copy\n        \u2502   \u2514\u2500\u2500 FakeAnnotation.get_import_records\n        \u2514\u2500\u2500 internal_import.py\n            \u251c\u2500\u2500 InternalImport.__init__\n            \u2514\u2500\u2500 InternalImport.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides test coverage for the `InternalImport` class, which is part of a larger type annotation system designed to manage and render Python imports programmatically. It verifies the functionality of initializing import objects, rendering import statements in various formats, obtaining import records, and creating object copies. By ensuring the correctness of the `InternalImport` class's behavior, the module supports developers in building reliable, consistent import handling for dynamically generated or programmatically managed codebases. This functionality streamlines the development process for tools and libraries that require precise, customizable import management.\n\n## FILE 1: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.get_import_records\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet all import records necessary for using the type annotation represented by the instance of the FakeAnnotation subclass. This method calls the protected method `_get_import_records()` to retrieve the initial set of import records. It filters out any records that are considered built-in types using the `is_builtins()` method of the `source` attribute of `ImportRecord`. The return value is a set of `ImportRecord` instances that are not built-in, ensuring only relevant imports are collected for the type annotation.\n\nReturns:\n    set[ImportRecord]: A set of `ImportRecord` objects required for the type annotation, excluding built-in types.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.copy\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def copy(self: Self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a copy of the type annotation wrapper.\n\nThis method utilizes the `copy` module's `copy` function to create a shallow copy of the current instance of the `FakeAnnotation` subclass. It ensures that the copied instance maintains the same state as the original while allowing for modifications to the copy without affecting the original.\n\nReturns:\n    Self: A new instance of the same type as the original `FakeAnnotation`.\n\nDependencies:\n    This method relies on the `copy` module, which is imported at the top of the file, and it overrides the default copying behavior to ensure that the custom attributes of the `FakeAnnotation` subclass, if any, are correctly copied.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/internal_import.py\n\n- CLASS METHOD: InternalImport.__init__\n  - CLASS SIGNATURE: class InternalImport(FakeAnnotation):\n  - SIGNATURE: def __init__(self, name: str, service_name: ServiceName | None=None, module_name: ServiceModuleName=ServiceModuleName.service_resource, *, stringify: bool=True, use_alias: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the InternalImport class, which serves as a wrapper for type annotations within the module. This constructor accepts various parameters to specify the name of the import, the associated service name, and the module name, along with options to control stringification and alias usage.\n\nParameters:\n- name (str): The name of the import to be wrapped.\n- service_name (ServiceName | None, optional): The service that the import belongs to. This is a nullable type, allowing for the absence of a service name.\n- module_name (ServiceModuleName, optional): Specifies the module name associated with the service, defaulting to ServiceModuleName.service_resource.\n- stringify (bool, optional): When True, converts the type annotation to a string to prevent circular dependencies. Defaults to True.\n- use_alias (bool, optional): When True, uses an alias for the name by prefixing it with an underscore. Defaults to False.\n\nAttributes:\n- self.name (str): Stores the import name.\n- self.service_name (ServiceName | None): Stores the service name or None.\n- self.module_name (ServiceModuleName): Stores the module name.\n- self.stringify (bool): Controls whether to stringify the output.\n- self.use_alias (bool): Indicates if the alias should be used.\n\nThis constructor directly interacts with the defined constants and types from the `mypy_boto3_builder.enums.service_module_name` and `mypy_boto3_builder.service_name` modules, ensuring that the type annotations are meaningful within the context of the AWS service framework.\n\"\"\"\n```\n\n- CLASS METHOD: InternalImport.render\n  - CLASS SIGNATURE: class InternalImport(FakeAnnotation):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the type annotation to a valid Python code format for local usage.\n\nThis method constructs a string representation of the type annotation based on the `name` attribute. If the `use_alias` attribute is set to `True`, the name is prefixed with an underscore by calling the `get_alias` method. If the `stringify` attribute is `True`, the resulting name is returned as a string enclosed in quotes. Otherwise, the name is returned as-is.\n\nReturns:\n    str: A valid type annotation, either as a plain name or a quoted string, based on the `use_alias` and `stringify` settings.\n\nAttributes used:\n- `name`: The original import name provided during the initialization of the `InternalImport` instance.\n- `use_alias`: A flag that determines whether to use the alias version of the name.\n- `stringify`: A flag that controls whether the result should be returned as a quoted string.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()",
    "mypy_boto3_builder/type_annotations/internal_import.py": "\"\"\"\nWrapper for simple type annotations from this module.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.service_name import ServiceName\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass InternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for simple type annotations from this module.\n\n    Arguments:\n        name -- Import name.\n        service_name -- Service that import belongs to.\n        module_name -- Service module name.\n        stringify -- Convert type annotation to string to avoid circular deps.\n        use_alias -- Use name alias.\n    \"\"\"\n\n    @staticmethod\n    def get_alias(name: str) -> str:\n        \"\"\"\n        Get import name alias.\n\n        Arguments:\n            name -- Original name.\n\n        Returns:\n            Name prefixed with underscore.\n        \"\"\"\n        return f'_{name}'\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.service_name, self.module_name, use_alias=self.use_alias, stringify=self.stringify)"
  },
  "call_tree": {
    "tests/type_annotations/test_internal_import.py:TestInternalImport:setup_method": {
      "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:__init__": {}
    },
    "tests/type_annotations/test_internal_import.py:TestInternalImport:test_render": {
      "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:render": {
        "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:get_alias": {}
      }
    },
    "tests/type_annotations/test_internal_import.py:TestInternalImport:test_get_import_records": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:_get_import_records": {}
      }
    },
    "tests/type_annotations/test_internal_import.py:TestInternalImport:test_copy": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:__copy__": {
          "mypy_boto3_builder/type_annotations/internal_import.py:InternalImport:__init__": {}
        }
      }
    }
  }
}