{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_import_string",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/import_helpers/test_import_string.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\nclass TestImportString:\n    def test_init(self) -> None:\n        assert ImportString(\"my\", \"module\").render() == \"my.module\"\n        assert ImportString(\"my\").render() == \"my\"\n\n        assert ImportString(\"\", \"\").render() == \".\"\n        assert ImportString(\"\", \"test\", \"my\").render() == \".test.my\"\n        assert ImportString(\"\", \"\", \"test\", \"my\").render() == \"..test.my\"\n\n        with pytest.raises(StructureError):\n            ImportString(\"\")\n        with pytest.raises(StructureError):\n            ImportString(\"test\", \"another.module\")\n        with pytest.raises(StructureError):\n            ImportString(\"my\", \"\", \"test\")\n\n    def test_from_str(self) -> None:\n        assert ImportString.from_str(\"my.module.path\").render() == \"my.module.path\"\n        assert ImportString.from_str(\".test\").render() == \".test\"\n        with pytest.raises(StructureError):\n            assert ImportString.from_str(\"\").render()\n\n    def test_operations(self) -> None:\n        assert ImportString(\"my\") < ImportString(\"test\")\n        assert ImportString(\"my\", \"test\")\n        assert hash(ImportString(\"my\")) != hash(ImportString(\"test\"))\n\n        with pytest.raises(BuildInternalError):\n            assert ImportString(\"my\") + ImportString(\"test\") == \"my.test\"\n\n    def test_render(self) -> None:\n        assert ImportString(\"my\", \"module\").render() == \"my.module\"\n\n    def test_parent(self) -> None:\n        assert ImportString(\"my\", \"module\").parent == \"my\"\n        assert not ImportString(\"\", \"\").parent\n\n    def test_is_builtins(self) -> None:\n        assert ImportString(\"builtins\").is_builtins()\n        assert ImportString(\"builtins\", \"type\").is_builtins()\n        assert not ImportString(\"other\").is_builtins()\n        assert not ImportString(\"type_defs\").is_builtins()\n        assert not ImportString(\"boto3\").is_builtins()\n\n    def test_is_type_defs(self) -> None:\n        assert ImportString(\"type_defs\").is_type_defs()\n        assert ImportString(\"service\", \"type_defs\").is_type_defs()\n        assert not ImportString(\"builtins\").is_type_defs()\n        assert not ImportString(\"other\").is_type_defs()\n        assert not ImportString(\"boto3\").is_builtins()\n\n    def test_is_third_party(self) -> None:\n        assert not ImportString(\"type_defs\").is_third_party()\n        assert not ImportString(\"builtins\").is_third_party()\n        assert not ImportString(\"other\").is_third_party()\n        assert ImportString(\"boto3\").is_third_party()\n        assert ImportString(\"boto3\", \"test\").is_third_party()\n        assert ImportString(\"botocore\").is_third_party()\n        assert ImportString(\"botocore\", \"test\").is_third_party()\n\n    def test_is_local(self) -> None:\n        assert not ImportString(\"\", \"\").is_local()\n        assert ImportString(\"mypy_boto3\", \"test\").is_local()\n        assert ImportString(\"type_defs\").is_local()\n        assert not ImportString(\"other\").is_local()\n\n    def test_comparison(self) -> None:\n        # third party\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"builtins\", \"str\")\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"boto3\")\n        assert ImportString(\"boto3\", \"extra\") < ImportString(\"mypy_boto3_s3\", \"service\")\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"asdf\")\n        assert ImportString(\"aiobotocore\", \"extra\") < ImportString(\"boto3\", \"extra\")\n\n        # local\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"builtins\", \"str\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"boto3\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"mypy_boto3_s3\", \"asd\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") < ImportString(\"mypy_boto3_s3\", \"service\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"asdf\")\n\n        # other\n        assert ImportString(\"asdf\", \"test\") > ImportString(\"asd\", \"test\")\n        assert ImportString(\"asdf\", \"test\") < ImportString(\"asdf\", \"test2\")\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initialize an ImportString instance.\n\nThis constructor takes a base Python import string and any additional parts, ensuring that the combined import string adheres to specific structural rules. It raises a StructureError if the provided components are empty, incorrectly formatted, or include empty segments after a non-empty segment.\n\nParameters:\n- parent (str): The master module name which serves as the primary component of the import string.\n- parts (str): Additional parts of the import string provided as variable length arguments.\n\nAttributes:\n- self.parts (Final[tuple[str, ...]]): A tuple containing all parts of the import string, ensuring immutability.\n\nRaises:\n- StructureError: If both parent and parts are empty, or if any part contains a dot, or if there are empty segments after a non-empty segment.\n\nThe constructor utilizes the StructureError exception class to enforce structural integrity of the import strings it constructs.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initialize an ImportString instance.\n\nThis constructor takes a base Python import string and any additional parts, ensuring that the combined import string adheres to specific structural rules. It raises a StructureError if the provided components are empty, incorrectly formatted, or include empty segments after a non-empty segment.\n\nParameters:\n- parent (str): The master module name which serves as the primary component of the import string.\n- parts (str): Additional parts of the import string provided as variable length arguments.\n\nAttributes:\n- self.parts (Final[tuple[str, ...]]): A tuple containing all parts of the import string, ensuring immutability.\n\nRaises:\n- StructureError: If both parent and parts are empty, or if any part contains a dot, or if there are empty segments after a non-empty segment.\n\nThe constructor utilizes the StructureError exception class to enforce structural integrity of the import strings it constructs.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.from_str": {
        "code": "    def from_str(cls, import_string: str) -> Self:\n        \"\"\"Create an `ImportString` instance from a dot-separated string representation of a Python import. The method splits the input string on the dot character, allowing for the construction of an import string that can consist of a master module name and additional parts.\n\nParameters:\n    import_string (str): A dot-separated string representing the import path.\n\nReturns:\n    ImportString: An instance of the `ImportString` class constructed from the provided import string.\n\nUsage:\nThis method facilitates the conversion of a string representation of a Python import into a structured `ImportString` object, enabling further manipulation and validation within the context of importing modules.\n\nDependencies:\nIt relies on the `ImportString` class, leveraging its constructor to initialize the instance with the split parts of the provided string.\"\"\"\n        '\\n        Create from string.\\n        '\n        return cls(*import_string.split('.'))",
        "docstring": "Create an `ImportString` instance from a dot-separated string representation of a Python import. The method splits the input string on the dot character, allowing for the construction of an import string that can consist of a master module name and additional parts.\n\nParameters:\n    import_string (str): A dot-separated string representing the import path.\n\nReturns:\n    ImportString: An instance of the `ImportString` class constructed from the provided import string.\n\nUsage:\nThis method facilitates the conversion of a string representation of a Python import into a structured `ImportString` object, enabling further manipulation and validation within the context of importing modules.\n\nDependencies:\nIt relies on the `ImportString` class, leveraging its constructor to initialize the instance with the split parts of the provided string.",
        "signature": "def from_str(cls, import_string: str) -> Self:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate the hash value for the ImportString instance based on its parts.\n\nThis method contributes to the instance's usability as a key in dictionaries or sets by generating a unique hash derived from the `parts` attribute, which represents the components of the import string. The `parts` attribute is defined during initialization and is a tuple containing the parent module and additional parts of the import string. This ensures that two ImportString instances with the same import components yield the same hash value, maintaining consistency and allowing for comparison within collections.\n\nReturns:\n    int: The computed hash value for the ImportString instance.\"\"\"\n        '\\n        Calculate hash value based on all parts.\\n        '\n        return hash(self.parts)",
        "docstring": "Calculate the hash value for the ImportString instance based on its parts.\n\nThis method contributes to the instance's usability as a key in dictionaries or sets by generating a unique hash derived from the `parts` attribute, which represents the components of the import string. The `parts` attribute is defined during initialization and is a tuple containing the parent module and additional parts of the import string. This ensures that two ImportString instances with the same import components yield the same hash value, maintaining consistency and allowing for comparison within collections.\n\nReturns:\n    int: The computed hash value for the ImportString instance.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Check for equality between two ImportString instances.\n\nParameters:\n- other (object): The object to compare against the current instance. It is expected to be an instance of ImportString.\n\nReturns:\n- bool: True if the two ImportString instances are equivalent (i.e., they render the same import string), otherwise False.\n\nRaises:\n- BuildInternalError: If the `other` object is not an instance of ImportString, this exception is raised with a message indicating the type of `other`. \n\nThis method relies on the `parts` attribute of the ImportString class, which is a tuple containing the components of the import string. The method compares these tuples directly to determine equality.\"\"\"\n        '\\n        Whether import strings produce the same render.\\n        '\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts",
        "docstring": "Check for equality between two ImportString instances.\n\nParameters:\n- other (object): The object to compare against the current instance. It is expected to be an instance of ImportString.\n\nReturns:\n- bool: True if the two ImportString instances are equivalent (i.e., they render the same import string), otherwise False.\n\nRaises:\n- BuildInternalError: If the `other` object is not an instance of ImportString, this exception is raised with a message indicating the type of `other`. \n\nThis method relies on the `parts` attribute of the ImportString class, which is a tuple containing the components of the import string. The method compares these tuples directly to determine equality.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__gt__": {
        "code": "    def __gt__(self, other: Self) -> bool:\n        \"\"\"Compare two ImportString instances for sorting based on custom logic that emulates `isort`. \n\nParameters:\n- other (Self): Another ImportString instance to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the other based on the import sorting criteria;\n  otherwise, False.\n\nThe comparison is done in the following order:\n1. First, it checks if both instances are equal, returning False if they are.\n2. It evaluates whether the imports are local (determined by the is_local method) and prioritizes local imports over non-local ones.\n3. Next, it checks if one import is from a third-party library (determined by the is_third_party method) and prioritizes third-party imports accordingly.\n4. Finally, it performs a lexicographical comparison of the parts of the import strings.\n\nConstants:\n- Boto3StubsPackageData.SERVICE_PREFIX and TypesAioBotocorePackageData.SERVICE_PREFIX are used in the is_local method to identify local modules. They help in determining the type of the import string for accurate comparison.\"\"\"\n        '\\n        Compare import strings for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts",
        "docstring": "Compare two ImportString instances for sorting based on custom logic that emulates `isort`. \n\nParameters:\n- other (Self): Another ImportString instance to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the other based on the import sorting criteria;\n  otherwise, False.\n\nThe comparison is done in the following order:\n1. First, it checks if both instances are equal, returning False if they are.\n2. It evaluates whether the imports are local (determined by the is_local method) and prioritizes local imports over non-local ones.\n3. Next, it checks if one import is from a third-party library (determined by the is_third_party method) and prioritizes third-party imports accordingly.\n4. Finally, it performs a lexicographical comparison of the parts of the import strings.\n\nConstants:\n- Boto3StubsPackageData.SERVICE_PREFIX and TypesAioBotocorePackageData.SERVICE_PREFIX are used in the is_local method to identify local modules. They help in determining the type of the import string for accurate comparison.",
        "signature": "def __gt__(self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__add__": {
        "code": "    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"Create a new import string by appending the parts of another `ImportString` instance or a string.\n\nParameters:\n- other (Self | str): An instance of `ImportString` or a string representing additional import parts to be appended.\n\nReturns:\n- Self: A new `ImportString` instance that combines the parts of the original instance with those from `other`.\n\nThis method relies on the instance's parts attribute, which stores the components of the import string, ensuring proper concatenation without breaking the structure of import strings. It utilizes the class constructor to create the new instance.\"\"\"\n        '\\n        Create a new import string by adding another import string parts to the end.\\n        '\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)",
        "docstring": "Create a new import string by appending the parts of another `ImportString` instance or a string.\n\nParameters:\n- other (Self | str): An instance of `ImportString` or a string representing additional import parts to be appended.\n\nReturns:\n- Self: A new `ImportString` instance that combines the parts of the original instance with those from `other`.\n\nThis method relies on the instance's parts attribute, which stores the components of the import string, ensuring proper concatenation without breaking the structure of import strings. It utilizes the class constructor to create the new instance.",
        "signature": "def __add__(self: Self, other: Self | str) -> Self:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the import string as a valid Python import statement.\n\nThis method combines the stored parts of the import into a single string separated by dots. The parts are initialized in the class constructor and represent a canonical import path.\n\nReturns:\n    str: A ready-to-use import string constructed from the parts of the ImportString instance.\n\nNo input parameters are taken, and it does not have side effects. It relies on the `parts` attribute, which is a tuple of strings initialized in the constructor, ensuring it reflects the correct import structure.\"\"\"\n        '\\n        Render to string.\\n\\n        Returns:\\n            Ready to use import string.\\n        '\n        return '.'.join(self.parts)",
        "docstring": "Render the import string as a valid Python import statement.\n\nThis method combines the stored parts of the import into a single string separated by dots. The parts are initialized in the class constructor and represent a canonical import path.\n\nReturns:\n    str: A ready-to-use import string constructed from the parts of the ImportString instance.\n\nNo input parameters are taken, and it does not have side effects. It relies on the `parts` attribute, which is a tuple of strings initialized in the constructor, ensuring it reflects the correct import structure.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.parent": {
        "code": "    def parent(self) -> str:\n        \"\"\"Get the first part of the import string, representing the parent module.\n\nReturns:\n    str: The first part of the import string, which corresponds to the parent module name. If the import string is empty, the method will return 'builtins' by default.\n\nNotes:\n    This method interacts with the `parts` attribute, which is a tuple containing all components of the import string. The `BUILTINS` constant is predefined in the class and represents the standard `builtins` module in Python.\"\"\"\n        '\\n        Get first import string part or `builtins`.\\n        '\n        return self.parts[0]",
        "docstring": "Get the first part of the import string, representing the parent module.\n\nReturns:\n    str: The first part of the import string, which corresponds to the parent module name. If the import string is empty, the method will return 'builtins' by default.\n\nNotes:\n    This method interacts with the `parts` attribute, which is a tuple containing all components of the import string. The `BUILTINS` constant is predefined in the class and represents the standard `builtins` module in Python.",
        "signature": "def parent(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_local": {
        "code": "    def is_local(self) -> bool:\n        \"\"\"Determine if the import string represents a local module.\n\nThis method checks whether the import string's parent is associated with local modules by evaluating if it starts with prefixes defined in `Boto3StubsPackageData.SERVICE_PREFIX` or `TypesAioBotocorePackageData.SERVICE_PREFIX`. Additionally, it assesses if the import string corresponds to type definitions through the `is_type_defs` method.\n\nReturns:\n    bool: True if the import string refers to a local module, False otherwise.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant defined in the `Boto3StubsPackageData`, representing the prefix for Boto3 service stubs.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant defined in the `TypesAioBotocorePackageData`, representing the prefix for Aiobotocore service stubs.\n- `is_type_defs()`: A method that determines if the import string is a type definition.\"\"\"\n        '\\n        Whether import is from local module.\\n        '\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()",
        "docstring": "Determine if the import string represents a local module.\n\nThis method checks whether the import string's parent is associated with local modules by evaluating if it starts with prefixes defined in `Boto3StubsPackageData.SERVICE_PREFIX` or `TypesAioBotocorePackageData.SERVICE_PREFIX`. Additionally, it assesses if the import string corresponds to type definitions through the `is_type_defs` method.\n\nReturns:\n    bool: True if the import string refers to a local module, False otherwise.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant defined in the `Boto3StubsPackageData`, representing the prefix for Boto3 service stubs.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant defined in the `TypesAioBotocorePackageData`, representing the prefix for Aiobotocore service stubs.\n- `is_type_defs()`: A method that determines if the import string is a type definition.",
        "signature": "def is_local(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_builtins": {
        "code": "    def is_builtins(self) -> bool:\n        \"\"\"Determines whether the import string represents the built-in Python `builtins` module.\n\nThis method checks if the `parent` part of the import string is equal to the `BUILTINS` constant, which is defined as \"builtins\". This allows the method to identify imports coming specifically from Python's built-in module.\n\nReturns:\n    bool: True if the import string refers to the `builtins` module, otherwise False.\"\"\"\n        '\\n        Whether import is from Python `builtins` module.\\n        '\n        return self.parent == self.BUILTINS",
        "docstring": "Determines whether the import string represents the built-in Python `builtins` module.\n\nThis method checks if the `parent` part of the import string is equal to the `BUILTINS` constant, which is defined as \"builtins\". This allows the method to identify imports coming specifically from Python's built-in module.\n\nReturns:\n    bool: True if the import string refers to the `builtins` module, otherwise False.",
        "signature": "def is_builtins(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_type_defs": {
        "code": "    def is_type_defs(self) -> bool:\n        \"\"\"Determine if the import string corresponds to a `type_defs` module.\n\nThis method checks if the last part of the import string is equal to the value of `type_defs` from the `ServiceModuleName` enum, indicating that the import is specifically relating to type definitions. If there are no parts in the import string, it returns `False`.\n\nReturns:\n    bool: True if the import string is from a `type_defs` module, otherwise False.\n\nDependencies:\n    - Uses `ServiceModuleName.type_defs.value` to compare against the last part of the import string.\"\"\"\n        '\\n        Whether import is from `type_defs` module.\\n        '\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value",
        "docstring": "Determine if the import string corresponds to a `type_defs` module.\n\nThis method checks if the last part of the import string is equal to the value of `type_defs` from the `ServiceModuleName` enum, indicating that the import is specifically relating to type definitions. If there are no parts in the import string, it returns `False`.\n\nReturns:\n    bool: True if the import string is from a `type_defs` module, otherwise False.\n\nDependencies:\n    - Uses `ServiceModuleName.type_defs.value` to compare against the last part of the import string.",
        "signature": "def is_type_defs(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_third_party": {
        "code": "    def is_third_party(self) -> bool:\n        \"\"\"Determine if the import string is from a third-party module.\n\nReturns:\n    bool: True if the module is classified as third-party, based on its parent name, otherwise False.\n\nDependencies:\n    - Uses the class-level constant `_THIRD_PARTY`, which contains a set of module names ('boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt').\n    - The method checks if the `parent` attribute of the `ImportString` instance is present in this set to ascertain whether the import is third-party.\"\"\"\n        '\\n        Whether import is from 3rd party module.\\n        '\n        return self.parent in self._THIRD_PARTY",
        "docstring": "Determine if the import string is from a third-party module.\n\nReturns:\n    bool: True if the module is classified as third-party, based on its parent name, otherwise False.\n\nDependencies:\n    - Uses the class-level constant `_THIRD_PARTY`, which contains a set of module names ('boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt').\n    - The method checks if the `parent` attribute of the `ImportString` instance is present in this set to ascertain whether the import is third-party.",
        "signature": "def is_third_party(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__add__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {}
  },
  "call_tree": {
    "tests/import_helpers/test_import_string.py:TestImportString:test_init": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_from_str": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_operations": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__add__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_render": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_parent": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_builtins": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_type_defs": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_third_party": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_local": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_comparison": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {}
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_import_string\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 import_helpers/\n        \u2514\u2500\u2500 import_string.py\n            \u251c\u2500\u2500 ImportString.__add__\n            \u251c\u2500\u2500 ImportString.__eq__\n            \u251c\u2500\u2500 ImportString.__gt__\n            \u251c\u2500\u2500 ImportString.__hash__\n            \u251c\u2500\u2500 ImportString.__init__\n            \u251c\u2500\u2500 ImportString.from_str\n            \u251c\u2500\u2500 ImportString.is_builtins\n            \u251c\u2500\u2500 ImportString.is_local\n            \u251c\u2500\u2500 ImportString.is_third_party\n            \u251c\u2500\u2500 ImportString.is_type_defs\n            \u251c\u2500\u2500 ImportString.parent\n            \u2514\u2500\u2500 ImportString.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and manage import string objects, providing robust and structured handling of import paths for Python modules. It ensures proper formatting, parsing, and validation of import strings, allowing developers to represent, render, and compare import paths with various levels of complexity. The module includes functionality to identify the type or context of a given import (e.g., built-in, third-party, local, or type definitions) and supports operations such as parent extraction and string-based comparisons. By offering clear and precise handling of import strings, the module eliminates ambiguity and potential errors in managing module imports, simplifying development workflows and ensuring consistency in codebases.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportString instance.\n\nThis constructor takes a base Python import string and any additional parts, ensuring that the combined import string adheres to specific structural rules. It raises a StructureError if the provided components are empty, incorrectly formatted, or include empty segments after a non-empty segment.\n\nParameters:\n- parent (str): The master module name which serves as the primary component of the import string.\n- parts (str): Additional parts of the import string provided as variable length arguments.\n\nAttributes:\n- self.parts (Final[tuple[str, ...]]): A tuple containing all parts of the import string, ensuring immutability.\n\nRaises:\n- StructureError: If both parent and parts are empty, or if any part contains a dot, or if there are empty segments after a non-empty segment.\n\nThe constructor utilizes the StructureError exception class to enforce structural integrity of the import strings it constructs.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__add__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __add__(self: Self, other: Self | str) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new import string by appending the parts of another `ImportString` instance or a string.\n\nParameters:\n- other (Self | str): An instance of `ImportString` or a string representing additional import parts to be appended.\n\nReturns:\n- Self: A new `ImportString` instance that combines the parts of the original instance with those from `other`.\n\nThis method relies on the instance's parts attribute, which stores the components of the import string, ensuring proper concatenation without breaking the structure of import strings. It utilizes the class constructor to create the new instance.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__gt__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __gt__(self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two ImportString instances for sorting based on custom logic that emulates `isort`. \n\nParameters:\n- other (Self): Another ImportString instance to compare against.\n\nReturns:\n- bool: True if the current instance is greater than the other based on the import sorting criteria;\n  otherwise, False.\n\nThe comparison is done in the following order:\n1. First, it checks if both instances are equal, returning False if they are.\n2. It evaluates whether the imports are local (determined by the is_local method) and prioritizes local imports over non-local ones.\n3. Next, it checks if one import is from a third-party library (determined by the is_third_party method) and prioritizes third-party imports accordingly.\n4. Finally, it performs a lexicographical comparison of the parts of the import strings.\n\nConstants:\n- Boto3StubsPackageData.SERVICE_PREFIX and TypesAioBotocorePackageData.SERVICE_PREFIX are used in the is_local method to identify local modules. They help in determining the type of the import string for accurate comparison.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_local\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_local(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string represents a local module.\n\nThis method checks whether the import string's parent is associated with local modules by evaluating if it starts with prefixes defined in `Boto3StubsPackageData.SERVICE_PREFIX` or `TypesAioBotocorePackageData.SERVICE_PREFIX`. Additionally, it assesses if the import string corresponds to type definitions through the `is_type_defs` method.\n\nReturns:\n    bool: True if the import string refers to a local module, False otherwise.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant defined in the `Boto3StubsPackageData`, representing the prefix for Boto3 service stubs.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant defined in the `TypesAioBotocorePackageData`, representing the prefix for Aiobotocore service stubs.\n- `is_type_defs()`: A method that determines if the import string is a type definition.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.from_str\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def from_str(cls, import_string: str) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an `ImportString` instance from a dot-separated string representation of a Python import. The method splits the input string on the dot character, allowing for the construction of an import string that can consist of a master module name and additional parts.\n\nParameters:\n    import_string (str): A dot-separated string representing the import path.\n\nReturns:\n    ImportString: An instance of the `ImportString` class constructed from the provided import string.\n\nUsage:\nThis method facilitates the conversion of a string representation of a Python import into a structured `ImportString` object, enabling further manipulation and validation within the context of importing modules.\n\nDependencies:\nIt relies on the `ImportString` class, leveraging its constructor to initialize the instance with the split parts of the provided string.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_third_party\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_third_party(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string is from a third-party module.\n\nReturns:\n    bool: True if the module is classified as third-party, based on its parent name, otherwise False.\n\nDependencies:\n    - Uses the class-level constant `_THIRD_PARTY`, which contains a set of module names ('boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt').\n    - The method checks if the `parent` attribute of the `ImportString` instance is present in this set to ascertain whether the import is third-party.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.render\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the import string as a valid Python import statement.\n\nThis method combines the stored parts of the import into a single string separated by dots. The parts are initialized in the class constructor and represent a canonical import path.\n\nReturns:\n    str: A ready-to-use import string constructed from the parts of the ImportString instance.\n\nNo input parameters are taken, and it does not have side effects. It relies on the `parts` attribute, which is a tuple of strings initialized in the constructor, ensuring it reflects the correct import structure.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__hash__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the hash value for the ImportString instance based on its parts.\n\nThis method contributes to the instance's usability as a key in dictionaries or sets by generating a unique hash derived from the `parts` attribute, which represents the components of the import string. The `parts` attribute is defined during initialization and is a tuple containing the parent module and additional parts of the import string. This ensures that two ImportString instances with the same import components yield the same hash value, maintaining consistency and allowing for comparison within collections.\n\nReturns:\n    int: The computed hash value for the ImportString instance.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.parent\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def parent(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the first part of the import string, representing the parent module.\n\nReturns:\n    str: The first part of the import string, which corresponds to the parent module name. If the import string is empty, the method will return 'builtins' by default.\n\nNotes:\n    This method interacts with the `parts` attribute, which is a tuple containing all components of the import string. The `BUILTINS` constant is predefined in the class and represents the standard `builtins` module in Python.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_type_defs\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_type_defs(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string corresponds to a `type_defs` module.\n\nThis method checks if the last part of the import string is equal to the value of `type_defs` from the `ServiceModuleName` enum, indicating that the import is specifically relating to type definitions. If there are no parts in the import string, it returns `False`.\n\nReturns:\n    bool: True if the import string is from a `type_defs` module, otherwise False.\n\nDependencies:\n    - Uses `ServiceModuleName.type_defs.value` to compare against the last part of the import string.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_builtins\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_builtins(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether the import string represents the built-in Python `builtins` module.\n\nThis method checks if the `parent` part of the import string is equal to the `BUILTINS` constant, which is defined as \"builtins\". This allows the method to identify imports coming specifically from Python's built-in module.\n\nReturns:\n    bool: True if the import string refers to the `builtins` module, otherwise False.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__eq__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck for equality between two ImportString instances.\n\nParameters:\n- other (object): The object to compare against the current instance. It is expected to be an instance of ImportString.\n\nReturns:\n- bool: True if the two ImportString instances are equivalent (i.e., they render the same import string), otherwise False.\n\nRaises:\n- BuildInternalError: If the `other` object is not an instance of ImportString, this exception is raised with a message indicating the type of `other`. \n\nThis method relies on the `parts` attribute of the ImportString class, which is a tuple containing the components of the import string. The method compares these tuples directly to determine equality.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()"
  }
}