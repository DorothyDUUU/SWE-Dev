{
  "dir_path": "/app/datashader",
  "package_name": "datashader",
  "sample_name": "datashader-test_macros",
  "src_dir": "datashader/",
  "test_dir": "datashader/tests/",
  "test_file": "datashader/tests/test_macros.py",
  "test_code": "from __future__ import annotations\nimport warnings\nimport pytest\n\nfrom datashader.macros import expand_varargs\nimport inspect\nfrom numba import jit\n\n\n# Example functions to test expand_varargs on\ndef function_no_vararg(a, b):\n    return a + b\n\n\ndef function_with_vararg(a, b, *others):\n    return a + b - function_no_vararg(*others)\n\n\ndef function_with_unsupported_vararg_use(a, b, *others):\n    print(others[0])\n    function_with_vararg(a, b, *others)\n\n\n@jit(nopython=True, nogil=True)\ndef function_no_vararg_numba(a, b):\n    return a + b\n\n\ndef function_with_vararg_call_numba(a, b, *others):\n    return a + b - function_no_vararg_numba(*others)\n\n\n# Help functions\ndef get_args(fn):\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        spec = inspect.getfullargspec(fn)\n\n    args = spec.args\n    if spec.varargs:\n        args += ['*' + spec.varargs]\n\n    return args\n\n\n# Tests\ndef test_expand_varargs():\n    assert get_args(function_with_vararg) == ['a', 'b', '*others']\n    function_with_vararg_expanded = expand_varargs(2)(function_with_vararg)\n    assert get_args(function_with_vararg_expanded) == ['a', 'b', '_0', '_1']\n\n    assert (function_with_vararg(1, 2, 3, 4) ==\n            function_with_vararg_expanded(1, 2, 3, 4))\n\n\ndef test_invalid_expand_number():\n    with pytest.raises(ValueError) as e:\n        # User forgets to construct decorator with expand_number\n        expand_varargs(function_no_vararg)\n\n    assert e.match(r\"non\\-negative integer\")\n\n\ndef test_no_varargs_error():\n    with pytest.raises(ValueError) as e:\n        expand_varargs(2)(function_no_vararg)\n\n    assert e.match(r\"does not have a variable length positional argument\")\n\n\ndef test_unsupported_vararg_use():\n    with pytest.raises(ValueError) as e:\n        expand_varargs(2)(function_with_unsupported_vararg_use)\n\n    assert e.match(r\"unsupported context\")\n\n\ndef test_numba_jit_expanded_function():\n    jit_fn = jit(nopython=True, nogil=True)(\n        expand_varargs(2)(function_with_vararg_call_numba)\n    )\n    assert function_with_vararg_call_numba(1, 2, 3, 4) == jit_fn(1, 2, 3, 4)\n",
  "GT_file_code": {
    "datashader/macros.py": "\"\"\"\nUtilities for manipulating the Abstract Syntax Tree of Python constructs\n\"\"\"\nimport re\nimport copy\nimport inspect\nimport ast\nimport textwrap\n\n\nclass NameVisitor(ast.NodeVisitor):\n    \"\"\"\n    NodeVisitor that builds a set of all of the named identifiers in an AST\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.names = set()\n\n    def visit_Name(self, node):\n        self.names.add(node.id)\n\n    def visit_arg(self, node):\n        if hasattr(node, 'arg'):\n            self.names.add(node.arg)\n        elif hasattr(node, 'id'):\n            self.names.add(node.id)\n\n    def get_new_names(self, num_names):\n        \"\"\"\n        Returns a list of new names that are not already present in the AST.\n\n        New names will have the form _N, for N a non-negative integer. If the\n        AST has no existing identifiers of this form, then the returned names\n        will start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\n        of this form, then the names returned will not include the existing\n        identifiers.\n\n        Parameters\n        ----------\n        num_names: int\n            The number of new names to return\n\n        Returns\n        -------\n        list of str\n        \"\"\"\n        prop_re = re.compile(r\"^_(\\d+)$\")\n        matching_names = [n for n in self.names if prop_re.match(n)]\n        if matching_names:\n            start_number = max([int(n[1:]) for n in matching_names]) + 1\n        else:\n            start_number = 0\n\n        return [\"_\" + str(n) for n in\n                range(start_number, start_number + num_names)]\n\n\nclass ExpandVarargTransformer(ast.NodeTransformer):\n    \"\"\"\n    Node transformer that replaces the starred use of a variable in an AST\n    with a collection of unstarred named variables.\n    \"\"\"\n    def __init__(self, starred_name, expand_names, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        starred_name: str\n            The name of the starred variable to replace\n        expand_names: list of stf\n            List of the new names that should be used to replace the starred\n            variable\n\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.starred_name = starred_name\n        self.expand_names = expand_names\n\n\nclass ExpandVarargTransformerStarred(ExpandVarargTransformer):\n    # Python 3\n    def visit_Starred(self, node):\n        if node.value.id == self.starred_name:\n            return [ast.Name(id=name, ctx=node.ctx) for name in\n                    self.expand_names]\n        else:\n            return node\n\n\ndef function_to_ast(fn):\n    \"\"\"\n    Get the AST representation of a function\n    \"\"\"\n    # Get source code for function\n    # Dedent is needed if this is a nested function\n    fn_source = textwrap.dedent(inspect.getsource(fn))\n\n    # Parse function source code into an AST\n    fn_ast = ast.parse(fn_source)\n\n    # # The function will be the fist element of the module body\n    # fn_ast = module_ast.body[0]\n\n    return fn_ast\n\n\ndef ast_to_source(ast):\n    \"\"\"Convert AST to source code string using the astor package\"\"\"\n    import astor\n    return astor.to_source(ast)\n\n\ndef compile_function_ast(fn_ast):\n    \"\"\"\n    Compile function AST into a code object suitable for use in eval/exec\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    return compile(fn_ast, \"<%s>\" % fndef_ast.name, mode='exec')\n\n\ndef function_ast_to_function(fn_ast, stacklevel=1):\n    # Validate\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n\n    # Compile AST to code object\n    code = compile_function_ast(fn_ast)\n\n    # Evaluate the function in a scope that includes the globals and\n    # locals of desired frame.\n    current_frame = inspect.currentframe()\n    eval_frame = current_frame\n    for _ in range(stacklevel):\n        eval_frame = eval_frame.f_back\n\n    eval_locals = eval_frame.f_locals\n    eval_globals = eval_frame.f_globals\n    del current_frame\n    scope = copy.copy(eval_globals)\n    scope.update(eval_locals)\n\n    # Evaluate function in scope\n    eval(code, scope)\n\n    # Return the newly evaluated function from the scope\n    return scope[fndef_ast.name]\n\n\ndef _build_arg(name):\n    return ast.arg(arg=name)\n\n\ndef expand_function_ast_varargs(fn_ast, expand_number):\n    \"\"\"\n    Given a function AST that use a variable length positional argument\n    (e.g. *args), return a function that replaces the use of this argument\n    with one or more fixed arguments.\n\n    To be supported, a function must have a starred argument in the function\n    signature, and it may only use this argument in starred form as the\n    input to other functions.\n\n    For example, suppose expand_number is 3 and fn_ast is an AST\n    representing this function...\n\n    def my_fn1(a, b, *args):\n        print(a, b)\n        other_fn(a, b, *args)\n\n    Then this function will return the AST of a function equivalent to...\n\n    def my_fn1(a, b, _0, _1, _2):\n        print(a, b)\n        other_fn(a, b, _0, _1, _2)\n\n    If the input function uses `args` for anything other than passing it to\n    other functions in starred form, an error will be raised.\n\n    Parameters\n    ----------\n    fn_ast: ast.FunctionDef\n    expand_number: int\n\n    Returns\n    -------\n    ast.FunctionDef\n    \"\"\"\n    assert isinstance(fn_ast, ast.Module)\n\n    # Copy ast so we don't modify the input\n    fn_ast = copy.deepcopy(fn_ast)\n\n    # Extract function definition\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n\n    # Get function args\n    fn_args = fndef_ast.args\n\n    # Function variable arity argument\n    fn_vararg = fn_args.vararg\n\n    # Require vararg\n    if not fn_vararg:\n        raise ValueError(\"\"\"\\\nInput function AST does not have a variable length positional argument\n(e.g. *args) in the function signature\"\"\")\n    assert fn_vararg\n\n    # Get vararg name\n    if isinstance(fn_vararg, str):\n        vararg_name = fn_vararg\n    else:\n        vararg_name = fn_vararg.arg\n\n    # Compute new unique names to use in place of the variable argument\n    before_name_visitor = NameVisitor()\n    before_name_visitor.visit(fn_ast)\n    expand_names = before_name_visitor.get_new_names(expand_number)\n\n    # Replace use of *args in function body\n    expand_transformer = ExpandVarargTransformerStarred\n\n    new_fn_ast = expand_transformer(\n        vararg_name, expand_names\n    ).visit(fn_ast)\n\n    new_fndef_ast = new_fn_ast.body[0]\n\n    # Replace vararg with additional args in function signature\n    new_fndef_ast.args.args.extend(\n        [_build_arg(name=name) for name in expand_names]\n    )\n    new_fndef_ast.args.vararg = None\n\n    # Run a new NameVistor an see if there were any other non-starred uses\n    # of the variable length argument. If so, raise an exception\n    after_name_visitor = NameVisitor()\n    after_name_visitor.visit(new_fn_ast)\n    if vararg_name in after_name_visitor.names:\n        raise ValueError(\"\"\"\\\nThe variable length positional argument {n} is used in an unsupported context\n\"\"\".format(n=vararg_name))\n\n    # Remove decorators if present to avoid recursion\n    fndef_ast.decorator_list = []\n\n    # Add missing source code locations\n    ast.fix_missing_locations(new_fn_ast)\n\n    # Return result\n    return new_fn_ast\n\n\ndef expand_varargs(expand_number):\n    \"\"\"\n    Decorator to expand the variable length (starred) argument in a function\n    signature with a fixed number of arguments.\n\n    Parameters\n    ----------\n    expand_number: int\n        The number of fixed arguments that should replace the variable length\n        argument\n\n    Returns\n    -------\n    function\n        Decorator Function\n    \"\"\"\n    if not isinstance(expand_number, int) or expand_number < 0:\n        raise ValueError(\"expand_number must be a non-negative integer\")\n\n    def _expand_varargs(fn):\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)\n    return _expand_varargs\n"
  },
  "GT_src_dict": {
    "datashader/macros.py": {
      "NameVisitor.__init__": {
        "code": "    def __init__(self, *args, **kwargs):\n        \"\"\"Initializes a NameVisitor instance that will track named identifiers within an Abstract Syntax Tree (AST). This constructor calls the parent class's `__init__` method to ensure proper initialization and creates an empty set, `self.names`, to store unique names found during visitation of AST nodes.\n\nParameters\n----------\n*args: variable length argument list\n    Positional arguments passed to the parent class initializer.\n**kwargs: variable length keyword argument list\n    Keyword arguments passed to the parent class initializer.\n\nAttributes\n----------\nself.names: set\n    A set that holds unique string identifiers encountered in the AST. This attribute is crucial for building a list of new names that don't conflict with existing identifiers when manipulating the AST.\n\nNotes\n-----\nThis class is a part of a visitor pattern implementation that traverses the AST constructed using the `ast` module in Python, mainly used for identifying and expanding names in functions with variable-length arguments.\"\"\"\n        super().__init__(*args, **kwargs)\n        self.names = set()",
        "docstring": "Initializes a NameVisitor instance that will track named identifiers within an Abstract Syntax Tree (AST). This constructor calls the parent class's `__init__` method to ensure proper initialization and creates an empty set, `self.names`, to store unique names found during visitation of AST nodes.\n\nParameters\n----------\n*args: variable length argument list\n    Positional arguments passed to the parent class initializer.\n**kwargs: variable length keyword argument list\n    Keyword arguments passed to the parent class initializer.\n\nAttributes\n----------\nself.names: set\n    A set that holds unique string identifiers encountered in the AST. This attribute is crucial for building a list of new names that don't conflict with existing identifiers when manipulating the AST.\n\nNotes\n-----\nThis class is a part of a visitor pattern implementation that traverses the AST constructed using the `ast` module in Python, mainly used for identifying and expanding names in functions with variable-length arguments.",
        "signature": "def __init__(self, *args, **kwargs):",
        "type": "Method",
        "class_signature": "class NameVisitor(ast.NodeVisitor):"
      },
      "NameVisitor.visit_Name": {
        "code": "    def visit_Name(self, node):\n        \"\"\"Visiting method for the NameVisitor class that processes Name nodes in an Abstract Syntax Tree (AST).\n\nParameters\n----------\nnode : ast.Name\n    An instance of ast.Name, representing a named identifier in the AST.\n\nReturns\n-------\nNone\n    This method updates the `names` attribute of the NameVisitor instance by adding\n    the identifier name (`node.id`) of the visited Name node to the set of names.\n\nSide Effects\n------------\nModifies the `names` attribute, which is a set that accumulates all named identifiers encountered during tree traversal.\n\nInteraction with Other Code\n---------------------------\nThe `names` attribute is initialized as an empty set in the NameVisitor class constructor and is used to collect unique identifier names from the entire AST. The collected names can later be queried to obtain new unique names through the `get_new_names` method.\"\"\"\n        self.names.add(node.id)",
        "docstring": "Visiting method for the NameVisitor class that processes Name nodes in an Abstract Syntax Tree (AST).\n\nParameters\n----------\nnode : ast.Name\n    An instance of ast.Name, representing a named identifier in the AST.\n\nReturns\n-------\nNone\n    This method updates the `names` attribute of the NameVisitor instance by adding\n    the identifier name (`node.id`) of the visited Name node to the set of names.\n\nSide Effects\n------------\nModifies the `names` attribute, which is a set that accumulates all named identifiers encountered during tree traversal.\n\nInteraction with Other Code\n---------------------------\nThe `names` attribute is initialized as an empty set in the NameVisitor class constructor and is used to collect unique identifier names from the entire AST. The collected names can later be queried to obtain new unique names through the `get_new_names` method.",
        "signature": "def visit_Name(self, node):",
        "type": "Method",
        "class_signature": "class NameVisitor(ast.NodeVisitor):"
      },
      "NameVisitor.visit_arg": {
        "code": "    def visit_arg(self, node):\n        \"\"\"Visit an argument node in an Abstract Syntax Tree (AST) and collect its identifier.\n\nThis method checks for the presence of attributes 'arg' or 'id' in the given `node`, and adds the corresponding identifier to the set of names maintained by the `NameVisitor` instance. This is used to gather all named identifiers in the AST for further analysis.\n\nParameters\n----------\nnode : ast.arg\n    The AST node representing the argument, which is expected to be an instance of `ast.arg`.\n\nReturns\n-------\nNone\n    The method modifies the internal state of the `NameVisitor` instance by adding the identifier to the `names` set, but does not return a value.\n\nDependencies\n------------\nThis method relies on the `names` attribute, which is a set initialized in the `__init__` method of the `NameVisitor` class to store unique identifiers found during AST traversal.\"\"\"\n        if hasattr(node, 'arg'):\n            self.names.add(node.arg)\n        elif hasattr(node, 'id'):\n            self.names.add(node.id)",
        "docstring": "Visit an argument node in an Abstract Syntax Tree (AST) and collect its identifier.\n\nThis method checks for the presence of attributes 'arg' or 'id' in the given `node`, and adds the corresponding identifier to the set of names maintained by the `NameVisitor` instance. This is used to gather all named identifiers in the AST for further analysis.\n\nParameters\n----------\nnode : ast.arg\n    The AST node representing the argument, which is expected to be an instance of `ast.arg`.\n\nReturns\n-------\nNone\n    The method modifies the internal state of the `NameVisitor` instance by adding the identifier to the `names` set, but does not return a value.\n\nDependencies\n------------\nThis method relies on the `names` attribute, which is a set initialized in the `__init__` method of the `NameVisitor` class to store unique identifiers found during AST traversal.",
        "signature": "def visit_arg(self, node):",
        "type": "Method",
        "class_signature": "class NameVisitor(ast.NodeVisitor):"
      },
      "NameVisitor.get_new_names": {
        "code": "    def get_new_names(self, num_names):\n        \"\"\"Returns a list of new unique names in the format _N, where N is a non-negative integer, that are not already present in the Abstract Syntax Tree (AST). The method ensures that if existing identifiers of this form are found, the new names will not overlap with them, starting from the smallest available integer. The method takes a single parameter:\n\nParameters\n----------\nnum_names: int\n    The number of new unique names to generate.\n\nReturns\n-------\nlist of str\n    A list of new names in the form of strings that can be safely added to the AST without conflicting with pre-existing names.\n\nThe method uses a regular expression (prop_re) to identify existing names of the pattern _N in the set of collected names. It computes the maximum existing numeric suffix to ensure that new names begin at the first available integer, defaulting to 0 if no such names exist.\"\"\"\n        \"\\n        Returns a list of new names that are not already present in the AST.\\n\\n        New names will have the form _N, for N a non-negative integer. If the\\n        AST has no existing identifiers of this form, then the returned names\\n        will start at 0 ('_0', '_1', '_2'). If the AST already has identifiers\\n        of this form, then the names returned will not include the existing\\n        identifiers.\\n\\n        Parameters\\n        ----------\\n        num_names: int\\n            The number of new names to return\\n\\n        Returns\\n        -------\\n        list of str\\n        \"\n        prop_re = re.compile('^_(\\\\d+)$')\n        matching_names = [n for n in self.names if prop_re.match(n)]\n        if matching_names:\n            start_number = max([int(n[1:]) for n in matching_names]) + 1\n        else:\n            start_number = 0\n        return ['_' + str(n) for n in range(start_number, start_number + num_names)]",
        "docstring": "Returns a list of new unique names in the format _N, where N is a non-negative integer, that are not already present in the Abstract Syntax Tree (AST). The method ensures that if existing identifiers of this form are found, the new names will not overlap with them, starting from the smallest available integer. The method takes a single parameter:\n\nParameters\n----------\nnum_names: int\n    The number of new unique names to generate.\n\nReturns\n-------\nlist of str\n    A list of new names in the form of strings that can be safely added to the AST without conflicting with pre-existing names.\n\nThe method uses a regular expression (prop_re) to identify existing names of the pattern _N in the set of collected names. It computes the maximum existing numeric suffix to ensure that new names begin at the first available integer, defaulting to 0 if no such names exist.",
        "signature": "def get_new_names(self, num_names):",
        "type": "Method",
        "class_signature": "class NameVisitor(ast.NodeVisitor):"
      },
      "ExpandVarargTransformer.__init__": {
        "code": "    def __init__(self, starred_name, expand_names, *args, **kwargs):\n        \"\"\"Initialize an instance of the ExpandVarargTransformer class, which is responsible for replacing the starred variable in the AST with a list of specified unstarred variable names.\n\nParameters\n----------\nstarred_name: str\n    The name of the starred argument that will be replaced in the AST.\nexpand_names: list of str\n    A list of new unstarred names that will be used to replace the starred variable.\n*args: Variable length argument list.\n**kwargs: Arbitrary keyword arguments.\n\nThis constructor calls the superclass (NodeTransformer) constructor to initialize the node transformer. The attributes `starred_name` and `expand_names` are stored for use in AST traversal and transformation, allowing the transformer to accurately replace the starred argument during the visitation process.\"\"\"\n        '\\n        Parameters\\n        ----------\\n        starred_name: str\\n            The name of the starred variable to replace\\n        expand_names: list of stf\\n            List of the new names that should be used to replace the starred\\n            variable\\n\\n        '\n        super().__init__(*args, **kwargs)\n        self.starred_name = starred_name\n        self.expand_names = expand_names",
        "docstring": "Initialize an instance of the ExpandVarargTransformer class, which is responsible for replacing the starred variable in the AST with a list of specified unstarred variable names.\n\nParameters\n----------\nstarred_name: str\n    The name of the starred argument that will be replaced in the AST.\nexpand_names: list of str\n    A list of new unstarred names that will be used to replace the starred variable.\n*args: Variable length argument list.\n**kwargs: Arbitrary keyword arguments.\n\nThis constructor calls the superclass (NodeTransformer) constructor to initialize the node transformer. The attributes `starred_name` and `expand_names` are stored for use in AST traversal and transformation, allowing the transformer to accurately replace the starred argument during the visitation process.",
        "signature": "def __init__(self, starred_name, expand_names, *args, **kwargs):",
        "type": "Method",
        "class_signature": "class ExpandVarargTransformer(ast.NodeTransformer):"
      },
      "ExpandVarargTransformerStarred.visit_Starred": {
        "code": "    def visit_Starred(self, node):\n        \"\"\"Visits a `Starred` AST node and replaces it with a list of unstarred `Name` nodes if the starred variable matches the specified `starred_name`.\n\nParameters\n----------\nnode: ast.Starred\n    The AST node representing a starred expression (e.g., *args).\n\nReturns\n-------\nlist or ast.Starred\n    A list of unstarred `Name` nodes corresponding to the names in `expand_names` if the starred variable's identifier matches `starred_name`. If the identifier does not match, returns the original starred node unchanged.\n\nNotes\n-----\nThis method relies on the attributes `starred_name` and `expand_names`, which are initialized in the `ExpandVarargTransformer` constructor. `starred_name` is the name of the variable to be replaced (e.g., \"args\"), while `expand_names` is a list of new unique names that will replace the starred use. If the node's variable matches `starred_name`, it produces the corresponding `Name` nodes for further use in the AST transformation.\"\"\"\n        if node.value.id == self.starred_name:\n            return [ast.Name(id=name, ctx=node.ctx) for name in self.expand_names]\n        else:\n            return node",
        "docstring": "Visits a `Starred` AST node and replaces it with a list of unstarred `Name` nodes if the starred variable matches the specified `starred_name`.\n\nParameters\n----------\nnode: ast.Starred\n    The AST node representing a starred expression (e.g., *args).\n\nReturns\n-------\nlist or ast.Starred\n    A list of unstarred `Name` nodes corresponding to the names in `expand_names` if the starred variable's identifier matches `starred_name`. If the identifier does not match, returns the original starred node unchanged.\n\nNotes\n-----\nThis method relies on the attributes `starred_name` and `expand_names`, which are initialized in the `ExpandVarargTransformer` constructor. `starred_name` is the name of the variable to be replaced (e.g., \"args\"), while `expand_names` is a list of new unique names that will replace the starred use. If the node's variable matches `starred_name`, it produces the corresponding `Name` nodes for further use in the AST transformation.",
        "signature": "def visit_Starred(self, node):",
        "type": "Method",
        "class_signature": "class ExpandVarargTransformerStarred(ExpandVarargTransformer):"
      },
      "function_to_ast": {
        "code": "def function_to_ast(fn):\n    \"\"\"Get the Abstract Syntax Tree (AST) representation of a given function. This function retrieves the source code of the provided function, dedents it to handle nested functions properly, and parses the dedented source code into an AST using the `ast.parse` method from Python's `ast` module.\n\nParameters\n----------\nfn: Callable\n    The function whose AST representation is to be obtained.\n\nReturns\n-------\nast.Module\n    The AST representation of the input function, encapsulated within a module node.\n\nDependencies\n------------\n- `textwrap.dedent`: Used for removing common leading whitespace from the function's source code to ensure accurate parsing.\n- `inspect.getsource`: Retrieves the source code of the provided function.\n- `ast`: The built-in module used for parsing the source code into its AST form.\"\"\"\n    '\\n    Get the AST representation of a function\\n    '\n    fn_source = textwrap.dedent(inspect.getsource(fn))\n    fn_ast = ast.parse(fn_source)\n    return fn_ast",
        "docstring": "Get the Abstract Syntax Tree (AST) representation of a given function. This function retrieves the source code of the provided function, dedents it to handle nested functions properly, and parses the dedented source code into an AST using the `ast.parse` method from Python's `ast` module.\n\nParameters\n----------\nfn: Callable\n    The function whose AST representation is to be obtained.\n\nReturns\n-------\nast.Module\n    The AST representation of the input function, encapsulated within a module node.\n\nDependencies\n------------\n- `textwrap.dedent`: Used for removing common leading whitespace from the function's source code to ensure accurate parsing.\n- `inspect.getsource`: Retrieves the source code of the provided function.\n- `ast`: The built-in module used for parsing the source code into its AST form.",
        "signature": "def function_to_ast(fn):",
        "type": "Function",
        "class_signature": null
      },
      "compile_function_ast": {
        "code": "def compile_function_ast(fn_ast):\n    \"\"\"Compile an Abstract Syntax Tree (AST) representation of a function into a code object that can be executed with `eval` or `exec`.\n\nParameters\n----------\nfn_ast: ast.Module\n    The AST of a function. It is expected to have a single body element, which must be a `FunctionDef`.\n\nReturns\n-------\ncode\n    A code object representing the compiled function, suitable for execution.\n\nNotes\n-----\nThis function asserts that `fn_ast` is of type `ast.Module` and that its first body element is a `FunctionDef`. The name of the function is used as part of the representation in the returned code object. The function's primary role is to facilitate dynamic code execution via AST manipulation, enabling the adaptation and expansion of function signatures in higher-level constructs.\"\"\"\n    '\\n    Compile function AST into a code object suitable for use in eval/exec\\n    '\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    return compile(fn_ast, '<%s>' % fndef_ast.name, mode='exec')",
        "docstring": "Compile an Abstract Syntax Tree (AST) representation of a function into a code object that can be executed with `eval` or `exec`.\n\nParameters\n----------\nfn_ast: ast.Module\n    The AST of a function. It is expected to have a single body element, which must be a `FunctionDef`.\n\nReturns\n-------\ncode\n    A code object representing the compiled function, suitable for execution.\n\nNotes\n-----\nThis function asserts that `fn_ast` is of type `ast.Module` and that its first body element is a `FunctionDef`. The name of the function is used as part of the representation in the returned code object. The function's primary role is to facilitate dynamic code execution via AST manipulation, enabling the adaptation and expansion of function signatures in higher-level constructs.",
        "signature": "def compile_function_ast(fn_ast):",
        "type": "Function",
        "class_signature": null
      },
      "function_ast_to_function": {
        "code": "def function_ast_to_function(fn_ast, stacklevel=1):\n    \"\"\"Convert an AST representation of a function into an executable function object.\n\nParameters\n----------\nfn_ast: ast.Module\n    The AST representation of a function, containing a single function definition in its body.\n\nstacklevel: int, optional\n    The level of the stack frame to evaluate the function in, default is 1, referencing the immediate caller.\n\nReturns\n-------\nfunction\n    The dynamically created function corresponding to the provided AST.\n\nRaises\n------\nAssertionError\n    If the provided AST does not represent a valid function (i.e., it does not contain an ast.FunctionDef).\n\nDependencies\n------------\n- The function relies on `compile_function_ast` to convert the AST into a code object.\n- It uses `inspect.currentframe` to access the current stack and evaluate the function in the correct context, allowing the created function to access the local and global variables of the caller's environment.\n- `copy` is used to create a new dictionary for the evaluation scope to prevent mutation of the original global scope.\"\"\"\n    assert isinstance(fn_ast, ast.Module)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    code = compile_function_ast(fn_ast)\n    current_frame = inspect.currentframe()\n    eval_frame = current_frame\n    for _ in range(stacklevel):\n        eval_frame = eval_frame.f_back\n    eval_locals = eval_frame.f_locals\n    eval_globals = eval_frame.f_globals\n    del current_frame\n    scope = copy.copy(eval_globals)\n    scope.update(eval_locals)\n    eval(code, scope)\n    return scope[fndef_ast.name]",
        "docstring": "Convert an AST representation of a function into an executable function object.\n\nParameters\n----------\nfn_ast: ast.Module\n    The AST representation of a function, containing a single function definition in its body.\n\nstacklevel: int, optional\n    The level of the stack frame to evaluate the function in, default is 1, referencing the immediate caller.\n\nReturns\n-------\nfunction\n    The dynamically created function corresponding to the provided AST.\n\nRaises\n------\nAssertionError\n    If the provided AST does not represent a valid function (i.e., it does not contain an ast.FunctionDef).\n\nDependencies\n------------\n- The function relies on `compile_function_ast` to convert the AST into a code object.\n- It uses `inspect.currentframe` to access the current stack and evaluate the function in the correct context, allowing the created function to access the local and global variables of the caller's environment.\n- `copy` is used to create a new dictionary for the evaluation scope to prevent mutation of the original global scope.",
        "signature": "def function_ast_to_function(fn_ast, stacklevel=1):",
        "type": "Function",
        "class_signature": null
      },
      "_build_arg": {
        "code": "def _build_arg(name):\n    \"\"\"Create an AST argument node with the specified name.\n\nParameters\n----------\nname: str\n    The name of the argument to be represented in the AST.\n\nReturns\n-------\nast.arg\n    An instance of `ast.arg` initialized with the provided name.\n\nThis function is a utility for constructing argument nodes when modifying \nfunction signatures in an AST. It is particularly used in the `expand_function_ast_varargs` \nfunction to create new fixed argument representations for variable length style arguments.\"\"\"\n    return ast.arg(arg=name)",
        "docstring": "Create an AST argument node with the specified name.\n\nParameters\n----------\nname: str\n    The name of the argument to be represented in the AST.\n\nReturns\n-------\nast.arg\n    An instance of `ast.arg` initialized with the provided name.\n\nThis function is a utility for constructing argument nodes when modifying \nfunction signatures in an AST. It is particularly used in the `expand_function_ast_varargs` \nfunction to create new fixed argument representations for variable length style arguments.",
        "signature": "def _build_arg(name):",
        "type": "Function",
        "class_signature": null
      },
      "expand_function_ast_varargs": {
        "code": "def expand_function_ast_varargs(fn_ast, expand_number):\n    \"\"\"Transform a function's Abstract Syntax Tree (AST) by replacing a variable-length positional argument (e.g., *args) with fixed positional arguments.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST representation of a function, which must include a starred argument (e.g., *args) in its signature.\nexpand_number : int\n    The number of fixed arguments that should replace the starred variable-length argument.\n\nReturns\n-------\nast.Module\n    A new AST representing the function with the starred argument replaced by fixed positional arguments, named sequentially (e.g., _0, _1, ...).\n\nRaises\n------\nValueError\n    If the function definition does not include a variable-length argument, or if the variable argument is used in non-starred contexts.\n\nNotes\n-----\nThis function works in conjunction with the NameVisitor and ExpandVarargTransformerStarred classes, which are used to identify existing identifiers and replace starred uses of the variable argument, respectively. The function ensures that newly created argument names do not conflict with existing names in the AST.\"\"\"\n    '\\n    Given a function AST that use a variable length positional argument\\n    (e.g. *args), return a function that replaces the use of this argument\\n    with one or more fixed arguments.\\n\\n    To be supported, a function must have a starred argument in the function\\n    signature, and it may only use this argument in starred form as the\\n    input to other functions.\\n\\n    For example, suppose expand_number is 3 and fn_ast is an AST\\n    representing this function...\\n\\n    def my_fn1(a, b, *args):\\n        print(a, b)\\n        other_fn(a, b, *args)\\n\\n    Then this function will return the AST of a function equivalent to...\\n\\n    def my_fn1(a, b, _0, _1, _2):\\n        print(a, b)\\n        other_fn(a, b, _0, _1, _2)\\n\\n    If the input function uses `args` for anything other than passing it to\\n    other functions in starred form, an error will be raised.\\n\\n    Parameters\\n    ----------\\n    fn_ast: ast.FunctionDef\\n    expand_number: int\\n\\n    Returns\\n    -------\\n    ast.FunctionDef\\n    '\n    assert isinstance(fn_ast, ast.Module)\n    fn_ast = copy.deepcopy(fn_ast)\n    fndef_ast = fn_ast.body[0]\n    assert isinstance(fndef_ast, ast.FunctionDef)\n    fn_args = fndef_ast.args\n    fn_vararg = fn_args.vararg\n    if not fn_vararg:\n        raise ValueError('Input function AST does not have a variable length positional argument\\n(e.g. *args) in the function signature')\n    assert fn_vararg\n    if isinstance(fn_vararg, str):\n        vararg_name = fn_vararg\n    else:\n        vararg_name = fn_vararg.arg\n    before_name_visitor = NameVisitor()\n    before_name_visitor.visit(fn_ast)\n    expand_names = before_name_visitor.get_new_names(expand_number)\n    expand_transformer = ExpandVarargTransformerStarred\n    new_fn_ast = expand_transformer(vararg_name, expand_names).visit(fn_ast)\n    new_fndef_ast = new_fn_ast.body[0]\n    new_fndef_ast.args.args.extend([_build_arg(name=name) for name in expand_names])\n    new_fndef_ast.args.vararg = None\n    after_name_visitor = NameVisitor()\n    after_name_visitor.visit(new_fn_ast)\n    if vararg_name in after_name_visitor.names:\n        raise ValueError('The variable length positional argument {n} is used in an unsupported context\\n'.format(n=vararg_name))\n    fndef_ast.decorator_list = []\n    ast.fix_missing_locations(new_fn_ast)\n    return new_fn_ast",
        "docstring": "Transform a function's Abstract Syntax Tree (AST) by replacing a variable-length positional argument (e.g., *args) with fixed positional arguments.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST representation of a function, which must include a starred argument (e.g., *args) in its signature.\nexpand_number : int\n    The number of fixed arguments that should replace the starred variable-length argument.\n\nReturns\n-------\nast.Module\n    A new AST representing the function with the starred argument replaced by fixed positional arguments, named sequentially (e.g., _0, _1, ...).\n\nRaises\n------\nValueError\n    If the function definition does not include a variable-length argument, or if the variable argument is used in non-starred contexts.\n\nNotes\n-----\nThis function works in conjunction with the NameVisitor and ExpandVarargTransformerStarred classes, which are used to identify existing identifiers and replace starred uses of the variable argument, respectively. The function ensures that newly created argument names do not conflict with existing names in the AST.",
        "signature": "def expand_function_ast_varargs(fn_ast, expand_number):",
        "type": "Function",
        "class_signature": null
      },
      "expand_varargs": {
        "code": "def expand_varargs(expand_number):\n    \"\"\"Decorator to replace a variable-length positional argument (e.g., *args) in a function's signature with a specified fixed number of arguments. This allows for the use of explicit argument names instead of relying on a star-arg.\n\nParameters\n----------\nexpand_number : int\n    The number of fixed arguments to replace the star-arg. Must be a non-negative integer.\n\nReturns\n-------\nfunction\n    A decorator function that, when applied to a target function, expands its signature by replacing the starred argument with the defined number of new arguments.\n\nRaises\n------\nValueError\n    If `expand_number` is not a non-negative integer.\n\nDependencies\n------------\nThis function utilizes the `function_to_ast`, `expand_function_ast_varargs`, and `function_ast_to_function` utility functions to manipulate the Abstract Syntax Tree (AST) of the input function. The `expand_function_ast_varargs` function specifically ensures that the star-arg is replaced only under permissible conditions, while `function_ast_to_function` compiles the modified AST back into a callable function.\"\"\"\n    '\\n    Decorator to expand the variable length (starred) argument in a function\\n    signature with a fixed number of arguments.\\n\\n    Parameters\\n    ----------\\n    expand_number: int\\n        The number of fixed arguments that should replace the variable length\\n        argument\\n\\n    Returns\\n    -------\\n    function\\n        Decorator Function\\n    '\n    if not isinstance(expand_number, int) or expand_number < 0:\n        raise ValueError('expand_number must be a non-negative integer')\n\n    def _expand_varargs(fn):\n        \"\"\"Decorator function that expands a variable length positional argument (e.g., *args) in a given function's signature to a fixed number of named arguments. \n\nParameters\n----------\nfn : callable\n    The function to be decorated, which must include a starred argument in its signature.\n    \nReturns\n-------\ncallable\n    A new function equivalent to the original, but with the starred argument replaced by the specified number of fixed arguments.\n\nRaises\n------\nValueError\n    If the input function does not have a variable length positional argument or if the variable argument is used in an unsupported context.\n\nDependencies\n------------\nInteracts with several other functions: \n- `function_to_ast(fn)`: Converts the input function to its Abstract Syntax Tree (AST).\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Modifies the AST to expand the variable arguments to fixed ones.\n- `function_ast_to_function(fn_ast, stacklevel)`: Converts the modified AST back to a Python function.\n\nThe variable `expand_number`, which is defined in the outer scope, determines how many fixed arguments will replace the original starred argument.\"\"\"\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)\n    return _expand_varargs",
        "docstring": "Decorator to replace a variable-length positional argument (e.g., *args) in a function's signature with a specified fixed number of arguments. This allows for the use of explicit argument names instead of relying on a star-arg.\n\nParameters\n----------\nexpand_number : int\n    The number of fixed arguments to replace the star-arg. Must be a non-negative integer.\n\nReturns\n-------\nfunction\n    A decorator function that, when applied to a target function, expands its signature by replacing the starred argument with the defined number of new arguments.\n\nRaises\n------\nValueError\n    If `expand_number` is not a non-negative integer.\n\nDependencies\n------------\nThis function utilizes the `function_to_ast`, `expand_function_ast_varargs`, and `function_ast_to_function` utility functions to manipulate the Abstract Syntax Tree (AST) of the input function. The `expand_function_ast_varargs` function specifically ensures that the star-arg is replaced only under permissible conditions, while `function_ast_to_function` compiles the modified AST back into a callable function.",
        "signature": "def expand_varargs(expand_number):",
        "type": "Function",
        "class_signature": null
      },
      "_expand_varargs": {
        "code": "    def _expand_varargs(fn):\n        \"\"\"Decorator function that expands a variable length positional argument (e.g., *args) in a given function's signature to a fixed number of named arguments. \n\nParameters\n----------\nfn : callable\n    The function to be decorated, which must include a starred argument in its signature.\n    \nReturns\n-------\ncallable\n    A new function equivalent to the original, but with the starred argument replaced by the specified number of fixed arguments.\n\nRaises\n------\nValueError\n    If the input function does not have a variable length positional argument or if the variable argument is used in an unsupported context.\n\nDependencies\n------------\nInteracts with several other functions: \n- `function_to_ast(fn)`: Converts the input function to its Abstract Syntax Tree (AST).\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Modifies the AST to expand the variable arguments to fixed ones.\n- `function_ast_to_function(fn_ast, stacklevel)`: Converts the modified AST back to a Python function.\n\nThe variable `expand_number`, which is defined in the outer scope, determines how many fixed arguments will replace the original starred argument.\"\"\"\n        fn_ast = function_to_ast(fn)\n        fn_expanded_ast = expand_function_ast_varargs(fn_ast, expand_number)\n        return function_ast_to_function(fn_expanded_ast, stacklevel=2)",
        "docstring": "Decorator function that expands a variable length positional argument (e.g., *args) in a given function's signature to a fixed number of named arguments. \n\nParameters\n----------\nfn : callable\n    The function to be decorated, which must include a starred argument in its signature.\n    \nReturns\n-------\ncallable\n    A new function equivalent to the original, but with the starred argument replaced by the specified number of fixed arguments.\n\nRaises\n------\nValueError\n    If the input function does not have a variable length positional argument or if the variable argument is used in an unsupported context.\n\nDependencies\n------------\nInteracts with several other functions: \n- `function_to_ast(fn)`: Converts the input function to its Abstract Syntax Tree (AST).\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Modifies the AST to expand the variable arguments to fixed ones.\n- `function_ast_to_function(fn_ast, stacklevel)`: Converts the modified AST back to a Python function.\n\nThe variable `expand_number`, which is defined in the outer scope, determines how many fixed arguments will replace the original starred argument.",
        "signature": "def _expand_varargs(fn):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "call_tree": {
    "datashader/tests/test_macros.py:test_expand_varargs": {
      "datashader/tests/test_macros.py:get_args": {},
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        },
        "datashader/macros.py:function_ast_to_function": {
          "datashader/macros.py:compile_function_ast": {}
        }
      },
      "datashader/tests/test_macros.py:function_with_vararg": {
        "datashader/tests/test_macros.py:function_no_vararg": {}
      },
      "datashader/tests/test_macros.py:function_no_vararg": {}
    },
    "datashader/tests/test_macros.py:test_invalid_expand_number": {
      "datashader/macros.py:expand_varargs": {}
    },
    "datashader/tests/test_macros.py:test_no_varargs_error": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {}
      }
    },
    "datashader/tests/test_macros.py:test_unsupported_vararg_use": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        }
      }
    },
    "datashader/tests/test_macros.py:test_numba_jit_expanded_function": {
      "datashader/macros.py:expand_varargs": {},
      "datashader/macros.py:_expand_varargs": {
        "datashader/macros.py:function_to_ast": {},
        "datashader/macros.py:expand_function_ast_varargs": {
          "datashader/macros.py:NameVisitor:__init__": {},
          "datashader/macros.py:NameVisitor:visit_arg": {},
          "datashader/macros.py:NameVisitor:visit_Name": {},
          "datashader/macros.py:NameVisitor:get_new_names": {},
          "datashader/macros.py:ExpandVarargTransformer:__init__": {},
          "datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred": {},
          "datashader/macros.py:_build_arg": {}
        },
        "datashader/macros.py:function_ast_to_function": {
          "datashader/macros.py:compile_function_ast": {}
        }
      },
      "datashader/tests/test_macros.py:function_with_vararg_call_numba": {}
    }
  },
  "PRD": "# PROJECT NAME: datashader-test_macros\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 datashader/\n    \u2514\u2500\u2500 macros.py\n        \u251c\u2500\u2500 ExpandVarargTransformer.__init__\n        \u251c\u2500\u2500 ExpandVarargTransformerStarred.visit_Starred\n        \u251c\u2500\u2500 NameVisitor.__init__\n        \u251c\u2500\u2500 NameVisitor.get_new_names\n        \u251c\u2500\u2500 NameVisitor.visit_Name\n        \u251c\u2500\u2500 NameVisitor.visit_arg\n        \u251c\u2500\u2500 _build_arg\n        \u251c\u2500\u2500 _expand_varargs\n        \u251c\u2500\u2500 compile_function_ast\n        \u251c\u2500\u2500 expand_function_ast_varargs\n        \u251c\u2500\u2500 expand_varargs\n        \u251c\u2500\u2500 function_ast_to_function\n        \u2514\u2500\u2500 function_to_ast\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality to expand and handle variable-length positional arguments (varargs) in Python functions. It introduces a mechanism to replace varargs with explicit, positional arguments for improved clarity and compatibility, particularly in contexts like JIT (Just-In-Time) compilation with Numba, where varargs are not natively supported. This capability allows developers to create functions that are both more predictable and compatible with performance-critical execution environments. By addressing the limitations of varargs in certain use cases, the module simplifies the handling of dynamic arguments and ensures robust, error-checked usage, reducing potential runtime errors and improving maintainability for developers.\n\n## FILE 1: datashader/macros.py\n\n- FUNCTION NAME: function_to_ast\n  - SIGNATURE: def function_to_ast(fn):\n  - DOCSTRING: \n```python\n\"\"\"\nGet the Abstract Syntax Tree (AST) representation of a given function. This function retrieves the source code of the provided function, dedents it to handle nested functions properly, and parses the dedented source code into an AST using the `ast.parse` method from Python's `ast` module.\n\nParameters\n----------\nfn: Callable\n    The function whose AST representation is to be obtained.\n\nReturns\n-------\nast.Module\n    The AST representation of the input function, encapsulated within a module node.\n\nDependencies\n------------\n- `textwrap.dedent`: Used for removing common leading whitespace from the function's source code to ensure accurate parsing.\n- `inspect.getsource`: Retrieves the source code of the provided function.\n- `ast`: The built-in module used for parsing the source code into its AST form.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:_expand_varargs\n\n- FUNCTION NAME: compile_function_ast\n  - SIGNATURE: def compile_function_ast(fn_ast):\n  - DOCSTRING: \n```python\n\"\"\"\nCompile an Abstract Syntax Tree (AST) representation of a function into a code object that can be executed with `eval` or `exec`.\n\nParameters\n----------\nfn_ast: ast.Module\n    The AST of a function. It is expected to have a single body element, which must be a `FunctionDef`.\n\nReturns\n-------\ncode\n    A code object representing the compiled function, suitable for execution.\n\nNotes\n-----\nThis function asserts that `fn_ast` is of type `ast.Module` and that its first body element is a `FunctionDef`. The name of the function is used as part of the representation in the returned code object. The function's primary role is to facilitate dynamic code execution via AST manipulation, enabling the adaptation and expansion of function signatures in higher-level constructs.\n\"\"\"\n```\n\n- FUNCTION NAME: expand_function_ast_varargs\n  - SIGNATURE: def expand_function_ast_varargs(fn_ast, expand_number):\n  - DOCSTRING: \n```python\n\"\"\"\nTransform a function's Abstract Syntax Tree (AST) by replacing a variable-length positional argument (e.g., *args) with fixed positional arguments.\n\nParameters\n----------\nfn_ast : ast.Module\n    The AST representation of a function, which must include a starred argument (e.g., *args) in its signature.\nexpand_number : int\n    The number of fixed arguments that should replace the starred variable-length argument.\n\nReturns\n-------\nast.Module\n    A new AST representing the function with the starred argument replaced by fixed positional arguments, named sequentially (e.g., _0, _1, ...).\n\nRaises\n------\nValueError\n    If the function definition does not include a variable-length argument, or if the variable argument is used in non-starred contexts.\n\nNotes\n-----\nThis function works in conjunction with the NameVisitor and ExpandVarargTransformerStarred classes, which are used to identify existing identifiers and replace starred uses of the variable argument, respectively. The function ensures that newly created argument names do not conflict with existing names in the AST.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:_expand_varargs\n    - datashader/macros.py:NameVisitor:get_new_names\n    - datashader/macros.py:NameVisitor:__init__\n    - datashader/macros.py:NameVisitor:visit_Name\n    - datashader/macros.py:NameVisitor:visit_arg\n    - datashader/macros.py:ExpandVarargTransformer:__init__\n    - datashader/macros.py:_build_arg\n    - datashader/macros.py:ExpandVarargTransformerStarred:visit_Starred\n\n- FUNCTION NAME: expand_varargs\n  - SIGNATURE: def expand_varargs(expand_number):\n  - DOCSTRING: \n```python\n\"\"\"\nDecorator to replace a variable-length positional argument (e.g., *args) in a function's signature with a specified fixed number of arguments. This allows for the use of explicit argument names instead of relying on a star-arg.\n\nParameters\n----------\nexpand_number : int\n    The number of fixed arguments to replace the star-arg. Must be a non-negative integer.\n\nReturns\n-------\nfunction\n    A decorator function that, when applied to a target function, expands its signature by replacing the starred argument with the defined number of new arguments.\n\nRaises\n------\nValueError\n    If `expand_number` is not a non-negative integer.\n\nDependencies\n------------\nThis function utilizes the `function_to_ast`, `expand_function_ast_varargs`, and `function_ast_to_function` utility functions to manipulate the Abstract Syntax Tree (AST) of the input function. The `expand_function_ast_varargs` function specifically ensures that the star-arg is replaced only under permissible conditions, while `function_ast_to_function` compiles the modified AST back into a callable function.\n\"\"\"\n```\n\n- FUNCTION NAME: _expand_varargs\n  - SIGNATURE: def _expand_varargs(fn):\n  - DOCSTRING: \n```python\n\"\"\"\nDecorator function that expands a variable length positional argument (e.g., *args) in a given function's signature to a fixed number of named arguments. \n\nParameters\n----------\nfn : callable\n    The function to be decorated, which must include a starred argument in its signature.\n    \nReturns\n-------\ncallable\n    A new function equivalent to the original, but with the starred argument replaced by the specified number of fixed arguments.\n\nRaises\n------\nValueError\n    If the input function does not have a variable length positional argument or if the variable argument is used in an unsupported context.\n\nDependencies\n------------\nInteracts with several other functions: \n- `function_to_ast(fn)`: Converts the input function to its Abstract Syntax Tree (AST).\n- `expand_function_ast_varargs(fn_ast, expand_number)`: Modifies the AST to expand the variable arguments to fixed ones.\n- `function_ast_to_function(fn_ast, stacklevel)`: Converts the modified AST back to a Python function.\n\nThe variable `expand_number`, which is defined in the outer scope, determines how many fixed arguments will replace the original starred argument.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:function_ast_to_function\n    - datashader/macros.py:expand_function_ast_varargs\n    - datashader/macros.py:function_to_ast\n\n- CLASS METHOD: NameVisitor.get_new_names\n  - CLASS SIGNATURE: class NameVisitor(ast.NodeVisitor):\n  - SIGNATURE: def get_new_names(self, num_names):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a list of new unique names in the format _N, where N is a non-negative integer, that are not already present in the Abstract Syntax Tree (AST). The method ensures that if existing identifiers of this form are found, the new names will not overlap with them, starting from the smallest available integer. The method takes a single parameter:\n\nParameters\n----------\nnum_names: int\n    The number of new unique names to generate.\n\nReturns\n-------\nlist of str\n    A list of new names in the form of strings that can be safely added to the AST without conflicting with pre-existing names.\n\nThe method uses a regular expression (prop_re) to identify existing names of the pattern _N in the set of collected names. It computes the maximum existing numeric suffix to ensure that new names begin at the first available integer, defaulting to 0 if no such names exist.\n\"\"\"\n```\n\n- CLASS METHOD: NameVisitor.__init__\n  - CLASS SIGNATURE: class NameVisitor(ast.NodeVisitor):\n  - SIGNATURE: def __init__(self, *args, **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a NameVisitor instance that will track named identifiers within an Abstract Syntax Tree (AST). This constructor calls the parent class's `__init__` method to ensure proper initialization and creates an empty set, `self.names`, to store unique names found during visitation of AST nodes.\n\nParameters\n----------\n*args: variable length argument list\n    Positional arguments passed to the parent class initializer.\n**kwargs: variable length keyword argument list\n    Keyword arguments passed to the parent class initializer.\n\nAttributes\n----------\nself.names: set\n    A set that holds unique string identifiers encountered in the AST. This attribute is crucial for building a list of new names that don't conflict with existing identifiers when manipulating the AST.\n\nNotes\n-----\nThis class is a part of a visitor pattern implementation that traverses the AST constructed using the `ast` module in Python, mainly used for identifying and expanding names in functions with variable-length arguments.\n\"\"\"\n```\n\n- CLASS METHOD: NameVisitor.visit_Name\n  - CLASS SIGNATURE: class NameVisitor(ast.NodeVisitor):\n  - SIGNATURE: def visit_Name(self, node):\n  - DOCSTRING: \n```python\n\"\"\"\nVisiting method for the NameVisitor class that processes Name nodes in an Abstract Syntax Tree (AST).\n\nParameters\n----------\nnode : ast.Name\n    An instance of ast.Name, representing a named identifier in the AST.\n\nReturns\n-------\nNone\n    This method updates the `names` attribute of the NameVisitor instance by adding\n    the identifier name (`node.id`) of the visited Name node to the set of names.\n\nSide Effects\n------------\nModifies the `names` attribute, which is a set that accumulates all named identifiers encountered during tree traversal.\n\nInteraction with Other Code\n---------------------------\nThe `names` attribute is initialized as an empty set in the NameVisitor class constructor and is used to collect unique identifier names from the entire AST. The collected names can later be queried to obtain new unique names through the `get_new_names` method.\n\"\"\"\n```\n\n- CLASS METHOD: NameVisitor.visit_arg\n  - CLASS SIGNATURE: class NameVisitor(ast.NodeVisitor):\n  - SIGNATURE: def visit_arg(self, node):\n  - DOCSTRING: \n```python\n\"\"\"\nVisit an argument node in an Abstract Syntax Tree (AST) and collect its identifier.\n\nThis method checks for the presence of attributes 'arg' or 'id' in the given `node`, and adds the corresponding identifier to the set of names maintained by the `NameVisitor` instance. This is used to gather all named identifiers in the AST for further analysis.\n\nParameters\n----------\nnode : ast.arg\n    The AST node representing the argument, which is expected to be an instance of `ast.arg`.\n\nReturns\n-------\nNone\n    The method modifies the internal state of the `NameVisitor` instance by adding the identifier to the `names` set, but does not return a value.\n\nDependencies\n------------\nThis method relies on the `names` attribute, which is a set initialized in the `__init__` method of the `NameVisitor` class to store unique identifiers found during AST traversal.\n\"\"\"\n```\n\n- FUNCTION NAME: function_ast_to_function\n  - SIGNATURE: def function_ast_to_function(fn_ast, stacklevel=1):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert an AST representation of a function into an executable function object.\n\nParameters\n----------\nfn_ast: ast.Module\n    The AST representation of a function, containing a single function definition in its body.\n\nstacklevel: int, optional\n    The level of the stack frame to evaluate the function in, default is 1, referencing the immediate caller.\n\nReturns\n-------\nfunction\n    The dynamically created function corresponding to the provided AST.\n\nRaises\n------\nAssertionError\n    If the provided AST does not represent a valid function (i.e., it does not contain an ast.FunctionDef).\n\nDependencies\n------------\n- The function relies on `compile_function_ast` to convert the AST into a code object.\n- It uses `inspect.currentframe` to access the current stack and evaluate the function in the correct context, allowing the created function to access the local and global variables of the caller's environment.\n- `copy` is used to create a new dictionary for the evaluation scope to prevent mutation of the original global scope.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - datashader/macros.py:compile_function_ast\n    - datashader/macros.py:_expand_varargs\n\n- CLASS METHOD: ExpandVarargTransformer.__init__\n  - CLASS SIGNATURE: class ExpandVarargTransformer(ast.NodeTransformer):\n  - SIGNATURE: def __init__(self, starred_name, expand_names, *args, **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the ExpandVarargTransformer class, which is responsible for replacing the starred variable in the AST with a list of specified unstarred variable names.\n\nParameters\n----------\nstarred_name: str\n    The name of the starred argument that will be replaced in the AST.\nexpand_names: list of str\n    A list of new unstarred names that will be used to replace the starred variable.\n*args: Variable length argument list.\n**kwargs: Arbitrary keyword arguments.\n\nThis constructor calls the superclass (NodeTransformer) constructor to initialize the node transformer. The attributes `starred_name` and `expand_names` are stored for use in AST traversal and transformation, allowing the transformer to accurately replace the starred argument during the visitation process.\n\"\"\"\n```\n\n- FUNCTION NAME: _build_arg\n  - SIGNATURE: def _build_arg(name):\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an AST argument node with the specified name.\n\nParameters\n----------\nname: str\n    The name of the argument to be represented in the AST.\n\nReturns\n-------\nast.arg\n    An instance of `ast.arg` initialized with the provided name.\n\nThis function is a utility for constructing argument nodes when modifying \nfunction signatures in an AST. It is particularly used in the `expand_function_ast_varargs` \nfunction to create new fixed argument representations for variable length style arguments.\n\"\"\"\n```\n\n- CLASS METHOD: ExpandVarargTransformerStarred.visit_Starred\n  - CLASS SIGNATURE: class ExpandVarargTransformerStarred(ExpandVarargTransformer):\n  - SIGNATURE: def visit_Starred(self, node):\n  - DOCSTRING: \n```python\n\"\"\"\nVisits a `Starred` AST node and replaces it with a list of unstarred `Name` nodes if the starred variable matches the specified `starred_name`.\n\nParameters\n----------\nnode: ast.Starred\n    The AST node representing a starred expression (e.g., *args).\n\nReturns\n-------\nlist or ast.Starred\n    A list of unstarred `Name` nodes corresponding to the names in `expand_names` if the starred variable's identifier matches `starred_name`. If the identifier does not match, returns the original starred node unchanged.\n\nNotes\n-----\nThis method relies on the attributes `starred_name` and `expand_names`, which are initialized in the `ExpandVarargTransformer` constructor. `starred_name` is the name of the variable to be replaced (e.g., \"args\"), while `expand_names` is a list of new unique names that will replace the starred use. If the node's variable matches `starred_name`, it produces the corresponding `Name` nodes for further use in the AST transformation.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "datashader/macros.py": "\"\"\"\nUtilities for manipulating the Abstract Syntax Tree of Python constructs\n\"\"\"\nimport re\nimport copy\nimport inspect\nimport ast\nimport textwrap\n\nclass NameVisitor(ast.NodeVisitor):\n    \"\"\"\n    NodeVisitor that builds a set of all of the named identifiers in an AST\n    \"\"\"\n\nclass ExpandVarargTransformer(ast.NodeTransformer):\n    \"\"\"\n    Node transformer that replaces the starred use of a variable in an AST\n    with a collection of unstarred named variables.\n    \"\"\"\n\nclass ExpandVarargTransformerStarred(ExpandVarargTransformer):\n\ndef ast_to_source(ast):\n    \"\"\"Convert AST to source code string using the astor package\"\"\"\n    import astor\n    return astor.to_source(ast)"
  }
}