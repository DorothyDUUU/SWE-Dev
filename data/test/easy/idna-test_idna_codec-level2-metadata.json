{
  "dir_path": "/app/idna",
  "package_name": "idna",
  "sample_name": "idna-test_idna_codec",
  "src_dir": "idna/",
  "test_dir": "tests/",
  "test_file": "tests/test_idna_codec.py",
  "test_code": "#!/usr/bin/env python\n\nimport codecs\nimport io\nimport unittest\n\nimport idna.codec\n\nCODEC_NAME = \"idna2008\"\n\n\nclass IDNACodecTests(unittest.TestCase):\n    def setUp(self):\n        from . import test_idna\n\n        self.idnatests = test_idna.IDNATests()\n        self.idnatests.setUp()\n\n    def testCodec(self):\n        self.assertIs(codecs.lookup(CODEC_NAME).incrementalencoder, idna.codec.IncrementalEncoder)\n\n    def testDirectDecode(self):\n        self.idnatests.test_decode(decode=lambda obj: codecs.decode(obj, CODEC_NAME))\n\n    def testIndirectDecode(self):\n        self.idnatests.test_decode(decode=lambda obj: obj.decode(CODEC_NAME), skip_str=True)\n\n    def testDirectEncode(self):\n        self.idnatests.test_encode(encode=lambda obj: codecs.encode(obj, CODEC_NAME))\n\n    def testIndirectEncode(self):\n        self.idnatests.test_encode(encode=lambda obj: obj.encode(CODEC_NAME), skip_bytes=True)\n\n    def testStreamReader(self):\n        def decode(obj):\n            if isinstance(obj, str):\n                obj = bytes(obj, \"ascii\")\n            buffer = io.BytesIO(obj)\n            stream = codecs.getreader(CODEC_NAME)(buffer)\n            return stream.read()\n\n        return self.idnatests.test_decode(decode=decode, skip_str=True)\n\n    def testStreamWriter(self):\n        def encode(obj):\n            buffer = io.BytesIO()\n            stream = codecs.getwriter(CODEC_NAME)(buffer)\n            stream.write(obj)\n            stream.flush()\n            return buffer.getvalue()\n\n        return self.idnatests.test_encode(encode=encode)\n\n    def testIncrementalDecoder(self):\n        # Tests derived from Python standard library test/test_codecs.py\n\n        incremental_tests = (\n            (\"python.org\", b\"python.org\"),\n            (\"python.org.\", b\"python.org.\"),\n            (\"pyth\\xf6n.org\", b\"xn--pythn-mua.org\"),\n            (\"pyth\\xf6n.org.\", b\"xn--pythn-mua.org.\"),\n        )\n\n        for decoded, encoded in incremental_tests:\n            self.assertEqual(\n                \"\".join(codecs.iterdecode((bytes([c]) for c in encoded), CODEC_NAME)),\n                decoded,\n            )\n\n        decoder = codecs.getincrementaldecoder(CODEC_NAME)()\n        self.assertEqual(\n            decoder.decode(\n                b\"xn--xam\",\n            ),\n            \"\",\n        )\n        self.assertEqual(\n            decoder.decode(\n                b\"ple-9ta.o\",\n            ),\n            \"\\xe4xample.\",\n        )\n        self.assertEqual(decoder.decode(b\"rg\"), \"\")\n        self.assertEqual(decoder.decode(b\"\", True), \"org\")\n\n        decoder.reset()\n        self.assertEqual(\n            decoder.decode(\n                b\"xn--xam\",\n            ),\n            \"\",\n        )\n        self.assertEqual(\n            decoder.decode(\n                b\"ple-9ta.o\",\n            ),\n            \"\\xe4xample.\",\n        )\n        self.assertEqual(decoder.decode(b\"rg.\"), \"org.\")\n        self.assertEqual(decoder.decode(b\"\", True), \"\")\n\n    def testIncrementalEncoder(self):\n        # Tests derived from Python standard library test/test_codecs.py\n\n        incremental_tests = (\n            (\"python.org\", b\"python.org\"),\n            (\"python.org.\", b\"python.org.\"),\n            (\"pyth\\xf6n.org\", b\"xn--pythn-mua.org\"),\n            (\"pyth\\xf6n.org.\", b\"xn--pythn-mua.org.\"),\n        )\n        for decoded, encoded in incremental_tests:\n            self.assertEqual(b\"\".join(codecs.iterencode(decoded, CODEC_NAME)), encoded)\n\n        encoder = codecs.getincrementalencoder(CODEC_NAME)()\n        self.assertEqual(encoder.encode(\"\\xe4x\"), b\"\")\n        self.assertEqual(encoder.encode(\"ample.org\"), b\"xn--xample-9ta.\")\n        self.assertEqual(encoder.encode(\"\", True), b\"org\")\n\n        encoder.reset()\n        self.assertEqual(encoder.encode(\"\\xe4x\"), b\"\")\n        self.assertEqual(encoder.encode(\"ample.org.\"), b\"xn--xample-9ta.org.\")\n        self.assertEqual(encoder.encode(\"\", True), b\"\")\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n",
  "GT_file_code": {
    "idna/codec.py": "import codecs\nimport re\nfrom typing import Any, Optional, Tuple\n\nfrom .core import IDNAError, alabel, decode, encode, ulabel\n\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\n\n\nclass Codec(codecs.Codec):\n    def encode(self, data: str, errors: str = \"strict\") -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return b\"\", 0\n\n        return encode(data), len(data)\n\n    def decode(self, data: bytes, errors: str = \"strict\") -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return \"\", 0\n\n        return decode(data), len(data)\n\n\nclass IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return b\"\", 0\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = b\"\"\n        if labels:\n            if not labels[-1]:\n                trailing_dot = b\".\"\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = b\".\"\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(alabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        # Join with U+002E\n        result_bytes = b\".\".join(result) + trailing_dot\n        size += len(trailing_dot)\n        return result_bytes, size\n\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n        if errors != \"strict\":\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n\n        if not data:\n            return (\"\", 0)\n\n        if not isinstance(data, str):\n            data = str(data, \"ascii\")\n\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = \"\"\n        if labels:\n            if not labels[-1]:\n                trailing_dot = \".\"\n                del labels[-1]\n            elif not final:\n                # Keep potentially unfinished label until the next call\n                del labels[-1]\n                if labels:\n                    trailing_dot = \".\"\n\n        result = []\n        size = 0\n        for label in labels:\n            result.append(ulabel(label))\n            if size:\n                size += 1\n            size += len(label)\n\n        result_str = \".\".join(result) + trailing_dot\n        size += len(trailing_dot)\n        return (result_str, size)\n\n\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\n\n\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\n\n\ndef search_function(name: str) -> Optional[codecs.CodecInfo]:\n    if name != \"idna2008\":\n        return None\n    return codecs.CodecInfo(\n        name=name,\n        encode=Codec().encode,\n        decode=Codec().decode,\n        incrementalencoder=IncrementalEncoder,\n        incrementaldecoder=IncrementalDecoder,\n        streamwriter=StreamWriter,\n        streamreader=StreamReader,\n    )\n\n\ncodecs.register(search_function)\n",
    "idna/core.py": "import bisect\nimport re\nimport unicodedata\nfrom typing import Optional, Union\n\nfrom . import idnadata\nfrom .intranges import intranges_contain\n\n_virama_combining_class = 9\n_alabel_prefix = b\"xn--\"\n_unicode_dots_re = re.compile(\"[\\u002e\\u3002\\uff0e\\uff61]\")\n\n\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n\n    pass\n\n\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n\n    pass\n\n\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n\n    pass\n\n\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n\n    pass\n\n\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):\n            raise ValueError(\"Unknown character in unicodedata\")\n    return v\n\n\ndef _is_script(cp: str, script: str) -> bool:\n    return intranges_contain(ord(cp), idnadata.scripts[script])\n\n\ndef _punycode(s: str) -> bytes:\n    return s.encode(\"punycode\")\n\n\ndef _unot(s: int) -> str:\n    return \"U+{:04X}\".format(s)\n\n\ndef valid_label_length(label: Union[bytes, str]) -> bool:\n    if len(label) > 63:\n        return False\n    return True\n\n\ndef valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\n\n\ndef check_bidi(label: str, check_ltr: bool = False) -> bool:\n    # Bidi rules should only be applied if string contains RTL characters\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == \"\":\n            # String likely comes from a newer version of Unicode\n            raise IDNABidiError(\"Unknown directionality in label {} at position {}\".format(repr(label), idx))\n        if direction in [\"R\", \"AL\", \"AN\"]:\n            bidi_label = True\n    if not bidi_label and not check_ltr:\n        return True\n\n    # Bidi rule 1\n    direction = unicodedata.bidirectional(label[0])\n    if direction in [\"R\", \"AL\"]:\n        rtl = True\n    elif direction == \"L\":\n        rtl = False\n    else:\n        raise IDNABidiError(\"First codepoint in label {} must be directionality L, R or AL\".format(repr(label)))\n\n    valid_ending = False\n    number_type: Optional[str] = None\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n\n        if rtl:\n            # Bidi rule 2\n            if direction not in [\n                \"R\",\n                \"AL\",\n                \"AN\",\n                \"EN\",\n                \"ES\",\n                \"CS\",\n                \"ET\",\n                \"ON\",\n                \"BN\",\n                \"NSM\",\n            ]:\n                raise IDNABidiError(\"Invalid direction for codepoint at position {} in a right-to-left label\".format(idx))\n            # Bidi rule 3\n            if direction in [\"R\", \"AL\", \"EN\", \"AN\"]:\n                valid_ending = True\n            elif direction != \"NSM\":\n                valid_ending = False\n            # Bidi rule 4\n            if direction in [\"AN\", \"EN\"]:\n                if not number_type:\n                    number_type = direction\n                else:\n                    if number_type != direction:\n                        raise IDNABidiError(\"Can not mix numeral types in a right-to-left label\")\n        else:\n            # Bidi rule 5\n            if direction not in [\"L\", \"EN\", \"ES\", \"CS\", \"ET\", \"ON\", \"BN\", \"NSM\"]:\n                raise IDNABidiError(\"Invalid direction for codepoint at position {} in a left-to-right label\".format(idx))\n            # Bidi rule 6\n            if direction in [\"L\", \"EN\"]:\n                valid_ending = True\n            elif direction != \"NSM\":\n                valid_ending = False\n\n    if not valid_ending:\n        raise IDNABidiError(\"Label ends with illegal codepoint directionality\")\n\n    return True\n\n\ndef check_initial_combiner(label: str) -> bool:\n    if unicodedata.category(label[0])[0] == \"M\":\n        raise IDNAError(\"Label begins with an illegal combining character\")\n    return True\n\n\ndef check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == \"--\":\n        raise IDNAError(\"Label has disallowed hyphens in 3rd and 4th position\")\n    if label[0] == \"-\" or label[-1] == \"-\":\n        raise IDNAError(\"Label must not start or end with a hyphen\")\n    return True\n\n\ndef check_nfc(label: str) -> None:\n    if unicodedata.normalize(\"NFC\", label) != label:\n        raise IDNAError(\"Label must be in Normalization Form C\")\n\n\ndef valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n\n    if cp_value == 0x200C:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n\n        ok = False\n        for i in range(pos - 1, -1, -1):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord(\"T\"):\n                continue\n            elif joining_type in [ord(\"L\"), ord(\"D\")]:\n                ok = True\n                break\n            else:\n                break\n\n        if not ok:\n            return False\n\n        ok = False\n        for i in range(pos + 1, len(label)):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord(\"T\"):\n                continue\n            elif joining_type in [ord(\"R\"), ord(\"D\")]:\n                ok = True\n                break\n            else:\n                break\n        return ok\n\n    if cp_value == 0x200D:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        return False\n\n    else:\n        return False\n\n\ndef valid_contexto(label: str, pos: int, exception: bool = False) -> bool:\n    cp_value = ord(label[pos])\n\n    if cp_value == 0x00B7:\n        if 0 < pos < len(label) - 1:\n            if ord(label[pos - 1]) == 0x006C and ord(label[pos + 1]) == 0x006C:\n                return True\n        return False\n\n    elif cp_value == 0x0375:\n        if pos < len(label) - 1 and len(label) > 1:\n            return _is_script(label[pos + 1], \"Greek\")\n        return False\n\n    elif cp_value == 0x05F3 or cp_value == 0x05F4:\n        if pos > 0:\n            return _is_script(label[pos - 1], \"Hebrew\")\n        return False\n\n    elif cp_value == 0x30FB:\n        for cp in label:\n            if cp == \"\\u30fb\":\n                continue\n            if _is_script(cp, \"Hiragana\") or _is_script(cp, \"Katakana\") or _is_script(cp, \"Han\"):\n                return True\n        return False\n\n    elif 0x660 <= cp_value <= 0x669:\n        for cp in label:\n            if 0x6F0 <= ord(cp) <= 0x06F9:\n                return False\n        return True\n\n    elif 0x6F0 <= cp_value <= 0x6F9:\n        for cp in label:\n            if 0x660 <= ord(cp) <= 0x0669:\n                return False\n        return True\n\n    return False\n\n\ndef check_label(label: Union[str, bytes, bytearray]) -> None:\n    if isinstance(label, (bytes, bytearray)):\n        label = label.decode(\"utf-8\")\n    if len(label) == 0:\n        raise IDNAError(\"Empty Label\")\n\n    check_nfc(label)\n    check_hyphen_ok(label)\n    check_initial_combiner(label)\n\n    for pos, cp in enumerate(label):\n        cp_value = ord(cp)\n        if intranges_contain(cp_value, idnadata.codepoint_classes[\"PVALID\"]):\n            continue\n        elif intranges_contain(cp_value, idnadata.codepoint_classes[\"CONTEXTJ\"]):\n            try:\n                if not valid_contextj(label, pos):\n                    raise InvalidCodepointContext(\n                        \"Joiner {} not allowed at position {} in {}\".format(_unot(cp_value), pos + 1, repr(label))\n                    )\n            except ValueError:\n                raise IDNAError(\n                    \"Unknown codepoint adjacent to joiner {} at position {} in {}\".format(\n                        _unot(cp_value), pos + 1, repr(label)\n                    )\n                )\n        elif intranges_contain(cp_value, idnadata.codepoint_classes[\"CONTEXTO\"]):\n            if not valid_contexto(label, pos):\n                raise InvalidCodepointContext(\n                    \"Codepoint {} not allowed at position {} in {}\".format(_unot(cp_value), pos + 1, repr(label))\n                )\n        else:\n            raise InvalidCodepoint(\n                \"Codepoint {} at position {} of {} not allowed\".format(_unot(cp_value), pos + 1, repr(label))\n            )\n\n    check_bidi(label)\n\n\ndef alabel(label: str) -> bytes:\n    try:\n        label_bytes = label.encode(\"ascii\")\n        ulabel(label_bytes)\n        if not valid_label_length(label_bytes):\n            raise IDNAError(\"Label too long\")\n        return label_bytes\n    except UnicodeEncodeError:\n        pass\n\n    check_label(label)\n    label_bytes = _alabel_prefix + _punycode(label)\n\n    if not valid_label_length(label_bytes):\n        raise IDNAError(\"Label too long\")\n\n    return label_bytes\n\n\ndef ulabel(label: Union[str, bytes, bytearray]) -> str:\n    if not isinstance(label, (bytes, bytearray)):\n        try:\n            label_bytes = label.encode(\"ascii\")\n        except UnicodeEncodeError:\n            check_label(label)\n            return label\n    else:\n        label_bytes = label\n\n    label_bytes = label_bytes.lower()\n    if label_bytes.startswith(_alabel_prefix):\n        label_bytes = label_bytes[len(_alabel_prefix) :]\n        if not label_bytes:\n            raise IDNAError(\"Malformed A-label, no Punycode eligible content found\")\n        if label_bytes.decode(\"ascii\")[-1] == \"-\":\n            raise IDNAError(\"A-label must not end with a hyphen\")\n    else:\n        check_label(label_bytes)\n        return label_bytes.decode(\"ascii\")\n\n    try:\n        label = label_bytes.decode(\"punycode\")\n    except UnicodeError:\n        raise IDNAError(\"Invalid A-label\")\n    check_label(label)\n    return label\n\n\ndef uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:\n    \"\"\"Re-map the characters in the string according to UTS46 processing.\"\"\"\n    from .uts46data import uts46data\n\n    output = \"\"\n\n    for pos, char in enumerate(domain):\n        code_point = ord(char)\n        try:\n            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, \"Z\")) - 1]\n            status = uts46row[1]\n            replacement: Optional[str] = None\n            if len(uts46row) == 3:\n                replacement = uts46row[2]\n            if (\n                status == \"V\"\n                or (status == \"D\" and not transitional)\n                or (status == \"3\" and not std3_rules and replacement is None)\n            ):\n                output += char\n            elif replacement is not None and (\n                status == \"M\" or (status == \"3\" and not std3_rules) or (status == \"D\" and transitional)\n            ):\n                output += replacement\n            elif status != \"I\":\n                raise IndexError()\n        except IndexError:\n            raise InvalidCodepoint(\n                \"Codepoint {} not allowed at position {} in {}\".format(_unot(code_point), pos + 1, repr(domain))\n            )\n\n    return unicodedata.normalize(\"NFC\", output)\n\n\ndef encode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n    transitional: bool = False,\n) -> bytes:\n    if not isinstance(s, str):\n        try:\n            s = str(s, \"ascii\")\n        except UnicodeDecodeError:\n            raise IDNAError(\"should pass a unicode string to the function rather than a byte string.\")\n    if uts46:\n        s = uts46_remap(s, std3_rules, transitional)\n    trailing_dot = False\n    result = []\n    if strict:\n        labels = s.split(\".\")\n    else:\n        labels = _unicode_dots_re.split(s)\n    if not labels or labels == [\"\"]:\n        raise IDNAError(\"Empty domain\")\n    if labels[-1] == \"\":\n        del labels[-1]\n        trailing_dot = True\n    for label in labels:\n        s = alabel(label)\n        if s:\n            result.append(s)\n        else:\n            raise IDNAError(\"Empty label\")\n    if trailing_dot:\n        result.append(b\"\")\n    s = b\".\".join(result)\n    if not valid_string_length(s, trailing_dot):\n        raise IDNAError(\"Domain too long\")\n    return s\n\n\ndef decode(\n    s: Union[str, bytes, bytearray],\n    strict: bool = False,\n    uts46: bool = False,\n    std3_rules: bool = False,\n) -> str:\n    try:\n        if not isinstance(s, str):\n            s = str(s, \"ascii\")\n    except UnicodeDecodeError:\n        raise IDNAError(\"Invalid ASCII in A-label\")\n    if uts46:\n        s = uts46_remap(s, std3_rules, False)\n    trailing_dot = False\n    result = []\n    if not strict:\n        labels = _unicode_dots_re.split(s)\n    else:\n        labels = s.split(\".\")\n    if not labels or labels == [\"\"]:\n        raise IDNAError(\"Empty domain\")\n    if not labels[-1]:\n        del labels[-1]\n        trailing_dot = True\n    for label in labels:\n        s = ulabel(label)\n        if s:\n            result.append(s)\n        else:\n            raise IDNAError(\"Empty label\")\n    if trailing_dot:\n        result.append(\"\")\n    return \".\".join(result)\n"
  },
  "GT_src_dict": {
    "idna/codec.py": {
      "Codec.encode": {
        "code": "    def encode(self, data: str, errors: str='strict') -> Tuple[bytes, int]:\n        \"\"\"Encodes the provided Unicode `data` string into bytes using IDNA (Internationalized Domain Names in Applications) encoding.\n\nParameters:\n- data (str): The input string to be encoded. Must be a valid Unicode string.\n- errors (str, optional): Specifies the error handling scheme. Currently only \"strict\" is supported, which raises an IDNAError for any unsupported error handling options.\n\nReturns:\n- Tuple[bytes, int]: A tuple containing the encoded byte representation of the input string and the length of the original string.\n\nRaises:\n- IDNAError: Raises this error if an unsupported error handling scheme is provided.\n\nNotes:\n- This method relies on the `encode` function imported from the `core` module, which performs the actual encoding process.\n- The method also utilizes the IDNAError class defined in the `core` module to handle errors related to encoding.\"\"\"\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return (b'', 0)\n        return (encode(data), len(data))",
        "docstring": "Encodes the provided Unicode `data` string into bytes using IDNA (Internationalized Domain Names in Applications) encoding.\n\nParameters:\n- data (str): The input string to be encoded. Must be a valid Unicode string.\n- errors (str, optional): Specifies the error handling scheme. Currently only \"strict\" is supported, which raises an IDNAError for any unsupported error handling options.\n\nReturns:\n- Tuple[bytes, int]: A tuple containing the encoded byte representation of the input string and the length of the original string.\n\nRaises:\n- IDNAError: Raises this error if an unsupported error handling scheme is provided.\n\nNotes:\n- This method relies on the `encode` function imported from the `core` module, which performs the actual encoding process.\n- The method also utilizes the IDNAError class defined in the `core` module to handle errors related to encoding.",
        "signature": "def encode(self, data: str, errors: str='strict') -> Tuple[bytes, int]:",
        "type": "Method",
        "class_signature": "class Codec(codecs.Codec):"
      },
      "Codec.decode": {
        "code": "    def decode(self, data: bytes, errors: str='strict') -> Tuple[str, int]:\n        \"\"\"Decode a byte string in IDNA (Internationalized Domain Names in Applications) format into a Unicode string.\n\nParameters:\n- data (bytes): The byte string to decode. Must be in IDNA format.\n- errors (str, optional): Specifies the error handling scheme to use. Must be \"strict\"; otherwise, an IDNAError is raised. Default is \"strict\".\n\nReturns:\n- Tuple[str, int]: A tuple containing the decoded Unicode string and the length of the input data.\n\nRaises:\n- IDNAError: If the error handling scheme is not \"strict\".\n\nThis method relies on the external `decode` function, defined elsewhere in the code, to perform the actual decoding of the byte string.\"\"\"\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return ('', 0)\n        return (decode(data), len(data))",
        "docstring": "Decode a byte string in IDNA (Internationalized Domain Names in Applications) format into a Unicode string.\n\nParameters:\n- data (bytes): The byte string to decode. Must be in IDNA format.\n- errors (str, optional): Specifies the error handling scheme to use. Must be \"strict\"; otherwise, an IDNAError is raised. Default is \"strict\".\n\nReturns:\n- Tuple[str, int]: A tuple containing the decoded Unicode string and the length of the input data.\n\nRaises:\n- IDNAError: If the error handling scheme is not \"strict\".\n\nThis method relies on the external `decode` function, defined elsewhere in the code, to perform the actual decoding of the byte string.",
        "signature": "def decode(self, data: bytes, errors: str='strict') -> Tuple[str, int]:",
        "type": "Method",
        "class_signature": "class Codec(codecs.Codec):"
      },
      "IncrementalEncoder._buffer_encode": {
        "code": "    def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n        \"\"\"Buffers and encodes input data into bytes suitable for IDNA (Internationalized Domain Names in Applications) encoding. The method splits the input string into labels using the `_unicode_dots_re` regular expression, which identifies various dot characters. It encodes each label into ASCII-compatible format using the `alabel` function, and handles trailing dots based on the presence of incomplete labels in the stream. \n\nParameters:\n- data (str): The input string to be encoded.\n- errors (str): The error handling scheme to use. Only \"strict\" is supported.\n- final (bool): Indicates if this call is the last in the sequence for encoding.\n\nReturns:\n- Tuple[bytes, int]: A tuple consisting of the encoded byte string and the total number of input characters processed.\n\nRaises `IDNAError` if the error handling scheme is unsupported. Note that trailing dots in the encoded result are managed based on the input label structure, either preserving or discarding them based on whether a complete label is obtained.\"\"\"\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return (b'', 0)\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = b''\n        if labels:\n            if not labels[-1]:\n                trailing_dot = b'.'\n                del labels[-1]\n            elif not final:\n                del labels[-1]\n                if labels:\n                    trailing_dot = b'.'\n        result = []\n        size = 0\n        for label in labels:\n            result.append(alabel(label))\n            if size:\n                size += 1\n            size += len(label)\n        result_bytes = b'.'.join(result) + trailing_dot\n        size += len(trailing_dot)\n        return (result_bytes, size)",
        "docstring": "Buffers and encodes input data into bytes suitable for IDNA (Internationalized Domain Names in Applications) encoding. The method splits the input string into labels using the `_unicode_dots_re` regular expression, which identifies various dot characters. It encodes each label into ASCII-compatible format using the `alabel` function, and handles trailing dots based on the presence of incomplete labels in the stream. \n\nParameters:\n- data (str): The input string to be encoded.\n- errors (str): The error handling scheme to use. Only \"strict\" is supported.\n- final (bool): Indicates if this call is the last in the sequence for encoding.\n\nReturns:\n- Tuple[bytes, int]: A tuple consisting of the encoded byte string and the total number of input characters processed.\n\nRaises `IDNAError` if the error handling scheme is unsupported. Note that trailing dots in the encoded result are managed based on the input label structure, either preserving or discarding them based on whether a complete label is obtained.",
        "signature": "def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:",
        "type": "Method",
        "class_signature": "class IncrementalEncoder(codecs.BufferedIncrementalEncoder):"
      },
      "IncrementalDecoder._buffer_decode": {
        "code": "    def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n        \"\"\"Decodes a byte string containing Internationalized Domain Names (IDN) into a Unicode string.\n\nParameters:\n- data (Any): The input byte string to decode. If not in string format, it will be converted from ASCII.\n- errors (str): Error handling scheme; must be \"strict\", or an IDNAError will be raised.\n- final (bool): Indicates whether this is the final chunk of data; affects how trailing dots are handled.\n\nReturns:\n- Tuple[str, int]: A tuple containing the decoded Unicode string and the number of bytes processed.\n\nThis method uses the `_unicode_dots_re` regular expression to split the input data into labels based on specified Unicode dot characters. It interacts with the `ulabel()` function to process each label and handles trailing dots according to the rules of IDN encoding. The function is part of the `IncrementalDecoder` class, which is intended for incrementally decoding data in manageable pieces.\"\"\"\n        if errors != 'strict':\n            raise IDNAError('Unsupported error handling \"{}\"'.format(errors))\n        if not data:\n            return ('', 0)\n        if not isinstance(data, str):\n            data = str(data, 'ascii')\n        labels = _unicode_dots_re.split(data)\n        trailing_dot = ''\n        if labels:\n            if not labels[-1]:\n                trailing_dot = '.'\n                del labels[-1]\n            elif not final:\n                del labels[-1]\n                if labels:\n                    trailing_dot = '.'\n        result = []\n        size = 0\n        for label in labels:\n            result.append(ulabel(label))\n            if size:\n                size += 1\n            size += len(label)\n        result_str = '.'.join(result) + trailing_dot\n        size += len(trailing_dot)\n        return (result_str, size)",
        "docstring": "Decodes a byte string containing Internationalized Domain Names (IDN) into a Unicode string.\n\nParameters:\n- data (Any): The input byte string to decode. If not in string format, it will be converted from ASCII.\n- errors (str): Error handling scheme; must be \"strict\", or an IDNAError will be raised.\n- final (bool): Indicates whether this is the final chunk of data; affects how trailing dots are handled.\n\nReturns:\n- Tuple[str, int]: A tuple containing the decoded Unicode string and the number of bytes processed.\n\nThis method uses the `_unicode_dots_re` regular expression to split the input data into labels based on specified Unicode dot characters. It interacts with the `ulabel()` function to process each label and handles trailing dots according to the rules of IDN encoding. The function is part of the `IncrementalDecoder` class, which is intended for incrementally decoding data in manageable pieces.",
        "signature": "def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:",
        "type": "Method",
        "class_signature": "class IncrementalDecoder(codecs.BufferedIncrementalDecoder):"
      },
      "search_function": {
        "code": "def search_function(name: str) -> Optional[codecs.CodecInfo]:\n    \"\"\"Returns a `codecs.CodecInfo` object for the 'idna2008' codec if the specified name matches. This function acts as a search function for codecs, enabling the registration of the 'idna2008' encoding and decoding methods within Python's codec registry.\n\nParameters:\n- name (str): The name of the codec to search for.\n\nReturns:\n- Optional[codecs.CodecInfo]: A `CodecInfo` object containing encoding and decoding methods, as well as incremental encoder/decoder and stream writer/reader classes if the name matches 'idna2008'; otherwise, returns None.\n\nDependencies:\nThe function relies on the `Codec`, `IncrementalEncoder`, `IncrementalDecoder`, `StreamWriter`, and `StreamReader` classes defined in the same module, which implement the actual encoding/decoding logic and streaming capabilities for IDNA (Internationalized Domain Names in Applications) as per the specifications.\"\"\"\n    if name != 'idna2008':\n        return None\n    return codecs.CodecInfo(name=name, encode=Codec().encode, decode=Codec().decode, incrementalencoder=IncrementalEncoder, incrementaldecoder=IncrementalDecoder, streamwriter=StreamWriter, streamreader=StreamReader)",
        "docstring": "Returns a `codecs.CodecInfo` object for the 'idna2008' codec if the specified name matches. This function acts as a search function for codecs, enabling the registration of the 'idna2008' encoding and decoding methods within Python's codec registry.\n\nParameters:\n- name (str): The name of the codec to search for.\n\nReturns:\n- Optional[codecs.CodecInfo]: A `CodecInfo` object containing encoding and decoding methods, as well as incremental encoder/decoder and stream writer/reader classes if the name matches 'idna2008'; otherwise, returns None.\n\nDependencies:\nThe function relies on the `Codec`, `IncrementalEncoder`, `IncrementalDecoder`, `StreamWriter`, and `StreamReader` classes defined in the same module, which implement the actual encoding/decoding logic and streaming capabilities for IDNA (Internationalized Domain Names in Applications) as per the specifications.",
        "signature": "def search_function(name: str) -> Optional[codecs.CodecInfo]:",
        "type": "Function",
        "class_signature": null
      }
    },
    "idna/core.py": {
      "alabel": {
        "code": "def alabel(label: str) -> bytes:\n    \"\"\"Convert a Unicode string label into an ASCII-compatible encoding (A-label) using Punycode.\n\nParameters:\n- label (str): The Unicode string to be converted into an ASCII label.\n\nReturns:\n- bytes: The corresponding ASCII A-label encoded in bytes, prefixed with 'xn--' if Punycode conversion is required.\n\nRaises:\n- IDNAError: If the label is too long, contains invalid characters, or violates IDNA constraints.\n\nDependencies:\n- The function utilizes `valid_label_length` to check the length of the label and `_punycode` to perform the Punycode encoding. \n- `_alabel_prefix` is a constant defined as `b\"xn--\"` which is prepended to the Punycode-encoded label to indicate it is an A-label.\n- The `ulabel` function is also called to ensure compliance with decode expectations for valid ASCII labels.\"\"\"\n    try:\n        label_bytes = label.encode('ascii')\n        ulabel(label_bytes)\n        if not valid_label_length(label_bytes):\n            raise IDNAError('Label too long')\n        return label_bytes\n    except UnicodeEncodeError:\n        pass\n    check_label(label)\n    label_bytes = _alabel_prefix + _punycode(label)\n    if not valid_label_length(label_bytes):\n        raise IDNAError('Label too long')\n    return label_bytes",
        "docstring": "Convert a Unicode string label into an ASCII-compatible encoding (A-label) using Punycode.\n\nParameters:\n- label (str): The Unicode string to be converted into an ASCII label.\n\nReturns:\n- bytes: The corresponding ASCII A-label encoded in bytes, prefixed with 'xn--' if Punycode conversion is required.\n\nRaises:\n- IDNAError: If the label is too long, contains invalid characters, or violates IDNA constraints.\n\nDependencies:\n- The function utilizes `valid_label_length` to check the length of the label and `_punycode` to perform the Punycode encoding. \n- `_alabel_prefix` is a constant defined as `b\"xn--\"` which is prepended to the Punycode-encoded label to indicate it is an A-label.\n- The `ulabel` function is also called to ensure compliance with decode expectations for valid ASCII labels.",
        "signature": "def alabel(label: str) -> bytes:",
        "type": "Function",
        "class_signature": null
      },
      "ulabel": {
        "code": "def ulabel(label: Union[str, bytes, bytearray]) -> str:\n    \"\"\"Convert an ASCII-compatible encoding of a domain name (A-label) to its Unicode representation.\n\nParameters:\n- label (Union[str, bytes, bytearray]): The A-label to convert. It can be a string, bytes, or bytearray. It must either be a valid ASCII string with the prefix 'xn--' or a valid UTF-8 string.\n\nReturns:\n- str: The decoded Unicode representation of the input A-label.\n\nRaises:\n- IDNAError: If the label is malformed, contains disallowed characters, or does not comply with IDNA specifications.\n\nDependencies:\n- This function interacts with the `check_label` function to validate the label and may raise exceptions derived from `IDNAError` based on those validations.\n- It uses the `_alabel_prefix` constant (`b\"xn--\"`) to identify the prefix for A-labels. It also uses the Punycode encoding/decoding process to convert the label appropriately.\"\"\"\n    if not isinstance(label, (bytes, bytearray)):\n        try:\n            label_bytes = label.encode('ascii')\n        except UnicodeEncodeError:\n            check_label(label)\n            return label\n    else:\n        label_bytes = label\n    label_bytes = label_bytes.lower()\n    if label_bytes.startswith(_alabel_prefix):\n        label_bytes = label_bytes[len(_alabel_prefix):]\n        if not label_bytes:\n            raise IDNAError('Malformed A-label, no Punycode eligible content found')\n        if label_bytes.decode('ascii')[-1] == '-':\n            raise IDNAError('A-label must not end with a hyphen')\n    else:\n        check_label(label_bytes)\n        return label_bytes.decode('ascii')\n    try:\n        label = label_bytes.decode('punycode')\n    except UnicodeError:\n        raise IDNAError('Invalid A-label')\n    check_label(label)\n    return label",
        "docstring": "Convert an ASCII-compatible encoding of a domain name (A-label) to its Unicode representation.\n\nParameters:\n- label (Union[str, bytes, bytearray]): The A-label to convert. It can be a string, bytes, or bytearray. It must either be a valid ASCII string with the prefix 'xn--' or a valid UTF-8 string.\n\nReturns:\n- str: The decoded Unicode representation of the input A-label.\n\nRaises:\n- IDNAError: If the label is malformed, contains disallowed characters, or does not comply with IDNA specifications.\n\nDependencies:\n- This function interacts with the `check_label` function to validate the label and may raise exceptions derived from `IDNAError` based on those validations.\n- It uses the `_alabel_prefix` constant (`b\"xn--\"`) to identify the prefix for A-labels. It also uses the Punycode encoding/decoding process to convert the label appropriately.",
        "signature": "def ulabel(label: Union[str, bytes, bytearray]) -> str:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: idna-test_idna_codec\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 idna/\n    \u251c\u2500\u2500 codec.py\n    \u2502   \u251c\u2500\u2500 Codec.decode\n    \u2502   \u251c\u2500\u2500 Codec.encode\n    \u2502   \u251c\u2500\u2500 IncrementalDecoder._buffer_decode\n    \u2502   \u251c\u2500\u2500 IncrementalEncoder._buffer_encode\n    \u2502   \u2514\u2500\u2500 search_function\n    \u2514\u2500\u2500 core.py\n        \u251c\u2500\u2500 alabel\n        \u2514\u2500\u2500 ulabel\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for validating, encoding, and decoding domain names in compliance with the IDNA 2008 standard, which supports internationalized domain names by converting them to a punycode representation suitable for DNS systems. It ensures accurate transformations between Unicode and ASCII representations of domain names while handling incremental processing, direct encoding/decoding, and streaming operations seamlessly. By offering robust and standardized processing of internationalized domain names, the module solves the problem of ensuring compatibility between user-friendly domain name formats and the requirements of underlying network protocols. This simplifies the development and maintenance of software that needs to handle internationalized domain names reliably and efficiently.\n\n## FILE 1: idna/codec.py\n\n- CLASS METHOD: Codec.decode\n  - CLASS SIGNATURE: class Codec(codecs.Codec):\n  - SIGNATURE: def decode(self, data: bytes, errors: str='strict') -> Tuple[str, int]:\n  - DOCSTRING: \n```python\n\"\"\"\nDecode a byte string in IDNA (Internationalized Domain Names in Applications) format into a Unicode string.\n\nParameters:\n- data (bytes): The byte string to decode. Must be in IDNA format.\n- errors (str, optional): Specifies the error handling scheme to use. Must be \"strict\"; otherwise, an IDNAError is raised. Default is \"strict\".\n\nReturns:\n- Tuple[str, int]: A tuple containing the decoded Unicode string and the length of the input data.\n\nRaises:\n- IDNAError: If the error handling scheme is not \"strict\".\n\nThis method relies on the external `decode` function, defined elsewhere in the code, to perform the actual decoding of the byte string.\n\"\"\"\n```\n\n- CLASS METHOD: IncrementalDecoder._buffer_decode\n  - CLASS SIGNATURE: class IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n  - SIGNATURE: def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:\n  - DOCSTRING: \n```python\n\"\"\"\nDecodes a byte string containing Internationalized Domain Names (IDN) into a Unicode string.\n\nParameters:\n- data (Any): The input byte string to decode. If not in string format, it will be converted from ASCII.\n- errors (str): Error handling scheme; must be \"strict\", or an IDNAError will be raised.\n- final (bool): Indicates whether this is the final chunk of data; affects how trailing dots are handled.\n\nReturns:\n- Tuple[str, int]: A tuple containing the decoded Unicode string and the number of bytes processed.\n\nThis method uses the `_unicode_dots_re` regular expression to split the input data into labels based on specified Unicode dot characters. It interacts with the `ulabel()` function to process each label and handles trailing dots according to the rules of IDN encoding. The function is part of the `IncrementalDecoder` class, which is intended for incrementally decoding data in manageable pieces.\n\"\"\"\n```\n\n- FUNCTION NAME: search_function\n  - SIGNATURE: def search_function(name: str) -> Optional[codecs.CodecInfo]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a `codecs.CodecInfo` object for the 'idna2008' codec if the specified name matches. This function acts as a search function for codecs, enabling the registration of the 'idna2008' encoding and decoding methods within Python's codec registry.\n\nParameters:\n- name (str): The name of the codec to search for.\n\nReturns:\n- Optional[codecs.CodecInfo]: A `CodecInfo` object containing encoding and decoding methods, as well as incremental encoder/decoder and stream writer/reader classes if the name matches 'idna2008'; otherwise, returns None.\n\nDependencies:\nThe function relies on the `Codec`, `IncrementalEncoder`, `IncrementalDecoder`, `StreamWriter`, and `StreamReader` classes defined in the same module, which implement the actual encoding/decoding logic and streaming capabilities for IDNA (Internationalized Domain Names in Applications) as per the specifications.\n\"\"\"\n```\n\n- CLASS METHOD: Codec.encode\n  - CLASS SIGNATURE: class Codec(codecs.Codec):\n  - SIGNATURE: def encode(self, data: str, errors: str='strict') -> Tuple[bytes, int]:\n  - DOCSTRING: \n```python\n\"\"\"\nEncodes the provided Unicode `data` string into bytes using IDNA (Internationalized Domain Names in Applications) encoding.\n\nParameters:\n- data (str): The input string to be encoded. Must be a valid Unicode string.\n- errors (str, optional): Specifies the error handling scheme. Currently only \"strict\" is supported, which raises an IDNAError for any unsupported error handling options.\n\nReturns:\n- Tuple[bytes, int]: A tuple containing the encoded byte representation of the input string and the length of the original string.\n\nRaises:\n- IDNAError: Raises this error if an unsupported error handling scheme is provided.\n\nNotes:\n- This method relies on the `encode` function imported from the `core` module, which performs the actual encoding process.\n- The method also utilizes the IDNAError class defined in the `core` module to handle errors related to encoding.\n\"\"\"\n```\n\n- CLASS METHOD: IncrementalEncoder._buffer_encode\n  - CLASS SIGNATURE: class IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n  - SIGNATURE: def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:\n  - DOCSTRING: \n```python\n\"\"\"\nBuffers and encodes input data into bytes suitable for IDNA (Internationalized Domain Names in Applications) encoding. The method splits the input string into labels using the `_unicode_dots_re` regular expression, which identifies various dot characters. It encodes each label into ASCII-compatible format using the `alabel` function, and handles trailing dots based on the presence of incomplete labels in the stream. \n\nParameters:\n- data (str): The input string to be encoded.\n- errors (str): The error handling scheme to use. Only \"strict\" is supported.\n- final (bool): Indicates if this call is the last in the sequence for encoding.\n\nReturns:\n- Tuple[bytes, int]: A tuple consisting of the encoded byte string and the total number of input characters processed.\n\nRaises `IDNAError` if the error handling scheme is unsupported. Note that trailing dots in the encoded result are managed based on the input label structure, either preserving or discarding them based on whether a complete label is obtained.\n\"\"\"\n```\n\n## FILE 2: idna/core.py\n\n- FUNCTION NAME: ulabel\n  - SIGNATURE: def ulabel(label: Union[str, bytes, bytearray]) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nConvert an ASCII-compatible encoding of a domain name (A-label) to its Unicode representation.\n\nParameters:\n- label (Union[str, bytes, bytearray]): The A-label to convert. It can be a string, bytes, or bytearray. It must either be a valid ASCII string with the prefix 'xn--' or a valid UTF-8 string.\n\nReturns:\n- str: The decoded Unicode representation of the input A-label.\n\nRaises:\n- IDNAError: If the label is malformed, contains disallowed characters, or does not comply with IDNA specifications.\n\nDependencies:\n- This function interacts with the `check_label` function to validate the label and may raise exceptions derived from `IDNAError` based on those validations.\n- It uses the `_alabel_prefix` constant (`b\"xn--\"`) to identify the prefix for A-labels. It also uses the Punycode encoding/decoding process to convert the label appropriately.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - idna/core.py:check_label\n    - idna/codec.py:IncrementalDecoder:_buffer_decode\n\n- FUNCTION NAME: alabel\n  - SIGNATURE: def alabel(label: str) -> bytes:\n  - DOCSTRING: \n```python\n\"\"\"\nConvert a Unicode string label into an ASCII-compatible encoding (A-label) using Punycode.\n\nParameters:\n- label (str): The Unicode string to be converted into an ASCII label.\n\nReturns:\n- bytes: The corresponding ASCII A-label encoded in bytes, prefixed with 'xn--' if Punycode conversion is required.\n\nRaises:\n- IDNAError: If the label is too long, contains invalid characters, or violates IDNA constraints.\n\nDependencies:\n- The function utilizes `valid_label_length` to check the length of the label and `_punycode` to perform the Punycode encoding. \n- `_alabel_prefix` is a constant defined as `b\"xn--\"` which is prepended to the Punycode-encoded label to indicate it is an A-label.\n- The `ulabel` function is also called to ensure compliance with decode expectations for valid ASCII labels.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - idna/core.py:check_label\n    - idna/core.py:ulabel\n    - idna/codec.py:IncrementalEncoder:_buffer_encode\n    - idna/core.py:_punycode\n    - idna/core.py:valid_label_length\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "idna/codec.py": "import codecs\nimport re\nfrom typing import Any, Optional, Tuple\nfrom .core import IDNAError, alabel, decode, encode, ulabel\n_unicode_dots_re = re.compile('[.\u3002\uff0e\uff61]')\n\nclass Codec(codecs.Codec):\n\nclass IncrementalEncoder(codecs.BufferedIncrementalEncoder):\n\nclass IncrementalDecoder(codecs.BufferedIncrementalDecoder):\n\nclass StreamWriter(Codec, codecs.StreamWriter):\n    pass\n\nclass StreamReader(Codec, codecs.StreamReader):\n    pass\ncodecs.register(search_function)",
    "idna/core.py": "import bisect\nimport re\nimport unicodedata\nfrom typing import Optional, Union\nfrom . import idnadata\nfrom .intranges import intranges_contain\n_virama_combining_class = 9\n_alabel_prefix = b'xn--'\n_unicode_dots_re = re.compile('[.\u3002\uff0e\uff61]')\n\nclass IDNAError(UnicodeError):\n    \"\"\"Base exception for all IDNA-encoding related problems\"\"\"\n    pass\n\nclass IDNABidiError(IDNAError):\n    \"\"\"Exception when bidirectional requirements are not satisfied\"\"\"\n    pass\n\nclass InvalidCodepoint(IDNAError):\n    \"\"\"Exception when a disallowed or unallocated codepoint is used\"\"\"\n    pass\n\nclass InvalidCodepointContext(IDNAError):\n    \"\"\"Exception when the codepoint is not valid in the context it is used\"\"\"\n    pass\n\ndef _combining_class(cp: int) -> int:\n    v = unicodedata.combining(chr(cp))\n    if v == 0:\n        if not unicodedata.name(chr(cp)):\n            raise ValueError('Unknown character in unicodedata')\n    return v\n\ndef _is_script(cp: str, script: str) -> bool:\n    return intranges_contain(ord(cp), idnadata.scripts[script])\n\ndef _punycode(s: str) -> bytes:\n    return s.encode('punycode')\n\ndef _unot(s: int) -> str:\n    return 'U+{:04X}'.format(s)\n\ndef valid_label_length(label: Union[bytes, str]) -> bool:\n    if len(label) > 63:\n        return False\n    return True\n\ndef valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:\n    if len(label) > (254 if trailing_dot else 253):\n        return False\n    return True\n\ndef check_bidi(label: str, check_ltr: bool=False) -> bool:\n    bidi_label = False\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if direction == '':\n            raise IDNABidiError('Unknown directionality in label {} at position {}'.format(repr(label), idx))\n        if direction in ['R', 'AL', 'AN']:\n            bidi_label = True\n    if not bidi_label and (not check_ltr):\n        return True\n    direction = unicodedata.bidirectional(label[0])\n    if direction in ['R', 'AL']:\n        rtl = True\n    elif direction == 'L':\n        rtl = False\n    else:\n        raise IDNABidiError('First codepoint in label {} must be directionality L, R or AL'.format(repr(label)))\n    valid_ending = False\n    number_type: Optional[str] = None\n    for idx, cp in enumerate(label, 1):\n        direction = unicodedata.bidirectional(cp)\n        if rtl:\n            if direction not in ['R', 'AL', 'AN', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:\n                raise IDNABidiError('Invalid direction for codepoint at position {} in a right-to-left label'.format(idx))\n            if direction in ['R', 'AL', 'EN', 'AN']:\n                valid_ending = True\n            elif direction != 'NSM':\n                valid_ending = False\n            if direction in ['AN', 'EN']:\n                if not number_type:\n                    number_type = direction\n                elif number_type != direction:\n                    raise IDNABidiError('Can not mix numeral types in a right-to-left label')\n        else:\n            if direction not in ['L', 'EN', 'ES', 'CS', 'ET', 'ON', 'BN', 'NSM']:\n                raise IDNABidiError('Invalid direction for codepoint at position {} in a left-to-right label'.format(idx))\n            if direction in ['L', 'EN']:\n                valid_ending = True\n            elif direction != 'NSM':\n                valid_ending = False\n    if not valid_ending:\n        raise IDNABidiError('Label ends with illegal codepoint directionality')\n    return True\n\ndef check_initial_combiner(label: str) -> bool:\n    if unicodedata.category(label[0])[0] == 'M':\n        raise IDNAError('Label begins with an illegal combining character')\n    return True\n\ndef check_hyphen_ok(label: str) -> bool:\n    if label[2:4] == '--':\n        raise IDNAError('Label has disallowed hyphens in 3rd and 4th position')\n    if label[0] == '-' or label[-1] == '-':\n        raise IDNAError('Label must not start or end with a hyphen')\n    return True\n\ndef check_nfc(label: str) -> None:\n    if unicodedata.normalize('NFC', label) != label:\n        raise IDNAError('Label must be in Normalization Form C')\n\ndef valid_contextj(label: str, pos: int) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 8204:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        ok = False\n        for i in range(pos - 1, -1, -1):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord('T'):\n                continue\n            elif joining_type in [ord('L'), ord('D')]:\n                ok = True\n                break\n            else:\n                break\n        if not ok:\n            return False\n        ok = False\n        for i in range(pos + 1, len(label)):\n            joining_type = idnadata.joining_types.get(ord(label[i]))\n            if joining_type == ord('T'):\n                continue\n            elif joining_type in [ord('R'), ord('D')]:\n                ok = True\n                break\n            else:\n                break\n        return ok\n    if cp_value == 8205:\n        if pos > 0:\n            if _combining_class(ord(label[pos - 1])) == _virama_combining_class:\n                return True\n        return False\n    else:\n        return False\n\ndef valid_contexto(label: str, pos: int, exception: bool=False) -> bool:\n    cp_value = ord(label[pos])\n    if cp_value == 183:\n        if 0 < pos < len(label) - 1:\n            if ord(label[pos - 1]) == 108 and ord(label[pos + 1]) == 108:\n                return True\n        return False\n    elif cp_value == 885:\n        if pos < len(label) - 1 and len(label) > 1:\n            return _is_script(label[pos + 1], 'Greek')\n        return False\n    elif cp_value == 1523 or cp_value == 1524:\n        if pos > 0:\n            return _is_script(label[pos - 1], 'Hebrew')\n        return False\n    elif cp_value == 12539:\n        for cp in label:\n            if cp == '\u30fb':\n                continue\n            if _is_script(cp, 'Hiragana') or _is_script(cp, 'Katakana') or _is_script(cp, 'Han'):\n                return True\n        return False\n    elif 1632 <= cp_value <= 1641:\n        for cp in label:\n            if 1776 <= ord(cp) <= 1785:\n                return False\n        return True\n    elif 1776 <= cp_value <= 1785:\n        for cp in label:\n            if 1632 <= ord(cp) <= 1641:\n                return False\n        return True\n    return False\n\ndef check_label(label: Union[str, bytes, bytearray]) -> None:\n    if isinstance(label, (bytes, bytearray)):\n        label = label.decode('utf-8')\n    if len(label) == 0:\n        raise IDNAError('Empty Label')\n    check_nfc(label)\n    check_hyphen_ok(label)\n    check_initial_combiner(label)\n    for pos, cp in enumerate(label):\n        cp_value = ord(cp)\n        if intranges_contain(cp_value, idnadata.codepoint_classes['PVALID']):\n            continue\n        elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTJ']):\n            try:\n                if not valid_contextj(label, pos):\n                    raise InvalidCodepointContext('Joiner {} not allowed at position {} in {}'.format(_unot(cp_value), pos + 1, repr(label)))\n            except ValueError:\n                raise IDNAError('Unknown codepoint adjacent to joiner {} at position {} in {}'.format(_unot(cp_value), pos + 1, repr(label)))\n        elif intranges_contain(cp_value, idnadata.codepoint_classes['CONTEXTO']):\n            if not valid_contexto(label, pos):\n                raise InvalidCodepointContext('Codepoint {} not allowed at position {} in {}'.format(_unot(cp_value), pos + 1, repr(label)))\n        else:\n            raise InvalidCodepoint('Codepoint {} at position {} of {} not allowed'.format(_unot(cp_value), pos + 1, repr(label)))\n    check_bidi(label)\n\ndef uts46_remap(domain: str, std3_rules: bool=True, transitional: bool=False) -> str:\n    \"\"\"Re-map the characters in the string according to UTS46 processing.\"\"\"\n    from .uts46data import uts46data\n    output = ''\n    for pos, char in enumerate(domain):\n        code_point = ord(char)\n        try:\n            uts46row = uts46data[code_point if code_point < 256 else bisect.bisect_left(uts46data, (code_point, 'Z')) - 1]\n            status = uts46row[1]\n            replacement: Optional[str] = None\n            if len(uts46row) == 3:\n                replacement = uts46row[2]\n            if status == 'V' or (status == 'D' and (not transitional)) or (status == '3' and (not std3_rules) and (replacement is None)):\n                output += char\n            elif replacement is not None and (status == 'M' or (status == '3' and (not std3_rules)) or (status == 'D' and transitional)):\n                output += replacement\n            elif status != 'I':\n                raise IndexError()\n        except IndexError:\n            raise InvalidCodepoint('Codepoint {} not allowed at position {} in {}'.format(_unot(code_point), pos + 1, repr(domain)))\n    return unicodedata.normalize('NFC', output)\n\ndef encode(s: Union[str, bytes, bytearray], strict: bool=False, uts46: bool=False, std3_rules: bool=False, transitional: bool=False) -> bytes:\n    if not isinstance(s, str):\n        try:\n            s = str(s, 'ascii')\n        except UnicodeDecodeError:\n            raise IDNAError('should pass a unicode string to the function rather than a byte string.')\n    if uts46:\n        s = uts46_remap(s, std3_rules, transitional)\n    trailing_dot = False\n    result = []\n    if strict:\n        labels = s.split('.')\n    else:\n        labels = _unicode_dots_re.split(s)\n    if not labels or labels == ['']:\n        raise IDNAError('Empty domain')\n    if labels[-1] == '':\n        del labels[-1]\n        trailing_dot = True\n    for label in labels:\n        s = alabel(label)\n        if s:\n            result.append(s)\n        else:\n            raise IDNAError('Empty label')\n    if trailing_dot:\n        result.append(b'')\n    s = b'.'.join(result)\n    if not valid_string_length(s, trailing_dot):\n        raise IDNAError('Domain too long')\n    return s\n\ndef decode(s: Union[str, bytes, bytearray], strict: bool=False, uts46: bool=False, std3_rules: bool=False) -> str:\n    try:\n        if not isinstance(s, str):\n            s = str(s, 'ascii')\n    except UnicodeDecodeError:\n        raise IDNAError('Invalid ASCII in A-label')\n    if uts46:\n        s = uts46_remap(s, std3_rules, False)\n    trailing_dot = False\n    result = []\n    if not strict:\n        labels = _unicode_dots_re.split(s)\n    else:\n        labels = s.split('.')\n    if not labels or labels == ['']:\n        raise IDNAError('Empty domain')\n    if not labels[-1]:\n        del labels[-1]\n        trailing_dot = True\n    for label in labels:\n        s = ulabel(label)\n        if s:\n            result.append(s)\n        else:\n            raise IDNAError('Empty label')\n    if trailing_dot:\n        result.append('')\n    return '.'.join(result)"
  },
  "call_tree": {
    "tests/test_idna_codec.py:IDNACodecTests:setUp": {
      "tests/test_idna.py:IDNATests:IDNATests": {},
      "tests/test_idna.py:IDNATests:setUp": {}
    },
    "tests/test_idna_codec.py:IDNACodecTests:testCodec": {
      "idna/codec.py:search_function": {}
    },
    "tests/test_idna_codec.py:IDNACodecTests:testDirectDecode": {
      "tests/test_idna.py:IDNATests:test_decode": {
        "idna/codec.py:Codec:decode": {
          "idna/core.py:decode": {
            "idna/core.py:ulabel": {
              "idna/core.py:check_label": {
                "idna/core.py:check_nfc": {},
                "idna/core.py:check_hyphen_ok": {},
                "idna/core.py:check_initial_combiner": {},
                "idna/intranges.py:intranges_contain": {
                  "idna/intranges.py:_encode_range": {},
                  "idna/intranges.py:_decode_range": {}
                },
                "idna/core.py:check_bidi": {},
                "idna/core.py:_unot": {},
                "idna/core.py:valid_contextj": {
                  "idna/core.py:_combining_class": {}
                }
              }
            }
          }
        }
      }
    },
    "tests/test_idna_codec.py:IDNACodecTests:testDirectEncode": {
      "tests/test_idna.py:IDNATests:test_encode": {
        "idna/codec.py:Codec:encode": {
          "idna/core.py:encode": {
            "idna/core.py:alabel": {
              "idna/core.py:ulabel": {
                "idna/core.py:check_label": {
                  "idna/core.py:check_nfc": {},
                  "idna/core.py:check_hyphen_ok": {},
                  "idna/core.py:check_initial_combiner": {},
                  "idna/intranges.py:intranges_contain": {
                    "idna/intranges.py:_encode_range": {},
                    "idna/intranges.py:_decode_range": {}
                  },
                  "idna/core.py:check_bidi": {},
                  "idna/core.py:_unot": {}
                }
              },
              "idna/core.py:valid_label_length": {},
              "idna/core.py:check_label": {
                "idna/core.py:check_nfc": {},
                "idna/core.py:check_hyphen_ok": {},
                "idna/core.py:check_initial_combiner": {},
                "idna/intranges.py:intranges_contain": {
                  "idna/intranges.py:_encode_range": {},
                  "idna/intranges.py:_decode_range": {}
                },
                "idna/core.py:check_bidi": {}
              },
              "idna/core.py:_punycode": {}
            },
            "idna/core.py:valid_string_length": {}
          }
        }
      }
    },
    "tests/test_idna_codec.py:IDNACodecTests:testIncrementalDecoder": {
      "idna/codec.py:IncrementalDecoder:_buffer_decode": {
        "idna/core.py:ulabel": {
          "idna/core.py:check_label": {
            "idna/core.py:check_nfc": {},
            "idna/core.py:check_hyphen_ok": {},
            "idna/core.py:check_initial_combiner": {},
            "idna/intranges.py:intranges_contain": {
              "idna/intranges.py:_encode_range": {},
              "idna/intranges.py:_decode_range": {}
            },
            "idna/core.py:check_bidi": {}
          }
        }
      }
    },
    "tests/test_idna_codec.py:IDNACodecTests:testIncrementalEncoder": {
      "idna/codec.py:IncrementalEncoder:_buffer_encode": {
        "idna/core.py:alabel": {
          "idna/core.py:ulabel": {
            "idna/core.py:check_label": {
              "idna/core.py:check_nfc": {},
              "idna/core.py:check_hyphen_ok": {},
              "idna/core.py:check_initial_combiner": {},
              "idna/intranges.py:intranges_contain": {
                "idna/intranges.py:_encode_range": {},
                "idna/intranges.py:_decode_range": {}
              },
              "idna/core.py:check_bidi": {}
            }
          },
          "idna/core.py:valid_label_length": {},
          "idna/core.py:check_label": {
            "idna/core.py:check_nfc": {},
            "idna/core.py:check_hyphen_ok": {},
            "idna/core.py:check_initial_combiner": {},
            "idna/intranges.py:intranges_contain": {
              "idna/intranges.py:_encode_range": {},
              "idna/intranges.py:_decode_range": {}
            },
            "idna/core.py:check_bidi": {}
          },
          "idna/core.py:_punycode": {}
        }
      }
    },
    "tests/test_idna_codec.py:IDNACodecTests:testIndirectDecode": {
      "tests/test_idna.py:IDNATests:test_decode": {
        "idna/codec.py:Codec:decode": {
          "idna/core.py:decode": {
            "idna/core.py:ulabel": {
              "idna/core.py:check_label": {
                "idna/core.py:check_nfc": {},
                "idna/core.py:check_hyphen_ok": {},
                "idna/core.py:check_initial_combiner": {},
                "idna/intranges.py:intranges_contain": {
                  "idna/intranges.py:_encode_range": {},
                  "idna/intranges.py:_decode_range": {}
                },
                "idna/core.py:check_bidi": {},
                "idna/core.py:_unot": {},
                "idna/core.py:valid_contextj": {
                  "idna/core.py:_combining_class": {}
                }
              }
            }
          }
        }
      }
    },
    "tests/test_idna_codec.py:IDNACodecTests:testIndirectEncode": {
      "tests/test_idna.py:IDNATests:test_encode": {
        "idna/codec.py:Codec:encode": {
          "idna/core.py:encode": {
            "idna/core.py:alabel": {
              "idna/core.py:ulabel": {
                "idna/core.py:check_label": {
                  "idna/core.py:check_nfc": {},
                  "idna/core.py:check_hyphen_ok": {},
                  "idna/core.py:check_initial_combiner": {},
                  "idna/intranges.py:intranges_contain": {
                    "idna/intranges.py:_encode_range": {},
                    "idna/intranges.py:_decode_range": {}
                  },
                  "idna/core.py:check_bidi": {},
                  "idna/core.py:_unot": {}
                }
              },
              "idna/core.py:valid_label_length": {},
              "idna/core.py:check_label": {
                "idna/core.py:check_nfc": {},
                "idna/core.py:check_hyphen_ok": {},
                "idna/core.py:check_initial_combiner": {},
                "idna/intranges.py:intranges_contain": {
                  "idna/intranges.py:_encode_range": {},
                  "idna/intranges.py:_decode_range": {}
                },
                "idna/core.py:check_bidi": {}
              },
              "idna/core.py:_punycode": {}
            },
            "idna/core.py:valid_string_length": {}
          }
        }
      }
    },
    "tests/test_idna_codec.py:IDNACodecTests:testStreamReader": {
      "tests/test_idna.py:IDNATests:test_decode": {
        "tests/test_idna_codec.py:IDNACodecTests:decode": {
          "idna/codec.py:Codec:decode": {
            "idna/core.py:decode": {
              "idna/core.py:ulabel": {
                "idna/core.py:check_label": {
                  "idna/core.py:check_nfc": {},
                  "idna/core.py:check_hyphen_ok": {},
                  "idna/core.py:check_initial_combiner": {},
                  "idna/intranges.py:intranges_contain": {
                    "idna/intranges.py:_encode_range": {},
                    "idna/intranges.py:_decode_range": {}
                  },
                  "idna/core.py:check_bidi": {},
                  "idna/core.py:_unot": {},
                  "idna/core.py:valid_contextj": {
                    "idna/core.py:_combining_class": {}
                  }
                }
              }
            }
          }
        }
      }
    },
    "tests/test_idna_codec.py:IDNACodecTests:testStreamWriter": {
      "tests/test_idna.py:IDNATests:test_encode": {
        "tests/test_idna_codec.py:IDNACodecTests:encode": {
          "idna/codec.py:Codec:encode": {
            "idna/core.py:encode": {
              "idna/core.py:alabel": {
                "idna/core.py:ulabel": {
                  "idna/core.py:check_label": {
                    "idna/core.py:check_nfc": {},
                    "idna/core.py:check_hyphen_ok": {},
                    "idna/core.py:check_initial_combiner": {},
                    "idna/intranges.py:intranges_contain": {
                      "idna/intranges.py:_encode_range": {},
                      "idna/intranges.py:_decode_range": {}
                    },
                    "idna/core.py:check_bidi": {},
                    "idna/core.py:_unot": {}
                  }
                },
                "idna/core.py:valid_label_length": {},
                "idna/core.py:check_label": {
                  "idna/core.py:check_nfc": {},
                  "idna/core.py:check_hyphen_ok": {},
                  "idna/core.py:check_initial_combiner": {},
                  "idna/intranges.py:intranges_contain": {
                    "idna/intranges.py:_encode_range": {},
                    "idna/intranges.py:_decode_range": {}
                  },
                  "idna/core.py:check_bidi": {}
                },
                "idna/core.py:_punycode": {}
              },
              "idna/core.py:valid_string_length": {}
            }
          }
        }
      }
    }
  }
}