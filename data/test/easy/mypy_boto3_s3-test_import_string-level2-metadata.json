{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_import_string",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/import_helpers/test_import_string.py",
  "test_code": "import pytest\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\nclass TestImportString:\n    def test_init(self) -> None:\n        assert ImportString(\"my\", \"module\").render() == \"my.module\"\n        assert ImportString(\"my\").render() == \"my\"\n\n        assert ImportString(\"\", \"\").render() == \".\"\n        assert ImportString(\"\", \"test\", \"my\").render() == \".test.my\"\n        assert ImportString(\"\", \"\", \"test\", \"my\").render() == \"..test.my\"\n\n        with pytest.raises(StructureError):\n            ImportString(\"\")\n        with pytest.raises(StructureError):\n            ImportString(\"test\", \"another.module\")\n        with pytest.raises(StructureError):\n            ImportString(\"my\", \"\", \"test\")\n\n    def test_from_str(self) -> None:\n        assert ImportString.from_str(\"my.module.path\").render() == \"my.module.path\"\n        assert ImportString.from_str(\".test\").render() == \".test\"\n        with pytest.raises(StructureError):\n            assert ImportString.from_str(\"\").render()\n\n    def test_operations(self) -> None:\n        assert ImportString(\"my\") < ImportString(\"test\")\n        assert ImportString(\"my\", \"test\")\n        assert hash(ImportString(\"my\")) != hash(ImportString(\"test\"))\n\n        with pytest.raises(BuildInternalError):\n            assert ImportString(\"my\") + ImportString(\"test\") == \"my.test\"\n\n    def test_render(self) -> None:\n        assert ImportString(\"my\", \"module\").render() == \"my.module\"\n\n    def test_parent(self) -> None:\n        assert ImportString(\"my\", \"module\").parent == \"my\"\n        assert not ImportString(\"\", \"\").parent\n\n    def test_is_builtins(self) -> None:\n        assert ImportString(\"builtins\").is_builtins()\n        assert ImportString(\"builtins\", \"type\").is_builtins()\n        assert not ImportString(\"other\").is_builtins()\n        assert not ImportString(\"type_defs\").is_builtins()\n        assert not ImportString(\"boto3\").is_builtins()\n\n    def test_is_type_defs(self) -> None:\n        assert ImportString(\"type_defs\").is_type_defs()\n        assert ImportString(\"service\", \"type_defs\").is_type_defs()\n        assert not ImportString(\"builtins\").is_type_defs()\n        assert not ImportString(\"other\").is_type_defs()\n        assert not ImportString(\"boto3\").is_builtins()\n\n    def test_is_third_party(self) -> None:\n        assert not ImportString(\"type_defs\").is_third_party()\n        assert not ImportString(\"builtins\").is_third_party()\n        assert not ImportString(\"other\").is_third_party()\n        assert ImportString(\"boto3\").is_third_party()\n        assert ImportString(\"boto3\", \"test\").is_third_party()\n        assert ImportString(\"botocore\").is_third_party()\n        assert ImportString(\"botocore\", \"test\").is_third_party()\n\n    def test_is_local(self) -> None:\n        assert not ImportString(\"\", \"\").is_local()\n        assert ImportString(\"mypy_boto3\", \"test\").is_local()\n        assert ImportString(\"type_defs\").is_local()\n        assert not ImportString(\"other\").is_local()\n\n    def test_comparison(self) -> None:\n        # third party\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"builtins\", \"str\")\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"boto3\")\n        assert ImportString(\"boto3\", \"extra\") < ImportString(\"mypy_boto3_s3\", \"service\")\n        assert ImportString(\"boto3\", \"extra\") > ImportString(\"asdf\")\n        assert ImportString(\"aiobotocore\", \"extra\") < ImportString(\"boto3\", \"extra\")\n\n        # local\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"builtins\", \"str\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"boto3\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"mypy_boto3_s3\", \"asd\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") < ImportString(\"mypy_boto3_s3\", \"service\")\n        assert ImportString(\"mypy_boto3_s3\", \"extra\") > ImportString(\"asdf\")\n\n        # other\n        assert ImportString(\"asdf\", \"test\") > ImportString(\"asd\", \"test\")\n        assert ImportString(\"asdf\", \"test\") < ImportString(\"asdf\", \"test2\")\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initializer for the ImportString class. It constructs an import string object from a master module name (parent) and optional additional parts. \n\nParameters:\n    parent (str): The master module name, which cannot be empty.\n    *parts (str): Additional parts of the import string. Their usage must not introduce empty segments after non-empty parts or contain dots.\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains a dot, or if there are empty parts after non-empty ones.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple containing the concatenated import parts, enforcing a structured format suitable for Python import statements.\n\nConstants:\n    StructureError: An exception used to signal issues with the import string structure, defined and handled in the mypy_boto3_builder.exceptions module.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initializer for the ImportString class. It constructs an import string object from a master module name (parent) and optional additional parts. \n\nParameters:\n    parent (str): The master module name, which cannot be empty.\n    *parts (str): Additional parts of the import string. Their usage must not introduce empty segments after non-empty parts or contain dots.\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains a dot, or if there are empty parts after non-empty ones.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple containing the concatenated import parts, enforcing a structured format suitable for Python import statements.\n\nConstants:\n    StructureError: An exception used to signal issues with the import string structure, defined and handled in the mypy_boto3_builder.exceptions module.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.from_str": {
        "code": "    def from_str(cls, import_string: str) -> Self:\n        \"\"\"Create an ImportString instance from a dot-separated import string.\n\nParameters:\n    import_string (str): A string representing a Python import path, which is split by dots to form the components of the ImportString. The input must follow a valid structure where parts are separated by dots. \n\nReturns:\n    ImportString: An instance of the ImportString class initialized with the specified import string parts. The parent module is the first part, and additional parts follow.\n\nRaises:\n    StructureError: If the import_string is empty or contains invalid formats, such as parts with dots or empty parts succeeding non-empty parts.\"\"\"\n        '\\n        Create from string.\\n        '\n        return cls(*import_string.split('.'))",
        "docstring": "Create an ImportString instance from a dot-separated import string.\n\nParameters:\n    import_string (str): A string representing a Python import path, which is split by dots to form the components of the ImportString. The input must follow a valid structure where parts are separated by dots. \n\nReturns:\n    ImportString: An instance of the ImportString class initialized with the specified import string parts. The parent module is the first part, and additional parts follow.\n\nRaises:\n    StructureError: If the import_string is empty or contains invalid formats, such as parts with dots or empty parts succeeding non-empty parts.",
        "signature": "def from_str(cls, import_string: str) -> Self:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ImportString instance based on its parts.\n\nThis method returns an integer hash that uniquely represents the instance, allowing it to be used in sets and as dictionary keys. The hash is derived from the `parts` attribute, which contains the components of the import string. This attribute is initialized in the constructor and consists of the master module name and any additional parts provided during the instantiation of the ImportString object.\n\nReturns:\n    int: The hash value of the import string parts.\n\nNo input parameters are required for this method. There are no side effects or dependencies besides the `parts` attribute, ensuring consistent behavior for instances with identical parts.\"\"\"\n        '\\n        Calculate hash value based on all parts.\\n        '\n        return hash(self.parts)",
        "docstring": "Calculate a hash value for the ImportString instance based on its parts.\n\nThis method returns an integer hash that uniquely represents the instance, allowing it to be used in sets and as dictionary keys. The hash is derived from the `parts` attribute, which contains the components of the import string. This attribute is initialized in the constructor and consists of the master module name and any additional parts provided during the instantiation of the ImportString object.\n\nReturns:\n    int: The hash value of the import string parts.\n\nNo input parameters are required for this method. There are no side effects or dependencies besides the `parts` attribute, ensuring consistent behavior for instances with identical parts.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__eq__": {
        "code": "    def __eq__(self, other: object) -> bool:\n        \"\"\"Determine if two ImportString instances are equivalent by comparing their parts.\n\nParameters:\n    other (object): The object to compare against. Must be of type ImportString.\n\nReturns:\n    bool: True if the parts of both ImportString instances are equal; False otherwise.\n\nRaises:\n    BuildInternalError: If the `other` object is not an instance of ImportString, indicating a mismatch in expected types.\n\nThis method uses the `parts` attribute, which is a tuple of string components representing the import string. It is initialized during the ImportString object's construction and is essential for rendering and comparison operations.\"\"\"\n        '\\n        Whether import strings produce the same render.\\n        '\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts",
        "docstring": "Determine if two ImportString instances are equivalent by comparing their parts.\n\nParameters:\n    other (object): The object to compare against. Must be of type ImportString.\n\nReturns:\n    bool: True if the parts of both ImportString instances are equal; False otherwise.\n\nRaises:\n    BuildInternalError: If the `other` object is not an instance of ImportString, indicating a mismatch in expected types.\n\nThis method uses the `parts` attribute, which is a tuple of string components representing the import string. It is initialized during the ImportString object's construction and is essential for rendering and comparison operations.",
        "signature": "def __eq__(self, other: object) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__gt__": {
        "code": "    def __gt__(self, other: Self) -> bool:\n        \"\"\"Compare two `ImportString` instances for sorting based on a custom logic that emulates the behavior of `isort`. The sorting is prioritized first by whether the import is local or a third-party module, and then by the lexicographical order of the import parts. \n\nParameters:\n- `other`: An instance of `ImportString` to compare against.\n\nReturns:\n- `bool`: `True` if this instance is greater than `other` according to the defined sorting logic, otherwise `False`.\n\nThe method leverages the `is_local()` and `is_third_party()` methods to determine the type of import before performing a direct comparison of the parts attribute. It also utilizes the equality operator (`__eq__`) to check for equality with `other`, returning `False` if they are equal.\"\"\"\n        '\\n        Compare import strings for sorting.\\n\\n        Emulates `isort` logic.\\n        '\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts",
        "docstring": "Compare two `ImportString` instances for sorting based on a custom logic that emulates the behavior of `isort`. The sorting is prioritized first by whether the import is local or a third-party module, and then by the lexicographical order of the import parts. \n\nParameters:\n- `other`: An instance of `ImportString` to compare against.\n\nReturns:\n- `bool`: `True` if this instance is greater than `other` according to the defined sorting logic, otherwise `False`.\n\nThe method leverages the `is_local()` and `is_third_party()` methods to determine the type of import before performing a direct comparison of the parts attribute. It also utilizes the equality operator (`__eq__`) to check for equality with `other`, returning `False` if they are equal.",
        "signature": "def __gt__(self, other: Self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.__add__": {
        "code": "    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"Create a new import string by concatenating the parts of another import string to the end of the current import string.\n\nParameters:\n- other (Self | str): An instance of ImportString or a string representing an import string to append.\n\nReturns:\n- Self: A new ImportString instance containing the combined parts of the current instance and the provided import string.\n\nThis method allows for the dynamic creation of ImportString instances by appending parts from another ImportString or a normal string, enabling better handling of import structures in code.\"\"\"\n        '\\n        Create a new import string by adding another import string parts to the end.\\n        '\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)",
        "docstring": "Create a new import string by concatenating the parts of another import string to the end of the current import string.\n\nParameters:\n- other (Self | str): An instance of ImportString or a string representing an import string to append.\n\nReturns:\n- Self: A new ImportString instance containing the combined parts of the current instance and the provided import string.\n\nThis method allows for the dynamic creation of ImportString instances by appending parts from another ImportString or a normal string, enabling better handling of import structures in code.",
        "signature": "def __add__(self: Self, other: Self | str) -> Self:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the import string to a valid Python import statement.\n\nThis method combines all parts of the ImportString instance into a single, dot-separated string that represents a valid import statement in Python. The parts are stored in the `self.parts` attribute, which is a tuple containing the individual components of the import string.\n\nReturns:\n    str: A ready-to-use import string composed of the joined parts.\n\nThis method does not take any parameters and has no side effects.\"\"\"\n        '\\n        Render to string.\\n\\n        Returns:\\n            Ready to use import string.\\n        '\n        return '.'.join(self.parts)",
        "docstring": "Render the import string to a valid Python import statement.\n\nThis method combines all parts of the ImportString instance into a single, dot-separated string that represents a valid import statement in Python. The parts are stored in the `self.parts` attribute, which is a tuple containing the individual components of the import string.\n\nReturns:\n    str: A ready-to-use import string composed of the joined parts.\n\nThis method does not take any parameters and has no side effects.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.parent": {
        "code": "    def parent(self) -> str:\n        \"\"\"Get the first part of the ImportString or return 'builtins'.\n\nThis property returns the first segment of the import string, which represents the primary module in the import hierarchy. If the ImportString instance is empty, it defaults to the built-in `builtins` module, as indicated by the class constant `BUILTINS`. This constant is defined as `BUILTINS: Final[str] = \"builtins\"` within the `ImportString` class.\n\nReturns:\n    str: The first part of the import string or 'builtins'.\"\"\"\n        '\\n        Get first import string part or `builtins`.\\n        '\n        return self.parts[0]",
        "docstring": "Get the first part of the ImportString or return 'builtins'.\n\nThis property returns the first segment of the import string, which represents the primary module in the import hierarchy. If the ImportString instance is empty, it defaults to the built-in `builtins` module, as indicated by the class constant `BUILTINS`. This constant is defined as `BUILTINS: Final[str] = \"builtins\"` within the `ImportString` class.\n\nReturns:\n    str: The first part of the import string or 'builtins'.",
        "signature": "def parent(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_local": {
        "code": "    def is_local(self) -> bool:\n        \"\"\"Determine if the import string represents a local module.\n\nThis method checks if the `parent` component of the import string starts with \nspecific prefixes that indicate it belongs to local modules related to AWS Boto3 \nstubs (defined in `Boto3StubsPackageData.SERVICE_PREFIX`) or AioBotocore \ntypes (defined in `TypesAioBotocorePackageData.SERVICE_PREFIX`). It also checks \nif the import string represents type definitions by calling `is_type_defs()`.\n\nReturns:\n    bool: True if the import string is local, False otherwise.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that indicates the prefix \n  for local Boto3 service modules.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that indicates the \n  prefix for local AioBotocore service modules.\n- `is_type_defs()`: A method that determines if the import string is from the \n  type definitions module.\"\"\"\n        '\\n        Whether import is from local module.\\n        '\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()",
        "docstring": "Determine if the import string represents a local module.\n\nThis method checks if the `parent` component of the import string starts with \nspecific prefixes that indicate it belongs to local modules related to AWS Boto3 \nstubs (defined in `Boto3StubsPackageData.SERVICE_PREFIX`) or AioBotocore \ntypes (defined in `TypesAioBotocorePackageData.SERVICE_PREFIX`). It also checks \nif the import string represents type definitions by calling `is_type_defs()`.\n\nReturns:\n    bool: True if the import string is local, False otherwise.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that indicates the prefix \n  for local Boto3 service modules.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that indicates the \n  prefix for local AioBotocore service modules.\n- `is_type_defs()`: A method that determines if the import string is from the \n  type definitions module.",
        "signature": "def is_local(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_builtins": {
        "code": "    def is_builtins(self) -> bool:\n        \"\"\"Determines if the import string corresponds to the Python `builtins` module.\n\nThis method checks if the first part of the import string, referred to as `parent`, is equal to the constant `BUILTINS`, which is defined as \"builtins\". It helps identify if the import is coming from the built-in Python modules.\n\nReturns:\n    bool: True if the import string is from the `builtins` module, otherwise False.\"\"\"\n        '\\n        Whether import is from Python `builtins` module.\\n        '\n        return self.parent == self.BUILTINS",
        "docstring": "Determines if the import string corresponds to the Python `builtins` module.\n\nThis method checks if the first part of the import string, referred to as `parent`, is equal to the constant `BUILTINS`, which is defined as \"builtins\". It helps identify if the import is coming from the built-in Python modules.\n\nReturns:\n    bool: True if the import string is from the `builtins` module, otherwise False.",
        "signature": "def is_builtins(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_type_defs": {
        "code": "    def is_type_defs(self) -> bool:\n        \"\"\"Determine if the current import string refers to a module intended for type definitions.\n\nThis method checks if the last part of the import string matches the `type_defs` value defined in the `ServiceModuleName` enumeration, indicating it is associated with type definitions. It returns `False` if the import string has no parts.\n\nReturns:\n    bool: True if the import string corresponds to a `type_defs` module, otherwise False.\n\nDependencies:\n- `self.parts`: A tuple containing the parts of the import string, initialized in the class constructor.\n- `ServiceModuleName.type_defs.value`: A constant that holds the string value representing type definitions, sourced from the `mypy_boto3_builder.enums.service_module_name` module.\"\"\"\n        '\\n        Whether import is from `type_defs` module.\\n        '\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value",
        "docstring": "Determine if the current import string refers to a module intended for type definitions.\n\nThis method checks if the last part of the import string matches the `type_defs` value defined in the `ServiceModuleName` enumeration, indicating it is associated with type definitions. It returns `False` if the import string has no parts.\n\nReturns:\n    bool: True if the import string corresponds to a `type_defs` module, otherwise False.\n\nDependencies:\n- `self.parts`: A tuple containing the parts of the import string, initialized in the class constructor.\n- `ServiceModuleName.type_defs.value`: A constant that holds the string value representing type definitions, sourced from the `mypy_boto3_builder.enums.service_module_name` module.",
        "signature": "def is_type_defs(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.is_third_party": {
        "code": "    def is_third_party(self) -> bool:\n        \"\"\"Determine if the import string refers to a third-party module.\n\nThis method checks if the parent part of the import string is included in the set of known third-party modules defined in the class-level constant `_THIRD_PARTY`. The set includes modules such as \"boto3\", \"botocore\", \"aioboto3\", \"aiobotocore\", \"s3transfer\", and \"awscrt\". If the parent module matches any of these names, the method returns `True`; otherwise, it returns `False`.\n\nReturns:\n    bool: `True` if the import is from a third-party module, `False` otherwise.\"\"\"\n        '\\n        Whether import is from 3rd party module.\\n        '\n        return self.parent in self._THIRD_PARTY",
        "docstring": "Determine if the import string refers to a third-party module.\n\nThis method checks if the parent part of the import string is included in the set of known third-party modules defined in the class-level constant `_THIRD_PARTY`. The set includes modules such as \"boto3\", \"botocore\", \"aioboto3\", \"aiobotocore\", \"s3transfer\", and \"awscrt\". If the parent module matches any of these names, the method returns `True`; otherwise, it returns `False`.\n\nReturns:\n    bool: `True` if the import is from a third-party module, `False` otherwise.",
        "signature": "def is_third_party(self) -> bool:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__add__": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
    "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
  },
  "call_tree": {
    "tests/import_helpers/test_import_string.py:TestImportString:test_init": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_from_str": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_operations": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__add__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_render": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_parent": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_builtins": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_type_defs": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_third_party": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_is_local": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
      }
    },
    "tests/import_helpers/test_import_string.py:TestImportString:test_comparison": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__gt__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {},
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_local": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {},
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_type_defs": {}
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_third_party": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__eq__": {}
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_import_string\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u2514\u2500\u2500 import_helpers/\n        \u2514\u2500\u2500 import_string.py\n            \u251c\u2500\u2500 ImportString\n            \u251c\u2500\u2500 ImportString.__add__\n            \u251c\u2500\u2500 ImportString.__eq__\n            \u251c\u2500\u2500 ImportString.__gt__\n            \u251c\u2500\u2500 ImportString.__hash__\n            \u251c\u2500\u2500 ImportString.__init__\n            \u251c\u2500\u2500 ImportString.from_str\n            \u251c\u2500\u2500 ImportString.is_builtins\n            \u251c\u2500\u2500 ImportString.is_local\n            \u251c\u2500\u2500 ImportString.is_third_party\n            \u251c\u2500\u2500 ImportString.is_type_defs\n            \u251c\u2500\u2500 ImportString.parent\n            \u2514\u2500\u2500 ImportString.render\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides functionality for managing and manipulating structured import paths within Python projects, primarily for use in code generation and library development. It defines a robust abstraction, `ImportString`, which allows users to represent, validate, and compare import paths programmatically. The module includes capabilities for rendering imports as strings, determining their context (e.g., standard library, third-party, local, or type definitions), and performing operations like comparisons and parent extraction. By offering structured handling of imports, it streamlines the organization and validation of dependencies, minimizing errors and ambiguities in dynamic or automated codebases. This benefits developers by simplifying import-related operations and enhancing the reliability of generated Python code.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializer for the ImportString class. It constructs an import string object from a master module name (parent) and optional additional parts. \n\nParameters:\n    parent (str): The master module name, which cannot be empty.\n    *parts (str): Additional parts of the import string. Their usage must not introduce empty segments after non-empty parts or contain dots.\n\nRaises:\n    StructureError: If both parent and parts are empty, if any part contains a dot, or if there are empty parts after non-empty ones.\n\nAttributes:\n    parts (tuple[str, ...]): A tuple containing the concatenated import parts, enforcing a structured format suitable for Python import statements.\n\nConstants:\n    StructureError: An exception used to signal issues with the import string structure, defined and handled in the mypy_boto3_builder.exceptions module.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__add__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __add__(self: Self, other: Self | str) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a new import string by concatenating the parts of another import string to the end of the current import string.\n\nParameters:\n- other (Self | str): An instance of ImportString or a string representing an import string to append.\n\nReturns:\n- Self: A new ImportString instance containing the combined parts of the current instance and the provided import string.\n\nThis method allows for the dynamic creation of ImportString instances by appending parts from another ImportString or a normal string, enabling better handling of import structures in code.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__gt__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __gt__(self, other: Self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCompare two `ImportString` instances for sorting based on a custom logic that emulates the behavior of `isort`. The sorting is prioritized first by whether the import is local or a third-party module, and then by the lexicographical order of the import parts. \n\nParameters:\n- `other`: An instance of `ImportString` to compare against.\n\nReturns:\n- `bool`: `True` if this instance is greater than `other` according to the defined sorting logic, otherwise `False`.\n\nThe method leverages the `is_local()` and `is_third_party()` methods to determine the type of import before performing a direct comparison of the parts attribute. It also utilizes the equality operator (`__eq__`) to check for equality with `other`, returning `False` if they are equal.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_local\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_local(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string represents a local module.\n\nThis method checks if the `parent` component of the import string starts with \nspecific prefixes that indicate it belongs to local modules related to AWS Boto3 \nstubs (defined in `Boto3StubsPackageData.SERVICE_PREFIX`) or AioBotocore \ntypes (defined in `TypesAioBotocorePackageData.SERVICE_PREFIX`). It also checks \nif the import string represents type definitions by calling `is_type_defs()`.\n\nReturns:\n    bool: True if the import string is local, False otherwise.\n\nDependencies:\n- `Boto3StubsPackageData.SERVICE_PREFIX`: A constant that indicates the prefix \n  for local Boto3 service modules.\n- `TypesAioBotocorePackageData.SERVICE_PREFIX`: A constant that indicates the \n  prefix for local AioBotocore service modules.\n- `is_type_defs()`: A method that determines if the import string is from the \n  type definitions module.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.from_str\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def from_str(cls, import_string: str) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an ImportString instance from a dot-separated import string.\n\nParameters:\n    import_string (str): A string representing a Python import path, which is split by dots to form the components of the ImportString. The input must follow a valid structure where parts are separated by dots. \n\nReturns:\n    ImportString: An instance of the ImportString class initialized with the specified import string parts. The parent module is the first part, and additional parts follow.\n\nRaises:\n    StructureError: If the import_string is empty or contains invalid formats, such as parts with dots or empty parts succeeding non-empty parts.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_third_party\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_third_party(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the import string refers to a third-party module.\n\nThis method checks if the parent part of the import string is included in the set of known third-party modules defined in the class-level constant `_THIRD_PARTY`. The set includes modules such as \"boto3\", \"botocore\", \"aioboto3\", \"aiobotocore\", \"s3transfer\", and \"awscrt\". If the parent module matches any of these names, the method returns `True`; otherwise, it returns `False`.\n\nReturns:\n    bool: `True` if the import is from a third-party module, `False` otherwise.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.render\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the import string to a valid Python import statement.\n\nThis method combines all parts of the ImportString instance into a single, dot-separated string that represents a valid import statement in Python. The parts are stored in the `self.parts` attribute, which is a tuple containing the individual components of the import string.\n\nReturns:\n    str: A ready-to-use import string composed of the joined parts.\n\nThis method does not take any parameters and has no side effects.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__hash__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ImportString instance based on its parts.\n\nThis method returns an integer hash that uniquely represents the instance, allowing it to be used in sets and as dictionary keys. The hash is derived from the `parts` attribute, which contains the components of the import string. This attribute is initialized in the constructor and consists of the master module name and any additional parts provided during the instantiation of the ImportString object.\n\nReturns:\n    int: The hash value of the import string parts.\n\nNo input parameters are required for this method. There are no side effects or dependencies besides the `parts` attribute, ensuring consistent behavior for instances with identical parts.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.parent\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def parent(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the first part of the ImportString or return 'builtins'.\n\nThis property returns the first segment of the import string, which represents the primary module in the import hierarchy. If the ImportString instance is empty, it defaults to the built-in `builtins` module, as indicated by the class constant `BUILTINS`. This constant is defined as `BUILTINS: Final[str] = \"builtins\"` within the `ImportString` class.\n\nReturns:\n    str: The first part of the import string or 'builtins'.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_type_defs\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_type_defs(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the current import string refers to a module intended for type definitions.\n\nThis method checks if the last part of the import string matches the `type_defs` value defined in the `ServiceModuleName` enumeration, indicating it is associated with type definitions. It returns `False` if the import string has no parts.\n\nReturns:\n    bool: True if the import string corresponds to a `type_defs` module, otherwise False.\n\nDependencies:\n- `self.parts`: A tuple containing the parts of the import string, initialized in the class constructor.\n- `ServiceModuleName.type_defs.value`: A constant that holds the string value representing type definitions, sourced from the `mypy_boto3_builder.enums.service_module_name` module.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.is_builtins\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def is_builtins(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if the import string corresponds to the Python `builtins` module.\n\nThis method checks if the first part of the import string, referred to as `parent`, is equal to the constant `BUILTINS`, which is defined as \"builtins\". It helps identify if the import is coming from the built-in Python modules.\n\nReturns:\n    bool: True if the import string is from the `builtins` module, otherwise False.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.__eq__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __eq__(self, other: object) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if two ImportString instances are equivalent by comparing their parts.\n\nParameters:\n    other (object): The object to compare against. Must be of type ImportString.\n\nReturns:\n    bool: True if the parts of both ImportString instances are equal; False otherwise.\n\nRaises:\n    BuildInternalError: If the `other` object is not an instance of ImportString, indicating a mismatch in expected types.\n\nThis method uses the `parts` attribute, which is a tuple of string components representing the import string. It is initialized during the ImportString object's construction and is essential for rendering and comparison operations.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()"
  }
}