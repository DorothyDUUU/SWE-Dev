{
  "dir_path": "/app/num2words",
  "package_name": "num2words",
  "sample_name": "num2words-test_az",
  "src_dir": "num2words/",
  "test_dir": "tests/",
  "test_file": "tests/test_az.py",
  "test_code": "# -*- coding, utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\n\nfrom unittest import TestCase\n\nfrom num2words import num2words\n\n\nclass Num2WordAZTest(TestCase):\n    lang = 'az'\n\n    CARDINAL_TEST_CASES = (\n        (0, 's\u0131f\u0131r',),\n        (1, 'bir',),\n        (2, 'iki',),\n        (3, '\u00fc\u00e7',),\n        (4, 'd\u00f6rd',),\n        (5, 'be\u015f',),\n        (6, 'alt\u0131',),\n        (7, 'yeddi',),\n        (8, 's\u0259kkiz',),\n        (9, 'doqquz',),\n        (10, 'on',),\n        (11, 'on bir',),\n        (20, 'iyirmi',),\n        (22, 'iyirmi iki',),\n        (30, 'otuz',),\n        (33, 'otuz \u00fc\u00e7',),\n        (40, 'q\u0131rx',),\n        (44, 'q\u0131rx d\u00f6rd',),\n        (50, '\u0259lli',),\n        (55, '\u0259lli be\u015f',),\n        (60, 'altm\u0131\u015f',),\n        (66, 'altm\u0131\u015f alt\u0131',),\n        (70, 'yetmi\u015f',),\n        (77, 'yetmi\u015f yeddi',),\n        (80, 's\u0259ks\u0259n',),\n        (88, 's\u0259ks\u0259n s\u0259kkiz',),\n        (90, 'doxsan',),\n        (99, 'doxsan doqquz',),\n        (100, 'y\u00fcz',),\n        (200, 'iki y\u00fcz',),\n        (678, 'alt\u0131 y\u00fcz yetmi\u015f s\u0259kkiz',),\n        (999, 'doqquz y\u00fcz doxsan doqquz',),\n        (1000, 'min',),\n        (100_000, 'y\u00fcz min',),\n        (328_914, '\u00fc\u00e7 y\u00fcz iyirmi s\u0259kkiz min doqquz y\u00fcz on d\u00f6rd',),\n        (1_000_000, 'bir milyon',),\n        (1_000_000_000, 'bir milyard',),\n        (10**12, 'bir trilyon',),\n        (10**15, 'bir katrilyon',),\n        (10**18, 'bir kentilyon',),\n        (10**21, 'bir sekstilyon',),\n        (10**24, 'bir septilyon',),\n        (10**27, 'bir oktilyon',),\n        (10**30, 'bir nonilyon',),\n        (10**33, 'bir desilyon',),\n        (10**36, 'bir undesilyon',),\n        (10**39, 'bir dodesilyon',),\n        (10**42, 'bir tredesilyon',),\n        (10**45, 'bir katordesilyon',),\n        (10**48, 'bir kendesilyon',),\n        (10**51, 'bir seksdesilyon',),\n        (10**54, 'bir septendesilyon',),\n        (10**57, 'bir oktodesilyon',),\n        (10**60, 'bir novemdesilyon',),\n        (10**63, 'bir vigintilyon',),\n        (-0, 's\u0131f\u0131r',),\n        (-1, 'm\u0259nfi bir',),\n        (-2, 'm\u0259nfi iki',),\n        (-3, 'm\u0259nfi \u00fc\u00e7',),\n        (-4, 'm\u0259nfi d\u00f6rd',),\n        (-5, 'm\u0259nfi be\u015f',),\n        (-6, 'm\u0259nfi alt\u0131',),\n        (-7, 'm\u0259nfi yeddi',),\n        (-8, 'm\u0259nfi s\u0259kkiz',),\n        (-9, 'm\u0259nfi doqquz',),\n        (-10, 'm\u0259nfi on',),\n        (-11, 'm\u0259nfi on bir',),\n        (-20, 'm\u0259nfi iyirmi',),\n        (-22, 'm\u0259nfi iyirmi iki',),\n        (-30, 'm\u0259nfi otuz',),\n        (-33, 'm\u0259nfi otuz \u00fc\u00e7',),\n        (-40, 'm\u0259nfi q\u0131rx',),\n        (-44, 'm\u0259nfi q\u0131rx d\u00f6rd',),\n        (-50, 'm\u0259nfi \u0259lli',),\n        (-55, 'm\u0259nfi \u0259lli be\u015f',),\n        (-60, 'm\u0259nfi altm\u0131\u015f',),\n        (-66, 'm\u0259nfi altm\u0131\u015f alt\u0131',),\n        (-70, 'm\u0259nfi yetmi\u015f',),\n        (-77, 'm\u0259nfi yetmi\u015f yeddi',),\n        (-80, 'm\u0259nfi s\u0259ks\u0259n',),\n        (-88, 'm\u0259nfi s\u0259ks\u0259n s\u0259kkiz',),\n        (-90, 'm\u0259nfi doxsan',),\n        (-99, 'm\u0259nfi doxsan doqquz',),\n        (-100, 'm\u0259nfi y\u00fcz',),\n        (-200, 'm\u0259nfi iki y\u00fcz',),\n        (-678, 'm\u0259nfi alt\u0131 y\u00fcz yetmi\u015f s\u0259kkiz',),\n        (-999, 'm\u0259nfi doqquz y\u00fcz doxsan doqquz',),\n        (-1000, 'm\u0259nfi min',),\n        (-100_000, 'm\u0259nfi y\u00fcz min',),\n        (-328_914, 'm\u0259nfi \u00fc\u00e7 y\u00fcz iyirmi s\u0259kkiz min doqquz y\u00fcz on d\u00f6rd',),\n        (-1_000_000, 'm\u0259nfi bir milyon',),\n        (-1_000_000_000, 'm\u0259nfi bir milyard',),\n        (-10**12, 'm\u0259nfi bir trilyon',),\n        (-10**15, 'm\u0259nfi bir katrilyon',),\n        (-10**18, 'm\u0259nfi bir kentilyon',),\n        (-10**21, 'm\u0259nfi bir sekstilyon',),\n        (-10**24, 'm\u0259nfi bir septilyon',),\n        (-10**27, 'm\u0259nfi bir oktilyon',),\n        (-10**30, 'm\u0259nfi bir nonilyon',),\n        (-10**33, 'm\u0259nfi bir desilyon',),\n        (-10**36, 'm\u0259nfi bir undesilyon',),\n        (-10**39, 'm\u0259nfi bir dodesilyon',),\n        (-10**42, 'm\u0259nfi bir tredesilyon',),\n        (-10**45, 'm\u0259nfi bir katordesilyon',),\n        (-10**48, 'm\u0259nfi bir kendesilyon',),\n        (-10**51, 'm\u0259nfi bir seksdesilyon',),\n        (-10**54, 'm\u0259nfi bir septendesilyon',),\n        (-10**57, 'm\u0259nfi bir oktodesilyon',),\n        (-10**60, 'm\u0259nfi bir novemdesilyon',),\n        (-10**63, 'm\u0259nfi bir vigintilyon'),\n    )\n\n    CARDINAL_FRACTION_TEST_CASES = (\n        (0.2, 's\u0131f\u0131r n\u00f6qt\u0259 iki',),\n        (0.02, 's\u0131f\u0131r n\u00f6qt\u0259 s\u0131f\u0131r iki',),\n        (0.23, 's\u0131f\u0131r n\u00f6qt\u0259 iyirmi \u00fc\u00e7',),\n        (0.0023, 's\u0131f\u0131r n\u00f6qt\u0259 s\u0131f\u0131r s\u0131f\u0131r iyirmi \u00fc\u00e7',),\n        (1.43, 'bir n\u00f6qt\u0259 q\u0131rx \u00fc\u00e7',),\n        (-0.2, 'm\u0259nfi s\u0131f\u0131r n\u00f6qt\u0259 iki',),\n        (-0.02, 'm\u0259nfi s\u0131f\u0131r n\u00f6qt\u0259 s\u0131f\u0131r iki',),\n        (-0.23, 'm\u0259nfi s\u0131f\u0131r n\u00f6qt\u0259 iyirmi \u00fc\u00e7',),\n        (-0.0023, 'm\u0259nfi s\u0131f\u0131r n\u00f6qt\u0259 s\u0131f\u0131r s\u0131f\u0131r iyirmi \u00fc\u00e7',),\n        (-1.43, 'm\u0259nfi bir n\u00f6qt\u0259 q\u0131rx \u00fc\u00e7',),\n    )\n\n    ORDINAL_TEST_CASES = (\n        (0, 's\u0131f\u0131r\u0131nc\u0131',),\n        (1, 'birinci',),\n        (2, 'ikinci',),\n        (3, '\u00fc\u00e7\u00fcnc\u00fc',),\n        (4, 'd\u00f6rd\u00fcnc\u00fc',),\n        (5, 'be\u015finci',),\n        (6, 'alt\u0131nc\u0131',),\n        (7, 'yeddinci',),\n        (8, 's\u0259kkizinci',),\n        (9, 'doqquzuncu',),\n        (10, 'onuncu',),\n        (11, 'on birinci',),\n        (20, 'iyirminci',),\n        (22, 'iyirmi ikinci',),\n        (30, 'otuzuncu',),\n        (33, 'otuz \u00fc\u00e7\u00fcnc\u00fc',),\n        (40, 'q\u0131rx\u0131nc\u0131',),\n        (44, 'q\u0131rx d\u00f6rd\u00fcnc\u00fc',),\n        (50, '\u0259llinci',),\n        (55, '\u0259lli be\u015finci',),\n        (60, 'altm\u0131\u015f\u0131nc\u0131',),\n        (66, 'altm\u0131\u015f alt\u0131nc\u0131',),\n        (70, 'yetmi\u015finci',),\n        (77, 'yetmi\u015f yeddinci',),\n        (80, 's\u0259ks\u0259ninci',),\n        (88, 's\u0259ks\u0259n s\u0259kkizinci',),\n        (90, 'doxsan\u0131nc\u0131',),\n        (99, 'doxsan doqquzuncu',),\n        (100, 'y\u00fcz\u00fcnc\u00fc',),\n        (1000, 'mininci',),\n        (328_914, '\u00fc\u00e7 y\u00fcz iyirmi s\u0259kkiz min doqquz y\u00fcz on d\u00f6rd\u00fcnc\u00fc',),\n        (1_000_000, 'bir milyonuncu'),\n    )\n\n    ORDINAL_NUM_TEST_CASES = (\n        (0, '0-c\u0131',),\n        (1, '1-ci',),\n        (2, '2-ci',),\n        (3, '3-c\u00fc',),\n        (4, '4-c\u00fc',),\n        (5, '5-ci',),\n        (6, '6-c\u0131',),\n        (7, '7-ci',),\n        (8, '8-ci',),\n        (9, '9-cu',),\n        (10, '10-cu',),\n        (11, '11-ci',),\n        (20, '20-ci',),\n        (22, '22-ci',),\n        (30, '30-cu',),\n        (33, '33-c\u00fc',),\n        (40, '40-c\u0131',),\n        (44, '44-c\u00fc',),\n        (50, '50-ci',),\n        (55, '55-ci',),\n        (60, '60-c\u0131',),\n        (66, '66-c\u0131',),\n        (70, '70-ci',),\n        (77, '77-ci',),\n        (80, '80-ci',),\n        (88, '88-ci',),\n        (90, '90-c\u0131',),\n        (99, '99-cu',),\n        (100, '100-c\u00fc',),\n        (1000, '1000-ci',),\n        (328_914, '328914-c\u00fc',),\n        (1_000_000, '1000000-cu'),\n    )\n\n    YEAR_TEST_CASES = (\n        (167, 'y\u00fcz altm\u0131\u015f yeddi'),\n        (1552, 'min be\u015f y\u00fcz \u0259lli iki'),\n        (1881, 'min s\u0259kkiz y\u00fcz s\u0259ks\u0259n bir'),\n        (2022, 'iki min iyirmi iki'),\n        (-1, 'e.\u0259. bir'),\n        (-500, 'e.\u0259. be\u015f y\u00fcz'),\n        (-5000, 'e.\u0259. be\u015f min'),\n    )\n\n    CURRENCY_TEST_CASES = (\n        (0.0, 's\u0131f\u0131r manat, s\u0131f\u0131r q\u0259pik'),\n        (0.01, 's\u0131f\u0131r manat, bir q\u0259pik'),\n        (0.1, 's\u0131f\u0131r manat, on q\u0259pik'),\n        (1.5, 'bir manat, \u0259lli q\u0259pik'),\n        (1.94, 'bir manat, doxsan d\u00f6rd q\u0259pik'),\n        (17.82, 'on yeddi manat, s\u0259ks\u0259n iki q\u0259pik'),\n    )\n\n    def test_cardinal(self):\n        \"\"\"Test cardinal conversion for integer numbers.\"\"\"\n\n        for number, expected in self.CARDINAL_TEST_CASES:\n            actual = num2words(number, lang=self.lang, to='cardinal')\n\n            self.assertEqual(actual, expected)\n\n    def test_cardinal_fracion(self):\n        \"\"\"Test cardinal conversion for numbers with fraction.\"\"\"\n\n        for number, expected in self.CARDINAL_FRACTION_TEST_CASES:\n            actual = num2words(number, lang=self.lang, to='cardinal')\n\n            self.assertEqual(actual, expected)\n\n    def test_ordinal(self):\n        \"\"\"Test ordinal conversion.\"\"\"\n\n        for number, expected in self.ORDINAL_TEST_CASES:\n            actual = num2words(number, lang=self.lang, to='ordinal')\n\n            self.assertEqual(actual, expected)\n\n    def test_ordinal_num(self):\n        \"\"\"Test 'ordinal_num' conversion.\"\"\"\n\n        for number, expected in self.ORDINAL_NUM_TEST_CASES:\n            actual = num2words(number, lang=self.lang, to='ordinal_num')\n\n            self.assertEqual(actual, expected)\n\n    def test_year(self):\n        \"\"\"Test year conversion.\"\"\"\n\n        for number, expected in self.YEAR_TEST_CASES:\n            actual = num2words(number, lang=self.lang, to='year')\n\n            self.assertEqual(actual, expected)\n\n    def test_currency(self):\n        \"\"\"Test currency conversion.\"\"\"\n\n        for number, expected in self.CURRENCY_TEST_CASES:\n            actual = num2words(\n                number, lang=self.lang, currency='AZN', to='currency')\n\n            self.assertEqual(actual, expected)\n",
  "GT_file_code": {
    "num2words/lang_AZ.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom .base import Num2Word_Base\n\n\nclass Num2Word_AZ(Num2Word_Base):\n    DIGITS = {\n        0: u\"s\u0131f\u0131r\",\n        1: u\"bir\",\n        2: u\"iki\",\n        3: u\"\u00fc\u00e7\",\n        4: u\"d\u00f6rd\",\n        5: u\"be\u015f\",\n        6: u\"alt\u0131\",\n        7: u\"yeddi\",\n        8: u\"s\u0259kkiz\",\n        9: u\"doqquz\",\n    }\n\n    DECIMALS = {\n        1: u\"on\",\n        2: u\"iyirmi\",\n        3: u\"otuz\",\n        4: u\"q\u0131rx\",\n        5: u\"\u0259lli\",\n        6: u\"altm\u0131\u015f\",\n        7: u\"yetmi\u015f\",\n        8: u\"s\u0259ks\u0259n\",\n        9: u\"doxsan\",\n    }\n\n    POWERS_OF_TEN = {\n        2: u\"y\u00fcz\",\n        3: u\"min\",\n        6: u\"milyon\",\n        9: u\"milyard\",\n        12: u\"trilyon\",\n        15: u\"katrilyon\",\n        18: u\"kentilyon\",\n        21: u\"sekstilyon\",\n        24: u\"septilyon\",\n        27: u\"oktilyon\",\n        30: u\"nonilyon\",\n        33: u\"desilyon\",\n        36: u\"undesilyon\",\n        39: u\"dodesilyon\",\n        42: u\"tredesilyon\",\n        45: u\"katordesilyon\",\n        48: u\"kendesilyon\",\n        51: u\"seksdesilyon\",\n        54: u\"septendesilyon\",\n        57: u\"oktodesilyon\",\n        60: u\"novemdesilyon\",\n        63: u\"vigintilyon\",\n    }\n\n    VOWELS = u\"a\u0131oue\u0259i\u00f6\u00fc\"\n    VOWEL_TO_CARDINAL_SUFFIX_MAP = {\n        **dict.fromkeys([\"a\", \"\u0131\"], \"\u0131nc\u0131\"),\n        **dict.fromkeys([\"e\", \"\u0259\", \"i\"], \"inci\"),\n        **dict.fromkeys([\"o\", \"u\"], \"uncu\"),\n        **dict.fromkeys([\"\u00f6\", \"\u00fc\"], \"\u00fcnc\u00fc\"),\n    }\n\n    VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP = {\n        **dict.fromkeys([\"a\", \"\u0131\"], \"c\u0131\"),\n        **dict.fromkeys([\"e\", \"\u0259\", \"i\"], \"ci\"),\n        **dict.fromkeys([\"o\", \"u\"], \"cu\"),\n        **dict.fromkeys([\"\u00f6\", \"\u00fc\"], \"c\u00fc\"),\n    }\n\n    CURRENCY_INTEGRAL = ('manat', 'manat')\n    CURRENCY_FRACTION = ('q\u0259pik', 'q\u0259pik')\n    CURRENCY_FORMS = {'AZN': (CURRENCY_INTEGRAL, CURRENCY_FRACTION)}\n\n    def setup(self):\n        super().setup()\n\n        self.negword = u\"m\u0259nfi\"\n        self.pointword = u\"n\u00f6qt\u0259\"\n\n    def to_cardinal(self, value):\n        value_str = str(value)\n        parts = value_str.split(\".\")\n        integral_part = parts[0]\n        fraction_part = parts[1] if len(parts) > 1 else \"\"\n\n        if integral_part.startswith(\"-\"):\n            integral_part = integral_part[1:]  # ignore minus sign here\n\n        integral_part_in_words = self.int_to_word(integral_part)\n        fraction_part_in_words = \"\" if not fraction_part else self.int_to_word(\n            fraction_part, leading_zeros=True)\n\n        value_in_words = integral_part_in_words\n        if fraction_part:\n            value_in_words = \" \".join(\n                [\n                    integral_part_in_words,\n                    self.pointword,\n                    fraction_part_in_words\n                ]\n            )\n\n        if value < 0:\n            value_in_words = \" \".join([self.negword, value_in_words])\n\n        return value_in_words\n\n    def to_ordinal(self, value):\n        assert int(value) == value\n\n        cardinal = self.to_cardinal(value)\n        last_vowel = self._last_vowel(cardinal)\n        assert last_vowel is not None\n        suffix = self.VOWEL_TO_CARDINAL_SUFFIX_MAP[last_vowel]\n\n        if cardinal.endswith(tuple(self.VOWELS)):\n            cardinal = cardinal[:-1]\n\n        ordinal = \"\".join([cardinal, suffix])\n\n        return ordinal\n\n    def to_ordinal_num(self, value):\n        assert int(value) == value\n\n        cardinal = self.to_cardinal(value)\n        last_vowel = self._last_vowel(cardinal)\n        assert last_vowel is not None\n        suffix = self.VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP[last_vowel]\n        ordinal_num = \"-\".join([str(value), suffix])\n\n        return ordinal_num\n\n    def to_year(self, value):\n        assert int(value) == value\n\n        year = self.to_cardinal(abs(value))\n        if value < 0:\n            year = \" \".join([\"e.\u0259.\", year])\n\n        return year\n\n    def pluralize(self, n, forms):\n        form = 0 if n == 1 else 1\n        return forms[form]\n\n    def int_to_word(self, num_str, leading_zeros=False):\n        words = []\n        reversed_str = list(reversed(num_str))\n\n        for index, digit in enumerate(reversed_str):\n            digit_int = int(digit)\n            # calculate remainder after dividing index by 3\n            # because number is parsed by three digit chunks\n            remainder_to_3 = index % 3\n            if remainder_to_3 == 0:\n                if index > 0:\n                    if set(reversed_str[index:index+3]) != {'0'}:\n                        words.insert(0, self.POWERS_OF_TEN[index])\n                if digit_int > 0:\n                    # we say \"min\" not \"bir min\"\n                    if not (digit_int == 1 and index == 3):\n                        words.insert(0, self.DIGITS[digit_int])\n            elif remainder_to_3 == 1:\n                if digit_int != 0:\n                    words.insert(0, self.DECIMALS[digit_int])\n            else:  # remainder is 2\n                if digit_int > 0:\n                    words.insert(0, self.POWERS_OF_TEN[2])  # \"y\u00fcz\"\n                if digit_int > 1:\n                    words.insert(0, self.DIGITS[digit_int])\n\n        if num_str == '0':\n            words.append(self.DIGITS[0])\n\n        if leading_zeros:\n            zeros_count = len(num_str) - len(str(int(num_str)))\n            words[:0] = zeros_count * [self.DIGITS[0]]\n\n        return \" \".join(words)\n\n    def _last_vowel(self, value):\n        for char in value[::-1]:\n            if char in self.VOWELS:\n                return char\n",
    "num2words/__init__.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom . import (lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE,\n               lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN,\n               lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR,\n               lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR,\n               lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID,\n               lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT,\n               lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR,\n               lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE,\n               lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI)\n\nCONVERTER_CLASSES = {\n    'am': lang_AM.Num2Word_AM(),\n    'ar': lang_AR.Num2Word_AR(),\n    'az': lang_AZ.Num2Word_AZ(),\n    'be': lang_BE.Num2Word_BE(),\n    'bn': lang_BN.Num2Word_BN(),\n    'ca': lang_CA.Num2Word_CA(),\n    'ce': lang_CE.Num2Word_CE(),\n    'cy': lang_CY.Num2Word_CY(),\n    'cz': lang_CZ.Num2Word_CZ(),\n    'en': lang_EN.Num2Word_EN(),\n    'en_IN': lang_EN_IN.Num2Word_EN_IN(),\n    'en_NG': lang_EN_NG.Num2Word_EN_NG(),\n    'fa': lang_FA.Num2Word_FA(),\n    'fr': lang_FR.Num2Word_FR(),\n    'fr_CH': lang_FR_CH.Num2Word_FR_CH(),\n    'fr_BE': lang_FR_BE.Num2Word_FR_BE(),\n    'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(),\n    'de': lang_DE.Num2Word_DE(),\n    'fi': lang_FI.Num2Word_FI(),\n    'eo': lang_EO.Num2Word_EO(),\n    'es': lang_ES.Num2Word_ES(),\n    'es_CO': lang_ES_CO.Num2Word_ES_CO(),\n    'es_CR': lang_ES_CR.Num2Word_ES_CR(),\n    'es_GT': lang_ES_GT.Num2Word_ES_GT(),\n    'es_NI': lang_ES_NI.Num2Word_ES_NI(),\n    'es_VE': lang_ES_VE.Num2Word_ES_VE(),\n    'id': lang_ID.Num2Word_ID(),\n    'ja': lang_JA.Num2Word_JA(),\n    'kn': lang_KN.Num2Word_KN(),\n    'ko': lang_KO.Num2Word_KO(),\n    'kz': lang_KZ.Num2Word_KZ(),\n    'lt': lang_LT.Num2Word_LT(),\n    'lv': lang_LV.Num2Word_LV(),\n    'pl': lang_PL.Num2Word_PL(),\n    'ro': lang_RO.Num2Word_RO(),\n    'ru': lang_RU.Num2Word_RU(),\n    'sk': lang_SK.Num2Word_SK(),\n    'sl': lang_SL.Num2Word_SL(),\n    'sr': lang_SR.Num2Word_SR(),\n    'sv': lang_SV.Num2Word_SV(),\n    'no': lang_NO.Num2Word_NO(),\n    'dk': lang_DK.Num2Word_DK(),\n    'pt': lang_PT.Num2Word_PT(),\n    'pt_BR': lang_PT_BR.Num2Word_PT_BR(),\n    'he': lang_HE.Num2Word_HE(),\n    'it': lang_IT.Num2Word_IT(),\n    'vi': lang_VI.Num2Word_VI(),\n    'tg': lang_TG.Num2Word_TG(),\n    'th': lang_TH.Num2Word_TH(),\n    'tr': lang_TR.Num2Word_TR(),\n    'nl': lang_NL.Num2Word_NL(),\n    'uk': lang_UK.Num2Word_UK(),\n    'te': lang_TE.Num2Word_TE(),\n    'tet': lang_TET.Num2Word_TET(),\n    'hu': lang_HU.Num2Word_HU(),\n    'is': lang_IS.Num2Word_IS(),\n}\n\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']\n\n\ndef num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    # We try the full language first\n    if lang not in CONVERTER_CLASSES:\n        # ... and then try only the first 2 letters\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n\n    # backwards compatible\n    if ordinal:\n        to = 'ordinal'\n\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)\n",
    "num2words/base.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nimport math\nfrom collections import OrderedDict\nfrom decimal import Decimal\n\nfrom .compat import to_s\nfrom .currency import parse_currency_parts, prefix_currency\n\n\nclass Num2Word_Base(object):\n    CURRENCY_FORMS = {}\n    CURRENCY_ADJECTIVES = {}\n\n    def __init__(self):\n        self.is_title = False\n        self.precision = 2\n        self.exclude_title = []\n        self.negword = \"(-) \"\n        self.pointword = \"(.)\"\n        self.errmsg_nonnum = \"type(%s) not in [long, int, float]\"\n        self.errmsg_floatord = \"Cannot treat float %s as ordinal.\"\n        self.errmsg_negord = \"Cannot treat negative num %s as ordinal.\"\n        self.errmsg_toobig = \"abs(%s) must be less than %s.\"\n\n        self.setup()\n\n        # uses cards\n        if any(hasattr(self, field) for field in\n               ['high_numwords', 'mid_numwords', 'low_numwords']):\n            self.cards = OrderedDict()\n            self.set_numwords()\n            self.MAXVAL = 1000 * list(self.cards.keys())[0]\n\n    def set_numwords(self):\n        self.set_high_numwords(self.high_numwords)\n        self.set_mid_numwords(self.mid_numwords)\n        self.set_low_numwords(self.low_numwords)\n\n    def set_high_numwords(self, *args):\n        raise NotImplementedError\n\n    def set_mid_numwords(self, mid):\n        for key, val in mid:\n            self.cards[key] = val\n\n    def set_low_numwords(self, numwords):\n        for word, n in zip(numwords, range(len(numwords) - 1, -1, -1)):\n            self.cards[n] = word\n\n    def splitnum(self, value):\n        for elem in self.cards:\n            if elem > value:\n                continue\n\n            out = []\n            if value == 0:\n                div, mod = 1, 0\n            else:\n                div, mod = divmod(value, elem)\n\n            if div == 1:\n                out.append((self.cards[1], 1))\n            else:\n                if div == value:  # The system tallies, eg Roman Numerals\n                    return [(div * self.cards[elem], div*elem)]\n                out.append(self.splitnum(div))\n\n            out.append((self.cards[elem], elem))\n\n            if mod:\n                out.append(self.splitnum(mod))\n\n            return out\n\n    def parse_minus(self, num_str):\n        \"\"\"Detach minus and return it as symbol with new num_str.\"\"\"\n        if num_str.startswith('-'):\n            # Extra spacing to compensate if there is no minus.\n            return '%s ' % self.negword.strip(), num_str[1:]\n        return '', num_str\n\n    def str_to_number(self, value):\n        return Decimal(value)\n\n    def to_cardinal(self, value):\n        try:\n            assert int(value) == value\n        except (ValueError, TypeError, AssertionError):\n            return self.to_cardinal_float(value)\n\n        out = \"\"\n        if value < 0:\n            value = abs(value)\n            out = \"%s \" % self.negword.strip()\n\n        if value >= self.MAXVAL:\n            raise OverflowError(self.errmsg_toobig % (value, self.MAXVAL))\n\n        val = self.splitnum(value)\n        words, num = self.clean(val)\n        return self.title(out + words)\n\n    def float2tuple(self, value):\n        pre = int(value)\n\n        # Simple way of finding decimal places to update the precision\n        self.precision = abs(Decimal(str(value)).as_tuple().exponent)\n\n        post = abs(value - pre) * 10**self.precision\n        if abs(round(post) - post) < 0.01:\n            # We generally floor all values beyond our precision (rather than\n            # rounding), but in cases where we have something like 1.239999999,\n            # which is probably due to python's handling of floats, we actually\n            # want to consider it as 1.24 instead of 1.23\n            post = int(round(post))\n        else:\n            post = int(math.floor(post))\n\n        return pre, post\n\n    def to_cardinal_float(self, value):\n        try:\n            float(value) == value\n        except (ValueError, TypeError, AssertionError, AttributeError):\n            raise TypeError(self.errmsg_nonnum % value)\n\n        pre, post = self.float2tuple(float(value))\n\n        post = str(post)\n        post = '0' * (self.precision - len(post)) + post\n\n        out = [self.to_cardinal(pre)]\n        if self.precision:\n            out.append(self.title(self.pointword))\n\n        for i in range(self.precision):\n            curr = int(post[i])\n            out.append(to_s(self.to_cardinal(curr)))\n\n        return \" \".join(out)\n\n    def merge(self, curr, next):\n        raise NotImplementedError\n\n    def clean(self, val):\n        out = val\n        while len(val) != 1:\n            out = []\n            left, right = val[:2]\n            if isinstance(left, tuple) and isinstance(right, tuple):\n                out.append(self.merge(left, right))\n                if val[2:]:\n                    out.append(val[2:])\n            else:\n                for elem in val:\n                    if isinstance(elem, list):\n                        if len(elem) == 1:\n                            out.append(elem[0])\n                        else:\n                            out.append(self.clean(elem))\n                    else:\n                        out.append(elem)\n            val = out\n        return out[0]\n\n    def title(self, value):\n        if self.is_title:\n            out = []\n            value = value.split()\n            for word in value:\n                if word in self.exclude_title:\n                    out.append(word)\n                else:\n                    out.append(word[0].upper() + word[1:])\n            value = \" \".join(out)\n        return value\n\n    def verify_ordinal(self, value):\n        if not value == int(value):\n            raise TypeError(self.errmsg_floatord % value)\n        if not abs(value) == value:\n            raise TypeError(self.errmsg_negord % value)\n\n    def to_ordinal(self, value):\n        return self.to_cardinal(value)\n\n    def to_ordinal_num(self, value):\n        return value\n\n    # Trivial version\n    def inflect(self, value, text):\n        text = text.split(\"/\")\n        if value == 1:\n            return text[0]\n        return \"\".join(text)\n\n    # //CHECK: generalise? Any others like pounds/shillings/pence?\n    def to_splitnum(self, val, hightxt=\"\", lowtxt=\"\", jointxt=\"\",\n                    divisor=100, longval=True, cents=True):\n        out = []\n\n        if isinstance(val, float):\n            high, low = self.float2tuple(val)\n        else:\n            try:\n                high, low = val\n            except TypeError:\n                high, low = divmod(val, divisor)\n\n        if high:\n            hightxt = self.title(self.inflect(high, hightxt))\n            out.append(self.to_cardinal(high))\n            if low:\n                if longval:\n                    if hightxt:\n                        out.append(hightxt)\n                    if jointxt:\n                        out.append(self.title(jointxt))\n            elif hightxt:\n                out.append(hightxt)\n\n        if low:\n            if cents:\n                out.append(self.to_cardinal(low))\n            else:\n                out.append(\"%02d\" % low)\n            if lowtxt and longval:\n                out.append(self.title(self.inflect(low, lowtxt)))\n\n        return \" \".join(out)\n\n    def to_year(self, value, **kwargs):\n        return self.to_cardinal(value)\n\n    def pluralize(self, n, forms):\n        \"\"\"\n        Should resolve gettext form:\n        http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html\n        \"\"\"\n        raise NotImplementedError\n\n    def _money_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_terse(self, number, currency):\n        return \"%02d\" % number\n\n    def to_currency(self, val, currency='EUR', cents=True, separator=',',\n                    adjective=False):\n        \"\"\"\n        Args:\n            val: Numeric value\n            currency (str): Currency code\n            cents (bool): Verbose cents\n            separator (str): Cent separator\n            adjective (bool): Prefix currency name with adjective\n        Returns:\n            str: Formatted string\n\n        \"\"\"\n        left, right, is_negative = parse_currency_parts(val)\n\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n\n        except KeyError:\n            raise NotImplementedError(\n                'Currency code \"%s\" not implemented for \"%s\"' %\n                (currency, self.__class__.__name__))\n\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n\n        minus_str = \"%s \" % self.negword.strip() if is_negative else \"\"\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) \\\n            if cents else self._cents_terse(right, currency)\n\n        return u'%s%s %s%s %s %s' % (\n            minus_str,\n            money_str,\n            self.pluralize(left, cr1),\n            separator,\n            cents_str,\n            self.pluralize(right, cr2)\n        )\n\n    def setup(self):\n        pass\n"
  },
  "GT_src_dict": {
    "num2words/lang_AZ.py": {
      "Num2Word_AZ.to_cardinal": {
        "code": "    def to_cardinal(self, value):\n        \"\"\"Converts a numeric value into its Azerbaijani cardinal representation.\n\nParameters:\n    value (int, float): The numeric value to be converted to words. It can be a negative, integral, or decimal number.\n\nReturns:\n    str: The numeric value converted into its corresponding words in Azerbaijani. The output includes the negative word 'm\u0259nfi' for negative numbers and the word 'n\u00f6qt\u0259' to denote the decimal point, if applicable.\n\nNote:\n- This method utilizes the `int_to_word` helper method to convert both the integral and fractional parts of the number into words.\n- Constants like `self.pointword` (defined in the `setup` method) and `self.negword` are used to format the return string correctly, specifically handling the negative sign and decimal point in the output.\n- The function assumes that any decimal portion follows the integral portion, with a separator of \".\" (dot).\"\"\"\n        value_str = str(value)\n        parts = value_str.split('.')\n        integral_part = parts[0]\n        fraction_part = parts[1] if len(parts) > 1 else ''\n        if integral_part.startswith('-'):\n            integral_part = integral_part[1:]\n        integral_part_in_words = self.int_to_word(integral_part)\n        fraction_part_in_words = '' if not fraction_part else self.int_to_word(fraction_part, leading_zeros=True)\n        value_in_words = integral_part_in_words\n        if fraction_part:\n            value_in_words = ' '.join([integral_part_in_words, self.pointword, fraction_part_in_words])\n        if value < 0:\n            value_in_words = ' '.join([self.negword, value_in_words])\n        return value_in_words",
        "docstring": "Converts a numeric value into its Azerbaijani cardinal representation.\n\nParameters:\n    value (int, float): The numeric value to be converted to words. It can be a negative, integral, or decimal number.\n\nReturns:\n    str: The numeric value converted into its corresponding words in Azerbaijani. The output includes the negative word 'm\u0259nfi' for negative numbers and the word 'n\u00f6qt\u0259' to denote the decimal point, if applicable.\n\nNote:\n- This method utilizes the `int_to_word` helper method to convert both the integral and fractional parts of the number into words.\n- Constants like `self.pointword` (defined in the `setup` method) and `self.negword` are used to format the return string correctly, specifically handling the negative sign and decimal point in the output.\n- The function assumes that any decimal portion follows the integral portion, with a separator of \".\" (dot).",
        "signature": "def to_cardinal(self, value):",
        "type": "Method",
        "class_signature": "class Num2Word_AZ(Num2Word_Base):"
      },
      "Num2Word_AZ.to_ordinal": {
        "code": "    def to_ordinal(self, value):\n        \"\"\"Converts a given integer value to its ordinal representation in Azerbaijani language.\n\nParameters:\n    value (int): The integer value to be converted to an ordinal. It must be a whole number.\n\nReturns:\n    str: The ordinal representation of the input integer as a string.\n\nDependencies:\n    This method utilizes the `to_cardinal` method from the `Num2Word_AZ` class to first convert the integer to its cardinal form. The suffix for the ordinal is determined by the last vowel in the cardinal representation using the `_last_vowel` helper method. Constants `VOWEL_TO_CARDINAL_SUFFIX_MAP` and `VOWELS` are used to map the last vowel to the correct ordinal suffix.\n\nSide Effects:\n    An assertion raises an error if the input value is not an integer or if it cannot be converted properly.\"\"\"\n        assert int(value) == value\n        cardinal = self.to_cardinal(value)\n        last_vowel = self._last_vowel(cardinal)\n        assert last_vowel is not None\n        suffix = self.VOWEL_TO_CARDINAL_SUFFIX_MAP[last_vowel]\n        if cardinal.endswith(tuple(self.VOWELS)):\n            cardinal = cardinal[:-1]\n        ordinal = ''.join([cardinal, suffix])\n        return ordinal",
        "docstring": "Converts a given integer value to its ordinal representation in Azerbaijani language.\n\nParameters:\n    value (int): The integer value to be converted to an ordinal. It must be a whole number.\n\nReturns:\n    str: The ordinal representation of the input integer as a string.\n\nDependencies:\n    This method utilizes the `to_cardinal` method from the `Num2Word_AZ` class to first convert the integer to its cardinal form. The suffix for the ordinal is determined by the last vowel in the cardinal representation using the `_last_vowel` helper method. Constants `VOWEL_TO_CARDINAL_SUFFIX_MAP` and `VOWELS` are used to map the last vowel to the correct ordinal suffix.\n\nSide Effects:\n    An assertion raises an error if the input value is not an integer or if it cannot be converted properly.",
        "signature": "def to_ordinal(self, value):",
        "type": "Method",
        "class_signature": "class Num2Word_AZ(Num2Word_Base):"
      },
      "Num2Word_AZ.to_ordinal_num": {
        "code": "    def to_ordinal_num(self, value):\n        \"\"\"Converts a given integer value to its ordinal representation as a string in Azerbaijani.\n\nParameters:\n- value (int): The integer to convert to its ordinal representation. Must be a whole number.\n\nReturns:\n- str: The ordinal representation of the integer, formatted as \"value-suffix\" where suffix is determined based on the last vowel of the cardinal form of the number.\n\nDependencies:\n- Utilizes the `to_cardinal` method to convert the integer to its cardinal form.\n- Uses the `_last_vowel` method to determine the last vowel in the cardinal form, which is essential for deciding the correct ordinal suffix from the `VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP`.\n\nConstants:\n- `VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP`: A dictionary mapping vowels to their respective ordinal suffixes, defining how the ordinal form should be constructed based on phonetic rules in Azerbaijani.\"\"\"\n        assert int(value) == value\n        cardinal = self.to_cardinal(value)\n        last_vowel = self._last_vowel(cardinal)\n        assert last_vowel is not None\n        suffix = self.VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP[last_vowel]\n        ordinal_num = '-'.join([str(value), suffix])\n        return ordinal_num",
        "docstring": "Converts a given integer value to its ordinal representation as a string in Azerbaijani.\n\nParameters:\n- value (int): The integer to convert to its ordinal representation. Must be a whole number.\n\nReturns:\n- str: The ordinal representation of the integer, formatted as \"value-suffix\" where suffix is determined based on the last vowel of the cardinal form of the number.\n\nDependencies:\n- Utilizes the `to_cardinal` method to convert the integer to its cardinal form.\n- Uses the `_last_vowel` method to determine the last vowel in the cardinal form, which is essential for deciding the correct ordinal suffix from the `VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP`.\n\nConstants:\n- `VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP`: A dictionary mapping vowels to their respective ordinal suffixes, defining how the ordinal form should be constructed based on phonetic rules in Azerbaijani.",
        "signature": "def to_ordinal_num(self, value):",
        "type": "Method",
        "class_signature": "class Num2Word_AZ(Num2Word_Base):"
      },
      "Num2Word_AZ.to_year": {
        "code": "    def to_year(self, value):\n        \"\"\"Converts a given integer year into its verbal representation in Azerbaijani.\n\nParameters:\n- value (int): An integer representing the year to be converted. The year can be positive or negative.\n\nReturns:\n- str: The verbal representation of the year in Azerbaijani. If the year is negative, it prefixes the output with \"e.\u0259.\" (indicating the year is before the common era).\n\nDependencies:\n- The method relies on the `to_cardinal` method from the Num2Word_AZ class to convert the absolute value of the year into words.\n- It asserts that the input value is an integer.\"\"\"\n        assert int(value) == value\n        year = self.to_cardinal(abs(value))\n        if value < 0:\n            year = ' '.join(['e.\u0259.', year])\n        return year",
        "docstring": "Converts a given integer year into its verbal representation in Azerbaijani.\n\nParameters:\n- value (int): An integer representing the year to be converted. The year can be positive or negative.\n\nReturns:\n- str: The verbal representation of the year in Azerbaijani. If the year is negative, it prefixes the output with \"e.\u0259.\" (indicating the year is before the common era).\n\nDependencies:\n- The method relies on the `to_cardinal` method from the Num2Word_AZ class to convert the absolute value of the year into words.\n- It asserts that the input value is an integer.",
        "signature": "def to_year(self, value):",
        "type": "Method",
        "class_signature": "class Num2Word_AZ(Num2Word_Base):"
      }
    },
    "num2words/__init__.py": {
      "num2words": {
        "code": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n    \"\"\"Converts a given number into its word representation in a specified language.\n\nParameters:\n- number (int, float, str): The number to be converted to words. It can be provided as an integer, float, or string.\n- ordinal (bool): If set to True, converts the number to its ordinal form (default is False).\n- lang (str): The language code (e.g., 'en', 'fr') for the conversion. If the full language code is not found, the first two letters will be used.\n- to (str): Specifies the type of number conversion ('cardinal', 'ordinal', 'ordinal_num', 'year', 'currency'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments to be passed to the conversion methods.\n\nReturns:\n- str: The word representation of the given number in the specified language.\n\nRaises:\n- NotImplementedError: If the language is not supported or the conversion type is not valid.\n\nDependencies:\n- Uses the CONVERTER_CLASSES dictionary which maps language codes to respective language converters that implement conversion logic.\n- Uses the CONVERTES_TYPES list to validate the type of conversion requested.\"\"\"\n    if lang not in CONVERTER_CLASSES:\n        lang = lang[:2]\n    if lang not in CONVERTER_CLASSES:\n        raise NotImplementedError()\n    converter = CONVERTER_CLASSES[lang]\n    if isinstance(number, str):\n        number = converter.str_to_number(number)\n    if ordinal:\n        to = 'ordinal'\n    if to not in CONVERTES_TYPES:\n        raise NotImplementedError()\n    return getattr(converter, 'to_{}'.format(to))(number, **kwargs)",
        "docstring": "Converts a given number into its word representation in a specified language.\n\nParameters:\n- number (int, float, str): The number to be converted to words. It can be provided as an integer, float, or string.\n- ordinal (bool): If set to True, converts the number to its ordinal form (default is False).\n- lang (str): The language code (e.g., 'en', 'fr') for the conversion. If the full language code is not found, the first two letters will be used.\n- to (str): Specifies the type of number conversion ('cardinal', 'ordinal', 'ordinal_num', 'year', 'currency'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments to be passed to the conversion methods.\n\nReturns:\n- str: The word representation of the given number in the specified language.\n\nRaises:\n- NotImplementedError: If the language is not supported or the conversion type is not valid.\n\nDependencies:\n- Uses the CONVERTER_CLASSES dictionary which maps language codes to respective language converters that implement conversion logic.\n- Uses the CONVERTES_TYPES list to validate the type of conversion requested.",
        "signature": "def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):",
        "type": "Function",
        "class_signature": null
      }
    },
    "num2words/base.py": {
      "Num2Word_Base.to_currency": {
        "code": "    def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):\n        \"\"\"Converts a numeric value into a formatted currency string. It decomposes the value into its whole and fractional parts, and handles formatting based on provided parameters such as currency type and verbosity of the fractional part.\n\nParameters:\n- val (numeric): The numeric value to be converted to currency format.\n- currency (str, optional): The currency code (default is 'EUR'). This code is used to determine how to format the currency.\n- cents (bool, optional): If True (default), returns verbose formatting for the fractional part; if False, returns a terse integer representation.\n- separator (str, optional): The string to use as a separator between the whole and fractional parts (default is ',').\n- adjective (bool, optional): If True, prefixes the currency name with an adjective based on the defined currency adjectives.\n\nReturns:\n- str: The formatted currency string that includes the whole and fractional parts, properly formatted based on the specified options, and includes a negation prefix if the value is negative.\n\nDependencies:\n- parse_currency_parts: A utility that splits the given value into left (whole), right (fractional), and a boolean indicating if it's negative. \n- CURRENCY_FORMS: A class-level dictionary mapping currency codes to their respective formats, defined in the Num2Word_Base class.\n- CURRENCY_ADJECTIVES: A class-level dictionary that may provide adjectives for certain currencies if applicable.\n- _money_verbose and _cents_verbose / _cents_terse: Methods that handle the formatting of the whole and fractional parts of the currency value.\n- pluralize: A method that handles pluralization of the currency terms based on the numeric values.\"\"\"\n        '\\n        Args:\\n            val: Numeric value\\n            currency (str): Currency code\\n            cents (bool): Verbose cents\\n            separator (str): Cent separator\\n            adjective (bool): Prefix currency name with adjective\\n        Returns:\\n            str: Formatted string\\n\\n        '\n        left, right, is_negative = parse_currency_parts(val)\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n        except KeyError:\n            raise NotImplementedError('Currency code \"%s\" not implemented for \"%s\"' % (currency, self.__class__.__name__))\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n        minus_str = '%s ' % self.negword.strip() if is_negative else ''\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) if cents else self._cents_terse(right, currency)\n        return u'%s%s %s%s %s %s' % (minus_str, money_str, self.pluralize(left, cr1), separator, cents_str, self.pluralize(right, cr2))",
        "docstring": "Converts a numeric value into a formatted currency string. It decomposes the value into its whole and fractional parts, and handles formatting based on provided parameters such as currency type and verbosity of the fractional part.\n\nParameters:\n- val (numeric): The numeric value to be converted to currency format.\n- currency (str, optional): The currency code (default is 'EUR'). This code is used to determine how to format the currency.\n- cents (bool, optional): If True (default), returns verbose formatting for the fractional part; if False, returns a terse integer representation.\n- separator (str, optional): The string to use as a separator between the whole and fractional parts (default is ',').\n- adjective (bool, optional): If True, prefixes the currency name with an adjective based on the defined currency adjectives.\n\nReturns:\n- str: The formatted currency string that includes the whole and fractional parts, properly formatted based on the specified options, and includes a negation prefix if the value is negative.\n\nDependencies:\n- parse_currency_parts: A utility that splits the given value into left (whole), right (fractional), and a boolean indicating if it's negative. \n- CURRENCY_FORMS: A class-level dictionary mapping currency codes to their respective formats, defined in the Num2Word_Base class.\n- CURRENCY_ADJECTIVES: A class-level dictionary that may provide adjectives for certain currencies if applicable.\n- _money_verbose and _cents_verbose / _cents_terse: Methods that handle the formatting of the whole and fractional parts of the currency value.\n- pluralize: A method that handles pluralization of the currency terms based on the numeric values.",
        "signature": "def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: num2words-test_az\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 num2words/\n    \u251c\u2500\u2500 __init__.py\n    \u2502   \u2514\u2500\u2500 num2words\n    \u251c\u2500\u2500 base.py\n    \u2502   \u2514\u2500\u2500 Num2Word_Base.to_currency\n    \u2514\u2500\u2500 lang_AZ.py\n        \u251c\u2500\u2500 Num2Word_AZ.to_cardinal\n        \u251c\u2500\u2500 Num2Word_AZ.to_ordinal\n        \u251c\u2500\u2500 Num2Word_AZ.to_ordinal_num\n        \u2514\u2500\u2500 Num2Word_AZ.to_year\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates numerical text conversion in the Azerbaijani language, allowing numbers to be represented as cardinal, ordinal, ordinal numeral, year, and currency textual formats. It supports a wide range of inputs, including integers, decimals, and negative values, ensuring accurate linguistic representation for various use cases. By leveraging the capabilities of the `num2words` library, this module simplifies the process of transforming numeric data into human-readable, grammatically correct Azerbaijani text, which is particularly valuable for localization, financial reporting, and date processing. This solution eliminates the manual effort of writing and validating complex numeric-to-text conversion rules, enabling developers and systems to generate precise and contextually appropriate outputs.\n\n## FILE 1: num2words/lang_AZ.py\n\n- CLASS METHOD: Num2Word_AZ.to_ordinal_num\n  - CLASS SIGNATURE: class Num2Word_AZ(Num2Word_Base):\n  - SIGNATURE: def to_ordinal_num(self, value):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given integer value to its ordinal representation as a string in Azerbaijani.\n\nParameters:\n- value (int): The integer to convert to its ordinal representation. Must be a whole number.\n\nReturns:\n- str: The ordinal representation of the integer, formatted as \"value-suffix\" where suffix is determined based on the last vowel of the cardinal form of the number.\n\nDependencies:\n- Utilizes the `to_cardinal` method to convert the integer to its cardinal form.\n- Uses the `_last_vowel` method to determine the last vowel in the cardinal form, which is essential for deciding the correct ordinal suffix from the `VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP`.\n\nConstants:\n- `VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP`: A dictionary mapping vowels to their respective ordinal suffixes, defining how the ordinal form should be constructed based on phonetic rules in Azerbaijani.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_AZ.to_cardinal\n  - CLASS SIGNATURE: class Num2Word_AZ(Num2Word_Base):\n  - SIGNATURE: def to_cardinal(self, value):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a numeric value into its Azerbaijani cardinal representation.\n\nParameters:\n    value (int, float): The numeric value to be converted to words. It can be a negative, integral, or decimal number.\n\nReturns:\n    str: The numeric value converted into its corresponding words in Azerbaijani. The output includes the negative word 'm\u0259nfi' for negative numbers and the word 'n\u00f6qt\u0259' to denote the decimal point, if applicable.\n\nNote:\n- This method utilizes the `int_to_word` helper method to convert both the integral and fractional parts of the number into words.\n- Constants like `self.pointword` (defined in the `setup` method) and `self.negword` are used to format the return string correctly, specifically handling the negative sign and decimal point in the output.\n- The function assumes that any decimal portion follows the integral portion, with a separator of \".\" (dot).\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_AZ.to_year\n  - CLASS SIGNATURE: class Num2Word_AZ(Num2Word_Base):\n  - SIGNATURE: def to_year(self, value):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given integer year into its verbal representation in Azerbaijani.\n\nParameters:\n- value (int): An integer representing the year to be converted. The year can be positive or negative.\n\nReturns:\n- str: The verbal representation of the year in Azerbaijani. If the year is negative, it prefixes the output with \"e.\u0259.\" (indicating the year is before the common era).\n\nDependencies:\n- The method relies on the `to_cardinal` method from the Num2Word_AZ class to convert the absolute value of the year into words.\n- It asserts that the input value is an integer.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_AZ.to_ordinal\n  - CLASS SIGNATURE: class Num2Word_AZ(Num2Word_Base):\n  - SIGNATURE: def to_ordinal(self, value):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given integer value to its ordinal representation in Azerbaijani language.\n\nParameters:\n    value (int): The integer value to be converted to an ordinal. It must be a whole number.\n\nReturns:\n    str: The ordinal representation of the input integer as a string.\n\nDependencies:\n    This method utilizes the `to_cardinal` method from the `Num2Word_AZ` class to first convert the integer to its cardinal form. The suffix for the ordinal is determined by the last vowel in the cardinal representation using the `_last_vowel` helper method. Constants `VOWEL_TO_CARDINAL_SUFFIX_MAP` and `VOWELS` are used to map the last vowel to the correct ordinal suffix.\n\nSide Effects:\n    An assertion raises an error if the input value is not an integer or if it cannot be converted properly.\n\"\"\"\n```\n\n## FILE 2: num2words/__init__.py\n\n- FUNCTION NAME: num2words\n  - SIGNATURE: def num2words(number, ordinal=False, lang='en', to='cardinal', **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given number into its word representation in a specified language.\n\nParameters:\n- number (int, float, str): The number to be converted to words. It can be provided as an integer, float, or string.\n- ordinal (bool): If set to True, converts the number to its ordinal form (default is False).\n- lang (str): The language code (e.g., 'en', 'fr') for the conversion. If the full language code is not found, the first two letters will be used.\n- to (str): Specifies the type of number conversion ('cardinal', 'ordinal', 'ordinal_num', 'year', 'currency'). Defaults to 'cardinal'.\n- **kwargs: Additional keyword arguments to be passed to the conversion methods.\n\nReturns:\n- str: The word representation of the given number in the specified language.\n\nRaises:\n- NotImplementedError: If the language is not supported or the conversion type is not valid.\n\nDependencies:\n- Uses the CONVERTER_CLASSES dictionary which maps language codes to respective language converters that implement conversion logic.\n- Uses the CONVERTES_TYPES list to validate the type of conversion requested.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - num2words/lang_AZ.py:Num2Word_AZ:to_ordinal_num\n    - num2words/lang_AZ.py:Num2Word_AZ:to_cardinal\n    - num2words/lang_AZ.py:Num2Word_AZ:to_year\n    - num2words/lang_AZ.py:Num2Word_AZ:to_ordinal\n    - num2words/base.py:Num2Word_Base:to_currency\n\n## FILE 3: num2words/base.py\n\n- CLASS METHOD: Num2Word_Base.to_currency\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a numeric value into a formatted currency string. It decomposes the value into its whole and fractional parts, and handles formatting based on provided parameters such as currency type and verbosity of the fractional part.\n\nParameters:\n- val (numeric): The numeric value to be converted to currency format.\n- currency (str, optional): The currency code (default is 'EUR'). This code is used to determine how to format the currency.\n- cents (bool, optional): If True (default), returns verbose formatting for the fractional part; if False, returns a terse integer representation.\n- separator (str, optional): The string to use as a separator between the whole and fractional parts (default is ',').\n- adjective (bool, optional): If True, prefixes the currency name with an adjective based on the defined currency adjectives.\n\nReturns:\n- str: The formatted currency string that includes the whole and fractional parts, properly formatted based on the specified options, and includes a negation prefix if the value is negative.\n\nDependencies:\n- parse_currency_parts: A utility that splits the given value into left (whole), right (fractional), and a boolean indicating if it's negative. \n- CURRENCY_FORMS: A class-level dictionary mapping currency codes to their respective formats, defined in the Num2Word_Base class.\n- CURRENCY_ADJECTIVES: A class-level dictionary that may provide adjectives for certain currencies if applicable.\n- _money_verbose and _cents_verbose / _cents_terse: Methods that handle the formatting of the whole and fractional parts of the currency value.\n- pluralize: A method that handles pluralization of the currency terms based on the numeric values.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "num2words/lang_AZ.py": "from __future__ import unicode_literals\nfrom .base import Num2Word_Base\n\nclass Num2Word_AZ(Num2Word_Base):\n    DIGITS = {0: u's\u0131f\u0131r', 1: u'bir', 2: u'iki', 3: u'\u00fc\u00e7', 4: u'd\u00f6rd', 5: u'be\u015f', 6: u'alt\u0131', 7: u'yeddi', 8: u's\u0259kkiz', 9: u'doqquz'}\n    DECIMALS = {1: u'on', 2: u'iyirmi', 3: u'otuz', 4: u'q\u0131rx', 5: u'\u0259lli', 6: u'altm\u0131\u015f', 7: u'yetmi\u015f', 8: u's\u0259ks\u0259n', 9: u'doxsan'}\n    POWERS_OF_TEN = {2: u'y\u00fcz', 3: u'min', 6: u'milyon', 9: u'milyard', 12: u'trilyon', 15: u'katrilyon', 18: u'kentilyon', 21: u'sekstilyon', 24: u'septilyon', 27: u'oktilyon', 30: u'nonilyon', 33: u'desilyon', 36: u'undesilyon', 39: u'dodesilyon', 42: u'tredesilyon', 45: u'katordesilyon', 48: u'kendesilyon', 51: u'seksdesilyon', 54: u'septendesilyon', 57: u'oktodesilyon', 60: u'novemdesilyon', 63: u'vigintilyon'}\n    VOWELS = u'a\u0131oue\u0259i\u00f6\u00fc'\n    VOWEL_TO_CARDINAL_SUFFIX_MAP = {**dict.fromkeys(['a', '\u0131'], '\u0131nc\u0131'), **dict.fromkeys(['e', '\u0259', 'i'], 'inci'), **dict.fromkeys(['o', 'u'], 'uncu'), **dict.fromkeys(['\u00f6', '\u00fc'], '\u00fcnc\u00fc')}\n    VOWEL_TO_CARDINAL_NUM_SUFFIX_MAP = {**dict.fromkeys(['a', '\u0131'], 'c\u0131'), **dict.fromkeys(['e', '\u0259', 'i'], 'ci'), **dict.fromkeys(['o', 'u'], 'cu'), **dict.fromkeys(['\u00f6', '\u00fc'], 'c\u00fc')}\n    CURRENCY_INTEGRAL = ('manat', 'manat')\n    CURRENCY_FRACTION = ('q\u0259pik', 'q\u0259pik')\n    CURRENCY_FORMS = {'AZN': (CURRENCY_INTEGRAL, CURRENCY_FRACTION)}\n\n    def setup(self):\n        super().setup()\n        self.negword = u'm\u0259nfi'\n        self.pointword = u'n\u00f6qt\u0259'\n\n    def pluralize(self, n, forms):\n        form = 0 if n == 1 else 1\n        return forms[form]\n\n    def int_to_word(self, num_str, leading_zeros=False):\n        words = []\n        reversed_str = list(reversed(num_str))\n        for index, digit in enumerate(reversed_str):\n            digit_int = int(digit)\n            remainder_to_3 = index % 3\n            if remainder_to_3 == 0:\n                if index > 0:\n                    if set(reversed_str[index:index + 3]) != {'0'}:\n                        words.insert(0, self.POWERS_OF_TEN[index])\n                if digit_int > 0:\n                    if not (digit_int == 1 and index == 3):\n                        words.insert(0, self.DIGITS[digit_int])\n            elif remainder_to_3 == 1:\n                if digit_int != 0:\n                    words.insert(0, self.DECIMALS[digit_int])\n            else:\n                if digit_int > 0:\n                    words.insert(0, self.POWERS_OF_TEN[2])\n                if digit_int > 1:\n                    words.insert(0, self.DIGITS[digit_int])\n        if num_str == '0':\n            words.append(self.DIGITS[0])\n        if leading_zeros:\n            zeros_count = len(num_str) - len(str(int(num_str)))\n            words[:0] = zeros_count * [self.DIGITS[0]]\n        return ' '.join(words)\n\n    def _last_vowel(self, value):\n        for char in value[::-1]:\n            if char in self.VOWELS:\n                return char",
    "num2words/__init__.py": "from __future__ import unicode_literals\nfrom . import lang_AM, lang_AR, lang_AZ, lang_BE, lang_BN, lang_CA, lang_CE, lang_CY, lang_CZ, lang_DE, lang_DK, lang_EN, lang_EN_IN, lang_EN_NG, lang_EO, lang_ES, lang_ES_CO, lang_ES_CR, lang_ES_GT, lang_ES_NI, lang_ES_VE, lang_FA, lang_FI, lang_FR, lang_FR_BE, lang_FR_CH, lang_FR_DZ, lang_HE, lang_HU, lang_ID, lang_IS, lang_IT, lang_JA, lang_KN, lang_KO, lang_KZ, lang_LT, lang_LV, lang_NL, lang_NO, lang_PL, lang_PT, lang_PT_BR, lang_RO, lang_RU, lang_SK, lang_SL, lang_SR, lang_SV, lang_TE, lang_TET, lang_TG, lang_TH, lang_TR, lang_UK, lang_VI\nCONVERTER_CLASSES = {'am': lang_AM.Num2Word_AM(), 'ar': lang_AR.Num2Word_AR(), 'az': lang_AZ.Num2Word_AZ(), 'be': lang_BE.Num2Word_BE(), 'bn': lang_BN.Num2Word_BN(), 'ca': lang_CA.Num2Word_CA(), 'ce': lang_CE.Num2Word_CE(), 'cy': lang_CY.Num2Word_CY(), 'cz': lang_CZ.Num2Word_CZ(), 'en': lang_EN.Num2Word_EN(), 'en_IN': lang_EN_IN.Num2Word_EN_IN(), 'en_NG': lang_EN_NG.Num2Word_EN_NG(), 'fa': lang_FA.Num2Word_FA(), 'fr': lang_FR.Num2Word_FR(), 'fr_CH': lang_FR_CH.Num2Word_FR_CH(), 'fr_BE': lang_FR_BE.Num2Word_FR_BE(), 'fr_DZ': lang_FR_DZ.Num2Word_FR_DZ(), 'de': lang_DE.Num2Word_DE(), 'fi': lang_FI.Num2Word_FI(), 'eo': lang_EO.Num2Word_EO(), 'es': lang_ES.Num2Word_ES(), 'es_CO': lang_ES_CO.Num2Word_ES_CO(), 'es_CR': lang_ES_CR.Num2Word_ES_CR(), 'es_GT': lang_ES_GT.Num2Word_ES_GT(), 'es_NI': lang_ES_NI.Num2Word_ES_NI(), 'es_VE': lang_ES_VE.Num2Word_ES_VE(), 'id': lang_ID.Num2Word_ID(), 'ja': lang_JA.Num2Word_JA(), 'kn': lang_KN.Num2Word_KN(), 'ko': lang_KO.Num2Word_KO(), 'kz': lang_KZ.Num2Word_KZ(), 'lt': lang_LT.Num2Word_LT(), 'lv': lang_LV.Num2Word_LV(), 'pl': lang_PL.Num2Word_PL(), 'ro': lang_RO.Num2Word_RO(), 'ru': lang_RU.Num2Word_RU(), 'sk': lang_SK.Num2Word_SK(), 'sl': lang_SL.Num2Word_SL(), 'sr': lang_SR.Num2Word_SR(), 'sv': lang_SV.Num2Word_SV(), 'no': lang_NO.Num2Word_NO(), 'dk': lang_DK.Num2Word_DK(), 'pt': lang_PT.Num2Word_PT(), 'pt_BR': lang_PT_BR.Num2Word_PT_BR(), 'he': lang_HE.Num2Word_HE(), 'it': lang_IT.Num2Word_IT(), 'vi': lang_VI.Num2Word_VI(), 'tg': lang_TG.Num2Word_TG(), 'th': lang_TH.Num2Word_TH(), 'tr': lang_TR.Num2Word_TR(), 'nl': lang_NL.Num2Word_NL(), 'uk': lang_UK.Num2Word_UK(), 'te': lang_TE.Num2Word_TE(), 'tet': lang_TET.Num2Word_TET(), 'hu': lang_HU.Num2Word_HU(), 'is': lang_IS.Num2Word_IS()}\nCONVERTES_TYPES = ['cardinal', 'ordinal', 'ordinal_num', 'year', 'currency']",
    "num2words/base.py": "from __future__ import unicode_literals\nimport math\nfrom collections import OrderedDict\nfrom decimal import Decimal\nfrom .compat import to_s\nfrom .currency import parse_currency_parts, prefix_currency\n\nclass Num2Word_Base(object):\n    CURRENCY_FORMS = {}\n    CURRENCY_ADJECTIVES = {}\n\n    def __init__(self):\n        self.is_title = False\n        self.precision = 2\n        self.exclude_title = []\n        self.negword = '(-) '\n        self.pointword = '(.)'\n        self.errmsg_nonnum = 'type(%s) not in [long, int, float]'\n        self.errmsg_floatord = 'Cannot treat float %s as ordinal.'\n        self.errmsg_negord = 'Cannot treat negative num %s as ordinal.'\n        self.errmsg_toobig = 'abs(%s) must be less than %s.'\n        self.setup()\n        if any((hasattr(self, field) for field in ['high_numwords', 'mid_numwords', 'low_numwords'])):\n            self.cards = OrderedDict()\n            self.set_numwords()\n            self.MAXVAL = 1000 * list(self.cards.keys())[0]\n\n    def set_numwords(self):\n        self.set_high_numwords(self.high_numwords)\n        self.set_mid_numwords(self.mid_numwords)\n        self.set_low_numwords(self.low_numwords)\n\n    def set_high_numwords(self, *args):\n        raise NotImplementedError\n\n    def set_mid_numwords(self, mid):\n        for key, val in mid:\n            self.cards[key] = val\n\n    def set_low_numwords(self, numwords):\n        for word, n in zip(numwords, range(len(numwords) - 1, -1, -1)):\n            self.cards[n] = word\n\n    def splitnum(self, value):\n        for elem in self.cards:\n            if elem > value:\n                continue\n            out = []\n            if value == 0:\n                div, mod = (1, 0)\n            else:\n                div, mod = divmod(value, elem)\n            if div == 1:\n                out.append((self.cards[1], 1))\n            else:\n                if div == value:\n                    return [(div * self.cards[elem], div * elem)]\n                out.append(self.splitnum(div))\n            out.append((self.cards[elem], elem))\n            if mod:\n                out.append(self.splitnum(mod))\n            return out\n\n    def parse_minus(self, num_str):\n        \"\"\"Detach minus and return it as symbol with new num_str.\"\"\"\n        if num_str.startswith('-'):\n            return ('%s ' % self.negword.strip(), num_str[1:])\n        return ('', num_str)\n\n    def str_to_number(self, value):\n        return Decimal(value)\n\n    def to_cardinal(self, value):\n        try:\n            assert int(value) == value\n        except (ValueError, TypeError, AssertionError):\n            return self.to_cardinal_float(value)\n        out = ''\n        if value < 0:\n            value = abs(value)\n            out = '%s ' % self.negword.strip()\n        if value >= self.MAXVAL:\n            raise OverflowError(self.errmsg_toobig % (value, self.MAXVAL))\n        val = self.splitnum(value)\n        words, num = self.clean(val)\n        return self.title(out + words)\n\n    def float2tuple(self, value):\n        pre = int(value)\n        self.precision = abs(Decimal(str(value)).as_tuple().exponent)\n        post = abs(value - pre) * 10 ** self.precision\n        if abs(round(post) - post) < 0.01:\n            post = int(round(post))\n        else:\n            post = int(math.floor(post))\n        return (pre, post)\n\n    def to_cardinal_float(self, value):\n        try:\n            float(value) == value\n        except (ValueError, TypeError, AssertionError, AttributeError):\n            raise TypeError(self.errmsg_nonnum % value)\n        pre, post = self.float2tuple(float(value))\n        post = str(post)\n        post = '0' * (self.precision - len(post)) + post\n        out = [self.to_cardinal(pre)]\n        if self.precision:\n            out.append(self.title(self.pointword))\n        for i in range(self.precision):\n            curr = int(post[i])\n            out.append(to_s(self.to_cardinal(curr)))\n        return ' '.join(out)\n\n    def merge(self, curr, next):\n        raise NotImplementedError\n\n    def clean(self, val):\n        out = val\n        while len(val) != 1:\n            out = []\n            left, right = val[:2]\n            if isinstance(left, tuple) and isinstance(right, tuple):\n                out.append(self.merge(left, right))\n                if val[2:]:\n                    out.append(val[2:])\n            else:\n                for elem in val:\n                    if isinstance(elem, list):\n                        if len(elem) == 1:\n                            out.append(elem[0])\n                        else:\n                            out.append(self.clean(elem))\n                    else:\n                        out.append(elem)\n            val = out\n        return out[0]\n\n    def title(self, value):\n        if self.is_title:\n            out = []\n            value = value.split()\n            for word in value:\n                if word in self.exclude_title:\n                    out.append(word)\n                else:\n                    out.append(word[0].upper() + word[1:])\n            value = ' '.join(out)\n        return value\n\n    def verify_ordinal(self, value):\n        if not value == int(value):\n            raise TypeError(self.errmsg_floatord % value)\n        if not abs(value) == value:\n            raise TypeError(self.errmsg_negord % value)\n\n    def to_ordinal(self, value):\n        return self.to_cardinal(value)\n\n    def to_ordinal_num(self, value):\n        return value\n\n    def inflect(self, value, text):\n        text = text.split('/')\n        if value == 1:\n            return text[0]\n        return ''.join(text)\n\n    def to_splitnum(self, val, hightxt='', lowtxt='', jointxt='', divisor=100, longval=True, cents=True):\n        out = []\n        if isinstance(val, float):\n            high, low = self.float2tuple(val)\n        else:\n            try:\n                high, low = val\n            except TypeError:\n                high, low = divmod(val, divisor)\n        if high:\n            hightxt = self.title(self.inflect(high, hightxt))\n            out.append(self.to_cardinal(high))\n            if low:\n                if longval:\n                    if hightxt:\n                        out.append(hightxt)\n                    if jointxt:\n                        out.append(self.title(jointxt))\n            elif hightxt:\n                out.append(hightxt)\n        if low:\n            if cents:\n                out.append(self.to_cardinal(low))\n            else:\n                out.append('%02d' % low)\n            if lowtxt and longval:\n                out.append(self.title(self.inflect(low, lowtxt)))\n        return ' '.join(out)\n\n    def to_year(self, value, **kwargs):\n        return self.to_cardinal(value)\n\n    def pluralize(self, n, forms):\n        \"\"\"\n        Should resolve gettext form:\n        http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html\n        \"\"\"\n        raise NotImplementedError\n\n    def _money_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_terse(self, number, currency):\n        return '%02d' % number\n\n    def setup(self):\n        pass"
  },
  "call_tree": {
    "tests/test_az.py:Num2WordAZTest:test_cardinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_AZ.py:Num2Word_AZ:to_cardinal": {
          "num2words/lang_AZ.py:Num2Word_AZ:int_to_word": {}
        }
      }
    },
    "tests/test_az.py:Num2WordAZTest:test_cardinal_fracion": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_AZ.py:Num2Word_AZ:to_cardinal": {
          "num2words/lang_AZ.py:Num2Word_AZ:int_to_word": {}
        }
      }
    },
    "tests/test_az.py:Num2WordAZTest:test_currency": {
      "num2words/__init__.py:num2words": {
        "num2words/base.py:Num2Word_Base:to_currency": {
          "num2words/currency.py:parse_currency_parts": {},
          "num2words/base.py:Num2Word_Base:_money_verbose": {
            "num2words/lang_AZ.py:Num2Word_AZ:to_cardinal": {
              "num2words/lang_AZ.py:Num2Word_AZ:int_to_word": {}
            }
          },
          "num2words/base.py:Num2Word_Base:_cents_verbose": {
            "num2words/lang_AZ.py:Num2Word_AZ:to_cardinal": {
              "num2words/lang_AZ.py:Num2Word_AZ:int_to_word": {}
            }
          },
          "num2words/lang_AZ.py:Num2Word_AZ:pluralize": {}
        }
      }
    },
    "tests/test_az.py:Num2WordAZTest:test_ordinal": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_AZ.py:Num2Word_AZ:to_ordinal": {
          "num2words/lang_AZ.py:Num2Word_AZ:to_cardinal": {
            "num2words/lang_AZ.py:Num2Word_AZ:int_to_word": {}
          },
          "num2words/lang_AZ.py:Num2Word_AZ:_last_vowel": {}
        }
      }
    },
    "tests/test_az.py:Num2WordAZTest:test_ordinal_num": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_AZ.py:Num2Word_AZ:to_ordinal_num": {
          "num2words/lang_AZ.py:Num2Word_AZ:to_cardinal": {
            "num2words/lang_AZ.py:Num2Word_AZ:int_to_word": {}
          },
          "num2words/lang_AZ.py:Num2Word_AZ:_last_vowel": {}
        }
      }
    },
    "tests/test_az.py:Num2WordAZTest:test_year": {
      "num2words/__init__.py:num2words": {
        "num2words/lang_AZ.py:Num2Word_AZ:to_year": {
          "num2words/lang_AZ.py:Num2Word_AZ:to_cardinal": {
            "num2words/lang_AZ.py:Num2Word_AZ:int_to_word": {}
          }
        }
      }
    }
  }
}