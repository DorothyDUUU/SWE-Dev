{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_type_checks",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/utils/test_type_checks.py",
  "test_code": "from mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypedDictAttribute, TypeTypedDict\nfrom mypy_boto3_builder.type_annotations.type_union import TypeUnion\nfrom mypy_boto3_builder.utils.type_checks import (\n    get_optional,\n    is_literal,\n    is_type_def,\n    is_type_parent,\n    is_typed_dict,\n    is_union,\n)\n\n\nclass TestTypeChecks:\n    def test_get_optional(self) -> None:\n        assert get_optional(Type.DictStrAny).render() == \"Optional[Dict[str, Any]]\"\n        assert get_optional(TypeUnion([Type.str, Type.bool])).render() == \"Union[str, bool, None]\"\n\n    def test_is_type_def(self) -> None:\n        assert not is_type_def(Type.DictStrAny)\n        assert not is_type_def(Type.ListAny)\n        assert not is_type_def(TypeUnion([Type.str, Type.bool]))\n        assert is_type_def(TypeUnion([Type.str, Type.bool], name=\"MyUnion\"))\n        assert is_type_def(\n            TypeTypedDict(\"MyTypedDict\", [TypedDictAttribute(\"key\", Type.str, required=True)]),\n        )\n\n    def test_is_typed_dict(self) -> None:\n        assert not is_typed_dict(Type.DictStrAny)\n        assert not is_typed_dict(Type.ListAny)\n        assert not is_typed_dict(TypeUnion([Type.str, Type.bool]))\n        assert is_typed_dict(\n            TypeTypedDict(\"MyTypedDict\", [TypedDictAttribute(\"key\", Type.str, required=True)]),\n        )\n\n    def test_is_union(self) -> None:\n        assert not is_union(Type.DictStrAny)\n        assert not is_union(Type.ListAny)\n        assert is_union(TypeUnion([Type.str, Type.bool]))\n        assert is_union(TypeUnion([Type.str, Type.bool], name=\"MyUnion\"))\n\n    def test_is_literal(self) -> None:\n        assert not is_literal(Type.DictStrAny)\n        assert not is_literal(Type.ListAny)\n        assert is_literal(TypeLiteral(\"MyLiteral\", [\"value\"]))\n\n    def test_is_type_parent(self) -> None:\n        assert not is_type_parent(Type.str)\n        assert is_type_parent(Type.DictStrAny)\n        assert is_type_parent(Type.ListAny)\n        assert is_type_parent(TypeUnion([Type.str, Type.bool]))\n        assert is_type_parent(TypeUnion([Type.str, Type.bool], name=\"MyUnion\"))\n        assert is_type_parent(\n            TypeTypedDict(\n                \"MyTypedDict\",\n                [TypedDictAttribute(\"key\", Type.str, required=True)],\n            ),\n        )\n",
  "GT_file_code": {
    "mypy_boto3_builder/type_annotations/type_parent.py": "\"\"\"\nProtocol for types with children.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\n\n\nclass TypeParent(FakeAnnotation, ABC):\n    \"\"\"\n    Protocol for types with children.\n    \"\"\"\n\n    @abstractmethod\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children type annotations.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        ...\n\n    def find_type_annotation_parents(\n        self,\n        type_annotation: FakeAnnotation,\n        skip: Iterable[FakeAnnotation] = (),\n    ) -> \"set[TypeParent]\":\n        \"\"\"\n        Check recursively if child is present in type def.\n        \"\"\"\n        result: set[TypeParent] = set()\n        for child_type in self.iterate_children_type_annotations():\n            if child_type == type_annotation:\n                result.add(self)\n            if not isinstance(child_type, TypeParent):\n                continue\n\n            if child_type in skip:\n                continue\n\n            parents = child_type.find_type_annotation_parents(\n                type_annotation,\n                skip={*skip, child_type},\n            )\n            result.update(parents)\n\n        return result\n\n    def replace_self_references(self, replacement: FakeAnnotation) -> \"set[TypeParent]\":\n        \"\"\"\n        Replace self references with a new type annotation to avoid recursion.\n        \"\"\"\n        \"\"\"\n        Replace self references with a new type annotation to avoid recursion.\n        \"\"\"\n        parents = self.find_type_annotation_parents(self)\n        for parent in parents:\n            parent.replace_child(self, replacement)\n        return parents\n\n    def get_sortable_children(self) -> list[TypeDefSortable]:\n        \"\"\"\n        Extract required TypeDefSortable list from attributes.\n        \"\"\"\n        result: list[TypeDefSortable] = []\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if not isinstance(type_annotation, TypeDefSortable):\n                continue\n            result.append(type_annotation)\n\n        return result\n",
    "mypy_boto3_builder/type_annotations/type_subscript.py": "\"\"\"\nWrapper for subscript type annotations, like `List[str]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\n\n\nclass TypeSubscript(TypeParent):\n    \"\"\"\n    Wrapper for subscript type annotations, like `List[str]`.\n\n    Arguments:\n        parent -- Parent type annotation.\n        children -- Children type annotations.\n        stringify -- Convert type annotation to string.\n    \"\"\"\n\n    def __init__(\n        self,\n        parent: FakeAnnotation,\n        children: Iterable[FakeAnnotation] = (),\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.parent: FakeAnnotation = parent\n        self.children: list[FakeAnnotation] = list(children)\n        self._stringify = stringify\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        result = self.parent.render()\n        if self.children:\n            children = \", \".join([i.render() for i in self.children])\n            result = f\"{result}[{children}]\"\n\n        if self._stringify:\n            result = f'\"{result}\"'\n        return result\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        yield from self.parent.iterate_types()\n        for child in self.children:\n            yield from child.iterate_types()\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Add new child to Substcript.\n        \"\"\"\n        self.children.append(child)\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether subscript parent is Dict.\n        \"\"\"\n        return self.parent.is_dict()\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether subscript parent is List.\n        \"\"\"\n        return self.parent.is_list()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            parent=self.parent,\n            children=list(self.children),\n            stringify=self._stringify,\n        )\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        for child in self.children:\n            result.extend(child.get_local_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        yield from self.children\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        if child not in self.children:\n            raise TypeAnnotationError(f\"Child not found: {child}\")\n\n        index = self.children.index(child)\n        self.children[index] = new_child\n        return self\n\n    def iterate_children(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children.\n        \"\"\"\n        yield from self.children\n",
    "mypy_boto3_builder/utils/type_checks.py": "\"\"\"\nType checking utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom typing import TypeGuard\n\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\nfrom mypy_boto3_builder.type_annotations.type_union import TypeUnion\n\n\ndef is_typed_dict(annotation: FakeAnnotation) -> TypeGuard[TypeTypedDict]:\n    \"\"\"\n    Whether type annotation is TypedDict.\n    \"\"\"\n    return isinstance(annotation, TypeTypedDict)\n\n\ndef is_union(annotation: FakeAnnotation) -> TypeGuard[TypeUnion]:\n    \"\"\"\n    Whether type annotation is a Union.\n    \"\"\"\n    return isinstance(annotation, TypeUnion)\n\n\ndef is_literal(annotation: FakeAnnotation) -> TypeGuard[TypeLiteral]:\n    \"\"\"\n    Whether type annotation is a literal.\n    \"\"\"\n    return isinstance(annotation, TypeLiteral)\n\n\ndef is_type_def(annotation: FakeAnnotation) -> TypeGuard[TypeDefSortable]:\n    \"\"\"\n    Whether type annotation is a named TypeDefSortable.\n    \"\"\"\n    if is_typed_dict(annotation):\n        return True\n\n    if is_union(annotation):\n        return annotation.is_named()\n\n    return False\n\n\ndef is_type_parent(annotation: FakeAnnotation) -> TypeGuard[TypeParent]:\n    \"\"\"\n    Whether type annotation is a TypeParent.\n    \"\"\"\n    return isinstance(annotation, TypeParent)\n\n\ndef get_optional(wrapped: FakeAnnotation) -> TypeSubscript:\n    \"\"\"\n    Get Optional type annotation.\n    \"\"\"\n    if is_union(wrapped):\n        result = wrapped.copy()\n        result.add_child(Type.none)\n        return result\n    return TypeSubscript(Type.Optional, [wrapped])\n",
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": "\"\"\"\nWrapper for `typing/typing_extensions.TypedDict` type annotations.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypedDictAttribute:\n    \"\"\"\n    TypedDict attribute wrapper.\n\n    Arguments:\n        name -- Attribute name.\n        type_annotation -- Attribute type annotation.\n        required -- Whether the attribute has to be set.\n    \"\"\"\n\n    def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        self.name = name\n        self.required = required\n        self.type_annotation = type_annotation\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name, required and type annotation.\n        \"\"\"\n        return hash((self.name, self.required, self.type_annotation.get_sort_key()))\n\n    def get_type_annotation(self) -> FakeAnnotation:\n        \"\"\"\n        Get wrapped for non-required type annotation or raw type annotation.\n        \"\"\"\n        if self.is_required():\n            return self.type_annotation\n\n        return TypeSubscript(Type.NotRequired, [self.type_annotation])\n\n    def render(self) -> str:\n        \"\"\"\n        Render attribute to use in function-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'\"{self.name}\": {self.get_type_annotation().render()}'\n\n    def render_attribute(self) -> str:\n        \"\"\"\n        Render attribute to use in class-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f\"{self.name}: {self.get_type_annotation().render()}\"\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Itera over type annotations.\n        \"\"\"\n        yield from self.type_annotation.iterate_types()\n\n    def is_required(self) -> bool:\n        \"\"\"\n        Whether argument is required.\n        \"\"\"\n        return self.required\n\n    def mark_as_required(self) -> None:\n        \"\"\"\n        Mark attribute as required.\n        \"\"\"\n        self.required = True\n\n\nclass TypeTypedDict(TypeParent, TypeDefSortable):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.TypedDict` type annotations.\n\n    Arguments:\n        name -- Type name.\n        children -- Typed dict attributes.\n        docstring -- Docstring for render.\n        stringify -- Convert type annotation to string to avoid circular deps.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        children: Iterable[TypedDictAttribute] = (),\n        docstring: str = \"\",\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.name = name\n        self.children = list(children)\n        self.docstring = docstring\n        self._stringify = stringify\n        self.is_safe_as_class = True\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether TypedDict usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render TypedDict usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort Typed Dicts by name.\n        \"\"\"\n        return self.name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name and children.\n        \"\"\"\n        return hash((self.name, *self.children))\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.is_stringified():\n            return f'\"{self.name}\"'\n\n        return self.name\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        template = (\n            Path(\"common/typed_dict_class.py.jinja2\")\n            if self.is_safe_as_class\n            else Path(\"common/typed_dict.py.jinja2\")\n        )\n        return render_jinja2_template(template, {\"type_def\": self})\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using TypedDict.\n        \"\"\"\n        result = Type.TypedDict.get_import_records()\n        for child in self.iterate_children():\n            result.update(child.get_type_annotation().get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"\n        Add new attribute to a dictionary.\n\n        Arguments:\n            name -- Argument name.\n            type_annotation -- Argument type annotation.\n            required -- Whether argument has to be set.\n        \"\"\"\n        self.children.append(TypedDictAttribute(name, type_annotation, required=required))\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return True\n\n    def has_optional(self) -> bool:\n        \"\"\"\n        Whether TypedDict has optional keys.\n        \"\"\"\n        return any(not child.is_required() for child in self.children)\n\n    def has_required(self) -> bool:\n        \"\"\"\n        Whether TypedDict has required keys.\n        \"\"\"\n        return any(child.is_required() for child in self.children)\n\n    def get_required(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of required attributes.\n        \"\"\"\n        return tuple(child for child in self.children if child.is_required())\n\n    def get_optional(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of optional attributes.\n        \"\"\"\n        return tuple(child for child in self.children if not child.is_required())\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            self.name,\n            list(self.children),\n            docstring=self.docstring,\n            stringify=self.is_stringified(),\n        )\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check whether typed dict attributes are the same as `other`.\n        \"\"\"\n        return hash(self) == hash(other)\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        for child in self.children:\n            yield child.type_annotation\n\n    def get_children_literals(self, processed: Iterable[str] = ()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def iterate_children(self) -> Iterator[TypedDictAttribute]:\n        \"\"\"\n        Iterate over children from required to optional.\n        \"\"\"\n        yield from self.get_required()\n        yield from self.get_optional()\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [\n            child.type_annotation\n            for child in self.children\n            if child.type_annotation.get_local_types()\n        ]\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return True\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        children_types = [i.type_annotation for i in self.children]\n        if child not in children_types:\n            raise TypeAnnotationError(f\"Child not found: {child}\")\n\n        indices = [i for i, x in enumerate(children_types) if x == child]\n        for index in indices:\n            self.children[index].type_annotation = new_child\n\n        return self\n",
    "mypy_boto3_builder/type_annotations/type_annotation.py": "\"\"\"\nWrapper for `typing` type annotation.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Mapping\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass TypeAnnotation(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing` type annotation.\n\n    Arguments:\n        wrapped_type -- Original type annotation as a string.\n    \"\"\"\n\n    _TYPING: Final = ImportString(\"typing\")\n    _TYPING_EXTENSIONS: Final = ImportString(\"typing_extensions\")\n\n    # Set of supported type annotations. value is default import module\n    _SUPPORTED_TYPES: Final[Mapping[str, ImportString]] = {\n        \"Union\": _TYPING,  # typing.Union\n        \"Any\": _TYPING,  # typing.Any\n        \"Dict\": _TYPING,  # typing.Dict\n        \"List\": _TYPING,  # typing.List\n        \"Set\": _TYPING,  # typing.Set\n        \"Optional\": _TYPING,  # typing.Optional\n        \"IO\": _TYPING,  # typing.IO\n        \"overload\": _TYPING,  # typing.overload\n        \"Type\": _TYPING,  # typing.Type\n        \"NoReturn\": _TYPING,  # typing.NoReturn\n        \"TypedDict\": _TYPING,  # typing_extensions.TypedDict / typing.TypedDict\n        \"Literal\": _TYPING,  # typing_extensions.Literal / typing.Literal\n        \"Mapping\": _TYPING,  # typing.Mapping\n        \"Sequence\": _TYPING,  # typing.Sequence\n        \"Callable\": _TYPING,  # typing.Callable\n        \"Iterator\": _TYPING,  # typing.Iterator\n        \"Awaitable\": _TYPING,  # typing.Awaitable\n        \"AsyncIterator\": _TYPING,  # typing.AsyncIterator\n        \"NotRequired\": _TYPING,  # typing_extensions.NotRequired / typing.NotRequired\n        \"Unpack\": _TYPING,  # typing_extensions.Unpack / typing.Unpack\n    }\n\n    # Set of fallback type annotations\n    _FALLBACK: Final[Mapping[str, tuple[tuple[int, int] | None, ImportString]]] = {\n        \"NotRequired\": ((3, 12), _TYPING_EXTENSIONS),\n        \"TypedDict\": ((3, 12), _TYPING_EXTENSIONS),\n        \"Literal\": ((3, 12), _TYPING_EXTENSIONS),\n        \"Unpack\": ((3, 12), _TYPING_EXTENSIONS),\n    }\n\n    def __init__(self, wrapped_type: str) -> None:\n        if wrapped_type not in self._SUPPORTED_TYPES:\n            raise TypeAnnotationError(f\"Cannot wrap {wrapped_type}\")\n\n        self._wrapped_type: str = wrapped_type\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        return self.get_import_name()\n\n    def get_import_name(self) -> str:\n        \"\"\"\n        Create a safe name for imported annotation.\n        \"\"\"\n        return self._wrapped_type\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Create a safe Import Record for annotation.\n        \"\"\"\n        name = self.get_import_name()\n        source = self._SUPPORTED_TYPES[name]\n        if name not in self._FALLBACK:\n            return {ImportRecord(source=source, name=name)}\n\n        fallback_min_version, fallback_source = self._FALLBACK[name]\n\n        return {\n            ImportRecord(\n                source=source,\n                name=name,\n                fallback=ImportRecord(source=fallback_source, name=name),\n                min_version=fallback_min_version,\n            ),\n        }\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether annotation is a plain Dict.\n        \"\"\"\n        return self._wrapped_type == \"Dict\"\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether annotation is a plain List.\n        \"\"\"\n        return self._wrapped_type == \"List\"\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self._wrapped_type)\n",
    "mypy_boto3_builder/type_annotations/type_union.py": "\"\"\"\nWrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypeUnion(TypeSubscript, TypeDefSortable):\n    \"\"\"\n    Wrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n    \"\"\"\n\n    _MIN_CHILDREN: Final = 2\n\n    def __init__(\n        self,\n        children: Iterable[FakeAnnotation],\n        name: str = \"\",\n        *,\n        stringify: bool = False,\n    ) -> None:\n        self.name = name\n        self.parent = Type.Union\n        self.children: list[FakeAnnotation] = list(children)\n        if len(self.children) < self._MIN_CHILDREN:\n            raise TypeAnnotationError(f\"Union must have at least {self._MIN_CHILDREN} children\")\n        self._stringify = stringify\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether Union usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render Union usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if not self.is_named():\n            return super().render()\n\n        result = self.name\n\n        if self._stringify:\n            result = f'\"{result}\"'\n\n        return result\n\n    def is_named(self) -> bool:\n        \"\"\"\n        Check if type annotation is a named type annotation.\n        \"\"\"\n        return bool(self.name)\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(\n            children=list(self.children),\n            name=self.name,\n            stringify=self._stringify,\n        )\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def get_children_literals(self, processed: Iterable[str] = ()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Union.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return self._get_import_records()\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        if self.is_named():\n            yield self\n            return\n\n        yield from super().iterate_types()\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return self.is_named()\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [child for child in self.children if child.get_local_types()]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        if self.is_named():\n            return render_jinja2_template(Path(\"common/named_union.py.jinja2\"), {\"type_def\": self})\n\n        return self.render()\n",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def __init__(self, name: str, children: Iterable[str]) -> None:\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError(\"Literal should have children\")\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.inline:\n            children = \", \".join([repr(i) for i in sorted(self.children)])\n            return f\"Literal[{children}]\"\n\n        return self.name\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation(\"Literal\").get_import_records()\n\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation(\"Literal\").get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError(\"Use add_literal_child function.\")\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path(\"common/literal.py.jinja2\"), {\"literal\": self})\n",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/type_annotations/type_parent.py": {},
    "mypy_boto3_builder/type_annotations/type_subscript.py": {
      "TypeSubscript.__init__": {
        "code": "    def __init__(self, parent: FakeAnnotation, children: Iterable[FakeAnnotation]=(), *, stringify: bool=False) -> None:\n        \"\"\"Initialize a TypeSubscript instance, which represents a subscripted type annotation, such as `List[str]`.\n\nParameters:\n- parent (FakeAnnotation): The parent type annotation that this subscript is wrapping (e.g., `List` or `Dict`).\n- children (Iterable[FakeAnnotation], optional): An iterable of child type annotations, which can represent the types contained within the parent (e.g., `str` for `List[str]`). Defaults to an empty iterable.\n- stringify (bool, optional): A flag to indicate whether to convert the type annotation to a string format when rendering. Defaults to False.\n\nAttributes initialized:\n- self.parent: Holds the parent FakeAnnotation instance.\n- self.children: A list of child FakeAnnotation instances derived from the provided iterable.\n- self._stringify: A boolean that determines if the annotation should be rendered as a string.\n\nThis constructor sets up the necessary structure for managing type annotations in a subscripted form, enabling the rendering of types and retrieval of associated import records through other methods in the TypeSubscript class.\"\"\"\n        self.parent: FakeAnnotation = parent\n        self.children: list[FakeAnnotation] = list(children)\n        self._stringify = stringify",
        "docstring": "Initialize a TypeSubscript instance, which represents a subscripted type annotation, such as `List[str]`.\n\nParameters:\n- parent (FakeAnnotation): The parent type annotation that this subscript is wrapping (e.g., `List` or `Dict`).\n- children (Iterable[FakeAnnotation], optional): An iterable of child type annotations, which can represent the types contained within the parent (e.g., `str` for `List[str]`). Defaults to an empty iterable.\n- stringify (bool, optional): A flag to indicate whether to convert the type annotation to a string format when rendering. Defaults to False.\n\nAttributes initialized:\n- self.parent: Holds the parent FakeAnnotation instance.\n- self.children: A list of child FakeAnnotation instances derived from the provided iterable.\n- self._stringify: A boolean that determines if the annotation should be rendered as a string.\n\nThis constructor sets up the necessary structure for managing type annotations in a subscripted form, enabling the rendering of types and retrieval of associated import records through other methods in the TypeSubscript class.",
        "signature": "def __init__(self, parent: FakeAnnotation, children: Iterable[FakeAnnotation]=(), *, stringify: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class TypeSubscript(TypeParent):"
      },
      "TypeSubscript.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the type annotation of a `TypeSubscript` instance to a valid Python code representation for local usage.\n\nThis method constructs the representation by first rendering the parent type (e.g., `List` or `Dict`) and then appending the rendered children types (if any) within square brackets. If the `stringify` attribute is set to `True`, the final output is enclosed in double quotes, indicating that it should be treated as a string.\n\nReturns:\n    A string depicting the valid type annotation, combining the rendered parent type with its children types, if applicable.\n\nAttributes:\n    - `self.parent`: An instance of `FakeAnnotation` that serves as the parent type to be rendered.\n    - `self.children`: An iterable of `FakeAnnotation` instances, which represent the child type annotations to be rendered within the parent type.\n    - `self._stringify`: A boolean flag indicating whether the output should be enclosed in quotes.\n\nDependencies:\n    Leverages the `render()` method of both the parent and children types, which must also implement their own rendering logic consistent with the expected format for type annotations.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        result = self.parent.render()\n        if self.children:\n            children = ', '.join([i.render() for i in self.children])\n            result = f'{result}[{children}]'\n        if self._stringify:\n            result = f'\"{result}\"'\n        return result",
        "docstring": "Render the type annotation of a `TypeSubscript` instance to a valid Python code representation for local usage.\n\nThis method constructs the representation by first rendering the parent type (e.g., `List` or `Dict`) and then appending the rendered children types (if any) within square brackets. If the `stringify` attribute is set to `True`, the final output is enclosed in double quotes, indicating that it should be treated as a string.\n\nReturns:\n    A string depicting the valid type annotation, combining the rendered parent type with its children types, if applicable.\n\nAttributes:\n    - `self.parent`: An instance of `FakeAnnotation` that serves as the parent type to be rendered.\n    - `self.children`: An iterable of `FakeAnnotation` instances, which represent the child type annotations to be rendered within the parent type.\n    - `self._stringify`: A boolean flag indicating whether the output should be enclosed in quotes.\n\nDependencies:\n    Leverages the `render()` method of both the parent and children types, which must also implement their own rendering logic consistent with the expected format for type annotations.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeSubscript(TypeParent):"
      },
      "TypeSubscript.add_child": {
        "code": "    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"Add a new child type annotation to the TypeSubscript instance.\n\nParameters:\n    child (FakeAnnotation): The child type annotation to be added, which should be an instance of the FakeAnnotation class.\n\nReturns:\n    None: This method modifies the internal state of the TypeSubscript instance by appending the new child to its list of children.\n\nSide Effects:\n    The method increases the length of the `children` list, which is an attribute of the TypeSubscript instance. This list is crucial for methods like `render`, `iterate_types`, and `get_children_types`, which rely on the children for generating type annotations or extracting type information.\"\"\"\n        '\\n        Add new child to Substcript.\\n        '\n        self.children.append(child)",
        "docstring": "Add a new child type annotation to the TypeSubscript instance.\n\nParameters:\n    child (FakeAnnotation): The child type annotation to be added, which should be an instance of the FakeAnnotation class.\n\nReturns:\n    None: This method modifies the internal state of the TypeSubscript instance by appending the new child to its list of children.\n\nSide Effects:\n    The method increases the length of the `children` list, which is an attribute of the TypeSubscript instance. This list is crucial for methods like `render`, `iterate_types`, and `get_children_types`, which rely on the children for generating type annotations or extracting type information.",
        "signature": "def add_child(self, child: FakeAnnotation) -> None:",
        "type": "Method",
        "class_signature": "class TypeSubscript(TypeParent):"
      }
    },
    "mypy_boto3_builder/utils/type_checks.py": {
      "is_typed_dict": {
        "code": "def is_typed_dict(annotation: FakeAnnotation) -> TypeGuard[TypeTypedDict]:\n    \"\"\"Determines if the provided type annotation is a TypedDict.\n\nParameters:\n    annotation (FakeAnnotation): The annotation to check, expected to be an instance of FakeAnnotation or its subclasses.\n\nReturns:\n    TypeGuard[TypeTypedDict]: True if the annotation is an instance of TypeTypedDict; otherwise, False.\n\nThis function relies on the TypeTypedDict class defined in the type_annotations module, which represents type annotations for TypedDict in the mypy_boto3_builder package. It utilizes Python's built-in isinstance() function to perform the check.\"\"\"\n    '\\n    Whether type annotation is TypedDict.\\n    '\n    return isinstance(annotation, TypeTypedDict)",
        "docstring": "Determines if the provided type annotation is a TypedDict.\n\nParameters:\n    annotation (FakeAnnotation): The annotation to check, expected to be an instance of FakeAnnotation or its subclasses.\n\nReturns:\n    TypeGuard[TypeTypedDict]: True if the annotation is an instance of TypeTypedDict; otherwise, False.\n\nThis function relies on the TypeTypedDict class defined in the type_annotations module, which represents type annotations for TypedDict in the mypy_boto3_builder package. It utilizes Python's built-in isinstance() function to perform the check.",
        "signature": "def is_typed_dict(annotation: FakeAnnotation) -> TypeGuard[TypeTypedDict]:",
        "type": "Function",
        "class_signature": null
      },
      "is_union": {
        "code": "def is_union(annotation: FakeAnnotation) -> TypeGuard[TypeUnion]:\n    \"\"\"Determine if a given type annotation is a Union type. \n\nParameters:\n- annotation (FakeAnnotation): The type annotation to evaluate. It is expected to be an instance of a type that could represent various type constructs.\n\nReturns:\n- TypeGuard[TypeUnion]: Returns True if the provided annotation is an instance of TypeUnion, allowing for type narrowing in type checking contexts.\n\nDependencies:\n- This function relies on the TypeUnion class, which is imported from the mypy_boto3_builder.type_annotations.type_union module. TypeUnion encapsulates the notion of a Union type and is utilized to verify the type of the provided annotation.\"\"\"\n    '\\n    Whether type annotation is a Union.\\n    '\n    return isinstance(annotation, TypeUnion)",
        "docstring": "Determine if a given type annotation is a Union type. \n\nParameters:\n- annotation (FakeAnnotation): The type annotation to evaluate. It is expected to be an instance of a type that could represent various type constructs.\n\nReturns:\n- TypeGuard[TypeUnion]: Returns True if the provided annotation is an instance of TypeUnion, allowing for type narrowing in type checking contexts.\n\nDependencies:\n- This function relies on the TypeUnion class, which is imported from the mypy_boto3_builder.type_annotations.type_union module. TypeUnion encapsulates the notion of a Union type and is utilized to verify the type of the provided annotation.",
        "signature": "def is_union(annotation: FakeAnnotation) -> TypeGuard[TypeUnion]:",
        "type": "Function",
        "class_signature": null
      },
      "is_literal": {
        "code": "def is_literal(annotation: FakeAnnotation) -> TypeGuard[TypeLiteral]:\n    \"\"\"Determine if the given type annotation is a literal value.\n\nParameters:\n- annotation (FakeAnnotation): The annotation to be checked. This should be an instance of FakeAnnotation, potentially representing various types of Python annotations.\n\nReturns:\n- TypeGuard[TypeLiteral]: True if the annotation is an instance of TypeLiteral, indicating it represents a literal type; otherwise, False.\n\nThis function interacts with TypeLiteral, which is imported from the mypy_boto3_builder.type_annotations.type_literal module. The function leverages Python's isinstance() function to check the type of the annotation against TypeLiteral.\"\"\"\n    '\\n    Whether type annotation is a literal.\\n    '\n    return isinstance(annotation, TypeLiteral)",
        "docstring": "Determine if the given type annotation is a literal value.\n\nParameters:\n- annotation (FakeAnnotation): The annotation to be checked. This should be an instance of FakeAnnotation, potentially representing various types of Python annotations.\n\nReturns:\n- TypeGuard[TypeLiteral]: True if the annotation is an instance of TypeLiteral, indicating it represents a literal type; otherwise, False.\n\nThis function interacts with TypeLiteral, which is imported from the mypy_boto3_builder.type_annotations.type_literal module. The function leverages Python's isinstance() function to check the type of the annotation against TypeLiteral.",
        "signature": "def is_literal(annotation: FakeAnnotation) -> TypeGuard[TypeLiteral]:",
        "type": "Function",
        "class_signature": null
      },
      "is_type_def": {
        "code": "def is_type_def(annotation: FakeAnnotation) -> TypeGuard[TypeDefSortable]:\n    \"\"\"Checks if a given type annotation is a named TypeDefSortable.\n\nThis function determines if the provided annotation is either a TypedDict \nor a Union that is named. It relies on the helper functions `is_typed_dict` \nand `is_union`, both of which are defined in the same module. The `is_typed_dict` \nfunction checks for instances of TypeTypedDict, while `is_union` checks for \nTypeUnion instances that are named.\n\nParameters:\n    annotation (FakeAnnotation): The type annotation to be checked.\n\nReturns:\n    TypeGuard[TypeDefSortable]: True if the annotation is a TypedDict or \n    a named Union, False otherwise.\"\"\"\n    '\\n    Whether type annotation is a named TypeDefSortable.\\n    '\n    if is_typed_dict(annotation):\n        return True\n    if is_union(annotation):\n        return annotation.is_named()\n    return False",
        "docstring": "Checks if a given type annotation is a named TypeDefSortable.\n\nThis function determines if the provided annotation is either a TypedDict \nor a Union that is named. It relies on the helper functions `is_typed_dict` \nand `is_union`, both of which are defined in the same module. The `is_typed_dict` \nfunction checks for instances of TypeTypedDict, while `is_union` checks for \nTypeUnion instances that are named.\n\nParameters:\n    annotation (FakeAnnotation): The type annotation to be checked.\n\nReturns:\n    TypeGuard[TypeDefSortable]: True if the annotation is a TypedDict or \n    a named Union, False otherwise.",
        "signature": "def is_type_def(annotation: FakeAnnotation) -> TypeGuard[TypeDefSortable]:",
        "type": "Function",
        "class_signature": null
      },
      "is_type_parent": {
        "code": "def is_type_parent(annotation: FakeAnnotation) -> TypeGuard[TypeParent]:\n    \"\"\"Determines whether the provided type annotation is a TypeParent.\n\nParameters:\n- annotation (FakeAnnotation): The type annotation to be checked, expected to be an instance of the FakeAnnotation class or its subclasses.\n\nReturns:\n- TypeGuard[TypeParent]: A boolean indicating if the annotation is an instance of TypeParent. If true, TypeParent can safely be assumed as the actual type of the annotation.\n\nDependencies:\n- The function relies on the `TypeParent` class from the `mypy_boto3_builder.type_annotations.type_parent` module, which defines the TypeParent structure. This ensures that the code can accurately identify if the annotation conforms to the TypeParent type.\"\"\"\n    '\\n    Whether type annotation is a TypeParent.\\n    '\n    return isinstance(annotation, TypeParent)",
        "docstring": "Determines whether the provided type annotation is a TypeParent.\n\nParameters:\n- annotation (FakeAnnotation): The type annotation to be checked, expected to be an instance of the FakeAnnotation class or its subclasses.\n\nReturns:\n- TypeGuard[TypeParent]: A boolean indicating if the annotation is an instance of TypeParent. If true, TypeParent can safely be assumed as the actual type of the annotation.\n\nDependencies:\n- The function relies on the `TypeParent` class from the `mypy_boto3_builder.type_annotations.type_parent` module, which defines the TypeParent structure. This ensures that the code can accurately identify if the annotation conforms to the TypeParent type.",
        "signature": "def is_type_parent(annotation: FakeAnnotation) -> TypeGuard[TypeParent]:",
        "type": "Function",
        "class_signature": null
      },
      "get_optional": {
        "code": "def get_optional(wrapped: FakeAnnotation) -> TypeSubscript:\n    \"\"\"Generate an Optional type annotation from a given type annotation.\n\nParameters:\n- wrapped (FakeAnnotation): The original type annotation to be wrapped as Optional.\n\nReturns:\n- TypeSubscript: An Optional type annotation, which can either be a Union type that includes `None` or a TypeSubscript indicating it's made optional.\n\nThe function first checks if the provided 'wrapped' annotation is a Union by using the `is_union` utility. If it is, it creates a copy of the Union and adds `None` as a possible type. If it is not a Union, it wraps the annotation in a TypeSubscript with the 'Optional' keyword from the Type class, effectively creating an Optional type. The interaction hinges on the definitions of TypeSubscript and Type, which are imported from the type annotations module.\"\"\"\n    '\\n    Get Optional type annotation.\\n    '\n    if is_union(wrapped):\n        result = wrapped.copy()\n        result.add_child(Type.none)\n        return result\n    return TypeSubscript(Type.Optional, [wrapped])",
        "docstring": "Generate an Optional type annotation from a given type annotation.\n\nParameters:\n- wrapped (FakeAnnotation): The original type annotation to be wrapped as Optional.\n\nReturns:\n- TypeSubscript: An Optional type annotation, which can either be a Union type that includes `None` or a TypeSubscript indicating it's made optional.\n\nThe function first checks if the provided 'wrapped' annotation is a Union by using the `is_union` utility. If it is, it creates a copy of the Union and adds `None` as a possible type. If it is not a Union, it wraps the annotation in a TypeSubscript with the 'Optional' keyword from the Type class, effectively creating an Optional type. The interaction hinges on the definitions of TypeSubscript and Type, which are imported from the type annotations module.",
        "signature": "def get_optional(wrapped: FakeAnnotation) -> TypeSubscript:",
        "type": "Function",
        "class_signature": null
      }
    },
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": {
      "TypedDictAttribute.__init__": {
        "code": "    def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"Initialize a TypedDict attribute wrapper.\n\nParameters:\n- name (str): The name of the attribute.\n- type_annotation (FakeAnnotation): The type annotation associated with the attribute, represented as a FakeAnnotation object. This is part of the type annotation system and allows for flexibility in type definitions.\n- required (bool): A flag indicating whether the attribute is a required field in the TypedDict. \n\nThis method sets the instance attributes `name`, `required`, and `type_annotation` based on the provided parameters, facilitating the representation and management of TypedDict attributes in the TypeTypedDict class.\"\"\"\n        self.name = name\n        self.required = required\n        self.type_annotation = type_annotation",
        "docstring": "Initialize a TypedDict attribute wrapper.\n\nParameters:\n- name (str): The name of the attribute.\n- type_annotation (FakeAnnotation): The type annotation associated with the attribute, represented as a FakeAnnotation object. This is part of the type annotation system and allows for flexibility in type definitions.\n- required (bool): A flag indicating whether the attribute is a required field in the TypedDict. \n\nThis method sets the instance attributes `name`, `required`, and `type_annotation` based on the provided parameters, facilitating the representation and management of TypedDict attributes in the TypeTypedDict class.",
        "signature": "def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:",
        "type": "Method",
        "class_signature": "class TypedDictAttribute:"
      },
      "TypeTypedDict.__init__": {
        "code": "    def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:\n        \"\"\"Initialize a `TypeTypedDict` instance, which serves as a wrapper for defining `TypedDict` type annotations in Python.\n\nParameters:\n- `name` (str): The name of the TypedDict type being defined.\n- `children` (Iterable[TypedDictAttribute], optional): An iterable of `TypedDictAttribute` instances which define the attributes of the TypedDict. Default is an empty iterable.\n- `docstring` (str, optional): A docstring to provide documentation for the TypedDict. Default is an empty string.\n- `stringify` (bool, optional): A flag indicating whether the TypedDict should be rendered as a string. Default is False.\n\nAttributes initialized:\n- `self.name`: Stores the name of the TypedDict.\n- `self.children`: Converts `children` to a list for managing the TypedDict attributes.\n- `self.docstring`: Stores the provided docstring for the TypedDict.\n- `self._stringify`: Stores the stringify flag.\n- `self.is_safe_as_class`: A boolean set to True, indicating that this TypedDict can be safely used as a class.\n\nThis constructor is essential for creating TypedDict types, which are a way of defining structured data with optional and required fields.\"\"\"\n        self.name = name\n        self.children = list(children)\n        self.docstring = docstring\n        self._stringify = stringify\n        self.is_safe_as_class = True",
        "docstring": "Initialize a `TypeTypedDict` instance, which serves as a wrapper for defining `TypedDict` type annotations in Python.\n\nParameters:\n- `name` (str): The name of the TypedDict type being defined.\n- `children` (Iterable[TypedDictAttribute], optional): An iterable of `TypedDictAttribute` instances which define the attributes of the TypedDict. Default is an empty iterable.\n- `docstring` (str, optional): A docstring to provide documentation for the TypedDict. Default is an empty string.\n- `stringify` (bool, optional): A flag indicating whether the TypedDict should be rendered as a string. Default is False.\n\nAttributes initialized:\n- `self.name`: Stores the name of the TypedDict.\n- `self.children`: Converts `children` to a list for managing the TypedDict attributes.\n- `self.docstring`: Stores the provided docstring for the TypedDict.\n- `self._stringify`: Stores the stringify flag.\n- `self.is_safe_as_class`: A boolean set to True, indicating that this TypedDict can be safely used as a class.\n\nThis constructor is essential for creating TypedDict types, which are a way of defining structured data with optional and required fields.",
        "signature": "def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class TypeTypedDict(TypeParent, TypeDefSortable):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_annotation.py": {
      "TypeAnnotation.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the type annotation to a valid Python code for local usage.\n\nThis method retrieves the name of the wrapped type annotation, which should be one of the supported types defined in the `_SUPPORTED_TYPES` mapping. It does not take any parameters and returns the name of the wrapped type as a string.\n\nReturn:\n    A string representing the wrapped type, which corresponds to a valid type annotation that can be used in Python code.\n\nDependencies:\n    - The method relies on the `_wrapped_type` attribute, which is initialized in the constructor using a string representing the original type annotation.\n    - It also interacts with the `_SUPPORTED_TYPES` constant, ensuring that the wrapped type is one of the predefined type annotations supported by the class.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        return self.get_import_name()",
        "docstring": "Render the type annotation to a valid Python code for local usage.\n\nThis method retrieves the name of the wrapped type annotation, which should be one of the supported types defined in the `_SUPPORTED_TYPES` mapping. It does not take any parameters and returns the name of the wrapped type as a string.\n\nReturn:\n    A string representing the wrapped type, which corresponds to a valid type annotation that can be used in Python code.\n\nDependencies:\n    - The method relies on the `_wrapped_type` attribute, which is initialized in the constructor using a string representing the original type annotation.\n    - It also interacts with the `_SUPPORTED_TYPES` constant, ensuring that the wrapped type is one of the predefined type annotations supported by the class.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeAnnotation(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_union.py": {
      "TypeUnion.__init__": {
        "code": "    def __init__(self, children: Iterable[FakeAnnotation], name: str='', *, stringify: bool=False) -> None:\n        \"\"\"Initialize a TypeUnion instance, which serves as a wrapper for Union type annotations.\n\nParameters:\n- children (Iterable[FakeAnnotation]): An iterable collection of child type annotations that make up the Union.\n- name (str, optional): An optional name for the Union type. Defaults to an empty string.\n- stringify (bool, optional): If set to True, the Union type will be rendered as a string. Defaults to False.\n\nRaises:\n- TypeAnnotationError: If the number of child type annotations is less than the minimum required, defined by the class constant _MIN_CHILDREN (set to 2).\n\nAttributes:\n- name (str): Stores the name of the Union type.\n- parent (Type): References the Union type from the Type superclass.\n- children (list[FakeAnnotation]): Stores the list of child type annotations.\n- _stringify (bool): Indicates whether the Union type should be rendered as a string.\n\nThis constructor ensures that at least two child type annotations are provided, adhering to the definition of Union types.\"\"\"\n        self.name = name\n        self.parent = Type.Union\n        self.children: list[FakeAnnotation] = list(children)\n        if len(self.children) < self._MIN_CHILDREN:\n            raise TypeAnnotationError(f'Union must have at least {self._MIN_CHILDREN} children')\n        self._stringify = stringify",
        "docstring": "Initialize a TypeUnion instance, which serves as a wrapper for Union type annotations.\n\nParameters:\n- children (Iterable[FakeAnnotation]): An iterable collection of child type annotations that make up the Union.\n- name (str, optional): An optional name for the Union type. Defaults to an empty string.\n- stringify (bool, optional): If set to True, the Union type will be rendered as a string. Defaults to False.\n\nRaises:\n- TypeAnnotationError: If the number of child type annotations is less than the minimum required, defined by the class constant _MIN_CHILDREN (set to 2).\n\nAttributes:\n- name (str): Stores the name of the Union type.\n- parent (Type): References the Union type from the Type superclass.\n- children (list[FakeAnnotation]): Stores the list of child type annotations.\n- _stringify (bool): Indicates whether the Union type should be rendered as a string.\n\nThis constructor ensures that at least two child type annotations are provided, adhering to the definition of Union types.",
        "signature": "def __init__(self, children: Iterable[FakeAnnotation], name: str='', *, stringify: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      },
      "TypeUnion.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render a type annotation to valid Python code for local usage.\n\nThis method checks if the type annotation is named using the `is_named()` method. If it is not named, it calls the superclass's `render` method to obtain the representation. If it is named, the method initializes the result with the name of the type annotation. If the `_stringify` attribute is set to True, the result is enclosed in quotes.\n\nReturns:\n    A string representing the valid type annotation.\n\nAttributes:\n    - `self.name`: The name of the type annotation, which is used when rendering if the type is named.\n    - `self._stringify`: A boolean indicating whether the rendered output should be a string, influencing the final output format.\"\"\"\n        '\\n        Render type annotation to a valid Python code for local usage.\\n\\n        Returns:\\n            A string with a valid type annotation.\\n        '\n        if not self.is_named():\n            return super().render()\n        result = self.name\n        if self._stringify:\n            result = f'\"{result}\"'\n        return result",
        "docstring": "Render a type annotation to valid Python code for local usage.\n\nThis method checks if the type annotation is named using the `is_named()` method. If it is not named, it calls the superclass's `render` method to obtain the representation. If it is named, the method initializes the result with the name of the type annotation. If the `_stringify` attribute is set to True, the result is enclosed in quotes.\n\nReturns:\n    A string representing the valid type annotation.\n\nAttributes:\n    - `self.name`: The name of the type annotation, which is used when rendering if the type is named.\n    - `self._stringify`: A boolean indicating whether the rendered output should be a string, influencing the final output format.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      },
      "TypeUnion.is_named": {
        "code": "    def is_named(self) -> bool:\n        \"\"\"Check if the type annotation is a named type annotation.\n\nA named type annotation is identified by the presence of a non-empty `name` attribute. This method provides a way to determine if the current `TypeUnion` instance is represented by a specific name, which affects how the type is rendered and utilized.\n\nReturns:\n    bool: True if the type annotation has a name, otherwise False.\n\nNo parameters are required for this method. The method directly accesses the instance's `name` attribute.\"\"\"\n        '\\n        Check if type annotation is a named type annotation.\\n        '\n        return bool(self.name)",
        "docstring": "Check if the type annotation is a named type annotation.\n\nA named type annotation is identified by the presence of a non-empty `name` attribute. This method provides a way to determine if the current `TypeUnion` instance is represented by a specific name, which affects how the type is rendered and utilized.\n\nReturns:\n    bool: True if the type annotation has a name, otherwise False.\n\nNo parameters are required for this method. The method directly accesses the instance's `name` attribute.",
        "signature": "def is_named(self) -> bool:",
        "type": "Method",
        "class_signature": "class TypeUnion(TypeSubscript, TypeDefSortable):"
      }
    },
    "mypy_boto3_builder/type_annotations/type_literal.py": {
      "TypeLiteral.__init__": {
        "code": "    def __init__(self, name: str, children: Iterable[str]) -> None:\n        \"\"\"Initializes a TypeLiteral instance, representing a wrapper for `Literal` type annotations.\n\nParameters:\n    name (str): The non-inline name of the Literal type.\n    children (Iterable[str]): A collection of literal values. This must be non-empty, or a TypeAnnotationError will be raised.\n\nRaises:\n    TypeAnnotationError: If `children` is empty, indicating that a Literal must have at least one value.\n\nAttributes:\n    children (set[str]): A set containing the literal values provided in `children`.\n    name (str): The name of the Literal.\n\nThis constructor sets up the fundamental elements required for rendering and managing the literal type annotations within the TypeLiteral class, ensuring that validations are enforced.\"\"\"\n        self.children: set[str] = set(children)\n        self.name: str = name\n        if not children:\n            raise TypeAnnotationError('Literal should have children')",
        "docstring": "Initializes a TypeLiteral instance, representing a wrapper for `Literal` type annotations.\n\nParameters:\n    name (str): The non-inline name of the Literal type.\n    children (Iterable[str]): A collection of literal values. This must be non-empty, or a TypeAnnotationError will be raised.\n\nRaises:\n    TypeAnnotationError: If `children` is empty, indicating that a Literal must have at least one value.\n\nAttributes:\n    children (set[str]): A set containing the literal values provided in `children`.\n    name (str): The name of the Literal.\n\nThis constructor sets up the fundamental elements required for rendering and managing the literal type annotations within the TypeLiteral class, ensuring that validations are enforced.",
        "signature": "def __init__(self, name: str, children: Iterable[str]) -> None:",
        "type": "Method",
        "class_signature": "class TypeLiteral(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.copy": {
        "code": "    def copy(self: Self) -> Self:\n        \"\"\"Create and return a shallow copy of the current FakeAnnotation instance.\n\nThis method utilizes the `copy.copy()` function from the `copy` module to generate a new instance that is a shallow copy of the original. The copied instance maintains the same attributes as the original but does not create deep copies of nested objects. This method does not take any parameters and returns a new instance of the same type as the original FakeAnnotation. \n\nThe `Self` type hint indicates that the method returns an instance of the same class type, providing type safety and enabling easier type checks during method calls.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return copy.copy(self)",
        "docstring": "Create and return a shallow copy of the current FakeAnnotation instance.\n\nThis method utilizes the `copy.copy()` function from the `copy` module to generate a new instance that is a shallow copy of the original. The copied instance maintains the same attributes as the original but does not create deep copies of nested objects. This method does not take any parameters and returns a new instance of the same type as the original FakeAnnotation. \n\nThe `Self` type hint indicates that the method returns an instance of the same class type, providing type safety and enabling easier type checks during method calls.",
        "signature": "def copy(self: Self) -> Self:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    }
  },
  "dependency_dict": {},
  "call_tree": {
    "tests/utils/test_type_checks.py:TestTypeChecks:test_get_optional": {
      "mypy_boto3_builder/utils/type_checks.py:get_optional": {
        "mypy_boto3_builder/utils/type_checks.py:is_union": {
          "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:TypeUnion": {}
        },
        "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__": {},
        "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
          "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__copy__": {
            "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {}
          }
        },
        "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:add_child": {}
      },
      "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
        "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
          "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
        },
        "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
          "[ignored_or_cut_off]": "..."
        }
      },
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {},
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:render": {
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:is_named": {},
        "mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:render": {
          "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:render": {
            "mypy_boto3_builder/type_annotations/type_annotation.py:TypeAnnotation:get_import_name": {}
          },
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
            "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
              "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
            },
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
          },
          "mypy_boto3_builder/type_annotations/type_constant.py:TypeConstant:render": {}
        }
      }
    },
    "tests/utils/test_type_checks.py:TestTypeChecks:test_is_type_def": {
      "mypy_boto3_builder/utils/type_checks.py:is_type_def": {
        "mypy_boto3_builder/utils/type_checks.py:is_typed_dict": {
          "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:TypeTypedDict": {}
        },
        "mypy_boto3_builder/utils/type_checks.py:is_union": {},
        "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:is_named": {}
      },
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
    },
    "tests/utils/test_type_checks.py:TestTypeChecks:test_is_typed_dict": {
      "mypy_boto3_builder/utils/type_checks.py:is_typed_dict": {},
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
    },
    "tests/utils/test_type_checks.py:TestTypeChecks:test_is_union": {
      "mypy_boto3_builder/utils/type_checks.py:is_union": {},
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {}
    },
    "tests/utils/test_type_checks.py:TestTypeChecks:test_is_literal": {
      "mypy_boto3_builder/utils/type_checks.py:is_literal": {
        "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:TypeLiteral": {}
      },
      "mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:__init__": {}
    },
    "tests/utils/test_type_checks.py:TestTypeChecks:test_is_type_parent": {
      "mypy_boto3_builder/utils/type_checks.py:is_type_parent": {
        "mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:TypeParent": {}
      },
      "mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypedDictAttribute:__init__": {},
      "mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:__init__": {}
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_type_checks\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 type_annotations/\n    \u2502   \u251c\u2500\u2500 fake_annotation.py\n    \u2502   \u2502   \u2514\u2500\u2500 FakeAnnotation.copy\n    \u2502   \u251c\u2500\u2500 type_annotation.py\n    \u2502   \u2502   \u2514\u2500\u2500 TypeAnnotation.render\n    \u2502   \u251c\u2500\u2500 type_literal.py\n    \u2502   \u2502   \u251c\u2500\u2500 TypeLiteral.TypeLiteral\n    \u2502   \u2502   \u2514\u2500\u2500 TypeLiteral.__init__\n    \u2502   \u251c\u2500\u2500 type_parent.py\n    \u2502   \u2502   \u2514\u2500\u2500 TypeParent.TypeParent\n    \u2502   \u251c\u2500\u2500 type_subscript.py\n    \u2502   \u2502   \u251c\u2500\u2500 TypeSubscript.__init__\n    \u2502   \u2502   \u251c\u2500\u2500 TypeSubscript.add_child\n    \u2502   \u2502   \u2514\u2500\u2500 TypeSubscript.render\n    \u2502   \u251c\u2500\u2500 type_typed_dict.py\n    \u2502   \u2502   \u251c\u2500\u2500 TypeTypedDict.__init__\n    \u2502   \u2502   \u2514\u2500\u2500 TypedDictAttribute.__init__\n    \u2502   \u2514\u2500\u2500 type_union.py\n    \u2502       \u251c\u2500\u2500 TypeUnion.__init__\n    \u2502       \u251c\u2500\u2500 TypeUnion.is_named\n    \u2502       \u2514\u2500\u2500 TypeUnion.render\n    \u2514\u2500\u2500 utils/\n        \u2514\u2500\u2500 type_checks.py\n            \u251c\u2500\u2500 get_optional\n            \u251c\u2500\u2500 is_literal\n            \u251c\u2500\u2500 is_type_def\n            \u251c\u2500\u2500 is_type_parent\n            \u251c\u2500\u2500 is_typed_dict\n            \u2514\u2500\u2500 is_union\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a suite of type-checking utilities designed to evaluate and classify various Python type annotations, such as literal types, unions, typed dictionaries, and parent types. Its core functionality includes determining the structural properties and relationships of type definitions, such as whether a type is optional, a literal, a union, or a typed dictionary, thereby enabling precise analysis of type constructs. By streamlining these classification and inspection tasks, the module facilitates the development and validation of robust, type-safe code, solving the problem of efficiently handling complex type scenarios for developers working with static typing in Python. It is particularly suited for applications that involve code generation, static analysis, or enhancing type systems.\n\n## FILE 1: mypy_boto3_builder/type_annotations/type_parent.py\n\n## FILE 2: mypy_boto3_builder/type_annotations/type_subscript.py\n\n- CLASS METHOD: TypeSubscript.render\n  - CLASS SIGNATURE: class TypeSubscript(TypeParent):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the type annotation of a `TypeSubscript` instance to a valid Python code representation for local usage.\n\nThis method constructs the representation by first rendering the parent type (e.g., `List` or `Dict`) and then appending the rendered children types (if any) within square brackets. If the `stringify` attribute is set to `True`, the final output is enclosed in double quotes, indicating that it should be treated as a string.\n\nReturns:\n    A string depicting the valid type annotation, combining the rendered parent type with its children types, if applicable.\n\nAttributes:\n    - `self.parent`: An instance of `FakeAnnotation` that serves as the parent type to be rendered.\n    - `self.children`: An iterable of `FakeAnnotation` instances, which represent the child type annotations to be rendered within the parent type.\n    - `self._stringify`: A boolean flag indicating whether the output should be enclosed in quotes.\n\nDependencies:\n    Leverages the `render()` method of both the parent and children types, which must also implement their own rendering logic consistent with the expected format for type annotations.\n\"\"\"\n```\n\n- CLASS METHOD: TypeSubscript.__init__\n  - CLASS SIGNATURE: class TypeSubscript(TypeParent):\n  - SIGNATURE: def __init__(self, parent: FakeAnnotation, children: Iterable[FakeAnnotation]=(), *, stringify: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeSubscript instance, which represents a subscripted type annotation, such as `List[str]`.\n\nParameters:\n- parent (FakeAnnotation): The parent type annotation that this subscript is wrapping (e.g., `List` or `Dict`).\n- children (Iterable[FakeAnnotation], optional): An iterable of child type annotations, which can represent the types contained within the parent (e.g., `str` for `List[str]`). Defaults to an empty iterable.\n- stringify (bool, optional): A flag to indicate whether to convert the type annotation to a string format when rendering. Defaults to False.\n\nAttributes initialized:\n- self.parent: Holds the parent FakeAnnotation instance.\n- self.children: A list of child FakeAnnotation instances derived from the provided iterable.\n- self._stringify: A boolean that determines if the annotation should be rendered as a string.\n\nThis constructor sets up the necessary structure for managing type annotations in a subscripted form, enabling the rendering of types and retrieval of associated import records through other methods in the TypeSubscript class.\n\"\"\"\n```\n\n- CLASS METHOD: TypeSubscript.add_child\n  - CLASS SIGNATURE: class TypeSubscript(TypeParent):\n  - SIGNATURE: def add_child(self, child: FakeAnnotation) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nAdd a new child type annotation to the TypeSubscript instance.\n\nParameters:\n    child (FakeAnnotation): The child type annotation to be added, which should be an instance of the FakeAnnotation class.\n\nReturns:\n    None: This method modifies the internal state of the TypeSubscript instance by appending the new child to its list of children.\n\nSide Effects:\n    The method increases the length of the `children` list, which is an attribute of the TypeSubscript instance. This list is crucial for methods like `render`, `iterate_types`, and `get_children_types`, which rely on the children for generating type annotations or extracting type information.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/utils/type_checks.py\n\n- FUNCTION NAME: is_type_def\n  - SIGNATURE: def is_type_def(annotation: FakeAnnotation) -> TypeGuard[TypeDefSortable]:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if a given type annotation is a named TypeDefSortable.\n\nThis function determines if the provided annotation is either a TypedDict \nor a Union that is named. It relies on the helper functions `is_typed_dict` \nand `is_union`, both of which are defined in the same module. The `is_typed_dict` \nfunction checks for instances of TypeTypedDict, while `is_union` checks for \nTypeUnion instances that are named.\n\nParameters:\n    annotation (FakeAnnotation): The type annotation to be checked.\n\nReturns:\n    TypeGuard[TypeDefSortable]: True if the annotation is a TypedDict or \n    a named Union, False otherwise.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/type_checks.py:is_typed_dict\n    - mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:is_named\n    - mypy_boto3_builder/utils/type_checks.py:is_union\n\n- FUNCTION NAME: get_optional\n  - SIGNATURE: def get_optional(wrapped: FakeAnnotation) -> TypeSubscript:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate an Optional type annotation from a given type annotation.\n\nParameters:\n- wrapped (FakeAnnotation): The original type annotation to be wrapped as Optional.\n\nReturns:\n- TypeSubscript: An Optional type annotation, which can either be a Union type that includes `None` or a TypeSubscript indicating it's made optional.\n\nThe function first checks if the provided 'wrapped' annotation is a Union by using the `is_union` utility. If it is, it creates a copy of the Union and adds `None` as a possible type. If it is not a Union, it wraps the annotation in a TypeSubscript with the 'Optional' keyword from the Type class, effectively creating an Optional type. The interaction hinges on the definitions of TypeSubscript and Type, which are imported from the type annotations module.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:add_child\n    - mypy_boto3_builder/utils/type_checks.py:is_union\n    - mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy\n    - mypy_boto3_builder/type_annotations/type_subscript.py:TypeSubscript:__init__\n\n- FUNCTION NAME: is_typed_dict\n  - SIGNATURE: def is_typed_dict(annotation: FakeAnnotation) -> TypeGuard[TypeTypedDict]:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines if the provided type annotation is a TypedDict.\n\nParameters:\n    annotation (FakeAnnotation): The annotation to check, expected to be an instance of FakeAnnotation or its subclasses.\n\nReturns:\n    TypeGuard[TypeTypedDict]: True if the annotation is an instance of TypeTypedDict; otherwise, False.\n\nThis function relies on the TypeTypedDict class defined in the type_annotations module, which represents type annotations for TypedDict in the mypy_boto3_builder package. It utilizes Python's built-in isinstance() function to perform the check.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/utils/type_checks.py:is_type_def\n    - mypy_boto3_builder/type_annotations/type_typed_dict.py:TypeTypedDict:TypeTypedDict\n\n- FUNCTION NAME: is_literal\n  - SIGNATURE: def is_literal(annotation: FakeAnnotation) -> TypeGuard[TypeLiteral]:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if the given type annotation is a literal value.\n\nParameters:\n- annotation (FakeAnnotation): The annotation to be checked. This should be an instance of FakeAnnotation, potentially representing various types of Python annotations.\n\nReturns:\n- TypeGuard[TypeLiteral]: True if the annotation is an instance of TypeLiteral, indicating it represents a literal type; otherwise, False.\n\nThis function interacts with TypeLiteral, which is imported from the mypy_boto3_builder.type_annotations.type_literal module. The function leverages Python's isinstance() function to check the type of the annotation against TypeLiteral.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/type_annotations/type_literal.py:TypeLiteral:TypeLiteral\n\n- FUNCTION NAME: is_type_parent\n  - SIGNATURE: def is_type_parent(annotation: FakeAnnotation) -> TypeGuard[TypeParent]:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermines whether the provided type annotation is a TypeParent.\n\nParameters:\n- annotation (FakeAnnotation): The type annotation to be checked, expected to be an instance of the FakeAnnotation class or its subclasses.\n\nReturns:\n- TypeGuard[TypeParent]: A boolean indicating if the annotation is an instance of TypeParent. If true, TypeParent can safely be assumed as the actual type of the annotation.\n\nDependencies:\n- The function relies on the `TypeParent` class from the `mypy_boto3_builder.type_annotations.type_parent` module, which defines the TypeParent structure. This ensures that the code can accurately identify if the annotation conforms to the TypeParent type.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/type_annotations/type_parent.py:TypeParent:TypeParent\n\n- FUNCTION NAME: is_union\n  - SIGNATURE: def is_union(annotation: FakeAnnotation) -> TypeGuard[TypeUnion]:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine if a given type annotation is a Union type. \n\nParameters:\n- annotation (FakeAnnotation): The type annotation to evaluate. It is expected to be an instance of a type that could represent various type constructs.\n\nReturns:\n- TypeGuard[TypeUnion]: Returns True if the provided annotation is an instance of TypeUnion, allowing for type narrowing in type checking contexts.\n\nDependencies:\n- This function relies on the TypeUnion class, which is imported from the mypy_boto3_builder.type_annotations.type_union module. TypeUnion encapsulates the notion of a Union type and is utilized to verify the type of the provided annotation.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - mypy_boto3_builder/type_annotations/type_union.py:TypeUnion:TypeUnion\n    - mypy_boto3_builder/utils/type_checks.py:get_optional\n    - mypy_boto3_builder/utils/type_checks.py:is_type_def\n\n## FILE 4: mypy_boto3_builder/type_annotations/type_typed_dict.py\n\n- CLASS METHOD: TypedDictAttribute.__init__\n  - CLASS SIGNATURE: class TypedDictAttribute:\n  - SIGNATURE: def __init__(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypedDict attribute wrapper.\n\nParameters:\n- name (str): The name of the attribute.\n- type_annotation (FakeAnnotation): The type annotation associated with the attribute, represented as a FakeAnnotation object. This is part of the type annotation system and allows for flexibility in type definitions.\n- required (bool): A flag indicating whether the attribute is a required field in the TypedDict. \n\nThis method sets the instance attributes `name`, `required`, and `type_annotation` based on the provided parameters, facilitating the representation and management of TypedDict attributes in the TypeTypedDict class.\n\"\"\"\n```\n\n- CLASS METHOD: TypeTypedDict.__init__\n  - CLASS SIGNATURE: class TypeTypedDict(TypeParent, TypeDefSortable):\n  - SIGNATURE: def __init__(self, name: str, children: Iterable[TypedDictAttribute]=(), docstring: str='', *, stringify: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a `TypeTypedDict` instance, which serves as a wrapper for defining `TypedDict` type annotations in Python.\n\nParameters:\n- `name` (str): The name of the TypedDict type being defined.\n- `children` (Iterable[TypedDictAttribute], optional): An iterable of `TypedDictAttribute` instances which define the attributes of the TypedDict. Default is an empty iterable.\n- `docstring` (str, optional): A docstring to provide documentation for the TypedDict. Default is an empty string.\n- `stringify` (bool, optional): A flag indicating whether the TypedDict should be rendered as a string. Default is False.\n\nAttributes initialized:\n- `self.name`: Stores the name of the TypedDict.\n- `self.children`: Converts `children` to a list for managing the TypedDict attributes.\n- `self.docstring`: Stores the provided docstring for the TypedDict.\n- `self._stringify`: Stores the stringify flag.\n- `self.is_safe_as_class`: A boolean set to True, indicating that this TypedDict can be safely used as a class.\n\nThis constructor is essential for creating TypedDict types, which are a way of defining structured data with optional and required fields.\n\"\"\"\n```\n\n## FILE 5: mypy_boto3_builder/type_annotations/type_annotation.py\n\n- CLASS METHOD: TypeAnnotation.render\n  - CLASS SIGNATURE: class TypeAnnotation(FakeAnnotation):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the type annotation to a valid Python code for local usage.\n\nThis method retrieves the name of the wrapped type annotation, which should be one of the supported types defined in the `_SUPPORTED_TYPES` mapping. It does not take any parameters and returns the name of the wrapped type as a string.\n\nReturn:\n    A string representing the wrapped type, which corresponds to a valid type annotation that can be used in Python code.\n\nDependencies:\n    - The method relies on the `_wrapped_type` attribute, which is initialized in the constructor using a string representing the original type annotation.\n    - It also interacts with the `_SUPPORTED_TYPES` constant, ensuring that the wrapped type is one of the predefined type annotations supported by the class.\n\"\"\"\n```\n\n## FILE 6: mypy_boto3_builder/type_annotations/type_union.py\n\n- CLASS METHOD: TypeUnion.is_named\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def is_named(self) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if the type annotation is a named type annotation.\n\nA named type annotation is identified by the presence of a non-empty `name` attribute. This method provides a way to determine if the current `TypeUnion` instance is represented by a specific name, which affects how the type is rendered and utilized.\n\nReturns:\n    bool: True if the type annotation has a name, otherwise False.\n\nNo parameters are required for this method. The method directly accesses the instance's `name` attribute.\n\"\"\"\n```\n\n- CLASS METHOD: TypeUnion.__init__\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def __init__(self, children: Iterable[FakeAnnotation], name: str='', *, stringify: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a TypeUnion instance, which serves as a wrapper for Union type annotations.\n\nParameters:\n- children (Iterable[FakeAnnotation]): An iterable collection of child type annotations that make up the Union.\n- name (str, optional): An optional name for the Union type. Defaults to an empty string.\n- stringify (bool, optional): If set to True, the Union type will be rendered as a string. Defaults to False.\n\nRaises:\n- TypeAnnotationError: If the number of child type annotations is less than the minimum required, defined by the class constant _MIN_CHILDREN (set to 2).\n\nAttributes:\n- name (str): Stores the name of the Union type.\n- parent (Type): References the Union type from the Type superclass.\n- children (list[FakeAnnotation]): Stores the list of child type annotations.\n- _stringify (bool): Indicates whether the Union type should be rendered as a string.\n\nThis constructor ensures that at least two child type annotations are provided, adhering to the definition of Union types.\n\"\"\"\n```\n\n- CLASS METHOD: TypeUnion.render\n  - CLASS SIGNATURE: class TypeUnion(TypeSubscript, TypeDefSortable):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender a type annotation to valid Python code for local usage.\n\nThis method checks if the type annotation is named using the `is_named()` method. If it is not named, it calls the superclass's `render` method to obtain the representation. If it is named, the method initializes the result with the name of the type annotation. If the `_stringify` attribute is set to True, the result is enclosed in quotes.\n\nReturns:\n    A string representing the valid type annotation.\n\nAttributes:\n    - `self.name`: The name of the type annotation, which is used when rendering if the type is named.\n    - `self._stringify`: A boolean indicating whether the rendered output should be a string, influencing the final output format.\n\"\"\"\n```\n\n## FILE 7: mypy_boto3_builder/type_annotations/type_literal.py\n\n- CLASS METHOD: TypeLiteral.__init__\n  - CLASS SIGNATURE: class TypeLiteral(FakeAnnotation):\n  - SIGNATURE: def __init__(self, name: str, children: Iterable[str]) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a TypeLiteral instance, representing a wrapper for `Literal` type annotations.\n\nParameters:\n    name (str): The non-inline name of the Literal type.\n    children (Iterable[str]): A collection of literal values. This must be non-empty, or a TypeAnnotationError will be raised.\n\nRaises:\n    TypeAnnotationError: If `children` is empty, indicating that a Literal must have at least one value.\n\nAttributes:\n    children (set[str]): A set containing the literal values provided in `children`.\n    name (str): The name of the Literal.\n\nThis constructor sets up the fundamental elements required for rendering and managing the literal type annotations within the TypeLiteral class, ensuring that validations are enforced.\n\"\"\"\n```\n\n## FILE 8: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.copy\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def copy(self: Self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate and return a shallow copy of the current FakeAnnotation instance.\n\nThis method utilizes the `copy.copy()` function from the `copy` module to generate a new instance that is a shallow copy of the original. The copied instance maintains the same attributes as the original but does not create deep copies of nested objects. This method does not take any parameters and returns a new instance of the same type as the original FakeAnnotation. \n\nThe `Self` type hint indicates that the method returns an instance of the same class type, providing type safety and enabling easier type checks during method calls.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/type_annotations/type_parent.py": "\"\"\"\nProtocol for types with children.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\n\nclass TypeParent(FakeAnnotation, ABC):\n    \"\"\"\n    Protocol for types with children.\n    \"\"\"\n\n    @abstractmethod\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children type annotations.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        ...\n\n    def find_type_annotation_parents(self, type_annotation: FakeAnnotation, skip: Iterable[FakeAnnotation]=()) -> 'set[TypeParent]':\n        \"\"\"\n        Check recursively if child is present in type def.\n        \"\"\"\n        result: set[TypeParent] = set()\n        for child_type in self.iterate_children_type_annotations():\n            if child_type == type_annotation:\n                result.add(self)\n            if not isinstance(child_type, TypeParent):\n                continue\n            if child_type in skip:\n                continue\n            parents = child_type.find_type_annotation_parents(type_annotation, skip={*skip, child_type})\n            result.update(parents)\n        return result\n\n    def replace_self_references(self, replacement: FakeAnnotation) -> 'set[TypeParent]':\n        \"\"\"\n        Replace self references with a new type annotation to avoid recursion.\n        \"\"\"\n        '\\n        Replace self references with a new type annotation to avoid recursion.\\n        '\n        parents = self.find_type_annotation_parents(self)\n        for parent in parents:\n            parent.replace_child(self, replacement)\n        return parents\n\n    def get_sortable_children(self) -> list[TypeDefSortable]:\n        \"\"\"\n        Extract required TypeDefSortable list from attributes.\n        \"\"\"\n        result: list[TypeDefSortable] = []\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if not isinstance(type_annotation, TypeDefSortable):\n                continue\n            result.append(type_annotation)\n        return result",
    "mypy_boto3_builder/type_annotations/type_subscript.py": "\"\"\"\nWrapper for subscript type annotations, like `List[str]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\n\nclass TypeSubscript(TypeParent):\n    \"\"\"\n    Wrapper for subscript type annotations, like `List[str]`.\n\n    Arguments:\n        parent -- Parent type annotation.\n        children -- Children type annotations.\n        stringify -- Convert type annotation to string.\n    \"\"\"\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        yield from self.parent.iterate_types()\n        for child in self.children:\n            yield from child.iterate_types()\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether subscript parent is Dict.\n        \"\"\"\n        return self.parent.is_dict()\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether subscript parent is List.\n        \"\"\"\n        return self.parent.is_list()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(parent=self.parent, children=list(self.children), stringify=self._stringify)\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        result: list[FakeAnnotation] = []\n        for child in self.children:\n            result.extend(child.get_local_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        yield from self.children\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        if child not in self.children:\n            raise TypeAnnotationError(f'Child not found: {child}')\n        index = self.children.index(child)\n        self.children[index] = new_child\n        return self\n\n    def iterate_children(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Iterate over children.\n        \"\"\"\n        yield from self.children",
    "mypy_boto3_builder/utils/type_checks.py": "\"\"\"\nType checking utils.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom typing import TypeGuard\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.type_annotations.type_typed_dict import TypeTypedDict\nfrom mypy_boto3_builder.type_annotations.type_union import TypeUnion",
    "mypy_boto3_builder/type_annotations/type_typed_dict.py": "\"\"\"\nWrapper for `typing/typing_extensions.TypedDict` type annotations.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_parent import TypeParent\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypedDictAttribute:\n    \"\"\"\n    TypedDict attribute wrapper.\n\n    Arguments:\n        name -- Attribute name.\n        type_annotation -- Attribute type annotation.\n        required -- Whether the attribute has to be set.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name, required and type annotation.\n        \"\"\"\n        return hash((self.name, self.required, self.type_annotation.get_sort_key()))\n\n    def get_type_annotation(self) -> FakeAnnotation:\n        \"\"\"\n        Get wrapped for non-required type annotation or raw type annotation.\n        \"\"\"\n        if self.is_required():\n            return self.type_annotation\n        return TypeSubscript(Type.NotRequired, [self.type_annotation])\n\n    def render(self) -> str:\n        \"\"\"\n        Render attribute to use in function-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'\"{self.name}\": {self.get_type_annotation().render()}'\n\n    def render_attribute(self) -> str:\n        \"\"\"\n        Render attribute to use in class-based TypedDict definition.\n\n        Returns:\n            A string with argument definition.\n        \"\"\"\n        return f'{self.name}: {self.get_type_annotation().render()}'\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Itera over type annotations.\n        \"\"\"\n        yield from self.type_annotation.iterate_types()\n\n    def is_required(self) -> bool:\n        \"\"\"\n        Whether argument is required.\n        \"\"\"\n        return self.required\n\n    def mark_as_required(self) -> None:\n        \"\"\"\n        Mark attribute as required.\n        \"\"\"\n        self.required = True\n\nclass TypeTypedDict(TypeParent, TypeDefSortable):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.TypedDict` type annotations.\n\n    Arguments:\n        name -- Type name.\n        children -- Typed dict attributes.\n        docstring -- Docstring for render.\n        stringify -- Convert type annotation to string to avoid circular deps.\n    \"\"\"\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether TypedDict usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render TypedDict usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort Typed Dicts by name.\n        \"\"\"\n        return self.name\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on name and children.\n        \"\"\"\n        return hash((self.name, *self.children))\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.is_stringified():\n            return f'\"{self.name}\"'\n        return self.name\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        template = Path('common/typed_dict_class.py.jinja2') if self.is_safe_as_class else Path('common/typed_dict.py.jinja2')\n        return render_jinja2_template(template, {'type_def': self})\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using TypedDict.\n        \"\"\"\n        result = Type.TypedDict.get_import_records()\n        for child in self.iterate_children():\n            result.update(child.get_type_annotation().get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def add_attribute(self, name: str, type_annotation: FakeAnnotation, *, required: bool) -> None:\n        \"\"\"\n        Add new attribute to a dictionary.\n\n        Arguments:\n            name -- Argument name.\n            type_annotation -- Argument type annotation.\n            required -- Whether argument has to be set.\n        \"\"\"\n        self.children.append(TypedDictAttribute(name, type_annotation, required=required))\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return True\n\n    def has_optional(self) -> bool:\n        \"\"\"\n        Whether TypedDict has optional keys.\n        \"\"\"\n        return any((not child.is_required() for child in self.children))\n\n    def has_required(self) -> bool:\n        \"\"\"\n        Whether TypedDict has required keys.\n        \"\"\"\n        return any((child.is_required() for child in self.children))\n\n    def get_required(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of required attributes.\n        \"\"\"\n        return tuple((child for child in self.children if child.is_required()))\n\n    def get_optional(self) -> tuple[TypedDictAttribute, ...]:\n        \"\"\"\n        Get a list of optional attributes.\n        \"\"\"\n        return tuple((child for child in self.children if not child.is_required()))\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, list(self.children), docstring=self.docstring, stringify=self.is_stringified())\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check whether typed dict attributes are the same as `other`.\n        \"\"\"\n        return hash(self) == hash(other)\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def iterate_children_type_annotations(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        for child in self.children:\n            yield child.type_annotation\n\n    def get_children_literals(self, processed: Iterable[str]=()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def iterate_children(self) -> Iterator[TypedDictAttribute]:\n        \"\"\"\n        Iterate over children from required to optional.\n        \"\"\"\n        yield from self.get_required()\n        yield from self.get_optional()\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [child.type_annotation for child in self.children if child.type_annotation.get_local_types()]\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return True\n\n    def replace_child(self, child: FakeAnnotation, new_child: FakeAnnotation) -> Self:\n        \"\"\"\n        Replace child type annotation with a new one.\n        \"\"\"\n        children_types = [i.type_annotation for i in self.children]\n        if child not in children_types:\n            raise TypeAnnotationError(f'Child not found: {child}')\n        indices = [i for i, x in enumerate(children_types) if x == child]\n        for index in indices:\n            self.children[index].type_annotation = new_child\n        return self",
    "mypy_boto3_builder/type_annotations/type_annotation.py": "\"\"\"\nWrapper for `typing` type annotation.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Mapping\nfrom typing import Final, Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass TypeAnnotation(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing` type annotation.\n\n    Arguments:\n        wrapped_type -- Original type annotation as a string.\n    \"\"\"\n    _TYPING: Final = ImportString('typing')\n    _TYPING_EXTENSIONS: Final = ImportString('typing_extensions')\n    _SUPPORTED_TYPES: Final[Mapping[str, ImportString]] = {'Union': _TYPING, 'Any': _TYPING, 'Dict': _TYPING, 'List': _TYPING, 'Set': _TYPING, 'Optional': _TYPING, 'IO': _TYPING, 'overload': _TYPING, 'Type': _TYPING, 'NoReturn': _TYPING, 'TypedDict': _TYPING, 'Literal': _TYPING, 'Mapping': _TYPING, 'Sequence': _TYPING, 'Callable': _TYPING, 'Iterator': _TYPING, 'Awaitable': _TYPING, 'AsyncIterator': _TYPING, 'NotRequired': _TYPING, 'Unpack': _TYPING}\n    _FALLBACK: Final[Mapping[str, tuple[tuple[int, int] | None, ImportString]]] = {'NotRequired': ((3, 12), _TYPING_EXTENSIONS), 'TypedDict': ((3, 12), _TYPING_EXTENSIONS), 'Literal': ((3, 12), _TYPING_EXTENSIONS), 'Unpack': ((3, 12), _TYPING_EXTENSIONS)}\n\n    def __init__(self, wrapped_type: str) -> None:\n        if wrapped_type not in self._SUPPORTED_TYPES:\n            raise TypeAnnotationError(f'Cannot wrap {wrapped_type}')\n        self._wrapped_type: str = wrapped_type\n\n    def get_import_name(self) -> str:\n        \"\"\"\n        Create a safe name for imported annotation.\n        \"\"\"\n        return self._wrapped_type\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Create a safe Import Record for annotation.\n        \"\"\"\n        name = self.get_import_name()\n        source = self._SUPPORTED_TYPES[name]\n        if name not in self._FALLBACK:\n            return {ImportRecord(source=source, name=name)}\n        fallback_min_version, fallback_source = self._FALLBACK[name]\n        return {ImportRecord(source=source, name=name, fallback=ImportRecord(source=fallback_source, name=name), min_version=fallback_min_version)}\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether annotation is a plain Dict.\n        \"\"\"\n        return self._wrapped_type == 'Dict'\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether annotation is a plain List.\n        \"\"\"\n        return self._wrapped_type == 'List'\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self._wrapped_type)",
    "mypy_boto3_builder/type_annotations/type_union.py": "\"\"\"\nWrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable, Iterator\nfrom pathlib import Path\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type import Type\nfrom mypy_boto3_builder.type_annotations.type_def_sortable import TypeDefSortable\nfrom mypy_boto3_builder.type_annotations.type_literal import TypeLiteral\nfrom mypy_boto3_builder.type_annotations.type_subscript import TypeSubscript\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypeUnion(TypeSubscript, TypeDefSortable):\n    \"\"\"\n    Wrapper for name Union type annotations, like `MyUnion = Union[str, int]`.\n    \"\"\"\n    _MIN_CHILDREN: Final = 2\n\n    def is_stringified(self) -> bool:\n        \"\"\"\n        Whether Union usage should be rendered as a string.\n        \"\"\"\n        return self._stringify\n\n    def stringify(self) -> None:\n        \"\"\"\n        Render Union usage as a string.\n        \"\"\"\n        self._stringify = True\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(children=list(self.children), name=self.name, stringify=self._stringify)\n\n    def get_children_types(self) -> set[FakeAnnotation]:\n        \"\"\"\n        Extract required type annotations from attributes.\n        \"\"\"\n        result: set[FakeAnnotation] = set()\n        for child in self.children:\n            result.update(child.iterate_types())\n        return result\n\n    def get_children_literals(self, processed: Iterable[str]=()) -> set[TypeLiteral]:\n        \"\"\"\n        Extract required TypeLiteral list from attributes.\n        \"\"\"\n        result: set[TypeLiteral] = set()\n        if self.name in processed:\n            return result\n        children_types = self.get_children_types()\n        for type_annotation in children_types:\n            if isinstance(type_annotation, TypeLiteral):\n                result.add(type_annotation)\n            if isinstance(type_annotation, TypeDefSortable):\n                result.update(type_annotation.get_children_literals((self.name, *processed)))\n        return result\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Union.\n        \"\"\"\n        result: set[ImportRecord] = set()\n        result.update(self.parent.get_import_records())\n        for child in self.children:\n            result.update(child.get_import_records())\n        return result\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {InternalImportRecord(ServiceModuleName.type_defs, name=self.name)}\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return self._get_import_records()\n\n    def iterate_types(self) -> Iterator[FakeAnnotation]:\n        \"\"\"\n        Extract type annotations from children.\n        \"\"\"\n        if self.is_named():\n            yield self\n            return\n        yield from super().iterate_types()\n\n    def is_type_def(self) -> bool:\n        \"\"\"\n        Whether type annotation is a TypeDef.\n        \"\"\"\n        return self.is_named()\n\n    @property\n    def type_hint_annotations(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Type annotations list from arguments and return type with internal types.\n        \"\"\"\n        return [child for child in self.children if child.get_local_types()]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        if self.is_named():\n            return render_jinja2_template(Path('common/named_union.py.jinja2'), {'type_def': self})\n        return self.render()",
    "mypy_boto3_builder/type_annotations/type_literal.py": "\"\"\"\nWrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nfrom collections.abc import Iterable\nfrom pathlib import Path\nfrom typing import Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.internal_import_record import InternalImportRecord\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\nfrom mypy_boto3_builder.type_annotations.type_annotation import TypeAnnotation\nfrom mypy_boto3_builder.utils.jinja2 import render_jinja2_template\n\nclass TypeLiteral(FakeAnnotation):\n    \"\"\"\n    Wrapper for `typing/typing_extensions.Literal` type annotations like `Literal['a', 'b']`.\n\n    Arguments:\n        name -- Literal name for non-inline.\n        children -- Literal values.\n        inline -- Render literal inline.\n    \"\"\"\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Sort literals by name.\n        \"\"\"\n        return self.name\n\n    @property\n    def inline(self) -> bool:\n        \"\"\"\n        Whether Litereal should be rendered inline.\n\n        1-value literals are rendered inline.\n        \"\"\"\n        return len(self.children) == 1\n\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n\n        Returns:\n            A string with a valid type annotation.\n        \"\"\"\n        if self.inline:\n            children = ', '.join([repr(i) for i in sorted(self.children)])\n            return f'Literal[{children}]'\n        return self.name\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.inline:\n            return TypeAnnotation('Literal').get_import_records()\n        return {InternalImportRecord(ServiceModuleName.literals, name=self.name)}\n\n    def get_definition_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using Literal.\n        \"\"\"\n        return TypeAnnotation('Literal').get_import_records()\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.name, self.children)\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return True\n\n    def add_child(self, child: FakeAnnotation) -> None:\n        \"\"\"\n        Disabled method to avoid confusion.\n        \"\"\"\n        raise TypeAnnotationError('Use add_literal_child function.')\n\n    def is_same(self: Self, other: Self) -> bool:\n        \"\"\"\n        Check if literals have the same children.\n        \"\"\"\n        return self.children == other.children\n\n    def get_local_types(self) -> list[FakeAnnotation]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return [self]\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation definition.\n        \"\"\"\n        return render_jinja2_template(Path('common/literal.py.jinja2'), {'literal': self})",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}\n\n    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()"
  }
}