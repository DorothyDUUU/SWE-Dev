{
  "dir_path": "/app/uvicorn",
  "package_name": "uvicorn",
  "sample_name": "uvicorn-test_subprocess",
  "src_dir": "uvicorn/",
  "test_dir": "tests/",
  "test_file": "tests/test_subprocess.py",
  "test_code": "from __future__ import annotations\n\nimport socket\nfrom unittest.mock import patch\n\nfrom uvicorn._subprocess import SpawnProcess, get_subprocess, subprocess_started\nfrom uvicorn._types import ASGIReceiveCallable, ASGISendCallable, Scope\nfrom uvicorn.config import Config\n\n\ndef server_run(sockets: list[socket.socket]):  # pragma: no cover\n    ...\n\n\nasync def app(scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable) -> None:  # pragma: no cover\n    ...\n\n\ndef test_get_subprocess() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    process = get_subprocess(config, server_run, [fdsock])\n    assert isinstance(process, SpawnProcess)\n\n    fdsock.close()\n\n\ndef test_subprocess_started() -> None:\n    fdsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    fd = fdsock.fileno()\n    config = Config(app=app, fd=fd)\n    config.load()\n\n    with patch(\"tests.test_subprocess.server_run\") as mock_run:\n        with patch.object(config, \"configure_logging\") as mock_config_logging:\n            subprocess_started(config, server_run, [fdsock], None)\n            mock_run.assert_called_once()\n            mock_config_logging.assert_called_once()\n\n    fdsock.close()\n",
  "GT_file_code": {
    "uvicorn/config.py": "from __future__ import annotations\n\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport logging.config\nimport os\nimport socket\nimport ssl\nimport sys\nfrom configparser import RawConfigParser\nfrom pathlib import Path\nfrom typing import IO, Any, Awaitable, Callable, Literal\n\nimport click\n\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.importer import ImportFromStringError, import_from_string\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.asgi2 import ASGI2Middleware\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware\nfrom uvicorn.middleware.wsgi import WSGIMiddleware\n\nHTTPProtocolType = Literal[\"auto\", \"h11\", \"httptools\"]\nWSProtocolType = Literal[\"auto\", \"none\", \"websockets\", \"wsproto\"]\nLifespanType = Literal[\"auto\", \"on\", \"off\"]\nLoopSetupType = Literal[\"none\", \"auto\", \"asyncio\", \"uvloop\"]\nInterfaceType = Literal[\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nLOG_LEVELS: dict[str, int] = {\n    \"critical\": logging.CRITICAL,\n    \"error\": logging.ERROR,\n    \"warning\": logging.WARNING,\n    \"info\": logging.INFO,\n    \"debug\": logging.DEBUG,\n    \"trace\": TRACE_LOG_LEVEL,\n}\nHTTP_PROTOCOLS: dict[HTTPProtocolType, str] = {\n    \"auto\": \"uvicorn.protocols.http.auto:AutoHTTPProtocol\",\n    \"h11\": \"uvicorn.protocols.http.h11_impl:H11Protocol\",\n    \"httptools\": \"uvicorn.protocols.http.httptools_impl:HttpToolsProtocol\",\n}\nWS_PROTOCOLS: dict[WSProtocolType, str | None] = {\n    \"auto\": \"uvicorn.protocols.websockets.auto:AutoWebSocketsProtocol\",\n    \"none\": None,\n    \"websockets\": \"uvicorn.protocols.websockets.websockets_impl:WebSocketProtocol\",\n    \"wsproto\": \"uvicorn.protocols.websockets.wsproto_impl:WSProtocol\",\n}\nLIFESPAN: dict[LifespanType, str] = {\n    \"auto\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"on\": \"uvicorn.lifespan.on:LifespanOn\",\n    \"off\": \"uvicorn.lifespan.off:LifespanOff\",\n}\nLOOP_SETUPS: dict[LoopSetupType, str | None] = {\n    \"none\": None,\n    \"auto\": \"uvicorn.loops.auto:auto_loop_setup\",\n    \"asyncio\": \"uvicorn.loops.asyncio:asyncio_setup\",\n    \"uvloop\": \"uvicorn.loops.uvloop:uvloop_setup\",\n}\nINTERFACES: list[InterfaceType] = [\"auto\", \"asgi3\", \"asgi2\", \"wsgi\"]\n\nSSL_PROTOCOL_VERSION: int = ssl.PROTOCOL_TLS_SERVER\n\nLOGGING_CONFIG: dict[str, Any] = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"default\": {\n            \"()\": \"uvicorn.logging.DefaultFormatter\",\n            \"fmt\": \"%(levelprefix)s %(message)s\",\n            \"use_colors\": None,\n        },\n        \"access\": {\n            \"()\": \"uvicorn.logging.AccessFormatter\",\n            \"fmt\": '%(levelprefix)s %(client_addr)s - \"%(request_line)s\" %(status_code)s',  # noqa: E501\n        },\n    },\n    \"handlers\": {\n        \"default\": {\n            \"formatter\": \"default\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stderr\",\n        },\n        \"access\": {\n            \"formatter\": \"access\",\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n    },\n    \"loggers\": {\n        \"uvicorn\": {\"handlers\": [\"default\"], \"level\": \"INFO\", \"propagate\": False},\n        \"uvicorn.error\": {\"level\": \"INFO\"},\n        \"uvicorn.access\": {\"handlers\": [\"access\"], \"level\": \"INFO\", \"propagate\": False},\n    },\n}\n\nlogger = logging.getLogger(\"uvicorn.error\")\n\n\ndef create_ssl_context(\n    certfile: str | os.PathLike[str],\n    keyfile: str | os.PathLike[str] | None,\n    password: str | None,\n    ssl_version: int,\n    cert_reqs: int,\n    ca_certs: str | os.PathLike[str] | None,\n    ciphers: str | None,\n) -> ssl.SSLContext:\n    ctx = ssl.SSLContext(ssl_version)\n    get_password = (lambda: password) if password else None\n    ctx.load_cert_chain(certfile, keyfile, get_password)\n    ctx.verify_mode = ssl.VerifyMode(cert_reqs)\n    if ca_certs:\n        ctx.load_verify_locations(ca_certs)\n    if ciphers:\n        ctx.set_ciphers(ciphers)\n    return ctx\n\n\ndef is_dir(path: Path) -> bool:\n    try:\n        if not path.is_absolute():\n            path = path.resolve()\n        return path.is_dir()\n    except OSError:  # pragma: full coverage\n        return False\n\n\ndef resolve_reload_patterns(patterns_list: list[str], directories_list: list[str]) -> tuple[list[str], list[Path]]:\n    directories: list[Path] = list(set(map(Path, directories_list.copy())))\n    patterns: list[str] = patterns_list.copy()\n\n    current_working_directory = Path.cwd()\n    for pattern in patterns_list:\n        # Special case for the .* pattern, otherwise this would only match\n        # hidden directories which is probably undesired\n        if pattern == \".*\":\n            continue\n        patterns.append(pattern)\n        if is_dir(Path(pattern)):\n            directories.append(Path(pattern))\n        else:\n            for match in current_working_directory.glob(pattern):\n                if is_dir(match):\n                    directories.append(match)\n\n    directories = list(set(directories))\n    directories = list(map(Path, directories))\n    directories = list(map(lambda x: x.resolve(), directories))\n    directories = list({reload_path for reload_path in directories if is_dir(reload_path)})\n\n    children = []\n    for j in range(len(directories)):\n        for k in range(j + 1, len(directories)):  # pragma: full coverage\n            if directories[j] in directories[k].parents:\n                children.append(directories[k])\n            elif directories[k] in directories[j].parents:\n                children.append(directories[j])\n\n    directories = list(set(directories).difference(set(children)))\n\n    return list(set(patterns)), directories\n\n\ndef _normalize_dirs(dirs: list[str] | str | None) -> list[str]:\n    if dirs is None:\n        return []\n    if isinstance(dirs, str):\n        return [dirs]\n    return list(set(dirs))\n\n\nclass Config:\n    def __init__(\n        self,\n        app: ASGIApplication | Callable[..., Any] | str,\n        host: str = \"127.0.0.1\",\n        port: int = 8000,\n        uds: str | None = None,\n        fd: int | None = None,\n        loop: LoopSetupType = \"auto\",\n        http: type[asyncio.Protocol] | HTTPProtocolType = \"auto\",\n        ws: type[asyncio.Protocol] | WSProtocolType = \"auto\",\n        ws_max_size: int = 16 * 1024 * 1024,\n        ws_max_queue: int = 32,\n        ws_ping_interval: float | None = 20.0,\n        ws_ping_timeout: float | None = 20.0,\n        ws_per_message_deflate: bool = True,\n        lifespan: LifespanType = \"auto\",\n        env_file: str | os.PathLike[str] | None = None,\n        log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None = LOGGING_CONFIG,\n        log_level: str | int | None = None,\n        access_log: bool = True,\n        use_colors: bool | None = None,\n        interface: InterfaceType = \"auto\",\n        reload: bool = False,\n        reload_dirs: list[str] | str | None = None,\n        reload_delay: float = 0.25,\n        reload_includes: list[str] | str | None = None,\n        reload_excludes: list[str] | str | None = None,\n        workers: int | None = None,\n        proxy_headers: bool = True,\n        server_header: bool = True,\n        date_header: bool = True,\n        forwarded_allow_ips: list[str] | str | None = None,\n        root_path: str = \"\",\n        limit_concurrency: int | None = None,\n        limit_max_requests: int | None = None,\n        backlog: int = 2048,\n        timeout_keep_alive: int = 5,\n        timeout_notify: int = 30,\n        timeout_graceful_shutdown: int | None = None,\n        callback_notify: Callable[..., Awaitable[None]] | None = None,\n        ssl_keyfile: str | os.PathLike[str] | None = None,\n        ssl_certfile: str | os.PathLike[str] | None = None,\n        ssl_keyfile_password: str | None = None,\n        ssl_version: int = SSL_PROTOCOL_VERSION,\n        ssl_cert_reqs: int = ssl.CERT_NONE,\n        ssl_ca_certs: str | None = None,\n        ssl_ciphers: str = \"TLSv1\",\n        headers: list[tuple[str, str]] | None = None,\n        factory: bool = False,\n        h11_max_incomplete_event_size: int | None = None,\n    ):\n        self.app = app\n        self.host = host\n        self.port = port\n        self.uds = uds\n        self.fd = fd\n        self.loop = loop\n        self.http = http\n        self.ws = ws\n        self.ws_max_size = ws_max_size\n        self.ws_max_queue = ws_max_queue\n        self.ws_ping_interval = ws_ping_interval\n        self.ws_ping_timeout = ws_ping_timeout\n        self.ws_per_message_deflate = ws_per_message_deflate\n        self.lifespan = lifespan\n        self.log_config = log_config\n        self.log_level = log_level\n        self.access_log = access_log\n        self.use_colors = use_colors\n        self.interface = interface\n        self.reload = reload\n        self.reload_delay = reload_delay\n        self.workers = workers or 1\n        self.proxy_headers = proxy_headers\n        self.server_header = server_header\n        self.date_header = date_header\n        self.root_path = root_path\n        self.limit_concurrency = limit_concurrency\n        self.limit_max_requests = limit_max_requests\n        self.backlog = backlog\n        self.timeout_keep_alive = timeout_keep_alive\n        self.timeout_notify = timeout_notify\n        self.timeout_graceful_shutdown = timeout_graceful_shutdown\n        self.callback_notify = callback_notify\n        self.ssl_keyfile = ssl_keyfile\n        self.ssl_certfile = ssl_certfile\n        self.ssl_keyfile_password = ssl_keyfile_password\n        self.ssl_version = ssl_version\n        self.ssl_cert_reqs = ssl_cert_reqs\n        self.ssl_ca_certs = ssl_ca_certs\n        self.ssl_ciphers = ssl_ciphers\n        self.headers: list[tuple[str, str]] = headers or []\n        self.encoded_headers: list[tuple[bytes, bytes]] = []\n        self.factory = factory\n        self.h11_max_incomplete_event_size = h11_max_incomplete_event_size\n\n        self.loaded = False\n        self.configure_logging()\n\n        self.reload_dirs: list[Path] = []\n        self.reload_dirs_excludes: list[Path] = []\n        self.reload_includes: list[str] = []\n        self.reload_excludes: list[str] = []\n\n        if (reload_dirs or reload_includes or reload_excludes) and not self.should_reload:\n            logger.warning(\n                \"Current configuration will not reload as not all conditions are met, \" \"please refer to documentation.\"\n            )\n\n        if self.should_reload:\n            reload_dirs = _normalize_dirs(reload_dirs)\n            reload_includes = _normalize_dirs(reload_includes)\n            reload_excludes = _normalize_dirs(reload_excludes)\n\n            self.reload_includes, self.reload_dirs = resolve_reload_patterns(reload_includes, reload_dirs)\n\n            self.reload_excludes, self.reload_dirs_excludes = resolve_reload_patterns(reload_excludes, [])\n\n            reload_dirs_tmp = self.reload_dirs.copy()\n\n            for directory in self.reload_dirs_excludes:\n                for reload_directory in reload_dirs_tmp:\n                    if directory == reload_directory or directory in reload_directory.parents:\n                        try:\n                            self.reload_dirs.remove(reload_directory)\n                        except ValueError:  # pragma: full coverage\n                            pass\n\n            for pattern in self.reload_excludes:\n                if pattern in self.reload_includes:\n                    self.reload_includes.remove(pattern)  # pragma: full coverage\n\n            if not self.reload_dirs:\n                if reload_dirs:\n                    logger.warning(\n                        \"Provided reload directories %s did not contain valid \"\n                        + \"directories, watching current working directory.\",\n                        reload_dirs,\n                    )\n                self.reload_dirs = [Path(os.getcwd())]\n\n            logger.info(\n                \"Will watch for changes in these directories: %s\",\n                sorted(list(map(str, self.reload_dirs))),\n            )\n\n        if env_file is not None:\n            from dotenv import load_dotenv\n\n            logger.info(\"Loading environment from '%s'\", env_file)\n            load_dotenv(dotenv_path=env_file)\n\n        if workers is None and \"WEB_CONCURRENCY\" in os.environ:\n            self.workers = int(os.environ[\"WEB_CONCURRENCY\"])\n\n        self.forwarded_allow_ips: list[str] | str\n        if forwarded_allow_ips is None:\n            self.forwarded_allow_ips = os.environ.get(\"FORWARDED_ALLOW_IPS\", \"127.0.0.1\")\n        else:\n            self.forwarded_allow_ips = forwarded_allow_ips  # pragma: full coverage\n\n        if self.reload and self.workers > 1:\n            logger.warning('\"workers\" flag is ignored when reloading is enabled.')\n\n    @property\n    def asgi_version(self) -> Literal[\"2.0\", \"3.0\"]:\n        mapping: dict[str, Literal[\"2.0\", \"3.0\"]] = {\n            \"asgi2\": \"2.0\",\n            \"asgi3\": \"3.0\",\n            \"wsgi\": \"3.0\",\n        }\n        return mapping[self.interface]\n\n    @property\n    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)\n\n    @property\n    def use_subprocess(self) -> bool:\n        return bool(self.reload or self.workers > 1)\n\n    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, \"TRACE\")\n\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config[\"formatters\"][\"default\"][\"use_colors\"] = self.use_colors\n                    self.log_config[\"formatters\"][\"access\"][\"use_colors\"] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(\".json\"):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith((\".yaml\", \".yml\")):\n                # Install the PyYAML package or the uvicorn[standard] optional\n                # dependencies to enable this functionality.\n                import yaml\n\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                # See the note about fileConfig() here:\n                # https://docs.python.org/3/library/logging.config.html#configuration-file-format\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger(\"uvicorn.error\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.access\").setLevel(log_level)\n            logging.getLogger(\"uvicorn.asgi\").setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger(\"uvicorn.access\").handlers = []\n            logging.getLogger(\"uvicorn.access\").propagate = False\n\n    def load(self) -> None:\n        assert not self.loaded\n\n        if self.is_ssl:\n            assert self.ssl_certfile\n            self.ssl: ssl.SSLContext | None = create_ssl_context(\n                keyfile=self.ssl_keyfile,\n                certfile=self.ssl_certfile,\n                password=self.ssl_keyfile_password,\n                ssl_version=self.ssl_version,\n                cert_reqs=self.ssl_cert_reqs,\n                ca_certs=self.ssl_ca_certs,\n                ciphers=self.ssl_ciphers,\n            )\n        else:\n            self.ssl = None\n\n        encoded_headers = [(key.lower().encode(\"latin1\"), value.encode(\"latin1\")) for key, value in self.headers]\n        self.encoded_headers = (\n            [(b\"server\", b\"uvicorn\")] + encoded_headers\n            if b\"server\" not in dict(encoded_headers) and self.server_header\n            else encoded_headers\n        )\n\n        if isinstance(self.http, str):\n            http_protocol_class = import_from_string(HTTP_PROTOCOLS[self.http])\n            self.http_protocol_class: type[asyncio.Protocol] = http_protocol_class\n        else:\n            self.http_protocol_class = self.http\n\n        if isinstance(self.ws, str):\n            ws_protocol_class = import_from_string(WS_PROTOCOLS[self.ws])\n            self.ws_protocol_class: type[asyncio.Protocol] | None = ws_protocol_class\n        else:\n            self.ws_protocol_class = self.ws\n\n        self.lifespan_class = import_from_string(LIFESPAN[self.lifespan])\n\n        try:\n            self.loaded_app = import_from_string(self.app)\n        except ImportFromStringError as exc:\n            logger.error(\"Error loading ASGI app. %s\" % exc)\n            sys.exit(1)\n\n        try:\n            self.loaded_app = self.loaded_app()\n        except TypeError as exc:\n            if self.factory:\n                logger.error(\"Error loading ASGI app factory: %s\", exc)\n                sys.exit(1)\n        else:\n            if not self.factory:\n                logger.warning(\n                    \"ASGI app factory detected. Using it, \" \"but please consider setting the --factory flag explicitly.\"\n                )\n\n        if self.interface == \"auto\":\n            if inspect.isclass(self.loaded_app):\n                use_asgi_3 = hasattr(self.loaded_app, \"__await__\")\n            elif inspect.isfunction(self.loaded_app):\n                use_asgi_3 = asyncio.iscoroutinefunction(self.loaded_app)\n            else:\n                call = getattr(self.loaded_app, \"__call__\", None)\n                use_asgi_3 = asyncio.iscoroutinefunction(call)\n            self.interface = \"asgi3\" if use_asgi_3 else \"asgi2\"\n\n        if self.interface == \"wsgi\":\n            self.loaded_app = WSGIMiddleware(self.loaded_app)\n            self.ws_protocol_class = None\n        elif self.interface == \"asgi2\":\n            self.loaded_app = ASGI2Middleware(self.loaded_app)\n\n        if logger.getEffectiveLevel() <= TRACE_LOG_LEVEL:\n            self.loaded_app = MessageLoggerMiddleware(self.loaded_app)\n        if self.proxy_headers:\n            self.loaded_app = ProxyHeadersMiddleware(self.loaded_app, trusted_hosts=self.forwarded_allow_ips)\n\n        self.loaded = True\n\n    def setup_event_loop(self) -> None:\n        loop_setup: Callable | None = import_from_string(LOOP_SETUPS[self.loop])\n        if loop_setup is not None:\n            loop_setup(use_subprocess=self.use_subprocess)\n\n    def bind_socket(self) -> socket.socket:\n        logger_args: list[str | int]\n        if self.uds:  # pragma: py-win32\n            path = self.uds\n            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                sock.bind(path)\n                uds_perms = 0o666\n                os.chmod(self.uds, uds_perms)\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = \"Uvicorn running on unix socket %s (Press CTRL+C to quit)\"\n            sock_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(sock_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [self.uds]\n        elif self.fd:  # pragma: py-win32\n            sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            message = \"Uvicorn running on socket %s (Press CTRL+C to quit)\"\n            fd_name_format = \"%s\"\n            color_message = \"Uvicorn running on \" + click.style(fd_name_format, bold=True) + \" (Press CTRL+C to quit)\"\n            logger_args = [sock.getsockname()]\n        else:\n            family = socket.AF_INET\n            addr_format = \"%s://%s:%d\"\n\n            if self.host and \":\" in self.host:  # pragma: full coverage\n                # It's an IPv6 address.\n                family = socket.AF_INET6\n                addr_format = \"%s://[%s]:%d\"\n\n            sock = socket.socket(family=family)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.bind((self.host, self.port))\n            except OSError as exc:  # pragma: full coverage\n                logger.error(exc)\n                sys.exit(1)\n\n            message = f\"Uvicorn running on {addr_format} (Press CTRL+C to quit)\"\n            color_message = \"Uvicorn running on \" + click.style(addr_format, bold=True) + \" (Press CTRL+C to quit)\"\n            protocol_name = \"https\" if self.is_ssl else \"http\"\n            logger_args = [protocol_name, self.host, sock.getsockname()[1]]\n        logger.info(message, *logger_args, extra={\"color_message\": color_message})\n        sock.set_inheritable(True)\n        return sock\n\n    @property\n    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload\n",
    "uvicorn/_subprocess.py": "\"\"\"\nSome light wrappers around Python's multiprocessing, to deal with cleanly\nstarting child processes.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport multiprocessing\nimport os\nimport sys\nfrom multiprocessing.context import SpawnProcess\nfrom socket import socket\nfrom typing import Callable\n\nfrom uvicorn.config import Config\n\nmultiprocessing.allow_connection_pickling()\nspawn = multiprocessing.get_context(\"spawn\")\n\n\ndef get_subprocess(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n) -> SpawnProcess:\n    \"\"\"\n    Called in the parent process, to instantiate a new child process instance.\n    The child is not yet started at this point.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    \"\"\"\n    # We pass across the stdin fileno, and reopen it in the child process.\n    # This is required for some debugging environments.\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    # The `sys.stdin` can be `None`, see https://docs.python.org/3/library/sys.html#sys.__stdin__.\n    except (AttributeError, OSError):\n        stdin_fileno = None\n\n    kwargs = {\n        \"config\": config,\n        \"target\": target,\n        \"sockets\": sockets,\n        \"stdin_fileno\": stdin_fileno,\n    }\n\n    return spawn.Process(target=subprocess_started, kwargs=kwargs)\n\n\ndef subprocess_started(\n    config: Config,\n    target: Callable[..., None],\n    sockets: list[socket],\n    stdin_fileno: int | None,\n) -> None:\n    \"\"\"\n    Called when the child process starts.\n\n    * config - The Uvicorn configuration instance.\n    * target - A callable that accepts a list of sockets. In practice this will\n               be the `Server.run()` method.\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\n                by the parent process, and then passed to the child processes.\n    * stdin_fileno - The file number of sys.stdin, so that it can be reattached\n                     to the child process.\n    \"\"\"\n    # Re-open stdin.\n    if stdin_fileno is not None:\n        sys.stdin = os.fdopen(stdin_fileno)  # pragma: full coverage\n\n    # Logging needs to be setup again for each child.\n    config.configure_logging()\n\n    try:\n        # Now we can call into `Server.run(sockets=sockets)`\n        target(sockets=sockets)\n    except KeyboardInterrupt:  # pragma: no cover\n        # supress the exception to avoid a traceback from subprocess.Popen\n        # the parent already expects us to end, so no vital information is lost\n        pass\n"
  },
  "GT_src_dict": {
    "uvicorn/config.py": {
      "Config.__init__": {
        "code": "    def __init__(self, app: ASGIApplication | Callable[..., Any] | str, host: str='127.0.0.1', port: int=8000, uds: str | None=None, fd: int | None=None, loop: LoopSetupType='auto', http: type[asyncio.Protocol] | HTTPProtocolType='auto', ws: type[asyncio.Protocol] | WSProtocolType='auto', ws_max_size: int=16 * 1024 * 1024, ws_max_queue: int=32, ws_ping_interval: float | None=20.0, ws_ping_timeout: float | None=20.0, ws_per_message_deflate: bool=True, lifespan: LifespanType='auto', env_file: str | os.PathLike[str] | None=None, log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None=LOGGING_CONFIG, log_level: str | int | None=None, access_log: bool=True, use_colors: bool | None=None, interface: InterfaceType='auto', reload: bool=False, reload_dirs: list[str] | str | None=None, reload_delay: float=0.25, reload_includes: list[str] | str | None=None, reload_excludes: list[str] | str | None=None, workers: int | None=None, proxy_headers: bool=True, server_header: bool=True, date_header: bool=True, forwarded_allow_ips: list[str] | str | None=None, root_path: str='', limit_concurrency: int | None=None, limit_max_requests: int | None=None, backlog: int=2048, timeout_keep_alive: int=5, timeout_notify: int=30, timeout_graceful_shutdown: int | None=None, callback_notify: Callable[..., Awaitable[None]] | None=None, ssl_keyfile: str | os.PathLike[str] | None=None, ssl_certfile: str | os.PathLike[str] | None=None, ssl_keyfile_password: str | None=None, ssl_version: int=SSL_PROTOCOL_VERSION, ssl_cert_reqs: int=ssl.CERT_NONE, ssl_ca_certs: str | None=None, ssl_ciphers: str='TLSv1', headers: list[tuple[str, str]] | None=None, factory: bool=False, h11_max_incomplete_event_size: int | None=None):\n        \"\"\"Initializes a Config object for a Uvicorn ASGI server, encapsulating various server configuration options. \n\n    Parameters:\n    - app: ASGI application or callable entry point for the app.\n    - host: IP address to bind to (default is \"127.0.0.1\").\n    - port: Port to bind to (default is 8000).\n    - uds: Unix domain socket (optional).\n    - fd: Socket file descriptor (optional).\n    - loop: Event loop setup method (default is \"auto\").\n    - http: HTTP protocol type (default is \"auto\").\n    - ws: WebSocket protocol type (default is \"auto\").\n    - ws_max_size: Maximum size of a WebSocket message (default is 16 MiB).\n    - ws_max_queue: Maximum size of WebSocket message queue (default is 32).\n    - ws_ping_interval: Interval for pinging WebSocket clients (default is 20 seconds).\n    - ws_ping_timeout: Timeout for WebSocket pings (default is 20 seconds).\n    - ws_per_message_deflate: Enable per-message deflate for WebSocket (default is True).\n    - lifespan: Lifespan management (default is \"auto\").\n    - env_file: Path to environment file (optional).\n    - log_config: Configuration for logging (default is predefined LOGGING_CONFIG).\n    - log_level: Logging level (optional).\n    - access_log: Enable access logging (default is True).\n    - use_colors: Use colored logging output (default is None).\n    - interface: Type of application interface (default is \"auto\").\n    - reload: Enable auto-reloading of the server (default is False).\n    - reload_dirs: Directories to watch for changes (optional).\n    - reload_delay: Delay for reloads (default is 0.25 seconds).\n    - reload_includes: Patterns for files to include in reload (optional).\n    - reload_excludes: Patterns for files to exclude from reload (optional).\n    - workers: Number of worker processes (default is 1).\n    - proxy_headers: Enable proxy headers handling (default is True).\n    - server_header: Include server header in responses (default is True).\n    - date_header: Include date header in responses (default is True).\n    - forwarded_allow_ips: Allowed IPs for forwarded headers (optional).\n    - root_path: Root path for the application (default is empty).\n    - limit_concurrency: Max concurrent requests (optional).\n    - limit_max_requests: Max requests to serve before restarting workers (optional).\n    - backlog: Max number of pending connections (default is 2048).\n    - timeout_keep_alive: Keep-alive timeout (default is 5 seconds).\n    - timeout_notify: Notify timeout (default is 30 seconds).\n    - timeout_graceful_shutdown: Shutdown timeout (optional).\n    - callback_notify: Callback function for NOTIFY events (optional).\n    - ssl_keyfile: Path to SSL key file (optional).\n    - ssl_certfile: Path to SSL certificate file (optional).\n    - ssl_keyfile_password: Password for SSL key file (optional).\n    - ssl_version: SSL protocol version (default is SSL_PROTOCOL_VERSION).\n    - ssl_cert_reqs: SSL certificate requirements (default is ssl.CERT_NONE).\n    - ssl_ca_certs: Path to CA certificate file (optional).\n    - ssl_ciphers: Ciphers for SSL (default is \"TLSv1\").\n    - headers: Custom headers for responses (optional).\n    - factory: Indicates if the app is a factory (default is False).\n    - h11_max_incomplete_event_size: Max size for incomplete HTTP/1.1 events (optional).\n\n    Side effects:\n    Configures logging based on provided log_config and sets up reload functionality based on the given parameters. It also loads environment variables if an env_file is provided.\n\n    Constants used:\n    - LOGGING_CONFIG: A dictionary defined at the module level that provides the default configuration for logging.\n    - SSL_PROTOCOL_VERSION: Defines the SSL protocol version to be used for secure connections, imported from the ssl module.\"\"\"\n        self.app = app\n        self.host = host\n        self.port = port\n        self.uds = uds\n        self.fd = fd\n        self.loop = loop\n        self.http = http\n        self.ws = ws\n        self.ws_max_size = ws_max_size\n        self.ws_max_queue = ws_max_queue\n        self.ws_ping_interval = ws_ping_interval\n        self.ws_ping_timeout = ws_ping_timeout\n        self.ws_per_message_deflate = ws_per_message_deflate\n        self.lifespan = lifespan\n        self.log_config = log_config\n        self.log_level = log_level\n        self.access_log = access_log\n        self.use_colors = use_colors\n        self.interface = interface\n        self.reload = reload\n        self.reload_delay = reload_delay\n        self.workers = workers or 1\n        self.proxy_headers = proxy_headers\n        self.server_header = server_header\n        self.date_header = date_header\n        self.root_path = root_path\n        self.limit_concurrency = limit_concurrency\n        self.limit_max_requests = limit_max_requests\n        self.backlog = backlog\n        self.timeout_keep_alive = timeout_keep_alive\n        self.timeout_notify = timeout_notify\n        self.timeout_graceful_shutdown = timeout_graceful_shutdown\n        self.callback_notify = callback_notify\n        self.ssl_keyfile = ssl_keyfile\n        self.ssl_certfile = ssl_certfile\n        self.ssl_keyfile_password = ssl_keyfile_password\n        self.ssl_version = ssl_version\n        self.ssl_cert_reqs = ssl_cert_reqs\n        self.ssl_ca_certs = ssl_ca_certs\n        self.ssl_ciphers = ssl_ciphers\n        self.headers: list[tuple[str, str]] = headers or []\n        self.encoded_headers: list[tuple[bytes, bytes]] = []\n        self.factory = factory\n        self.h11_max_incomplete_event_size = h11_max_incomplete_event_size\n        self.loaded = False\n        self.configure_logging()\n        self.reload_dirs: list[Path] = []\n        self.reload_dirs_excludes: list[Path] = []\n        self.reload_includes: list[str] = []\n        self.reload_excludes: list[str] = []\n        if (reload_dirs or reload_includes or reload_excludes) and (not self.should_reload):\n            logger.warning('Current configuration will not reload as not all conditions are met, please refer to documentation.')\n        if self.should_reload:\n            reload_dirs = _normalize_dirs(reload_dirs)\n            reload_includes = _normalize_dirs(reload_includes)\n            reload_excludes = _normalize_dirs(reload_excludes)\n            self.reload_includes, self.reload_dirs = resolve_reload_patterns(reload_includes, reload_dirs)\n            self.reload_excludes, self.reload_dirs_excludes = resolve_reload_patterns(reload_excludes, [])\n            reload_dirs_tmp = self.reload_dirs.copy()\n            for directory in self.reload_dirs_excludes:\n                for reload_directory in reload_dirs_tmp:\n                    if directory == reload_directory or directory in reload_directory.parents:\n                        try:\n                            self.reload_dirs.remove(reload_directory)\n                        except ValueError:\n                            pass\n            for pattern in self.reload_excludes:\n                if pattern in self.reload_includes:\n                    self.reload_includes.remove(pattern)\n            if not self.reload_dirs:\n                if reload_dirs:\n                    logger.warning('Provided reload directories %s did not contain valid ' + 'directories, watching current working directory.', reload_dirs)\n                self.reload_dirs = [Path(os.getcwd())]\n            logger.info('Will watch for changes in these directories: %s', sorted(list(map(str, self.reload_dirs))))\n        if env_file is not None:\n            from dotenv import load_dotenv\n            logger.info(\"Loading environment from '%s'\", env_file)\n            load_dotenv(dotenv_path=env_file)\n        if workers is None and 'WEB_CONCURRENCY' in os.environ:\n            self.workers = int(os.environ['WEB_CONCURRENCY'])\n        self.forwarded_allow_ips: list[str] | str\n        if forwarded_allow_ips is None:\n            self.forwarded_allow_ips = os.environ.get('FORWARDED_ALLOW_IPS', '127.0.0.1')\n        else:\n            self.forwarded_allow_ips = forwarded_allow_ips\n        if self.reload and self.workers > 1:\n            logger.warning('\"workers\" flag is ignored when reloading is enabled.')",
        "docstring": "Initializes a Config object for a Uvicorn ASGI server, encapsulating various server configuration options. \n\nParameters:\n- app: ASGI application or callable entry point for the app.\n- host: IP address to bind to (default is \"127.0.0.1\").\n- port: Port to bind to (default is 8000).\n- uds: Unix domain socket (optional).\n- fd: Socket file descriptor (optional).\n- loop: Event loop setup method (default is \"auto\").\n- http: HTTP protocol type (default is \"auto\").\n- ws: WebSocket protocol type (default is \"auto\").\n- ws_max_size: Maximum size of a WebSocket message (default is 16 MiB).\n- ws_max_queue: Maximum size of WebSocket message queue (default is 32).\n- ws_ping_interval: Interval for pinging WebSocket clients (default is 20 seconds).\n- ws_ping_timeout: Timeout for WebSocket pings (default is 20 seconds).\n- ws_per_message_deflate: Enable per-message deflate for WebSocket (default is True).\n- lifespan: Lifespan management (default is \"auto\").\n- env_file: Path to environment file (optional).\n- log_config: Configuration for logging (default is predefined LOGGING_CONFIG).\n- log_level: Logging level (optional).\n- access_log: Enable access logging (default is True).\n- use_colors: Use colored logging output (default is None).\n- interface: Type of application interface (default is \"auto\").\n- reload: Enable auto-reloading of the server (default is False).\n- reload_dirs: Directories to watch for changes (optional).\n- reload_delay: Delay for reloads (default is 0.25 seconds).\n- reload_includes: Patterns for files to include in reload (optional).\n- reload_excludes: Patterns for files to exclude from reload (optional).\n- workers: Number of worker processes (default is 1).\n- proxy_headers: Enable proxy headers handling (default is True).\n- server_header: Include server header in responses (default is True).\n- date_header: Include date header in responses (default is True).\n- forwarded_allow_ips: Allowed IPs for forwarded headers (optional).\n- root_path: Root path for the application (default is empty).\n- limit_concurrency: Max concurrent requests (optional).\n- limit_max_requests: Max requests to serve before restarting workers (optional).\n- backlog: Max number of pending connections (default is 2048).\n- timeout_keep_alive: Keep-alive timeout (default is 5 seconds).\n- timeout_notify: Notify timeout (default is 30 seconds).\n- timeout_graceful_shutdown: Shutdown timeout (optional).\n- callback_notify: Callback function for NOTIFY events (optional).\n- ssl_keyfile: Path to SSL key file (optional).\n- ssl_certfile: Path to SSL certificate file (optional).\n- ssl_keyfile_password: Password for SSL key file (optional).\n- ssl_version: SSL protocol version (default is SSL_PROTOCOL_VERSION).\n- ssl_cert_reqs: SSL certificate requirements (default is ssl.CERT_NONE).\n- ssl_ca_certs: Path to CA certificate file (optional).\n- ssl_ciphers: Ciphers for SSL (default is \"TLSv1\").\n- headers: Custom headers for responses (optional).\n- factory: Indicates if the app is a factory (default is False).\n- h11_max_incomplete_event_size: Max size for incomplete HTTP/1.1 events (optional).\n\nSide effects:\nConfigures logging based on provided log_config and sets up reload functionality based on the given parameters. It also loads environment variables if an env_file is provided.\n\nConstants used:\n- LOGGING_CONFIG: A dictionary defined at the module level that provides the default configuration for logging.\n- SSL_PROTOCOL_VERSION: Defines the SSL protocol version to be used for secure connections, imported from the ssl module.",
        "signature": "def __init__(self, app: ASGIApplication | Callable[..., Any] | str, host: str='127.0.0.1', port: int=8000, uds: str | None=None, fd: int | None=None, loop: LoopSetupType='auto', http: type[asyncio.Protocol] | HTTPProtocolType='auto', ws: type[asyncio.Protocol] | WSProtocolType='auto', ws_max_size: int=16 * 1024 * 1024, ws_max_queue: int=32, ws_ping_interval: float | None=20.0, ws_ping_timeout: float | None=20.0, ws_per_message_deflate: bool=True, lifespan: LifespanType='auto', env_file: str | os.PathLike[str] | None=None, log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None=LOGGING_CONFIG, log_level: str | int | None=None, access_log: bool=True, use_colors: bool | None=None, interface: InterfaceType='auto', reload: bool=False, reload_dirs: list[str] | str | None=None, reload_delay: float=0.25, reload_includes: list[str] | str | None=None, reload_excludes: list[str] | str | None=None, workers: int | None=None, proxy_headers: bool=True, server_header: bool=True, date_header: bool=True, forwarded_allow_ips: list[str] | str | None=None, root_path: str='', limit_concurrency: int | None=None, limit_max_requests: int | None=None, backlog: int=2048, timeout_keep_alive: int=5, timeout_notify: int=30, timeout_graceful_shutdown: int | None=None, callback_notify: Callable[..., Awaitable[None]] | None=None, ssl_keyfile: str | os.PathLike[str] | None=None, ssl_certfile: str | os.PathLike[str] | None=None, ssl_keyfile_password: str | None=None, ssl_version: int=SSL_PROTOCOL_VERSION, ssl_cert_reqs: int=ssl.CERT_NONE, ssl_ca_certs: str | None=None, ssl_ciphers: str='TLSv1', headers: list[tuple[str, str]] | None=None, factory: bool=False, h11_max_incomplete_event_size: int | None=None):",
        "type": "Method",
        "class_signature": "class Config:"
      },
      "Config.load": {
        "code": "    def load(self) -> None:\n        \"\"\"Loads and prepares the configuration for the Uvicorn server. This method sets up the SSL context if SSL certificates are provided, encodes specified headers, and determines the HTTP and WebSocket protocol classes based on the configuration. It attempts to load the ASGI application from a specified string, handling potential factory patterns and inferring the interface type (ASGI 2 or ASGI 3). Additionally, it wraps the loaded application with the appropriate middleware based on the interface type and logging configuration. Finally, it marks the configuration as loaded to prevent re-initialization.\n\nDependencies include constants like `HTTP_PROTOCOLS`, `WS_PROTOCOLS`, and `LIFESPAN`, which map protocol types to their respective class paths. The method also utilizes the function `import_from_string` to dynamically load classes and mid-way checks to adaptively select middleware, which ensures correct operation in asynchronous environments.\n\nReturns: None, but affects the internal state of the instance by setting up various attributes related to the server configuration and application instance.\"\"\"\n        assert not self.loaded\n        if self.is_ssl:\n            assert self.ssl_certfile\n            self.ssl: ssl.SSLContext | None = create_ssl_context(keyfile=self.ssl_keyfile, certfile=self.ssl_certfile, password=self.ssl_keyfile_password, ssl_version=self.ssl_version, cert_reqs=self.ssl_cert_reqs, ca_certs=self.ssl_ca_certs, ciphers=self.ssl_ciphers)\n        else:\n            self.ssl = None\n        encoded_headers = [(key.lower().encode('latin1'), value.encode('latin1')) for key, value in self.headers]\n        self.encoded_headers = [(b'server', b'uvicorn')] + encoded_headers if b'server' not in dict(encoded_headers) and self.server_header else encoded_headers\n        if isinstance(self.http, str):\n            http_protocol_class = import_from_string(HTTP_PROTOCOLS[self.http])\n            self.http_protocol_class: type[asyncio.Protocol] = http_protocol_class\n        else:\n            self.http_protocol_class = self.http\n        if isinstance(self.ws, str):\n            ws_protocol_class = import_from_string(WS_PROTOCOLS[self.ws])\n            self.ws_protocol_class: type[asyncio.Protocol] | None = ws_protocol_class\n        else:\n            self.ws_protocol_class = self.ws\n        self.lifespan_class = import_from_string(LIFESPAN[self.lifespan])\n        try:\n            self.loaded_app = import_from_string(self.app)\n        except ImportFromStringError as exc:\n            logger.error('Error loading ASGI app. %s' % exc)\n            sys.exit(1)\n        try:\n            self.loaded_app = self.loaded_app()\n        except TypeError as exc:\n            if self.factory:\n                logger.error('Error loading ASGI app factory: %s', exc)\n                sys.exit(1)\n        else:\n            if not self.factory:\n                logger.warning('ASGI app factory detected. Using it, but please consider setting the --factory flag explicitly.')\n        if self.interface == 'auto':\n            if inspect.isclass(self.loaded_app):\n                use_asgi_3 = hasattr(self.loaded_app, '__await__')\n            elif inspect.isfunction(self.loaded_app):\n                use_asgi_3 = asyncio.iscoroutinefunction(self.loaded_app)\n            else:\n                call = getattr(self.loaded_app, '__call__', None)\n                use_asgi_3 = asyncio.iscoroutinefunction(call)\n            self.interface = 'asgi3' if use_asgi_3 else 'asgi2'\n        if self.interface == 'wsgi':\n            self.loaded_app = WSGIMiddleware(self.loaded_app)\n            self.ws_protocol_class = None\n        elif self.interface == 'asgi2':\n            self.loaded_app = ASGI2Middleware(self.loaded_app)\n        if logger.getEffectiveLevel() <= TRACE_LOG_LEVEL:\n            self.loaded_app = MessageLoggerMiddleware(self.loaded_app)\n        if self.proxy_headers:\n            self.loaded_app = ProxyHeadersMiddleware(self.loaded_app, trusted_hosts=self.forwarded_allow_ips)\n        self.loaded = True",
        "docstring": "Loads and prepares the configuration for the Uvicorn server. This method sets up the SSL context if SSL certificates are provided, encodes specified headers, and determines the HTTP and WebSocket protocol classes based on the configuration. It attempts to load the ASGI application from a specified string, handling potential factory patterns and inferring the interface type (ASGI 2 or ASGI 3). Additionally, it wraps the loaded application with the appropriate middleware based on the interface type and logging configuration. Finally, it marks the configuration as loaded to prevent re-initialization.\n\nDependencies include constants like `HTTP_PROTOCOLS`, `WS_PROTOCOLS`, and `LIFESPAN`, which map protocol types to their respective class paths. The method also utilizes the function `import_from_string` to dynamically load classes and mid-way checks to adaptively select middleware, which ensures correct operation in asynchronous environments.\n\nReturns: None, but affects the internal state of the instance by setting up various attributes related to the server configuration and application instance.",
        "signature": "def load(self) -> None:",
        "type": "Method",
        "class_signature": "class Config:"
      }
    },
    "uvicorn/_subprocess.py": {
      "get_subprocess": {
        "code": "def get_subprocess(config: Config, target: Callable[..., None], sockets: list[socket]) -> SpawnProcess:\n    \"\"\"Creates and returns a new child process instance configured to run a specified target function with given sockets.\n\nParameters:\n- config (Config): The Uvicorn configuration instance used for logging and server setup.\n- target (Callable[..., None]): A callable that accepts a list of sockets, typically the `Server.run()` method.\n- sockets (list[socket]): A list of socket objects to be passed to the server; these are initialized in the parent process.\n\nReturns:\n- SpawnProcess: An object representing the child process, which is not yet started at this point.\n\nThis function utilizes the `spawn` context from the `multiprocessing` module to create a new process. It captures the standard input file descriptor to ensure it is reattached in the child process for debugging purposes. The `subprocess_started` function is invoked in the child process to set up the environment and execute the target function.\"\"\"\n    '\\n    Called in the parent process, to instantiate a new child process instance.\\n    The child is not yet started at this point.\\n\\n    * config - The Uvicorn configuration instance.\\n    * target - A callable that accepts a list of sockets. In practice this will\\n               be the `Server.run()` method.\\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\\n                by the parent process, and then passed to the child processes.\\n    '\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    except (AttributeError, OSError):\n        stdin_fileno = None\n    kwargs = {'config': config, 'target': target, 'sockets': sockets, 'stdin_fileno': stdin_fileno}\n    return spawn.Process(target=subprocess_started, kwargs=kwargs)",
        "docstring": "Creates and returns a new child process instance configured to run a specified target function with given sockets.\n\nParameters:\n- config (Config): The Uvicorn configuration instance used for logging and server setup.\n- target (Callable[..., None]): A callable that accepts a list of sockets, typically the `Server.run()` method.\n- sockets (list[socket]): A list of socket objects to be passed to the server; these are initialized in the parent process.\n\nReturns:\n- SpawnProcess: An object representing the child process, which is not yet started at this point.\n\nThis function utilizes the `spawn` context from the `multiprocessing` module to create a new process. It captures the standard input file descriptor to ensure it is reattached in the child process for debugging purposes. The `subprocess_started` function is invoked in the child process to set up the environment and execute the target function.",
        "signature": "def get_subprocess(config: Config, target: Callable[..., None], sockets: list[socket]) -> SpawnProcess:",
        "type": "Function",
        "class_signature": null
      },
      "subprocess_started": {
        "code": "def subprocess_started(config: Config, target: Callable[..., None], sockets: list[socket], stdin_fileno: int | None) -> None:\n    \"\"\"Start a child process for the Uvicorn server.\n\nThis function is invoked when a child process begins execution. It re-establishes the standard input and configures logging for the child process before executing the provided target callable with the designated sockets.\n\nParameters:\n- config (Config): The Uvicorn configuration instance that governs logging and server settings.\n- target (Callable[..., None]): A callable, typically `Server.run`, that will be executed in the child process, receiving sockets as an argument.\n- sockets (list[socket]): A list of socket objects to be passed to the target for handling incoming connections.\n- stdin_fileno (int | None): The file descriptor for the standard input; if not None, it will be used to reattach stdin in the child process.\n\nReturn Value: None\n\nSide Effects: \n- Reattaches the standard input using `os.fdopen` if `stdin_fileno` is provided.\n- Configures logging specific to the child process by invoking `config.configure_logging()`.\n- Executes the target callable, allowing the child process to handle its respective sockets, and suppresses any `KeyboardInterrupt` exceptions to avoid traceback display.\"\"\"\n    '\\n    Called when the child process starts.\\n\\n    * config - The Uvicorn configuration instance.\\n    * target - A callable that accepts a list of sockets. In practice this will\\n               be the `Server.run()` method.\\n    * sockets - A list of sockets to pass to the server. Sockets are bound once\\n                by the parent process, and then passed to the child processes.\\n    * stdin_fileno - The file number of sys.stdin, so that it can be reattached\\n                     to the child process.\\n    '\n    if stdin_fileno is not None:\n        sys.stdin = os.fdopen(stdin_fileno)\n    config.configure_logging()\n    try:\n        target(sockets=sockets)\n    except KeyboardInterrupt:\n        pass",
        "docstring": "Start a child process for the Uvicorn server.\n\nThis function is invoked when a child process begins execution. It re-establishes the standard input and configures logging for the child process before executing the provided target callable with the designated sockets.\n\nParameters:\n- config (Config): The Uvicorn configuration instance that governs logging and server settings.\n- target (Callable[..., None]): A callable, typically `Server.run`, that will be executed in the child process, receiving sockets as an argument.\n- sockets (list[socket]): A list of socket objects to be passed to the target for handling incoming connections.\n- stdin_fileno (int | None): The file descriptor for the standard input; if not None, it will be used to reattach stdin in the child process.\n\nReturn Value: None\n\nSide Effects: \n- Reattaches the standard input using `os.fdopen` if `stdin_fileno` is provided.\n- Configures logging specific to the child process by invoking `config.configure_logging()`.\n- Executes the target callable, allowing the child process to handle its respective sockets, and suppresses any `KeyboardInterrupt` exceptions to avoid traceback display.",
        "signature": "def subprocess_started(config: Config, target: Callable[..., None], sockets: list[socket], stdin_fileno: int | None) -> None:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "uvicorn/config.py:Config:__init__": {
      "uvicorn/config.py": {
        "Config.configure_logging": {
          "code": "    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, 'TRACE')\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config['formatters']['default']['use_colors'] = self.use_colors\n                    self.log_config['formatters']['access']['use_colors'] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith('.json'):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(('.yaml', '.yml')):\n                import yaml\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger('uvicorn.error').setLevel(log_level)\n            logging.getLogger('uvicorn.access').setLevel(log_level)\n            logging.getLogger('uvicorn.asgi').setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger('uvicorn.access').handlers = []\n            logging.getLogger('uvicorn.access').propagate = False",
          "docstring": "",
          "signature": "def configure_logging(self) -> None:",
          "type": "Method",
          "class_signature": "class Config:"
        },
        "Config.should_reload": {
          "code": "    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload",
          "docstring": "",
          "signature": "def should_reload(self) -> bool:",
          "type": "Method",
          "class_signature": "class Config:"
        }
      }
    },
    "uvicorn/config.py:Config:load": {
      "uvicorn/importer.py": {
        "import_from_string": {
          "code": "def import_from_string(import_str: Any) -> Any:\n    if not isinstance(import_str, str):\n        return import_str\n\n    module_str, _, attrs_str = import_str.partition(\":\")\n    if not module_str or not attrs_str:\n        message = 'Import string \"{import_str}\" must be in format \"<module>:<attribute>\".'\n        raise ImportFromStringError(message.format(import_str=import_str))\n\n    try:\n        module = importlib.import_module(module_str)\n    except ModuleNotFoundError as exc:\n        if exc.name != module_str:\n            raise exc from None\n        message = 'Could not import module \"{module_str}\".'\n        raise ImportFromStringError(message.format(module_str=module_str))\n\n    instance = module\n    try:\n        for attr_str in attrs_str.split(\".\"):\n            instance = getattr(instance, attr_str)\n    except AttributeError:\n        message = 'Attribute \"{attrs_str}\" not found in module \"{module_str}\".'\n        raise ImportFromStringError(message.format(attrs_str=attrs_str, module_str=module_str))\n\n    return instance",
          "docstring": "",
          "signature": "def import_from_string(import_str: Any) -> Any:",
          "type": "Function",
          "class_signature": null
        }
      },
      "uvicorn/config.py": {
        "Config.is_ssl": {
          "code": "    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)",
          "docstring": "",
          "signature": "def is_ssl(self) -> bool:",
          "type": "Method",
          "class_signature": "class Config:"
        }
      },
      "uvicorn/middleware/proxy_headers.py": {
        "ProxyHeadersMiddleware.__init__": {
          "code": "    def __init__(self, app: ASGI3Application, trusted_hosts: list[str] | str = \"127.0.0.1\") -> None:\n        self.app = app\n        self.trusted_hosts = _TrustedHosts(trusted_hosts)",
          "docstring": "",
          "signature": "def __init__(self, app: ASGI3Application, trusted_hosts: list[str] | str='127.0.0.1') -> None:",
          "type": "Method",
          "class_signature": "class ProxyHeadersMiddleware:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: uvicorn-test_subprocess\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 uvicorn/\n    \u251c\u2500\u2500 _subprocess.py\n    \u2502   \u251c\u2500\u2500 get_subprocess\n    \u2502   \u2514\u2500\u2500 subprocess_started\n    \u2514\u2500\u2500 config.py\n        \u251c\u2500\u2500 Config.__init__\n        \u2514\u2500\u2500 Config.load\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module facilitates the orchestration and management of subprocesses for an ASGI (Asynchronous Server Gateway Interface) server, primarily enabling the integration and execution of server-side applications in environments requiring spawned child processes. It provides functionality to initialize configurations, bind sockets, and manage subprocess lifecycles programmatically, ensuring seamless server execution. By abstracting away the complexities of process handling and socket communication, this module simplifies server deployment workflows for developers, streamlining the setup of robust and scalable web services.\n\n## FILE 1: uvicorn/config.py\n\n- CLASS METHOD: Config.load\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def load(self) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nLoads and prepares the configuration for the Uvicorn server. This method sets up the SSL context if SSL certificates are provided, encodes specified headers, and determines the HTTP and WebSocket protocol classes based on the configuration. It attempts to load the ASGI application from a specified string, handling potential factory patterns and inferring the interface type (ASGI 2 or ASGI 3). Additionally, it wraps the loaded application with the appropriate middleware based on the interface type and logging configuration. Finally, it marks the configuration as loaded to prevent re-initialization.\n\nDependencies include constants like `HTTP_PROTOCOLS`, `WS_PROTOCOLS`, and `LIFESPAN`, which map protocol types to their respective class paths. The method also utilizes the function `import_from_string` to dynamically load classes and mid-way checks to adaptively select middleware, which ensures correct operation in asynchronous environments.\n\nReturns: None, but affects the internal state of the instance by setting up various attributes related to the server configuration and application instance.\n\"\"\"\n```\n\n- CLASS METHOD: Config.__init__\n  - CLASS SIGNATURE: class Config:\n  - SIGNATURE: def __init__(self, app: ASGIApplication | Callable[..., Any] | str, host: str='127.0.0.1', port: int=8000, uds: str | None=None, fd: int | None=None, loop: LoopSetupType='auto', http: type[asyncio.Protocol] | HTTPProtocolType='auto', ws: type[asyncio.Protocol] | WSProtocolType='auto', ws_max_size: int=16 * 1024 * 1024, ws_max_queue: int=32, ws_ping_interval: float | None=20.0, ws_ping_timeout: float | None=20.0, ws_per_message_deflate: bool=True, lifespan: LifespanType='auto', env_file: str | os.PathLike[str] | None=None, log_config: dict[str, Any] | str | RawConfigParser | IO[Any] | None=LOGGING_CONFIG, log_level: str | int | None=None, access_log: bool=True, use_colors: bool | None=None, interface: InterfaceType='auto', reload: bool=False, reload_dirs: list[str] | str | None=None, reload_delay: float=0.25, reload_includes: list[str] | str | None=None, reload_excludes: list[str] | str | None=None, workers: int | None=None, proxy_headers: bool=True, server_header: bool=True, date_header: bool=True, forwarded_allow_ips: list[str] | str | None=None, root_path: str='', limit_concurrency: int | None=None, limit_max_requests: int | None=None, backlog: int=2048, timeout_keep_alive: int=5, timeout_notify: int=30, timeout_graceful_shutdown: int | None=None, callback_notify: Callable[..., Awaitable[None]] | None=None, ssl_keyfile: str | os.PathLike[str] | None=None, ssl_certfile: str | os.PathLike[str] | None=None, ssl_keyfile_password: str | None=None, ssl_version: int=SSL_PROTOCOL_VERSION, ssl_cert_reqs: int=ssl.CERT_NONE, ssl_ca_certs: str | None=None, ssl_ciphers: str='TLSv1', headers: list[tuple[str, str]] | None=None, factory: bool=False, h11_max_incomplete_event_size: int | None=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a Config object for a Uvicorn ASGI server, encapsulating various server configuration options. \n\nParameters:\n- app: ASGI application or callable entry point for the app.\n- host: IP address to bind to (default is \"127.0.0.1\").\n- port: Port to bind to (default is 8000).\n- uds: Unix domain socket (optional).\n- fd: Socket file descriptor (optional).\n- loop: Event loop setup method (default is \"auto\").\n- http: HTTP protocol type (default is \"auto\").\n- ws: WebSocket protocol type (default is \"auto\").\n- ws_max_size: Maximum size of a WebSocket message (default is 16 MiB).\n- ws_max_queue: Maximum size of WebSocket message queue (default is 32).\n- ws_ping_interval: Interval for pinging WebSocket clients (default is 20 seconds).\n- ws_ping_timeout: Timeout for WebSocket pings (default is 20 seconds).\n- ws_per_message_deflate: Enable per-message deflate for WebSocket (default is True).\n- lifespan: Lifespan management (default is \"auto\").\n- env_file: Path to environment file (optional).\n- log_config: Configuration for logging (default is predefined LOGGING_CONFIG).\n- log_level: Logging level (optional).\n- access_log: Enable access logging (default is True).\n- use_colors: Use colored logging output (default is None).\n- interface: Type of application interface (default is \"auto\").\n- reload: Enable auto-reloading of the server (default is False).\n- reload_dirs: Directories to watch for changes (optional).\n- reload_delay: Delay for reloads (default is 0.25 seconds).\n- reload_includes: Patterns for files to include in reload (optional).\n- reload_excludes: Patterns for files to exclude from reload (optional).\n- workers: Number of worker processes (default is 1).\n- proxy_headers: Enable proxy headers handling (default is True).\n- server_header: Include server header in responses (default is True).\n- date_header: Include date header in responses (default is True).\n- forwarded_allow_ips: Allowed IPs for forwarded headers (optional).\n- root_path: Root path for the application (default is empty).\n- limit_concurrency: Max concurrent requests (optional).\n- limit_max_requests: Max requests to serve before restarting workers (optional).\n- backlog: Max number of pending connections (default is 2048).\n- timeout_keep_alive: Keep-alive timeout (default is 5 seconds).\n- timeout_notify: Notify timeout (default is 30 seconds).\n- timeout_graceful_shutdown: Shutdown timeout (optional).\n- callback_notify: Callback function for NOTIFY events (optional).\n- ssl_keyfile: Path to SSL key file (optional).\n- ssl_certfile: Path to SSL certificate file (optional).\n- ssl_keyfile_password: Password for SSL key file (optional).\n- ssl_version: SSL protocol version (default is SSL_PROTOCOL_VERSION).\n- ssl_cert_reqs: SSL certificate requirements (default is ssl.CERT_NONE).\n- ssl_ca_certs: Path to CA certificate file (optional).\n- ssl_ciphers: Ciphers for SSL (default is \"TLSv1\").\n- headers: Custom headers for responses (optional).\n- factory: Indicates if the app is a factory (default is False).\n- h11_max_incomplete_event_size: Max size for incomplete HTTP/1.1 events (optional).\n\nSide effects:\nConfigures logging based on provided log_config and sets up reload functionality based on the given parameters. It also loads environment variables if an env_file is provided.\n\nConstants used:\n- LOGGING_CONFIG: A dictionary defined at the module level that provides the default configuration for logging.\n- SSL_PROTOCOL_VERSION: Defines the SSL protocol version to be used for secure connections, imported from the ssl module.\n\"\"\"\n```\n\n## FILE 2: uvicorn/_subprocess.py\n\n- FUNCTION NAME: get_subprocess\n  - SIGNATURE: def get_subprocess(config: Config, target: Callable[..., None], sockets: list[socket]) -> SpawnProcess:\n  - DOCSTRING: \n```python\n\"\"\"\nCreates and returns a new child process instance configured to run a specified target function with given sockets.\n\nParameters:\n- config (Config): The Uvicorn configuration instance used for logging and server setup.\n- target (Callable[..., None]): A callable that accepts a list of sockets, typically the `Server.run()` method.\n- sockets (list[socket]): A list of socket objects to be passed to the server; these are initialized in the parent process.\n\nReturns:\n- SpawnProcess: An object representing the child process, which is not yet started at this point.\n\nThis function utilizes the `spawn` context from the `multiprocessing` module to create a new process. It captures the standard input file descriptor to ensure it is reattached in the child process for debugging purposes. The `subprocess_started` function is invoked in the child process to set up the environment and execute the target function.\n\"\"\"\n```\n\n- FUNCTION NAME: subprocess_started\n  - SIGNATURE: def subprocess_started(config: Config, target: Callable[..., None], sockets: list[socket], stdin_fileno: int | None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nStart a child process for the Uvicorn server.\n\nThis function is invoked when a child process begins execution. It re-establishes the standard input and configures logging for the child process before executing the provided target callable with the designated sockets.\n\nParameters:\n- config (Config): The Uvicorn configuration instance that governs logging and server settings.\n- target (Callable[..., None]): A callable, typically `Server.run`, that will be executed in the child process, receiving sockets as an argument.\n- sockets (list[socket]): A list of socket objects to be passed to the target for handling incoming connections.\n- stdin_fileno (int | None): The file descriptor for the standard input; if not None, it will be used to reattach stdin in the child process.\n\nReturn Value: None\n\nSide Effects: \n- Reattaches the standard input using `os.fdopen` if `stdin_fileno` is provided.\n- Configures logging specific to the child process by invoking `config.configure_logging()`.\n- Executes the target callable, allowing the child process to handle its respective sockets, and suppresses any `KeyboardInterrupt` exceptions to avoid traceback display.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "uvicorn/config.py": "from __future__ import annotations\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport logging.config\nimport os\nimport socket\nimport ssl\nimport sys\nfrom configparser import RawConfigParser\nfrom pathlib import Path\nfrom typing import IO, Any, Awaitable, Callable, Literal\nimport click\nfrom uvicorn._types import ASGIApplication\nfrom uvicorn.importer import ImportFromStringError, import_from_string\nfrom uvicorn.logging import TRACE_LOG_LEVEL\nfrom uvicorn.middleware.asgi2 import ASGI2Middleware\nfrom uvicorn.middleware.message_logger import MessageLoggerMiddleware\nfrom uvicorn.middleware.proxy_headers import ProxyHeadersMiddleware\nfrom uvicorn.middleware.wsgi import WSGIMiddleware\nHTTPProtocolType = Literal['auto', 'h11', 'httptools']\nWSProtocolType = Literal['auto', 'none', 'websockets', 'wsproto']\nLifespanType = Literal['auto', 'on', 'off']\nLoopSetupType = Literal['none', 'auto', 'asyncio', 'uvloop']\nInterfaceType = Literal['auto', 'asgi3', 'asgi2', 'wsgi']\nLOG_LEVELS: dict[str, int] = {'critical': logging.CRITICAL, 'error': logging.ERROR, 'warning': logging.WARNING, 'info': logging.INFO, 'debug': logging.DEBUG, 'trace': TRACE_LOG_LEVEL}\nHTTP_PROTOCOLS: dict[HTTPProtocolType, str] = {'auto': 'uvicorn.protocols.http.auto:AutoHTTPProtocol', 'h11': 'uvicorn.protocols.http.h11_impl:H11Protocol', 'httptools': 'uvicorn.protocols.http.httptools_impl:HttpToolsProtocol'}\nWS_PROTOCOLS: dict[WSProtocolType, str | None] = {'auto': 'uvicorn.protocols.websockets.auto:AutoWebSocketsProtocol', 'none': None, 'websockets': 'uvicorn.protocols.websockets.websockets_impl:WebSocketProtocol', 'wsproto': 'uvicorn.protocols.websockets.wsproto_impl:WSProtocol'}\nLIFESPAN: dict[LifespanType, str] = {'auto': 'uvicorn.lifespan.on:LifespanOn', 'on': 'uvicorn.lifespan.on:LifespanOn', 'off': 'uvicorn.lifespan.off:LifespanOff'}\nLOOP_SETUPS: dict[LoopSetupType, str | None] = {'none': None, 'auto': 'uvicorn.loops.auto:auto_loop_setup', 'asyncio': 'uvicorn.loops.asyncio:asyncio_setup', 'uvloop': 'uvicorn.loops.uvloop:uvloop_setup'}\nINTERFACES: list[InterfaceType] = ['auto', 'asgi3', 'asgi2', 'wsgi']\nSSL_PROTOCOL_VERSION: int = ssl.PROTOCOL_TLS_SERVER\nLOGGING_CONFIG: dict[str, Any] = {'version': 1, 'disable_existing_loggers': False, 'formatters': {'default': {'()': 'uvicorn.logging.DefaultFormatter', 'fmt': '%(levelprefix)s %(message)s', 'use_colors': None}, 'access': {'()': 'uvicorn.logging.AccessFormatter', 'fmt': '%(levelprefix)s %(client_addr)s - \"%(request_line)s\" %(status_code)s'}}, 'handlers': {'default': {'formatter': 'default', 'class': 'logging.StreamHandler', 'stream': 'ext://sys.stderr'}, 'access': {'formatter': 'access', 'class': 'logging.StreamHandler', 'stream': 'ext://sys.stdout'}}, 'loggers': {'uvicorn': {'handlers': ['default'], 'level': 'INFO', 'propagate': False}, 'uvicorn.error': {'level': 'INFO'}, 'uvicorn.access': {'handlers': ['access'], 'level': 'INFO', 'propagate': False}}}\nlogger = logging.getLogger('uvicorn.error')\n\ndef create_ssl_context(certfile: str | os.PathLike[str], keyfile: str | os.PathLike[str] | None, password: str | None, ssl_version: int, cert_reqs: int, ca_certs: str | os.PathLike[str] | None, ciphers: str | None) -> ssl.SSLContext:\n    ctx = ssl.SSLContext(ssl_version)\n    get_password = (lambda: password) if password else None\n    ctx.load_cert_chain(certfile, keyfile, get_password)\n    ctx.verify_mode = ssl.VerifyMode(cert_reqs)\n    if ca_certs:\n        ctx.load_verify_locations(ca_certs)\n    if ciphers:\n        ctx.set_ciphers(ciphers)\n    return ctx\n\ndef is_dir(path: Path) -> bool:\n    try:\n        if not path.is_absolute():\n            path = path.resolve()\n        return path.is_dir()\n    except OSError:\n        return False\n\ndef resolve_reload_patterns(patterns_list: list[str], directories_list: list[str]) -> tuple[list[str], list[Path]]:\n    directories: list[Path] = list(set(map(Path, directories_list.copy())))\n    patterns: list[str] = patterns_list.copy()\n    current_working_directory = Path.cwd()\n    for pattern in patterns_list:\n        if pattern == '.*':\n            continue\n        patterns.append(pattern)\n        if is_dir(Path(pattern)):\n            directories.append(Path(pattern))\n        else:\n            for match in current_working_directory.glob(pattern):\n                if is_dir(match):\n                    directories.append(match)\n    directories = list(set(directories))\n    directories = list(map(Path, directories))\n    directories = list(map(lambda x: x.resolve(), directories))\n    directories = list({reload_path for reload_path in directories if is_dir(reload_path)})\n    children = []\n    for j in range(len(directories)):\n        for k in range(j + 1, len(directories)):\n            if directories[j] in directories[k].parents:\n                children.append(directories[k])\n            elif directories[k] in directories[j].parents:\n                children.append(directories[j])\n    directories = list(set(directories).difference(set(children)))\n    return (list(set(patterns)), directories)\n\ndef _normalize_dirs(dirs: list[str] | str | None) -> list[str]:\n    if dirs is None:\n        return []\n    if isinstance(dirs, str):\n        return [dirs]\n    return list(set(dirs))\n\nclass Config:\n\n    @property\n    def asgi_version(self) -> Literal['2.0', '3.0']:\n        mapping: dict[str, Literal['2.0', '3.0']] = {'asgi2': '2.0', 'asgi3': '3.0', 'wsgi': '3.0'}\n        return mapping[self.interface]\n\n    @property\n    def is_ssl(self) -> bool:\n        return bool(self.ssl_keyfile or self.ssl_certfile)\n\n    @property\n    def use_subprocess(self) -> bool:\n        return bool(self.reload or self.workers > 1)\n\n    def configure_logging(self) -> None:\n        logging.addLevelName(TRACE_LOG_LEVEL, 'TRACE')\n        if self.log_config is not None:\n            if isinstance(self.log_config, dict):\n                if self.use_colors in (True, False):\n                    self.log_config['formatters']['default']['use_colors'] = self.use_colors\n                    self.log_config['formatters']['access']['use_colors'] = self.use_colors\n                logging.config.dictConfig(self.log_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith('.json'):\n                with open(self.log_config) as file:\n                    loaded_config = json.load(file)\n                    logging.config.dictConfig(loaded_config)\n            elif isinstance(self.log_config, str) and self.log_config.endswith(('.yaml', '.yml')):\n                import yaml\n                with open(self.log_config) as file:\n                    loaded_config = yaml.safe_load(file)\n                    logging.config.dictConfig(loaded_config)\n            else:\n                logging.config.fileConfig(self.log_config, disable_existing_loggers=False)\n        if self.log_level is not None:\n            if isinstance(self.log_level, str):\n                log_level = LOG_LEVELS[self.log_level]\n            else:\n                log_level = self.log_level\n            logging.getLogger('uvicorn.error').setLevel(log_level)\n            logging.getLogger('uvicorn.access').setLevel(log_level)\n            logging.getLogger('uvicorn.asgi').setLevel(log_level)\n        if self.access_log is False:\n            logging.getLogger('uvicorn.access').handlers = []\n            logging.getLogger('uvicorn.access').propagate = False\n\n    def setup_event_loop(self) -> None:\n        loop_setup: Callable | None = import_from_string(LOOP_SETUPS[self.loop])\n        if loop_setup is not None:\n            loop_setup(use_subprocess=self.use_subprocess)\n\n    def bind_socket(self) -> socket.socket:\n        logger_args: list[str | int]\n        if self.uds:\n            path = self.uds\n            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n            try:\n                sock.bind(path)\n                uds_perms = 438\n                os.chmod(self.uds, uds_perms)\n            except OSError as exc:\n                logger.error(exc)\n                sys.exit(1)\n            message = 'Uvicorn running on unix socket %s (Press CTRL+C to quit)'\n            sock_name_format = '%s'\n            color_message = 'Uvicorn running on ' + click.style(sock_name_format, bold=True) + ' (Press CTRL+C to quit)'\n            logger_args = [self.uds]\n        elif self.fd:\n            sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n            message = 'Uvicorn running on socket %s (Press CTRL+C to quit)'\n            fd_name_format = '%s'\n            color_message = 'Uvicorn running on ' + click.style(fd_name_format, bold=True) + ' (Press CTRL+C to quit)'\n            logger_args = [sock.getsockname()]\n        else:\n            family = socket.AF_INET\n            addr_format = '%s://%s:%d'\n            if self.host and ':' in self.host:\n                family = socket.AF_INET6\n                addr_format = '%s://[%s]:%d'\n            sock = socket.socket(family=family)\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            try:\n                sock.bind((self.host, self.port))\n            except OSError as exc:\n                logger.error(exc)\n                sys.exit(1)\n            message = f'Uvicorn running on {addr_format} (Press CTRL+C to quit)'\n            color_message = 'Uvicorn running on ' + click.style(addr_format, bold=True) + ' (Press CTRL+C to quit)'\n            protocol_name = 'https' if self.is_ssl else 'http'\n            logger_args = [protocol_name, self.host, sock.getsockname()[1]]\n        logger.info(message, *logger_args, extra={'color_message': color_message})\n        sock.set_inheritable(True)\n        return sock\n\n    @property\n    def should_reload(self) -> bool:\n        return isinstance(self.app, str) and self.reload",
    "uvicorn/_subprocess.py": "\"\"\"\nSome light wrappers around Python's multiprocessing, to deal with cleanly\nstarting child processes.\n\"\"\"\nfrom __future__ import annotations\nimport multiprocessing\nimport os\nimport sys\nfrom multiprocessing.context import SpawnProcess\nfrom socket import socket\nfrom typing import Callable\nfrom uvicorn.config import Config\nmultiprocessing.allow_connection_pickling()\nspawn = multiprocessing.get_context('spawn')"
  },
  "call_tree": {
    "tests/test_subprocess.py:test_get_subprocess": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/config.py:Config:load": {
        "uvicorn/config.py:Config:is_ssl": {},
        "uvicorn/importer.py:import_from_string": {
          "uvicorn/protocols/http/flow_control.py:FlowControl:FlowControl": {},
          "uvicorn/protocols/utils.py:ClientDisconnected:ClientDisconnected": {},
          "uvicorn/protocols/http/h11_impl.py:_get_status_phrase": {},
          "uvicorn/protocols/http/h11_impl.py:H11Protocol:H11Protocol": {},
          "uvicorn/protocols/http/h11_impl.py:RequestResponseCycle:RequestResponseCycle": {},
          "uvicorn/lifespan/on.py:LifespanOn:LifespanOn": {}
        },
        "uvicorn/middleware/proxy_headers.py:ProxyHeadersMiddleware:__init__": {
          "uvicorn/middleware/proxy_headers.py:_TrustedHosts:__init__": {
            "uvicorn/middleware/proxy_headers.py:_parse_raw_hosts": {}
          }
        }
      },
      "uvicorn/_subprocess.py:get_subprocess": {}
    },
    "tests/test_subprocess.py:test_subprocess_started": {
      "uvicorn/config.py:Config:__init__": {
        "uvicorn/config.py:Config:configure_logging": {
          "uvicorn/logging.py:ColourizedFormatter:__init__": {}
        },
        "uvicorn/config.py:Config:should_reload": {}
      },
      "uvicorn/config.py:Config:load": {
        "uvicorn/config.py:Config:is_ssl": {},
        "uvicorn/importer.py:import_from_string": {},
        "uvicorn/middleware/proxy_headers.py:ProxyHeadersMiddleware:__init__": {
          "uvicorn/middleware/proxy_headers.py:_TrustedHosts:__init__": {
            "uvicorn/middleware/proxy_headers.py:_parse_raw_hosts": {}
          }
        }
      },
      "uvicorn/_subprocess.py:subprocess_started": {}
    }
  }
}