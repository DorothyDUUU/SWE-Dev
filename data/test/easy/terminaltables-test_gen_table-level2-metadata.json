{
  "dir_path": "/app/terminaltables",
  "package_name": "terminaltables",
  "sample_name": "terminaltables-test_gen_table",
  "src_dir": "terminaltables3/",
  "test_dir": "tests/",
  "test_file": "tests/test_base_table/test_gen_table.py",
  "test_code": "\"\"\"Test method in BaseTable class.\"\"\"\n\nimport pytest\n\nfrom terminaltables3.base_table import BaseTable\nfrom terminaltables3.build import flatten\nfrom terminaltables3.width_and_alignment import max_dimensions\n\n\n@pytest.mark.parametrize(\"inner_heading_row_border\", [True, False])\n@pytest.mark.parametrize(\"inner_footing_row_border\", [True, False])\n@pytest.mark.parametrize(\"inner_row_border\", [True, False])\ndef test_inner_row_borders(\n    inner_heading_row_border, inner_footing_row_border, inner_row_border\n):\n    \"\"\"Test heading/footing/row borders.\n\n    :param bool inner_heading_row_border: Passed to table.\n    :param bool inner_footing_row_border: Passed to table.\n    :param bool inner_row_border: Passed to table.\n    \"\"\"\n    table_data = [\n        [\"Name\", \"Color\", \"Type\"],\n        [\"Avocado\", \"green\", \"nut\"],\n        [\"Tomato\", \"red\", \"fruit\"],\n        [\"Lettuce\", \"green\", \"vegetable\"],\n    ]\n    table = BaseTable(table_data)\n    table.inner_heading_row_border = inner_heading_row_border\n    table.inner_footing_row_border = inner_footing_row_border\n    table.inner_row_border = inner_row_border\n    inner_widths, inner_heights, outer_widths = max_dimensions(\n        table_data, table.padding_left, table.padding_right\n    )[:3]\n    actual = flatten(table.gen_table(inner_widths, inner_heights, outer_widths))\n\n    # Determine expected.\n    if inner_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    elif inner_heading_row_border and inner_footing_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    elif inner_heading_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    elif inner_footing_row_border:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    else:\n        expected = (\n            \"+---------+-------+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"outer_border\", [True, False])\ndef test_outer_borders(outer_border):\n    \"\"\"Test left/right/top/bottom table borders.\n\n    :param bool outer_border: Passed to table.\n    \"\"\"\n    table_data = [\n        [\"Name\", \"Color\", \"Type\"],\n        [\"Avocado\", \"green\", \"nut\"],\n        [\"Tomato\", \"red\", \"fruit\"],\n        [\"Lettuce\", \"green\", \"vegetable\"],\n    ]\n    table = BaseTable(table_data, \"Example Table\")\n    table.outer_border = outer_border\n    inner_widths, inner_heights, outer_widths = max_dimensions(\n        table_data, table.padding_left, table.padding_right\n    )[:3]\n    actual = flatten(table.gen_table(inner_widths, inner_heights, outer_widths))\n\n    # Determine expected.\n    if outer_border:\n        expected = (\n            \"+Example Table----+-----------+\\n\"\n            \"| Name    | Color | Type      |\\n\"\n            \"+---------+-------+-----------+\\n\"\n            \"| Avocado | green | nut       |\\n\"\n            \"| Tomato  | red   | fruit     |\\n\"\n            \"| Lettuce | green | vegetable |\\n\"\n            \"+---------+-------+-----------+\"\n        )\n    else:\n        expected = (\n            \" Name    | Color | Type      \\n\"\n            \"---------+-------+-----------\\n\"\n            \" Avocado | green | nut       \\n\"\n            \" Tomato  | red   | fruit     \\n\"\n            \" Lettuce | green | vegetable \"\n        )\n\n    assert actual == expected\n\n\n@pytest.mark.parametrize(\"mode\", [\"row\", \"one\", \"blank\", \"empty\", \"none\"])\n@pytest.mark.parametrize(\"bare\", [False, True])\ndef test_one_no_rows(mode, bare):\n    \"\"\"Test with one or no rows.\n\n    :param str mode: Type of table contents to test.\n    :param bool bare: Disable padding/borders.\n    \"\"\"\n    if mode == \"row\":\n        table_data = [\n            [\"Avocado\", \"green\", \"nut\"],\n        ]\n    elif mode == \"one\":\n        table_data = [\n            [\"Avocado\"],\n        ]\n    elif mode == \"blank\":\n        table_data = [\n            [\"\"],\n        ]\n    elif mode == \"empty\":\n        table_data = [\n            [],\n        ]\n    else:\n        table_data = []\n    table = BaseTable(table_data)\n    if bare:\n        table.inner_column_border = False\n        table.inner_footing_row_border = False\n        table.inner_heading_row_border = False\n        table.inner_row_border = False\n        table.outer_border = False\n        table.padding_left = 0\n        table.padding_right = 0\n    inner_widths, inner_heights, outer_widths = max_dimensions(\n        table_data, table.padding_left, table.padding_right\n    )[:3]\n    actual = flatten(table.gen_table(inner_widths, inner_heights, outer_widths))\n\n    # Determine expected.\n    if mode == \"row\":\n        if bare:\n            expected = \"Avocadogreennut\"\n        else:\n            expected = (\n                \"+---------+-------+-----+\\n\"\n                \"| Avocado | green | nut |\\n\"\n                \"+---------+-------+-----+\"\n            )\n    elif mode == \"one\":\n        if bare:\n            expected = \"Avocado\"\n        else:\n            expected = \"+---------+\\n\" \"| Avocado |\\n\" \"+---------+\"\n    elif mode == \"blank\":  # Remember there's still padding.\n        if bare:\n            expected = \"\"\n        else:\n            expected = \"+--+\\n\" \"|  |\\n\" \"+--+\"\n    elif mode == \"empty\":\n        if bare:\n            expected = \"\"\n        else:\n            expected = \"++\\n\" \"||\\n\" \"++\"\n    else:\n        if bare:\n            expected = \"\"\n        else:\n            expected = \"++\\n\" \"++\"\n\n    assert actual == expected\n",
  "GT_file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\n\nfrom typing import Generator, Iterator, Optional, Sequence, Union\n\nfrom terminaltables3.width_and_alignment import visible_width\n\n\ndef combine(\n    line: Union[\n        Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]\n    ],\n    left: str,\n    intersect: Optional[str],\n    right: str,\n) -> Generator[int, None, None]:\n    \"\"\"Zip borders between items in `line`.\n\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\n\n    :param iter line: List to iterate.\n    :param left: Left border.\n    :param intersect: Column separator.\n    :param right: Right border.\n\n    :return: Yields combined objects.\n    \"\"\"\n    # Yield left border.\n    if left:\n        yield left\n\n    # Yield items with intersect characters.\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:  # Generator.\n            try:\n                item = next(line)\n            except StopIteration:  # Was empty all along.\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n\n        # Yield right border.\n    if right:\n        yield right\n\n\ndef build_border(\n    outer_widths: Sequence[int],\n    horizontal: str,\n    left: str,\n    intersect: str,\n    right: str,\n    title: Optional[str] = None,\n):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n\n    # Hide title if it doesn't fit.\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n\n    # Handle no title.\n    if title is None or not outer_widths or not horizontal:\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n\n    # Handle title fitting in the first column.\n    if length == outer_widths[0]:\n        return combine(\n            [title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right\n        )\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [\n            horizontal * c for c in outer_widths[1:]\n        ]\n        return combine(columns, left, intersect, right)\n\n    # Handle wide titles/narrow columns.\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        # If title is taken care of.\n        if length < 1:\n            columns_and_intersects.append(\n                intersect if width is True else horizontal * width\n            )\n        # If title's last character overrides an intersect character.\n        elif width is True and length == 1:\n            length = 0\n        # If this is an intersect character that is overridden by the title.\n        elif width is True:\n            length -= 1\n        # If title's last character is within a column.\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (\n                width - length\n            )  # Append horizontal chars to title.\n            length = 0\n        # If remainder of title won't fit in a column.\n        else:\n            length -= width\n\n    return combine(columns_and_intersects, left, None, right)\n\n\ndef build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single row of list of lists including borders.\n\n    Row must already be padded and extended so each cell has the same number of lines.\n\n    Example return value:\n    [\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\n    ]\n\n    :param iter row: List of cells for one row.\n    :param str left: Left border.\n    :param str center: Column separator.\n    :param str right: Right border.\n\n    :return: Yields other generators that yield strings.\n    :rtype: iter\n    \"\"\"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)\n\n\ndef flatten(table):\n    \"\"\"Flatten table data into a single string with newlines.\n\n    :param iter table: Padded and bordered table data.\n\n    :return: Joined rows/cells.\n    :rtype: str\n    \"\"\"\n    return \"\\n\".join(\"\".join(r) for r in table)\n",
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\n\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\n\nfrom terminaltables3.terminal_io import terminal_size\n\nRE_COLOR_ANSI = re.compile(r\"(\\033\\[[\\d;]+m)\")\n\n\ndef visible_width(string: str) -> int:\n    \"\"\"Get the visible width of a unicode string.\n\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\n\n    From: https://github.com/Robpol86/terminaltables3/pull/9\n\n    :param str string: String to measure.\n\n    :return: String's width.\n    :rtype: int\n    \"\"\"\n    if \"\\033\" in string:\n        string = RE_COLOR_ANSI.sub(\"\", string)\n\n    # Convert to unicode.\n    try:\n        string = string.decode(\"u8\")\n    except (AttributeError, UnicodeEncodeError):\n        pass\n\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in (\"F\", \"W\"):\n            width += 2\n        else:\n            width += 1\n\n    return width\n\n\ndef align_and_pad_cell(\n    string: str,\n    align: Tuple,\n    inner_dimensions: Tuple,\n    padding: Sequence[int],\n    space: str = \" \",\n) -> List[str]:\n    \"\"\"Align a string horizontally and vertically. Also add additional padding in both dimensions.\n\n    :param str string: Input string to operate on.\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\n\n    :return: Padded cell split into lines.\n    :rtype: list\n    \"\"\"\n    if not hasattr(string, \"splitlines\"):\n        string = str(string)\n\n    # Handle trailing newlines or empty strings, str.splitlines() does not satisfy.\n    lines = string.splitlines() or [\"\"]\n    if string.endswith(\"\\n\"):\n        lines.append(\"\")\n\n    # Vertically align and pad.\n    if \"bottom\" in align:\n        lines = (\n            ([\"\"] * (inner_dimensions[1] - len(lines) + padding[2]))\n            + lines\n            + ([\"\"] * padding[3])\n        )\n    elif \"middle\" in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = (\n            ([\"\"] * (delta // 2 + delta % 2 + padding[2]))\n            + lines\n            + ([\"\"] * (delta // 2 + padding[3]))\n        )\n    else:\n        lines = (\n            ([\"\"] * padding[2])\n            + lines\n            + ([\"\"] * (inner_dimensions[1] - len(lines) + padding[3]))\n        )\n\n    # Horizontally align and pad.\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if \"right\" in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + (space * padding[1])\n        elif \"center\" in align:\n            lines[i] = (\n                (space * padding[0])\n                + line.center(new_width, space)\n                + (space * padding[1])\n            )\n        else:\n            lines[i] = (space * padding[0]) + line.ljust(new_width + padding[1], space)\n\n    return lines\n\n\ndef max_dimensions(\n    table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0\n):\n    \"\"\"Get maximum widths of each column and maximum height of each row.\n\n    :param iter table_data: List of list of strings (unmodified table data).\n    :param int padding_left: Number of space chars on left side of cell.\n    :param int padding_right: Number of space chars on right side of cell.\n    :param int padding_top: Number of empty lines on top side of cell.\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\n\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\n    :rtype: tuple\n    \"\"\"\n    inner_widths = [0] * (max(len(r) for r in table_data) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n\n    # Find max width and heights.\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, \"count\") or not hasattr(cell, \"splitlines\"):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count(\"\\n\") + 1)\n            inner_widths[i] = max(\n                inner_widths[i],\n                *[visible_width(the_line) for the_line in cell.splitlines()],\n            )\n\n    # Calculate with padding.\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n\n    return inner_widths, inner_heights, outer_widths, outer_heights\n\n\ndef column_max_width(\n    inner_widths: Sequence[int],\n    column_number: int,\n    outer_border: int,\n    inner_border: int,\n    padding: int,\n) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n\n    # Count how much space padding, outer, and inner borders take up.\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n\n    # Exclude selected column's width.\n    data_space = sum(inner_widths) - inner_widths[column_number]\n\n    return terminal_width - data_space - non_data_space\n\n\ndef table_width(\n    outer_widths: Sequence[int], outer_border: int, inner_border: int\n) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n\n    # Count how much space outer and inner borders take up.\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n\n    # Space of all columns and their padding.\n    data_space = sum(outer_widths)\n    return data_space + non_data_space\n",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\n\nfrom typing import Generator, Optional, Sequence, Tuple\n\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n\n    CHAR_F_INNER_HORIZONTAL = \"-\"\n    CHAR_F_INNER_INTERSECT = \"+\"\n    CHAR_F_INNER_VERTICAL = \"|\"\n    CHAR_F_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_F_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_F_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_F_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_H_INNER_HORIZONTAL = \"-\"\n    CHAR_H_INNER_INTERSECT = \"+\"\n    CHAR_H_INNER_VERTICAL = \"|\"\n    CHAR_H_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_H_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_H_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_H_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_INNER_HORIZONTAL = \"-\"\n    CHAR_INNER_INTERSECT = \"+\"\n    CHAR_INNER_VERTICAL = \"|\"\n    CHAR_OUTER_BOTTOM_HORIZONTAL = \"-\"\n    CHAR_OUTER_BOTTOM_INTERSECT = \"+\"\n    CHAR_OUTER_BOTTOM_LEFT = \"+\"\n    CHAR_OUTER_BOTTOM_RIGHT = \"+\"\n    CHAR_OUTER_LEFT_INTERSECT = \"+\"\n    CHAR_OUTER_LEFT_VERTICAL = \"|\"\n    CHAR_OUTER_RIGHT_INTERSECT = \"+\"\n    CHAR_OUTER_RIGHT_VERTICAL = \"|\"\n    CHAR_OUTER_TOP_HORIZONTAL = \"-\"\n    CHAR_OUTER_TOP_INTERSECT = \"+\"\n    CHAR_OUTER_TOP_LEFT = \"+\"\n    CHAR_OUTER_TOP_RIGHT = \"+\"\n\n    def __init__(\n        self, table_data: Sequence[Sequence[str]], title: Optional[str] = None\n    ):\n        \"\"\"Constructor.\n\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\n        :param title: Optional title to show within the top border of the table.\n        \"\"\"\n        self.table_data = table_data\n        self.title = title\n\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n\n        self.justify_columns = {}  # {0: 'right', 1: 'left', 2: 'center'}\n        self.padding_left = 1\n        self.padding_right = 1\n\n    def horizontal_border(\n        self, style: str, outer_widths: Sequence[int]\n    ) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == \"top\":\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = (\n                self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == \"bottom\":\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = (\n                self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else \"\"\n            )\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == \"heading\":\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        elif style == \"footing\":\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else \"\"\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else \"\"\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_row_lines(\n        self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int\n    ) -> Generator[Tuple[str, ...], None, None]:\n        r\"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n\n        # Resize row if it doesn't have enough cells.\n        if len(row) != len(inner_widths):\n            row = row + [\"\"] * (len(inner_widths) - len(row))\n\n        # Pad and align each cell. Split each cell into lines to support multi-line cells.\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(\n                align_and_pad_cell(cell, align, inner_dimensions, padding)\n            )\n\n        # Determine border characters.\n        if style == \"heading\":\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        elif style == \"footing\":\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else \"\"\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else \"\"\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else \"\"\n\n        # Yield each line.\n        yield from build_row(cells_in_row, left, center, right)\n\n    def gen_table(\n        self,\n        inner_widths: Sequence[int],\n        inner_heights: Sequence[int],\n        outer_widths: Sequence[int],\n    ) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine everything and yield every line of the entire table with borders.\n\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param iter inner_heights: List of heights (no padding) for each row.\n        :param iter outer_widths: List of widths (with padding) for each column.\n        :return:\n        \"\"\"\n        # Yield top border.\n        if self.outer_border:\n            yield self.horizontal_border(\"top\", outer_widths)\n\n        # Yield table body.\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = row_count - 1, row_count - 2\n        for i, row in enumerate(self.table_data):\n            # Yield the row line by line (e.g. multi-line rows).\n            if self.inner_heading_row_border and i == 0:\n                style = \"heading\"\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = \"footing\"\n            else:\n                style = \"row\"\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            # If this is the last row then break. No separator needed.\n            if i == last_row_index:\n                break\n            # Yield heading separator.\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border(\"heading\", outer_widths)\n            # Yield footing separator.\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border(\"footing\", outer_widths)\n            # Yield row separator.\n            elif self.inner_row_border:\n                yield self.horizontal_border(\"row\", outer_widths)\n\n        # Yield bottom border.\n        if self.outer_border:\n            yield self.horizontal_border(\"bottom\", outer_widths)\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(\n            self.table_data, self.padding_left, self.padding_right\n        )[:3]\n        return flatten(self.gen_table(*dimensions))\n"
  },
  "GT_src_dict": {
    "terminaltables3/build.py": {
      "combine": {
        "code": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n    \"\"\"Combine items in a sequence into a single string with specified borders and separators, primarily for formatting tables.\n\n:param Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]] line: A sequence of items to be combined, which can be a generator or an iterator. \n:param str left: The string to be placed at the beginning of the combined output (left border).\n:param Optional[str] intersect: A separator string to be placed between items in the sequence if multiple items are yielded.\n:param str right: The string to be placed at the end of the combined output (right border).\n\n:return: A generator yielding the combined items in the specified format.\n\nThe function is designed to format table rows by combining cell contents with specified borders and column separators, making it useful in conjunction with other functions that manage table layouts, such as `build_border` and `build_row`. It handles different types of input sequences and gracefully manages cases where the input is empty.\"\"\"\n    \"Zip borders between items in `line`.\\n\\n    e.g. ('l', '1', 'c', '2', 'c', '3', 'r')\\n\\n    :param iter line: List to iterate.\\n    :param left: Left border.\\n    :param intersect: Column separator.\\n    :param right: Right border.\\n\\n    :return: Yields combined objects.\\n    \"\n    if left:\n        yield left\n    if intersect:\n        try:\n            for j, i in enumerate(line, start=-len(line) + 1):\n                yield i\n                if j:\n                    yield intersect\n        except TypeError:\n            try:\n                item = next(line)\n            except StopIteration:\n                pass\n            else:\n                while True:\n                    yield item\n                    try:\n                        peek = next(line)\n                    except StopIteration:\n                        break\n                    yield intersect\n                    item = peek\n    else:\n        yield from line\n    if right:\n        yield right",
        "docstring": "Combine items in a sequence into a single string with specified borders and separators, primarily for formatting tables.\n\n:param Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]] line: A sequence of items to be combined, which can be a generator or an iterator. \n:param str left: The string to be placed at the beginning of the combined output (left border).\n:param Optional[str] intersect: A separator string to be placed between items in the sequence if multiple items are yielded.\n:param str right: The string to be placed at the end of the combined output (right border).\n\n:return: A generator yielding the combined items in the specified format.\n\nThe function is designed to format table rows by combining cell contents with specified borders and column separators, making it useful in conjunction with other functions that manage table layouts, such as `build_border` and `build_row`. It handles different types of input sequences and gracefully manages cases where the input is empty.",
        "signature": "def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:",
        "type": "Function",
        "class_signature": null
      },
      "flatten": {
        "code": "def flatten(table):\n    \"\"\"Flatten a table data structure into a single string, with each row separated by a newline character.\n\n:param iter table: A padded and bordered table data, represented as an iterable of rows, where each row is a list of strings.\n\n:return: A single string that concatenates all the rows and cells of the table, separated by newlines.\n:rtype: str\n\nThis function utilizes nested joins to construct the final string representation of the table, relying on the layout provided by previous functions in the code, such as `build_row` and `combine`, which handle the construction of the individual rows and cell combinations.\"\"\"\n    'Flatten table data into a single string with newlines.\\n\\n    :param iter table: Padded and bordered table data.\\n\\n    :return: Joined rows/cells.\\n    :rtype: str\\n    '\n    return '\\n'.join((''.join(r) for r in table))",
        "docstring": "Flatten a table data structure into a single string, with each row separated by a newline character.\n\n:param iter table: A padded and bordered table data, represented as an iterable of rows, where each row is a list of strings.\n\n:return: A single string that concatenates all the rows and cells of the table, separated by newlines.\n:rtype: str\n\nThis function utilizes nested joins to construct the final string representation of the table, relying on the layout provided by previous functions in the code, such as `build_row` and `combine`, which handle the construction of the individual rows and cell combinations.",
        "signature": "def flatten(table):",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/width_and_alignment.py": {
      "visible_width": {
        "code": "def visible_width(string: str) -> int:\n    \"\"\"Calculate the visible width of a Unicode string, accounting for varying widths of characters, including CJK characters that may occupy more space than ASCII characters. \n\n:param str string: The input string whose visible width is to be measured. This string may contain ANSI color codes, which will be stripped before calculation.\n:return: The number of visible characters in the string, accounting for multi-byte characters.\n:rtype: int\n\nThe function utilizes the `RE_COLOR_ANSI` regular expression, defined globally, to identify and remove ANSI color codes from the input string. It leverages `unicodedata.east_asian_width` to determine the width of individual characters, categorizing them as wide or narrow. The resulting width is used to accommodate proper text alignment in terminal-based applications.\"\"\"\n    \"Get the visible width of a unicode string.\\n\\n    Some CJK unicode characters are more than one byte unlike ASCII and latin unicode characters.\\n\\n    From: https://github.com/Robpol86/terminaltables3/pull/9\\n\\n    :param str string: String to measure.\\n\\n    :return: String's width.\\n    :rtype: int\\n    \"\n    if '\\x1b' in string:\n        string = RE_COLOR_ANSI.sub('', string)\n    try:\n        string = string.decode('u8')\n    except (AttributeError, UnicodeEncodeError):\n        pass\n    width = 0\n    for char in string:\n        if unicodedata.east_asian_width(char) in ('F', 'W'):\n            width += 2\n        else:\n            width += 1\n    return width",
        "docstring": "Calculate the visible width of a Unicode string, accounting for varying widths of characters, including CJK characters that may occupy more space than ASCII characters. \n\n:param str string: The input string whose visible width is to be measured. This string may contain ANSI color codes, which will be stripped before calculation.\n:return: The number of visible characters in the string, accounting for multi-byte characters.\n:rtype: int\n\nThe function utilizes the `RE_COLOR_ANSI` regular expression, defined globally, to identify and remove ANSI color codes from the input string. It leverages `unicodedata.east_asian_width` to determine the width of individual characters, categorizing them as wide or narrow. The resulting width is used to accommodate proper text alignment in terminal-based applications.",
        "signature": "def visible_width(string: str) -> int:",
        "type": "Function",
        "class_signature": null
      },
      "max_dimensions": {
        "code": "def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):\n    \"\"\"Get the maximum widths of each column and heights of each row in a table, considering specified padding.\n\n:param iter table_data: A list of lists containing strings representing the unmodified table data.\n:param int padding_left: The number of space characters to add to the left side of each cell.\n:param int padding_right: The number of space characters to add to the right side of each cell.\n:param int padding_top: The number of empty lines to add above each cell.\n:param int padding_bottom: The number of empty lines to add below each cell.\n\n:return: A tuple containing four lists: the maximum inner widths of each column, the maximum heights of each row, and their respective outer widths and heights after applying padding.\n:rtype: tuple\n\nThe function uses the `visible_width` helper function to account for varying widths of Unicode characters. It determines inner dimensions based on the longest string within each column and the highest string in each row, and then computes outer dimensions by adding the provided padding values.\"\"\"\n    'Get maximum widths of each column and maximum height of each row.\\n\\n    :param iter table_data: List of list of strings (unmodified table data).\\n    :param int padding_left: Number of space chars on left side of cell.\\n    :param int padding_right: Number of space chars on right side of cell.\\n    :param int padding_top: Number of empty lines on top side of cell.\\n    :param int padding_bottom: Number of empty lines on bottom side of cell.\\n\\n    :return: 4-item tuple of n-item lists. Inner column widths and row heights, outer column widths and row heights.\\n    :rtype: tuple\\n    '\n    inner_widths = [0] * (max((len(r) for r in table_data)) if table_data else 0)\n    inner_heights = [0] * len(table_data)\n    for j, row in enumerate(table_data):\n        for i, cell in enumerate(row):\n            if not hasattr(cell, 'count') or not hasattr(cell, 'splitlines'):\n                cell = str(cell)\n            if not cell:\n                continue\n            inner_heights[j] = max(inner_heights[j], cell.count('\\n') + 1)\n            inner_widths[i] = max(inner_widths[i], *[visible_width(the_line) for the_line in cell.splitlines()])\n    outer_widths = [padding_left + i + padding_right for i in inner_widths]\n    outer_heights = [padding_top + i + padding_bottom for i in inner_heights]\n    return (inner_widths, inner_heights, outer_widths, outer_heights)",
        "docstring": "Get the maximum widths of each column and heights of each row in a table, considering specified padding.\n\n:param iter table_data: A list of lists containing strings representing the unmodified table data.\n:param int padding_left: The number of space characters to add to the left side of each cell.\n:param int padding_right: The number of space characters to add to the right side of each cell.\n:param int padding_top: The number of empty lines to add above each cell.\n:param int padding_bottom: The number of empty lines to add below each cell.\n\n:return: A tuple containing four lists: the maximum inner widths of each column, the maximum heights of each row, and their respective outer widths and heights after applying padding.\n:rtype: tuple\n\nThe function uses the `visible_width` helper function to account for varying widths of Unicode characters. It determines inner dimensions based on the longest string within each column and the highest string in each row, and then computes outer dimensions by adding the provided padding values.",
        "signature": "def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):",
        "type": "Function",
        "class_signature": null
      }
    },
    "terminaltables3/base_table.py": {
      "BaseTable.__init__": {
        "code": "    def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n        \"\"\"Initialize a BaseTable instance with optional title and table data.\n\n    This constructor sets up the table's structural properties including borders, padding, \n    and column justification. The `table_data` parameter is a sequence of sequences, where each \n    inner sequence represents a row of the table containing strings. The `title` parameter, \n    if provided, will be displayed at the top of the table.\n\n    Attributes:\n        table_data (Sequence[Sequence[str]]): List representing the table's content, can be empty.\n        title (Optional[str]): Title displayed within the top border.\n        inner_column_border (bool): Indicates if there are vertical borders between columns (default: True).\n        inner_footing_row_border (bool): Indicates if a border appears above the last row (default: False).\n        inner_heading_row_border (bool): Indicates if a border appears below the first row (default: True).\n        inner_row_border (bool): Indicates if borders appear between every row (default: False).\n        outer_border (bool): Indicates if the outer border is displayed (default: True).\n        justify_columns (dict): Maps column indices to justification types (e.g., 'left', 'right', 'center').\n        padding_left (int): Number of spaces to pad on the left side of every cell (default: 1).\n        padding_right (int): Number of spaces to pad on the right side of every cell (default: 1).\n\n    No return value.\"\"\"\n        'Constructor.\\n\\n        :param iter table_data: List (empty or list of lists of strings) representing the table.\\n        :param title: Optional title to show within the top border of the table.\\n        '\n        self.table_data = table_data\n        self.title = title\n        self.inner_column_border = True\n        self.inner_footing_row_border = False\n        self.inner_heading_row_border = True\n        self.inner_row_border = False\n        self.outer_border = True\n        self.justify_columns = {}\n        self.padding_left = 1\n        self.padding_right = 1",
        "docstring": "Initialize a BaseTable instance with optional title and table data.\n\nThis constructor sets up the table's structural properties including borders, padding, \nand column justification. The `table_data` parameter is a sequence of sequences, where each \ninner sequence represents a row of the table containing strings. The `title` parameter, \nif provided, will be displayed at the top of the table.\n\nAttributes:\n    table_data (Sequence[Sequence[str]]): List representing the table's content, can be empty.\n    title (Optional[str]): Title displayed within the top border.\n    inner_column_border (bool): Indicates if there are vertical borders between columns (default: True).\n    inner_footing_row_border (bool): Indicates if a border appears above the last row (default: False).\n    inner_heading_row_border (bool): Indicates if a border appears below the first row (default: True).\n    inner_row_border (bool): Indicates if borders appear between every row (default: False).\n    outer_border (bool): Indicates if the outer border is displayed (default: True).\n    justify_columns (dict): Maps column indices to justification types (e.g., 'left', 'right', 'center').\n    padding_left (int): Number of spaces to pad on the left side of every cell (default: 1).\n    padding_right (int): Number of spaces to pad on the right side of every cell (default: 1).\n\nNo return value.",
        "signature": "def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):",
        "type": "Method",
        "class_signature": "class BaseTable:"
      },
      "BaseTable.gen_table": {
        "code": "    def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine all elements to generate the entire table as a sequence of strings, including borders and cell data.\n\n        This method iterates through the table's data to yield formatted lines for each row. Based on the configuration\n        of the class, it adds borders around the table and between rows. The parameters define the widths and heights of the\n        columns and rows, ensuring proper alignment and padding. It relies on helper methods like horizontal_border and \n        gen_row_lines for structure and formatting.\n\n        :param inner_widths: A sequence of integers representing the widths (without padding) for each column.\n        :param inner_heights: A sequence of integers indicating the heights (without padding) for each row.\n        :param outer_widths: A sequence of integers for the widths (with padding) for each column, used in building borders.\n        :yield: Yields tuples of strings, each representing a line of the table, ready to be printed.\"\"\"\n        'Combine everything and yield every line of the entire table with borders.\\n\\n        :param iter inner_widths: List of widths (no padding) for each column.\\n        :param iter inner_heights: List of heights (no padding) for each row.\\n        :param iter outer_widths: List of widths (with padding) for each column.\\n        :return:\\n        '\n        if self.outer_border:\n            yield self.horizontal_border('top', outer_widths)\n        row_count = len(self.table_data)\n        last_row_index, before_last_row_index = (row_count - 1, row_count - 2)\n        for i, row in enumerate(self.table_data):\n            if self.inner_heading_row_border and i == 0:\n                style = 'heading'\n            elif self.inner_footing_row_border and i == last_row_index:\n                style = 'footing'\n            else:\n                style = 'row'\n            yield from self.gen_row_lines(row, style, inner_widths, inner_heights[i])\n            if i == last_row_index:\n                break\n            if self.inner_heading_row_border and i == 0:\n                yield self.horizontal_border('heading', outer_widths)\n            elif self.inner_footing_row_border and i == before_last_row_index:\n                yield self.horizontal_border('footing', outer_widths)\n            elif self.inner_row_border:\n                yield self.horizontal_border('row', outer_widths)\n        if self.outer_border:\n            yield self.horizontal_border('bottom', outer_widths)",
        "docstring": "Combine all elements to generate the entire table as a sequence of strings, including borders and cell data.\n\nThis method iterates through the table's data to yield formatted lines for each row. Based on the configuration\nof the class, it adds borders around the table and between rows. The parameters define the widths and heights of the\ncolumns and rows, ensuring proper alignment and padding. It relies on helper methods like horizontal_border and \ngen_row_lines for structure and formatting.\n\n:param inner_widths: A sequence of integers representing the widths (without padding) for each column.\n:param inner_heights: A sequence of integers indicating the heights (without padding) for each row.\n:param outer_widths: A sequence of integers for the widths (with padding) for each column, used in building borders.\n:yield: Yields tuples of strings, each representing a line of the table, ready to be printed.",
        "signature": "def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:",
        "type": "Method",
        "class_signature": "class BaseTable:"
      }
    }
  },
  "dependency_dict": {
    "terminaltables3/width_and_alignment.py:max_dimensions": {},
    "terminaltables3/width_and_alignment.py:visible_width": {},
    "terminaltables3/build.py:flatten": {},
    "terminaltables3/base_table.py:BaseTable:gen_table": {
      "terminaltables3/base_table.py": {
        "BaseTable.horizontal_border": {
          "code": "    def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == 'top':\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == 'bottom':\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == 'heading':\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        elif style == 'footing':\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)",
          "docstring": "Build any kind of horizontal border for the table.\n\n:param str style: Type of border to return.\n:param iter outer_widths: List of widths (with padding) for each column.\n\n:return: Prepared border as a tuple of strings.\n:rtype: tuple",
          "signature": "def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:",
          "type": "Method",
          "class_signature": "class BaseTable:"
        },
        "BaseTable.gen_row_lines": {
          "code": "    def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n        if len(row) != len(inner_widths):\n            row = row + [''] * (len(inner_widths) - len(row))\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(align_and_pad_cell(cell, align, inner_dimensions, padding))\n        if style == 'heading':\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        elif style == 'footing':\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        yield from build_row(cells_in_row, left, center, right)",
          "docstring": "Combine cells in row and group them into lines with vertical borders.\n\nCaller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\nnewline character to the end of joined line.\n\nIn:\n['Row One Column One', 'Two', 'Three']\nOut:\n[\n    ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n]\n\nIn:\n['Row One\\nColumn One', 'Two', 'Three'],\nOut:\n[\n    ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n    ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n]\n\n:param iter row: One row in the table. List of cells.\n:param str style: Type of border characters to use.\n:param iter inner_widths: List of widths (no padding) for each column.\n:param int height: Inner height (no padding) (number of lines) to expand row to.\n\n:return: Yields lines split into components in a list. Caller must ''.join() line.",
          "signature": "def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:",
          "type": "Method",
          "class_signature": "class BaseTable:"
        }
      }
    },
    "terminaltables3/build.py:combine": {}
  },
  "PRD": "# PROJECT NAME: terminaltables-test_gen_table\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 terminaltables3/\n    \u251c\u2500\u2500 base_table.py\n    \u2502   \u251c\u2500\u2500 BaseTable.__init__\n    \u2502   \u2514\u2500\u2500 BaseTable.gen_table\n    \u251c\u2500\u2500 build.py\n    \u2502   \u251c\u2500\u2500 combine\n    \u2502   \u2514\u2500\u2500 flatten\n    \u2514\u2500\u2500 width_and_alignment.py\n        \u251c\u2500\u2500 max_dimensions\n        \u2514\u2500\u2500 visible_width\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module facilitates the creation, configuration, and rendering of text-based tables for terminal output. It provides functionality to define table data, control the presence and styling of inner and outer borders, and adjust padding and alignment to produce visually distinct and customizable tabular displays. With configurable options such as row borders, heading/footing styles, and flexible data formats, the module addresses the need for clear and precise text representations of organized data in terminal environments. It simplifies the process for developers to render well-structured tables, enhancing readability and user experience in command-line applications.\n\n## FILE 1: terminaltables3/build.py\n\n- FUNCTION NAME: combine\n  - SIGNATURE: def combine(line: Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]]], left: str, intersect: Optional[str], right: str) -> Generator[int, None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine items in a sequence into a single string with specified borders and separators, primarily for formatting tables.\n\n:param Union[Generator[Union[int, str], None, None], Iterator[Optional[Union[int, str]]] line: A sequence of items to be combined, which can be a generator or an iterator. \n:param str left: The string to be placed at the beginning of the combined output (left border).\n:param Optional[str] intersect: A separator string to be placed between items in the sequence if multiple items are yielded.\n:param str right: The string to be placed at the end of the combined output (right border).\n\n:return: A generator yielding the combined items in the specified format.\n\nThe function is designed to format table rows by combining cell contents with specified borders and column separators, making it useful in conjunction with other functions that manage table layouts, such as `build_border` and `build_row`. It handles different types of input sequences and gracefully manages cases where the input is empty.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/build.py:flatten\n\n- FUNCTION NAME: flatten\n  - SIGNATURE: def flatten(table):\n  - DOCSTRING: \n```python\n\"\"\"\nFlatten a table data structure into a single string, with each row separated by a newline character.\n\n:param iter table: A padded and bordered table data, represented as an iterable of rows, where each row is a list of strings.\n\n:return: A single string that concatenates all the rows and cells of the table, separated by newlines.\n:rtype: str\n\nThis function utilizes nested joins to construct the final string representation of the table, relying on the layout provided by previous functions in the code, such as `build_row` and `combine`, which handle the construction of the individual rows and cell combinations.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/base_table.py:BaseTable:gen_table\n    - terminaltables3/build.py:combine\n\n## FILE 2: terminaltables3/width_and_alignment.py\n\n- FUNCTION NAME: max_dimensions\n  - SIGNATURE: def max_dimensions(table_data, padding_left=0, padding_right=0, padding_top=0, padding_bottom=0):\n  - DOCSTRING: \n```python\n\"\"\"\nGet the maximum widths of each column and heights of each row in a table, considering specified padding.\n\n:param iter table_data: A list of lists containing strings representing the unmodified table data.\n:param int padding_left: The number of space characters to add to the left side of each cell.\n:param int padding_right: The number of space characters to add to the right side of each cell.\n:param int padding_top: The number of empty lines to add above each cell.\n:param int padding_bottom: The number of empty lines to add below each cell.\n\n:return: A tuple containing four lists: the maximum inner widths of each column, the maximum heights of each row, and their respective outer widths and heights after applying padding.\n:rtype: tuple\n\nThe function uses the `visible_width` helper function to account for varying widths of Unicode characters. It determines inner dimensions based on the longest string within each column and the highest string in each row, and then computes outer dimensions by adding the provided padding values.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:visible_width\n\n- FUNCTION NAME: visible_width\n  - SIGNATURE: def visible_width(string: str) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate the visible width of a Unicode string, accounting for varying widths of characters, including CJK characters that may occupy more space than ASCII characters. \n\n:param str string: The input string whose visible width is to be measured. This string may contain ANSI color codes, which will be stripped before calculation.\n:return: The number of visible characters in the string, accounting for multi-byte characters.\n:rtype: int\n\nThe function utilizes the `RE_COLOR_ANSI` regular expression, defined globally, to identify and remove ANSI color codes from the input string. It leverages `unicodedata.east_asian_width` to determine the width of individual characters, categorizing them as wide or narrow. The resulting width is used to accommodate proper text alignment in terminal-based applications.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - terminaltables3/width_and_alignment.py:max_dimensions\n\n## FILE 3: terminaltables3/base_table.py\n\n- CLASS METHOD: BaseTable.__init__\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def __init__(self, table_data: Sequence[Sequence[str]], title: Optional[str]=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a BaseTable instance with optional title and table data.\n\nThis constructor sets up the table's structural properties including borders, padding, \nand column justification. The `table_data` parameter is a sequence of sequences, where each \ninner sequence represents a row of the table containing strings. The `title` parameter, \nif provided, will be displayed at the top of the table.\n\nAttributes:\n    table_data (Sequence[Sequence[str]]): List representing the table's content, can be empty.\n    title (Optional[str]): Title displayed within the top border.\n    inner_column_border (bool): Indicates if there are vertical borders between columns (default: True).\n    inner_footing_row_border (bool): Indicates if a border appears above the last row (default: False).\n    inner_heading_row_border (bool): Indicates if a border appears below the first row (default: True).\n    inner_row_border (bool): Indicates if borders appear between every row (default: False).\n    outer_border (bool): Indicates if the outer border is displayed (default: True).\n    justify_columns (dict): Maps column indices to justification types (e.g., 'left', 'right', 'center').\n    padding_left (int): Number of spaces to pad on the left side of every cell (default: 1).\n    padding_right (int): Number of spaces to pad on the right side of every cell (default: 1).\n\nNo return value.\n\"\"\"\n```\n\n- CLASS METHOD: BaseTable.gen_table\n  - CLASS SIGNATURE: class BaseTable:\n  - SIGNATURE: def gen_table(self, inner_widths: Sequence[int], inner_heights: Sequence[int], outer_widths: Sequence[int]) -> Generator[Tuple[str, ...], None, None]:\n  - DOCSTRING: \n```python\n\"\"\"\nCombine all elements to generate the entire table as a sequence of strings, including borders and cell data.\n\nThis method iterates through the table's data to yield formatted lines for each row. Based on the configuration\nof the class, it adds borders around the table and between rows. The parameters define the widths and heights of the\ncolumns and rows, ensuring proper alignment and padding. It relies on helper methods like horizontal_border and \ngen_row_lines for structure and formatting.\n\n:param inner_widths: A sequence of integers representing the widths (without padding) for each column.\n:param inner_heights: A sequence of integers indicating the heights (without padding) for each row.\n:param outer_widths: A sequence of integers for the widths (with padding) for each column, used in building borders.\n:yield: Yields tuples of strings, each representing a line of the table, ready to be printed.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "terminaltables3/build.py": "\"\"\"Combine cells into rows.\"\"\"\nfrom typing import Generator, Iterator, Optional, Sequence, Union\nfrom terminaltables3.width_and_alignment import visible_width\n\ndef build_border(outer_widths: Sequence[int], horizontal: str, left: str, intersect: str, right: str, title: Optional[str]=None):\n    \"\"\"Build the top/bottom/middle row. Optionally embed the table title within the border.\n\n    Title is hidden if it doesn't fit between the left/right characters/edges.\n\n    Example return value:\n    ('<', '-----', '+', '------', '+', '-------', '>')\n    ('<', 'My Table', '----', '+', '------->')\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param str horizontal: Character to stretch across each column.\n    :param str left: Left border.\n    :param str intersect: Column separator.\n    :param str right: Right border.\n    :param title: Overlay the title on the border between the left and right characters.\n\n    :return: Returns a generator of strings representing a border.\n    :rtype: iter\n    \"\"\"\n    length = 0\n    if title is not None and outer_widths:\n        try:\n            length = visible_width(title)\n        except TypeError:\n            title = str(title)\n            length = visible_width(title)\n        if length > sum(outer_widths) + len(intersect) * (len(outer_widths) - 1):\n            title = None\n    if title is None or not outer_widths or (not horizontal):\n        return combine((horizontal * c for c in outer_widths), left, intersect, right)\n    if length == outer_widths[0]:\n        return combine([title] + [horizontal * c for c in outer_widths[1:]], left, intersect, right)\n    if length < outer_widths[0]:\n        columns = [title + horizontal * (outer_widths[0] - length)] + [horizontal * c for c in outer_widths[1:]]\n        return combine(columns, left, intersect, right)\n    columns_and_intersects = [title]\n    for width in combine(outer_widths, None, bool(intersect), None):\n        if length < 1:\n            columns_and_intersects.append(intersect if width is True else horizontal * width)\n        elif width is True and length == 1:\n            length = 0\n        elif width is True:\n            length -= 1\n        elif width >= length:\n            columns_and_intersects[0] += horizontal * (width - length)\n            length = 0\n        else:\n            length -= width\n    return combine(columns_and_intersects, left, None, right)\n\ndef build_row(row, left, center, right):\n    \"\"\"Combine single or multi-lined cells into a single row of list of lists including borders.\n\n    Row must already be padded and extended so each cell has the same number of lines.\n\n    Example return value:\n    [\n        ['>', 'Left ', '|', 'Center', '|', 'Right', '<'],\n        ['>', 'Cell1', '|', 'Cell2 ', '|', 'Cell3', '<'],\n    ]\n\n    :param iter row: List of cells for one row.\n    :param str left: Left border.\n    :param str center: Column separator.\n    :param str right: Right border.\n\n    :return: Yields other generators that yield strings.\n    :rtype: iter\n    \"\"\"\n    if not row or not row[0]:\n        yield combine((), left, center, right)\n        return\n    for row_index in range(len(row[0])):\n        yield combine((c[row_index] for c in row), left, center, right)",
    "terminaltables3/width_and_alignment.py": "\"\"\"Functions that handle alignment, padding, widths, etc.\"\"\"\nimport re\nimport unicodedata\nfrom typing import List, Sequence, Tuple\nfrom terminaltables3.terminal_io import terminal_size\nRE_COLOR_ANSI = re.compile('(\\\\033\\\\[[\\\\d;]+m)')\n\ndef align_and_pad_cell(string: str, align: Tuple, inner_dimensions: Tuple, padding: Sequence[int], space: str=' ') -> List[str]:\n    \"\"\"Align a string horizontally and vertically. Also add additional padding in both dimensions.\n\n    :param str string: Input string to operate on.\n    :param tuple align: Tuple that contains one of left/center/right and/or top/middle/bottom.\n    :param tuple inner_dimensions: Width and height ints to expand string to without padding.\n    :param iter padding: Number of space chars for left, right, top, and bottom (4 ints).\n    :param str space: Character to use as white space for resizing/padding (use single visible chars only).\n\n    :return: Padded cell split into lines.\n    :rtype: list\n    \"\"\"\n    if not hasattr(string, 'splitlines'):\n        string = str(string)\n    lines = string.splitlines() or ['']\n    if string.endswith('\\n'):\n        lines.append('')\n    if 'bottom' in align:\n        lines = [''] * (inner_dimensions[1] - len(lines) + padding[2]) + lines + [''] * padding[3]\n    elif 'middle' in align:\n        delta = inner_dimensions[1] - len(lines)\n        lines = [''] * (delta // 2 + delta % 2 + padding[2]) + lines + [''] * (delta // 2 + padding[3])\n    else:\n        lines = [''] * padding[2] + lines + [''] * (inner_dimensions[1] - len(lines) + padding[3])\n    for i, line in enumerate(lines):\n        new_width = inner_dimensions[0] + len(line) - visible_width(line)\n        if 'right' in align:\n            lines[i] = line.rjust(padding[0] + new_width, space) + space * padding[1]\n        elif 'center' in align:\n            lines[i] = space * padding[0] + line.center(new_width, space) + space * padding[1]\n        else:\n            lines[i] = space * padding[0] + line.ljust(new_width + padding[1], space)\n    return lines\n\ndef column_max_width(inner_widths: Sequence[int], column_number: int, outer_border: int, inner_border: int, padding: int) -> int:\n    \"\"\"Determine the maximum width of a column based on the current terminal width.\n\n    :param iter inner_widths: List of widths (no padding) for each column.\n    :param int column_number: The column number to query.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n    :param int padding: Total padding per cell (left + right padding).\n\n    :return: The maximum width the column can be without causing line wrapping.\n    \"\"\"\n    column_count = len(inner_widths)\n    terminal_width = terminal_size()[0]\n    non_data_space = outer_border\n    non_data_space += inner_border * (column_count - 1)\n    non_data_space += column_count * padding\n    data_space = sum(inner_widths) - inner_widths[column_number]\n    return terminal_width - data_space - non_data_space\n\ndef table_width(outer_widths: Sequence[int], outer_border: int, inner_border: int) -> int:\n    \"\"\"Determine the width of the entire table including borders and padding.\n\n    :param iter outer_widths: List of widths (with padding) for each column.\n    :param int outer_border: Sum of left and right outer border visible widths.\n    :param int inner_border: Visible width of the inner border character.\n\n    :return: The width of the table.\n    :rtype: int\n    \"\"\"\n    column_count = len(outer_widths)\n    non_data_space = outer_border\n    if column_count:\n        non_data_space += inner_border * (column_count - 1)\n    data_space = sum(outer_widths)\n    return data_space + non_data_space",
    "terminaltables3/base_table.py": "\"\"\"Base table class. Define just the bare minimum to build tables.\"\"\"\nfrom typing import Generator, Optional, Sequence, Tuple\nfrom terminaltables3.build import build_border, build_row, flatten\nfrom terminaltables3.width_and_alignment import align_and_pad_cell, max_dimensions\n\nclass BaseTable:\n    \"\"\"Base table class.\n\n    :ivar iter table_data: List (empty or list of lists of strings) representing the table.\n    :ivar str title: Optional title to show within the top border of the table.\n    :ivar bool inner_column_border: Separates columns.\n    :ivar bool inner_footing_row_border: Show a border before the last row.\n    :ivar bool inner_heading_row_border: Show a border after the first row.\n    :ivar bool inner_row_border: Show a border in between every row.\n    :ivar bool outer_border: Show the top, left, right, and bottom border.\n    :ivar dict justify_columns: Horizontal justification. Keys are column indexes (int). Values are right/left/center.\n    :ivar int padding_left: Number of spaces to pad on the left side of every cell.\n    :ivar int padding_right: Number of spaces to pad on the right side of every cell.\n    \"\"\"\n    CHAR_F_INNER_HORIZONTAL = '-'\n    CHAR_F_INNER_INTERSECT = '+'\n    CHAR_F_INNER_VERTICAL = '|'\n    CHAR_F_OUTER_LEFT_INTERSECT = '+'\n    CHAR_F_OUTER_LEFT_VERTICAL = '|'\n    CHAR_F_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_F_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_H_INNER_HORIZONTAL = '-'\n    CHAR_H_INNER_INTERSECT = '+'\n    CHAR_H_INNER_VERTICAL = '|'\n    CHAR_H_OUTER_LEFT_INTERSECT = '+'\n    CHAR_H_OUTER_LEFT_VERTICAL = '|'\n    CHAR_H_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_H_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_INNER_HORIZONTAL = '-'\n    CHAR_INNER_INTERSECT = '+'\n    CHAR_INNER_VERTICAL = '|'\n    CHAR_OUTER_BOTTOM_HORIZONTAL = '-'\n    CHAR_OUTER_BOTTOM_INTERSECT = '+'\n    CHAR_OUTER_BOTTOM_LEFT = '+'\n    CHAR_OUTER_BOTTOM_RIGHT = '+'\n    CHAR_OUTER_LEFT_INTERSECT = '+'\n    CHAR_OUTER_LEFT_VERTICAL = '|'\n    CHAR_OUTER_RIGHT_INTERSECT = '+'\n    CHAR_OUTER_RIGHT_VERTICAL = '|'\n    CHAR_OUTER_TOP_HORIZONTAL = '-'\n    CHAR_OUTER_TOP_INTERSECT = '+'\n    CHAR_OUTER_TOP_LEFT = '+'\n    CHAR_OUTER_TOP_RIGHT = '+'\n\n    def horizontal_border(self, style: str, outer_widths: Sequence[int]) -> Tuple[str, ...]:\n        \"\"\"Build any kind of horizontal border for the table.\n\n        :param str style: Type of border to return.\n        :param iter outer_widths: List of widths (with padding) for each column.\n\n        :return: Prepared border as a tuple of strings.\n        :rtype: tuple\n        \"\"\"\n        if style == 'top':\n            horizontal = self.CHAR_OUTER_TOP_HORIZONTAL\n            left = self.CHAR_OUTER_TOP_LEFT\n            intersect = self.CHAR_OUTER_TOP_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_TOP_RIGHT\n            title = self.title\n        elif style == 'bottom':\n            horizontal = self.CHAR_OUTER_BOTTOM_HORIZONTAL\n            left = self.CHAR_OUTER_BOTTOM_LEFT\n            intersect = self.CHAR_OUTER_BOTTOM_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_BOTTOM_RIGHT\n            title = None\n        elif style == 'heading':\n            horizontal = self.CHAR_H_INNER_HORIZONTAL\n            left = self.CHAR_H_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_H_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        elif style == 'footing':\n            horizontal = self.CHAR_F_INNER_HORIZONTAL\n            left = self.CHAR_F_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_F_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        else:\n            horizontal = self.CHAR_INNER_HORIZONTAL\n            left = self.CHAR_OUTER_LEFT_INTERSECT if self.outer_border else ''\n            intersect = self.CHAR_INNER_INTERSECT if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_INTERSECT if self.outer_border else ''\n            title = None\n        return build_border(outer_widths, horizontal, left, intersect, right, title)\n\n    def gen_row_lines(self, row: Sequence[str], style: str, inner_widths: Sequence[int], height: int) -> Generator[Tuple[str, ...], None, None]:\n        \"\"\"Combine cells in row and group them into lines with vertical borders.\n\n        Caller is expected to pass yielded lines to ''.join() to combine them into a printable line. Caller must append\n        newline character to the end of joined line.\n\n        In:\n        ['Row One Column One', 'Two', 'Three']\n        Out:\n        [\n            ('|', ' Row One Column One ', '|', ' Two ', '|', ' Three ', '|'),\n        ]\n\n        In:\n        ['Row One\\\\nColumn One', 'Two', 'Three'],\n        Out:\n        [\n            ('|', ' Row One    ', '|', ' Two ', '|', ' Three ', '|'),\n            ('|', ' Column One ', '|', '     ', '|', '       ', '|'),\n        ]\n\n        :param iter row: One row in the table. List of cells.\n        :param str style: Type of border characters to use.\n        :param iter inner_widths: List of widths (no padding) for each column.\n        :param int height: Inner height (no padding) (number of lines) to expand row to.\n\n        :return: Yields lines split into components in a list. Caller must ''.join() line.\n        \"\"\"\n        cells_in_row = []\n        if len(row) != len(inner_widths):\n            row = row + [''] * (len(inner_widths) - len(row))\n        for i, cell in enumerate(row):\n            align = (self.justify_columns.get(i),)\n            inner_dimensions = (inner_widths[i], height)\n            padding = (self.padding_left, self.padding_right, 0, 0)\n            cells_in_row.append(align_and_pad_cell(cell, align, inner_dimensions, padding))\n        if style == 'heading':\n            left = self.CHAR_H_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_H_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_H_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        elif style == 'footing':\n            left = self.CHAR_F_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_F_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_F_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        else:\n            left = self.CHAR_OUTER_LEFT_VERTICAL if self.outer_border else ''\n            center = self.CHAR_INNER_VERTICAL if self.inner_column_border else ''\n            right = self.CHAR_OUTER_RIGHT_VERTICAL if self.outer_border else ''\n        yield from build_row(cells_in_row, left, center, right)\n\n    @property\n    def table(self) -> str:\n        \"\"\"Return a large string of the entire table ready to be printed to the terminal.\"\"\"\n        dimensions = max_dimensions(self.table_data, self.padding_left, self.padding_right)[:3]\n        return flatten(self.gen_table(*dimensions))"
  },
  "call_tree": {
    "tests/test_base_table/test_gen_table.py:test_inner_row_borders": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/width_and_alignment.py:max_dimensions": {
        "terminaltables3/width_and_alignment.py:visible_width": {}
      },
      "terminaltables3/build.py:flatten": {
        "terminaltables3/base_table.py:BaseTable:gen_table": {
          "terminaltables3/base_table.py:BaseTable:horizontal_border": {
            "terminaltables3/build.py:build_border": {}
          },
          "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
            "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
              "terminaltables3/width_and_alignment.py:visible_width": {}
            },
            "terminaltables3/build.py:build_row": {}
          }
        },
        "terminaltables3/build.py:combine": {}
      }
    },
    "tests/test_base_table/test_gen_table.py:test_outer_borders": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/width_and_alignment.py:max_dimensions": {
        "terminaltables3/width_and_alignment.py:visible_width": {}
      },
      "terminaltables3/build.py:flatten": {
        "terminaltables3/base_table.py:BaseTable:gen_table": {
          "terminaltables3/base_table.py:BaseTable:horizontal_border": {
            "terminaltables3/build.py:build_border": {
              "terminaltables3/width_and_alignment.py:visible_width": {},
              "terminaltables3/build.py:combine": {}
            }
          },
          "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
            "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
              "terminaltables3/width_and_alignment.py:visible_width": {}
            },
            "terminaltables3/build.py:build_row": {}
          }
        },
        "terminaltables3/build.py:combine": {}
      }
    },
    "tests/test_base_table/test_gen_table.py:test_one_no_rows": {
      "terminaltables3/base_table.py:BaseTable:__init__": {},
      "terminaltables3/width_and_alignment.py:max_dimensions": {
        "terminaltables3/width_and_alignment.py:visible_width": {}
      },
      "terminaltables3/build.py:flatten": {
        "terminaltables3/base_table.py:BaseTable:gen_table": {
          "terminaltables3/base_table.py:BaseTable:horizontal_border": {
            "terminaltables3/build.py:build_border": {}
          },
          "terminaltables3/base_table.py:BaseTable:gen_row_lines": {
            "terminaltables3/width_and_alignment.py:align_and_pad_cell": {
              "terminaltables3/width_and_alignment.py:visible_width": {}
            },
            "terminaltables3/build.py:build_row": {}
          }
        },
        "terminaltables3/build.py:combine": {}
      }
    }
  }
}