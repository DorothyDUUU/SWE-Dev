{
  "dir_path": "/app/mparticle",
  "package_name": "mparticle",
  "sample_name": "mparticle-test_data_plan_context",
  "src_dir": "mparticle/",
  "test_dir": "test/",
  "test_file": "test/test_data_plan_context.py",
  "test_code": "# coding: utf-8\n\n\"\"\"\n    mParticle\n\n    mParticle Event API\n\n    OpenAPI spec version: 1.0.1\n    Contact: support@mparticle.com\n    Generated by: https://github.com/swagger-api/swagger-codegen.git\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport os\nimport sys\nimport unittest\n\nimport mparticle\nfrom mparticle.rest import ApiException\n\nclass TestDataPlanContext(unittest.TestCase):\n\n    def setUp(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def testPlanWithoutVersion(self):\n        model = mparticle.models.data_plan_context.DataPlanContext(\"foo\")\n        plan_dict = model.to_dict()\n        self.assertEqual(\"foo\", plan_dict[\"plan_id\"])\n        self.assertIsNone(plan_dict[\"plan_version\"])\n\n    def testPlanWithVersion(self):\n        model = mparticle.models.data_plan_context.DataPlanContext(\"foo\", 6)\n        plan_dict = model.to_dict()\n        self.assertEqual(\"foo\", plan_dict[\"plan_id\"])\n        self.assertEqual(6, plan_dict[\"plan_version\"])\n\nif __name__ == '__main__':\n    unittest.main()\n",
  "GT_file_code": {
    "mparticle/models/data_plan_context.py": "# coding: utf-8\n\n\"\"\"\n    mParticle\n\n    mParticle Event API\n\n    OpenAPI spec version: 1.0.1\n    Contact: support@mparticle.com\n    Generated by: https://github.com/swagger-api/swagger-codegen.git\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\n\nfrom pprint import pformat\nfrom six import iteritems\nimport re\n\n\nclass DataPlanContext(object):\n\n    def __init__(self, plan_id=None, plan_version=None):\n        \"\"\"\n        DataPlanContext - a model defined in Swagger\n\n        :param dict swaggerTypes: The key is attribute name\n                                  and the value is attribute type.\n        :param dict attributeMap: The key is attribute name\n                                  and the value is json key in definition.\n        \"\"\"\n        self.swagger_types = {\n            'plan_id': 'str',\n            'plan_version': 'int'\n        }\n\n        self.attribute_map = {\n            'plan_id': 'plan_id',\n            'plan_version': 'plan_version'\n        }\n\n        self._plan_id = plan_id\n        self._plan_version = plan_version\n\n    @property\n    def plan_id(self):\n        \"\"\"\n        Gets the plan_id of this DataPlanContext.\n\n\n        :return: The plan_id of this DataPlanContext.\n        :rtype: str\n        \"\"\"\n        return self._plan_id\n\n    @plan_id.setter\n    def plan_id(self, plan_id):\n        \"\"\"\n        Sets the plan_id of this DataPlanContext.\n\n\n        :param plan_id: The plan_id of this DataPlanContext.\n        :type: str\n        \"\"\"\n\n        self._plan_id = plan_id\n\n    @property\n    def plan_version(self):\n        \"\"\"\n        Gets the plan_version of this DataPlanContext.\n\n\n        :return: The plan_version of this DataPlanContext.\n        :rtype: int\n        \"\"\"\n        return self._plan_version\n\n    @plan_version.setter\n    def plan_version(self, plan_version):\n        \"\"\"\n        Sets the plan_version of this DataPlanContext.\n\n\n        :param plan_version: The plan_version of this DataPlanContext.\n        :type: int\n        \"\"\"\n\n        self._plan_version = plan_version\n\n    def to_dict(self):\n        \"\"\"\n        Returns the model properties as a dict\n        \"\"\"\n        result = {}\n\n        for attr, _ in iteritems(self.swagger_types):\n            value = getattr(self, attr)\n            if isinstance(value, list):\n                result[attr] = list(map(\n                    lambda x: x.to_dict() if hasattr(x, \"to_dict\") else x,\n                    value\n                ))\n            elif hasattr(value, \"to_dict\"):\n                result[attr] = value.to_dict()\n            elif isinstance(value, dict):\n                result[attr] = dict(map(\n                    lambda item: (item[0], item[1].to_dict())\n                    if hasattr(item[1], \"to_dict\") else item,\n                    value.items()\n                ))\n            else:\n                result[attr] = value\n\n        return result\n\n    def to_str(self):\n        \"\"\"\n        Returns the string representation of the model\n        \"\"\"\n        return pformat(self.to_dict())\n\n    def __repr__(self):\n        \"\"\"\n        For `print` and `pprint`\n        \"\"\"\n        return self.to_str()\n\n    def __eq__(self, other):\n        \"\"\"\n        Returns true if both objects are equal\n        \"\"\"\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        \"\"\"\n        Returns true if both objects are not equal\n        \"\"\"\n        return not self == other\n"
  },
  "GT_src_dict": {
    "mparticle/models/data_plan_context.py": {
      "DataPlanContext.__init__": {
        "code": "    def __init__(self, plan_id=None, plan_version=None):\n        \"\"\"Initializes a new instance of the DataPlanContext class, which represents a context for a data plan defined in the mParticle Event API. \n\n    This constructor takes two optional parameters: `plan_id`, which is a string representing the unique identifier of the data plan, and `plan_version`, which is an integer indicating the version of the data plan. \n\n    The `swagger_types` attribute is a dictionary mapping attribute names to their data types, defining the expected data structure. The `attribute_map` attribute maps the attribute names to their corresponding JSON keys in the data plan definition.\n\n    Parameters:\n    - plan_id (str, optional): The identifier for the data plan.\n    - plan_version (int, optional): The version number of the data plan.\n\n    Attributes:\n    - swagger_types: A dictionary specifying the data types of the attributes (i.e., 'plan_id': 'str' and 'plan_version': 'int').\n    - attribute_map: A dictionary mapping class attribute names to their JSON counterparts.\n\n    Returns:\n    None\"\"\"\n        '\\n        DataPlanContext - a model defined in Swagger\\n\\n        :param dict swaggerTypes: The key is attribute name\\n                                  and the value is attribute type.\\n        :param dict attributeMap: The key is attribute name\\n                                  and the value is json key in definition.\\n        '\n        self.swagger_types = {'plan_id': 'str', 'plan_version': 'int'}\n        self.attribute_map = {'plan_id': 'plan_id', 'plan_version': 'plan_version'}\n        self._plan_id = plan_id\n        self._plan_version = plan_version",
        "docstring": "Initializes a new instance of the DataPlanContext class, which represents a context for a data plan defined in the mParticle Event API. \n\nThis constructor takes two optional parameters: `plan_id`, which is a string representing the unique identifier of the data plan, and `plan_version`, which is an integer indicating the version of the data plan. \n\nThe `swagger_types` attribute is a dictionary mapping attribute names to their data types, defining the expected data structure. The `attribute_map` attribute maps the attribute names to their corresponding JSON keys in the data plan definition.\n\nParameters:\n- plan_id (str, optional): The identifier for the data plan.\n- plan_version (int, optional): The version number of the data plan.\n\nAttributes:\n- swagger_types: A dictionary specifying the data types of the attributes (i.e., 'plan_id': 'str' and 'plan_version': 'int').\n- attribute_map: A dictionary mapping class attribute names to their JSON counterparts.\n\nReturns:\nNone",
        "signature": "def __init__(self, plan_id=None, plan_version=None):",
        "type": "Method",
        "class_signature": "class DataPlanContext(object):"
      },
      "DataPlanContext.to_dict": {
        "code": "    def to_dict(self):\n        \"\"\"Returns a dictionary representation of the DataPlanContext model's properties. The method iterates over the attributes defined in the `swagger_types` dictionary, retrieving their values and converting them into a dict format, suitable for serialization. If an attribute is a list or another object with a `to_dict` method, it recursively converts those as well. This method facilitates the transformation of the model into a data structure that can be easily manipulated or transformed into JSON.\n\nNo input parameters are required for this method. The output is a dictionary (`result`) containing key-value pairs where the keys correspond to the attribute names defined in the `attribute_map` and the values are the attributes' current values. This method is primarily utilized for converting the instance's properties into a format conducive for API communication or logging.\n\nThe method relies on `self.swagger_types`, which is a dictionary defined in the class constructor, mapping attribute names to their types. It also uses the built-in `iteritems` function from the `six` module to ensure compatibility across Python 2 and 3.\"\"\"\n        '\\n        Returns the model properties as a dict\\n        '\n        result = {}\n        for attr, _ in iteritems(self.swagger_types):\n            value = getattr(self, attr)\n            if isinstance(value, list):\n                result[attr] = list(map(lambda x: x.to_dict() if hasattr(x, 'to_dict') else x, value))\n            elif hasattr(value, 'to_dict'):\n                result[attr] = value.to_dict()\n            elif isinstance(value, dict):\n                result[attr] = dict(map(lambda item: (item[0], item[1].to_dict()) if hasattr(item[1], 'to_dict') else item, value.items()))\n            else:\n                result[attr] = value\n        return result",
        "docstring": "Returns a dictionary representation of the DataPlanContext model's properties. The method iterates over the attributes defined in the `swagger_types` dictionary, retrieving their values and converting them into a dict format, suitable for serialization. If an attribute is a list or another object with a `to_dict` method, it recursively converts those as well. This method facilitates the transformation of the model into a data structure that can be easily manipulated or transformed into JSON.\n\nNo input parameters are required for this method. The output is a dictionary (`result`) containing key-value pairs where the keys correspond to the attribute names defined in the `attribute_map` and the values are the attributes' current values. This method is primarily utilized for converting the instance's properties into a format conducive for API communication or logging.\n\nThe method relies on `self.swagger_types`, which is a dictionary defined in the class constructor, mapping attribute names to their types. It also uses the built-in `iteritems` function from the `six` module to ensure compatibility across Python 2 and 3.",
        "signature": "def to_dict(self):",
        "type": "Method",
        "class_signature": "class DataPlanContext(object):"
      }
    }
  },
  "dependency_dict": {
    "mparticle/models/data_plan_context.py:DataPlanContext:to_dict": {
      "mparticle/models/data_plan_context.py": {
        "DataPlanContext.plan_id": {
          "code": "    def plan_id(self, plan_id):\n        \"\"\"\n        Sets the plan_id of this DataPlanContext.\n\n\n        :param plan_id: The plan_id of this DataPlanContext.\n        :type: str\n        \"\"\"\n        self._plan_id = plan_id",
          "docstring": "Sets the plan_id of this DataPlanContext.\n\n\n:param plan_id: The plan_id of this DataPlanContext.\n:type: str",
          "signature": "def plan_id(self, plan_id):",
          "type": "Method",
          "class_signature": "class DataPlanContext(object):"
        },
        "DataPlanContext.plan_version": {
          "code": "    def plan_version(self, plan_version):\n        \"\"\"\n        Sets the plan_version of this DataPlanContext.\n\n\n        :param plan_version: The plan_version of this DataPlanContext.\n        :type: int\n        \"\"\"\n        self._plan_version = plan_version",
          "docstring": "Sets the plan_version of this DataPlanContext.\n\n\n:param plan_version: The plan_version of this DataPlanContext.\n:type: int",
          "signature": "def plan_version(self, plan_version):",
          "type": "Method",
          "class_signature": "class DataPlanContext(object):"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: mparticle-test_data_plan_context\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mparticle/\n    \u2514\u2500\u2500 models/\n        \u2514\u2500\u2500 data_plan_context.py\n            \u251c\u2500\u2500 DataPlanContext.__init__\n            \u2514\u2500\u2500 DataPlanContext.to_dict\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe `DataPlanContext` module facilitates the integration of data plan metadata into the mParticle event processing pipeline, enabling developers to standardize and validate event data according to predefined data plan specifications. This module supports the creation and representation of data plan contexts, including attributes such as a plan identifier and an optional version number, which are structured into a dictionary format for seamless handling. By ensuring compatibility with data governance requirements, the module streamlines event tracking across various implementations, empowering developers to build consistent, policy-compliant data flows across their applications.\n\n## FILE 1: mparticle/models/data_plan_context.py\n\n- CLASS METHOD: DataPlanContext.__init__\n  - CLASS SIGNATURE: class DataPlanContext(object):\n  - SIGNATURE: def __init__(self, plan_id=None, plan_version=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a new instance of the DataPlanContext class, which represents a context for a data plan defined in the mParticle Event API. \n\nThis constructor takes two optional parameters: `plan_id`, which is a string representing the unique identifier of the data plan, and `plan_version`, which is an integer indicating the version of the data plan. \n\nThe `swagger_types` attribute is a dictionary mapping attribute names to their data types, defining the expected data structure. The `attribute_map` attribute maps the attribute names to their corresponding JSON keys in the data plan definition.\n\nParameters:\n- plan_id (str, optional): The identifier for the data plan.\n- plan_version (int, optional): The version number of the data plan.\n\nAttributes:\n- swagger_types: A dictionary specifying the data types of the attributes (i.e., 'plan_id': 'str' and 'plan_version': 'int').\n- attribute_map: A dictionary mapping class attribute names to their JSON counterparts.\n\nReturns:\nNone\n\"\"\"\n```\n\n- CLASS METHOD: DataPlanContext.to_dict\n  - CLASS SIGNATURE: class DataPlanContext(object):\n  - SIGNATURE: def to_dict(self):\n  - DOCSTRING: \n```python\n\"\"\"\nReturns a dictionary representation of the DataPlanContext model's properties. The method iterates over the attributes defined in the `swagger_types` dictionary, retrieving their values and converting them into a dict format, suitable for serialization. If an attribute is a list or another object with a `to_dict` method, it recursively converts those as well. This method facilitates the transformation of the model into a data structure that can be easily manipulated or transformed into JSON.\n\nNo input parameters are required for this method. The output is a dictionary (`result`) containing key-value pairs where the keys correspond to the attribute names defined in the `attribute_map` and the values are the attributes' current values. This method is primarily utilized for converting the instance's properties into a format conducive for API communication or logging.\n\nThe method relies on `self.swagger_types`, which is a dictionary defined in the class constructor, mapping attribute names to their types. It also uses the built-in `iteritems` function from the `six` module to ensure compatibility across Python 2 and 3.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mparticle/models/data_plan_context.py": "\"\"\"\n    mParticle\n\n    mParticle Event API\n\n    OpenAPI spec version: 1.0.1\n    Contact: support@mparticle.com\n    Generated by: https://github.com/swagger-api/swagger-codegen.git\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\nfrom pprint import pformat\nfrom six import iteritems\nimport re\n\nclass DataPlanContext(object):\n\n    @property\n    def plan_id(self):\n        \"\"\"\n        Gets the plan_id of this DataPlanContext.\n\n\n        :return: The plan_id of this DataPlanContext.\n        :rtype: str\n        \"\"\"\n        return self._plan_id\n\n    @plan_id.setter\n    def plan_id(self, plan_id):\n        \"\"\"\n        Sets the plan_id of this DataPlanContext.\n\n\n        :param plan_id: The plan_id of this DataPlanContext.\n        :type: str\n        \"\"\"\n        self._plan_id = plan_id\n\n    @property\n    def plan_version(self):\n        \"\"\"\n        Gets the plan_version of this DataPlanContext.\n\n\n        :return: The plan_version of this DataPlanContext.\n        :rtype: int\n        \"\"\"\n        return self._plan_version\n\n    @plan_version.setter\n    def plan_version(self, plan_version):\n        \"\"\"\n        Sets the plan_version of this DataPlanContext.\n\n\n        :param plan_version: The plan_version of this DataPlanContext.\n        :type: int\n        \"\"\"\n        self._plan_version = plan_version\n\n    def to_str(self):\n        \"\"\"\n        Returns the string representation of the model\n        \"\"\"\n        return pformat(self.to_dict())\n\n    def __repr__(self):\n        \"\"\"\n        For `print` and `pprint`\n        \"\"\"\n        return self.to_str()\n\n    def __eq__(self, other):\n        \"\"\"\n        Returns true if both objects are equal\n        \"\"\"\n        return self.__dict__ == other.__dict__\n\n    def __ne__(self, other):\n        \"\"\"\n        Returns true if both objects are not equal\n        \"\"\"\n        return not self == other"
  },
  "call_tree": {
    "test/test_data_plan_context.py:TestDataPlanContext:testPlanWithVersion": {
      "mparticle/models/data_plan_context.py:DataPlanContext:__init__": {},
      "mparticle/models/data_plan_context.py:DataPlanContext:to_dict": {
        "mparticle/models/data_plan_context.py:DataPlanContext:plan_id": {},
        "mparticle/models/data_plan_context.py:DataPlanContext:plan_version": {}
      }
    },
    "test/test_data_plan_context.py:TestDataPlanContext:testPlanWithoutVersion": {
      "mparticle/models/data_plan_context.py:DataPlanContext:__init__": {},
      "mparticle/models/data_plan_context.py:DataPlanContext:to_dict": {
        "mparticle/models/data_plan_context.py:DataPlanContext:plan_id": {},
        "mparticle/models/data_plan_context.py:DataPlanContext:plan_version": {}
      }
    }
  }
}