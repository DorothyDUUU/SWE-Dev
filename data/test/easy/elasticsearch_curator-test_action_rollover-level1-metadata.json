{
  "dir_path": "/app/elasticsearch_curator",
  "package_name": "elasticsearch_curator",
  "sample_name": "elasticsearch_curator-test_action_rollover",
  "src_dir": "curator/",
  "test_dir": "tests/",
  "test_file": "tests/unit/test_action_rollover.py",
  "test_code": "\"\"\"test_action_rollover\"\"\"\n# pylint: disable=missing-function-docstring, missing-class-docstring, protected-access, attribute-defined-outside-init\nfrom unittest import TestCase\nfrom unittest.mock import Mock\nfrom curator.actions import Rollover\nfrom curator.exceptions import ConfigurationError\n\n# Get test variables and constants from a single source\nfrom . import testvars\n\nclass TestActionRollover(TestCase):\n    VERSION = {'version': {'number': '8.0.0'} }\n    def builder(self):\n        self.client = Mock()\n        self.client.info.return_value = self.VERSION\n    def test_init_raise_bad_client(self):\n        self.assertRaises(TypeError, Rollover, 'invalid', 'name', {})\n    def test_init_raise_bad_conditions(self):\n        self.builder()\n        self.assertRaises(ConfigurationError, Rollover, self.client, 'name', 'string')\n    def test_init_raise_bad_extra_settings(self):\n        self.builder()\n        self.assertRaises(\n            ConfigurationError, Rollover, self.client, 'name', {'a':'b'}, None, 'string')\n    def test_init_raise_non_rollable_index(self):\n        self.builder()\n        self.client.indices.get_alias.return_value = testvars.alias_retval\n        self.assertRaises(ValueError, Rollover, self.client, testvars.named_alias, {'a':'b'})\n    def test_do_dry_run(self):\n        self.builder()\n        self.client.indices.get_alias.return_value = testvars.rollable_alias\n        self.client.indices.rollover.return_value = testvars.dry_run_rollover\n        rlo = Rollover(self.client, testvars.named_alias, testvars.rollover_conditions)\n        self.assertIsNone(rlo.do_dry_run())\n    def test_max_size_in_acceptable_verion(self):\n        self.builder()\n        self.client.indices.get_alias.return_value = testvars.rollable_alias\n        conditions = { 'max_size': '1g' }\n        rlo = Rollover(self.client, testvars.named_alias, conditions)\n        self.assertEqual(conditions, rlo.conditions)\n",
  "GT_file_code": {
    "curator/actions/rollover.py": "\"\"\"Open index action class\"\"\"\nimport logging\nfrom curator.exceptions import ConfigurationError\nfrom curator.helpers.date_ops import parse_date_pattern\nfrom curator.helpers.testers import rollable_alias, verify_client_object\nfrom curator.helpers.utils import report_failure\n\nclass Rollover:\n    \"\"\"Rollover Action Class\"\"\"\n    def __init__(\n            self, client, name=None, conditions=None, new_index=None, extra_settings=None,\n            wait_for_active_shards=1\n        ):\n        \"\"\"\n        :param client: A client connection object\n        :param name: The name of the single-index-mapped alias to test for rollover conditions.\n        :param new_index: A new index name\n        :param conditions: Conditions to test\n        :param extra_settings: Must be either ``None``, or a dictionary of settings to apply to the new index on rollover. This is used in place of ``settings`` in the Rollover API, mostly because it's already existent in other places here in Curator\n        :param wait_for_active_shards: The number of shards expected to be active before returning.\n\n        :type client: :py:class:`~.elasticsearch.Elasticsearch`\n        :type name: str\n        :type new_index: str\n        :type conditions: dict\n        :type extra_settings: dict or None\n        :type wait_for_active_shards: int\n        \"\"\"\n        self.loggit = logging.getLogger('curator.actions.rollover')\n        if not isinstance(conditions, dict):\n            raise ConfigurationError('\"conditions\" must be a dictionary')\n        else:\n            self.loggit.debug('\"conditions\" is %s', conditions)\n        if not isinstance(extra_settings, dict) and extra_settings is not None:\n            raise ConfigurationError(\n                '\"extra_settings\" must be a dictionary or None')\n        verify_client_object(client)\n        #: Object attribute that gets the value of param ``client``.\n        self.client = client\n        #: Object attribute that gets the value of param ``conditions``.\n        self.conditions = conditions\n        #: Object attribute that gets the value of param ``extra_settings``.\n        self.settings = extra_settings\n        #: The :py:func:`~.curator.helpers.date_ops.parse_date_pattern` rendered version of what\n        #: was passed as ``new_index``, or else ``None``\n        self.new_index = parse_date_pattern(new_index) if new_index else new_index\n        #: Object attribute that gets the value of param ``wait_for_active_shards``.\n        self.wait_for_active_shards = wait_for_active_shards\n\n        #: Object attribute that gets the value of param ``name``.\n        self.name = None\n        # Verify that `conditions` and `settings` are good?\n        # Verify that `name` is an alias, and is only mapped to one index.\n        if rollable_alias(client, name):\n            self.name = name\n        else:\n            raise ValueError(\n                f'Unable to perform index rollover with alias '\n                f'\"{name}\". See previous logs for more details.'\n            )\n\n    def log_result(self, result):\n        \"\"\"Log the results based on whether the index rolled over or not\"\"\"\n        dryrun_string = ''\n        if result['dry_run']:\n            dryrun_string = 'DRY-RUN: '\n        self.loggit.debug('%sResult: %s', dryrun_string, result)\n        rollover_string = (\n            f\"{dryrun_string}Old index {result['old_index']} \"\n            f\"rolled over to new index {result['new_index']}\"\n        )\n        # Success is determined by at one condition being True\n        success = False\n        for k in list(result['conditions'].keys()):\n            if result['conditions'][k]:\n                success = True\n        if result['dry_run'] and success: # log \"successful\" dry-run\n            self.loggit.info(rollover_string)\n        elif result['rolled_over']:\n            self.loggit.info(rollover_string)\n        else:\n            msg = (\n                f\"{dryrun_string}Rollover conditions not met. \"\n                f\"Index {result['old_index']} not rolled over.\"\n            )\n            self.loggit.info(msg)\n\n    def doit(self, dry_run=False):\n        \"\"\"\n        This exists solely to prevent having to have duplicate code in both  :py:meth:`do_dry_run`\n        and :py:meth:`do_action` because :py:meth:`~.elasticsearch.client.IndicesClient.rollover`\n        has its own ``dry_run`` flag.\n        \"\"\"\n        return self.client.indices.rollover(\n            alias=self.name,\n            new_index=self.new_index,\n            conditions=self.conditions,\n            settings=self.settings,\n            dry_run=dry_run,\n            wait_for_active_shards=self.wait_for_active_shards,\n        )\n\n    def do_dry_run(self):\n        \"\"\"Log what the output would be, but take no action.\"\"\"\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        self.log_result(self.doit(dry_run=True))\n\n    def do_action(self):\n        \"\"\"\n        :py:meth:`~.elasticsearch.client.IndicesClient.rollover` the index referenced by alias\n        :py:attr:`name`\n        \"\"\"\n        self.loggit.info('Performing index rollover')\n        try:\n            self.log_result(self.doit())\n        # pylint: disable=broad-except\n        except Exception as err:\n            report_failure(err)\n",
    "curator/exceptions.py": "\"\"\"Curator Exceptions\"\"\"\nclass CuratorException(Exception):\n    \"\"\"\n    Base class for all exceptions raised by Curator which are not Elasticsearch\n    exceptions.\n    \"\"\"\n\nclass ConfigurationError(CuratorException):\n    \"\"\"\n    Exception raised when a misconfiguration is detected\n    \"\"\"\n\nclass MissingArgument(CuratorException):\n    \"\"\"\n    Exception raised when a needed argument is not passed.\n    \"\"\"\n\nclass NoIndices(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty index_list\n    \"\"\"\n\nclass NoSnapshots(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty snapshot_list\n    \"\"\"\n\nclass ActionError(CuratorException):\n    \"\"\"\n    Exception raised when an action (against an index_list or snapshot_list) cannot be taken.\n    \"\"\"\n\nclass FailedExecution(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to execute for some reason.\n    \"\"\"\n\nclass SnapshotInProgress(ActionError):\n    \"\"\"\n    Exception raised when a snapshot is already in progress\n    \"\"\"\n\nclass ActionTimeout(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to complete in the allotted time\n    \"\"\"\n\nclass FailedSnapshot(CuratorException):\n    \"\"\"\n    Exception raised when a snapshot does not complete with state SUCCESS\n    \"\"\"\n\nclass FailedRestore(CuratorException):\n    \"\"\"\n    Exception raised when a Snapshot Restore does not restore all selected indices\n    \"\"\"\n\nclass FailedReindex(CuratorException):\n    \"\"\"\n    Exception raised when failures are found in the reindex task response\n    \"\"\"\n\nclass ClientException(CuratorException):\n    \"\"\"\n    Exception raised when the Elasticsearch client and/or connection is the source of the problem.\n    \"\"\"\n\nclass LoggingException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot either log or configure logging\n    \"\"\"\n\nclass RepositoryException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot verify a snapshot repository\n    \"\"\"\n\nclass SearchableSnapshotException(CuratorException):\n    \"\"\"\n    Exception raised when Curator finds something out of order with a Searchable Snapshot\n    \"\"\"\n"
  },
  "GT_src_dict": {
    "curator/actions/rollover.py": {
      "Rollover.__init__": {
        "code": "    def __init__(self, client, name=None, conditions=None, new_index=None, extra_settings=None, wait_for_active_shards=1):\n        \"\"\"Initialize the Rollover action class, which handles the rollover of Elasticsearch indices based on specified conditions and settings.\n\nParameters:\n- client (Elasticsearch): An Elasticsearch client connection object used to communicate with the Elasticsearch cluster.\n- name (str, optional): The alias name linked to the index to test for rollover conditions. Defaults to None.\n- conditions (dict, optional): A dictionary defining conditions that must be met for the rollover to occur. Must be provided as a dictionary.\n- new_index (str, optional): The name of the new index to be created upon rollover. If None, no new index will be set.\n- extra_settings (dict or None, optional): Additional settings to apply to the new index on rollover; must be a dictionary or None.\n- wait_for_active_shards (int, optional): The minimum number of shards that must be active before the method returns. Defaults to 1.\n\nRaises:\n- ConfigurationError: If conditions or extra_settings are not dictionaries.\n- ValueError: If the provided alias does not map to a single index.\n\nAttributes:\n- client: Stores the provided client connection object.\n- conditions: Stores the conditions for rollover verification.\n- settings: Stores additional settings for the new index.\n- new_index: Contains the parsed version of the new index name.\n- wait_for_active_shards: Defines the expected number of active shards to wait for.\n- name: Holds the validated alias name for rollover operations.\n\nDependencies:\n- Uses `parse_date_pattern` from `curator.helpers.date_ops` to process the new_index.\n- Verifies the alias using `rollable_alias` from `curator.helpers.testers` to ensure it points to a single index.\"\"\"\n        \"\\n        :param client: A client connection object\\n        :param name: The name of the single-index-mapped alias to test for rollover conditions.\\n        :param new_index: A new index name\\n        :param conditions: Conditions to test\\n        :param extra_settings: Must be either ``None``, or a dictionary of settings to apply to the new index on rollover. This is used in place of ``settings`` in the Rollover API, mostly because it's already existent in other places here in Curator\\n        :param wait_for_active_shards: The number of shards expected to be active before returning.\\n\\n        :type client: :py:class:`~.elasticsearch.Elasticsearch`\\n        :type name: str\\n        :type new_index: str\\n        :type conditions: dict\\n        :type extra_settings: dict or None\\n        :type wait_for_active_shards: int\\n        \"\n        self.loggit = logging.getLogger('curator.actions.rollover')\n        if not isinstance(conditions, dict):\n            raise ConfigurationError('\"conditions\" must be a dictionary')\n        else:\n            self.loggit.debug('\"conditions\" is %s', conditions)\n        if not isinstance(extra_settings, dict) and extra_settings is not None:\n            raise ConfigurationError('\"extra_settings\" must be a dictionary or None')\n        verify_client_object(client)\n        self.client = client\n        self.conditions = conditions\n        self.settings = extra_settings\n        self.new_index = parse_date_pattern(new_index) if new_index else new_index\n        self.wait_for_active_shards = wait_for_active_shards\n        self.name = None\n        if rollable_alias(client, name):\n            self.name = name\n        else:\n            raise ValueError(f'Unable to perform index rollover with alias \"{name}\". See previous logs for more details.')",
        "docstring": "Initialize the Rollover action class, which handles the rollover of Elasticsearch indices based on specified conditions and settings.\n\nParameters:\n- client (Elasticsearch): An Elasticsearch client connection object used to communicate with the Elasticsearch cluster.\n- name (str, optional): The alias name linked to the index to test for rollover conditions. Defaults to None.\n- conditions (dict, optional): A dictionary defining conditions that must be met for the rollover to occur. Must be provided as a dictionary.\n- new_index (str, optional): The name of the new index to be created upon rollover. If None, no new index will be set.\n- extra_settings (dict or None, optional): Additional settings to apply to the new index on rollover; must be a dictionary or None.\n- wait_for_active_shards (int, optional): The minimum number of shards that must be active before the method returns. Defaults to 1.\n\nRaises:\n- ConfigurationError: If conditions or extra_settings are not dictionaries.\n- ValueError: If the provided alias does not map to a single index.\n\nAttributes:\n- client: Stores the provided client connection object.\n- conditions: Stores the conditions for rollover verification.\n- settings: Stores additional settings for the new index.\n- new_index: Contains the parsed version of the new index name.\n- wait_for_active_shards: Defines the expected number of active shards to wait for.\n- name: Holds the validated alias name for rollover operations.\n\nDependencies:\n- Uses `parse_date_pattern` from `curator.helpers.date_ops` to process the new_index.\n- Verifies the alias using `rollable_alias` from `curator.helpers.testers` to ensure it points to a single index.",
        "signature": "def __init__(self, client, name=None, conditions=None, new_index=None, extra_settings=None, wait_for_active_shards=1):",
        "type": "Method",
        "class_signature": "class Rollover:"
      },
      "Rollover.do_dry_run": {
        "code": "    def do_dry_run(self):\n        \"\"\"Log the output of a simulated index rollover operation without performing any changes.\n\nThis method logs a message indicating that it is operating in dry-run mode, meaning no actual changes will be made to the index. It then calls the `doit` method with the `dry_run` parameter set to `True`, which triggers an output detailing what would have occurred without modifying the state of the system. The results are passed to the `log_result` method for logging.\n\nNo parameters are required for this method. The expected output is a log entry showing what the rollover output would have been, including whether the rollover conditions were met.\n\nDependencies:\n- `self.loggit`: Logger instance for recording the messages.\n- `self.doit`: Method that executes the rollover action and returns a result dictionary containing details about the rollover operation.\n- `self.log_result`: Method that processes and logs the results of the rollover simulation.\"\"\"\n        'Log what the output would be, but take no action.'\n        self.loggit.info('DRY-RUN MODE.  No changes will be made.')\n        self.log_result(self.doit(dry_run=True))",
        "docstring": "Log the output of a simulated index rollover operation without performing any changes.\n\nThis method logs a message indicating that it is operating in dry-run mode, meaning no actual changes will be made to the index. It then calls the `doit` method with the `dry_run` parameter set to `True`, which triggers an output detailing what would have occurred without modifying the state of the system. The results are passed to the `log_result` method for logging.\n\nNo parameters are required for this method. The expected output is a log entry showing what the rollover output would have been, including whether the rollover conditions were met.\n\nDependencies:\n- `self.loggit`: Logger instance for recording the messages.\n- `self.doit`: Method that executes the rollover action and returns a result dictionary containing details about the rollover operation.\n- `self.log_result`: Method that processes and logs the results of the rollover simulation.",
        "signature": "def do_dry_run(self):",
        "type": "Method",
        "class_signature": "class Rollover:"
      }
    },
    "curator/exceptions.py": {}
  },
  "dependency_dict": {
    "curator/actions/rollover.py:Rollover:__init__": {
      "curator/helpers/testers.py": {
        "rollable_alias": {
          "code": "def rollable_alias(client, alias):\n    \"\"\"\n    Calls :py:meth:`~.elasticsearch.client.IndicesClient.get_alias`\n\n    :param client: A client connection object\n    :param alias: An Elasticsearch alias\n\n    :type client: :py:class:`~.elasticsearch.Elasticsearch`\n    :type alias: str\n\n\n    :returns: ``True`` or ``False`` depending on whether ``alias`` is an alias that\n        points to an index that can be used by the ``_rollover`` API.\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    try:\n        response = client.indices.get_alias(name=alias)\n    except NotFoundError:\n        logger.error('Alias \"%s\" not found.', alias)\n        return False\n    # Response should be like:\n    # {'there_should_be_only_one': {'aliases': {'value of \"alias\" here': {}}}}\n    # where 'there_should_be_only_one' is a single index name that ends in a number,\n    # and 'value of \"alias\" here' reflects the value of the passed parameter, except\n    # where the ``is_write_index`` setting makes it possible to have more than one\n    # index associated with a rollover index\n    for idx in response:\n        if 'is_write_index' in response[idx]['aliases'][alias]:\n            if response[idx]['aliases'][alias]['is_write_index']:\n                return True\n    # implied ``else``: If not ``is_write_index``, it has to fit the following criteria:\n    if len(response) > 1:\n        logger.error(\n            '\"alias\" must only reference one index, but points to %s', response\n        )\n        return False\n    index = list(response.keys())[0]\n    rollable = False\n    # In order for `rollable` to be True, the last 2 digits of the index\n    # must be digits, or a hyphen followed by a digit.\n    # NOTE: This is not a guarantee that the rest of the index name is\n    # necessarily correctly formatted.\n    if index[-2:][1].isdigit():\n        if index[-2:][0].isdigit():\n            rollable = True\n        elif index[-2:][0] == '-':\n            rollable = True\n    return rollable",
          "docstring": "Calls :py:meth:`~.elasticsearch.client.IndicesClient.get_alias`\n\n:param client: A client connection object\n:param alias: An Elasticsearch alias\n\n:type client: :py:class:`~.elasticsearch.Elasticsearch`\n:type alias: str\n\n\n:returns: ``True`` or ``False`` depending on whether ``alias`` is an alias that\n    points to an index that can be used by the ``_rollover`` API.\n:rtype: bool",
          "signature": "def rollable_alias(client, alias):",
          "type": "Function",
          "class_signature": null
        },
        "verify_client_object": {
          "code": "def verify_client_object(test):\n    \"\"\"\n    :param test: The variable or object to test\n\n    :type test: :py:class:`~.elasticsearch.Elasticsearch`\n\n    :returns: ``True`` if ``test`` is a proper :py:class:`~.elasticsearch.Elasticsearch`\n        client object and raise a :py:exc:`TypeError` exception if it is not.\n    :rtype: bool\n    \"\"\"\n    logger = logging.getLogger(__name__)\n    # Ignore mock type for testing\n    if str(type(test)) == \"<class 'unittest.mock.Mock'>\":\n        pass\n    elif not isinstance(test, Elasticsearch):\n        msg = f'Not a valid client object. Type: {type(test)} was passed'\n        logger.error(msg)\n        raise TypeError(msg)",
          "docstring": ":param test: The variable or object to test\n\n:type test: :py:class:`~.elasticsearch.Elasticsearch`\n\n:returns: ``True`` if ``test`` is a proper :py:class:`~.elasticsearch.Elasticsearch`\n    client object and raise a :py:exc:`TypeError` exception if it is not.\n:rtype: bool",
          "signature": "def verify_client_object(test):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "curator/actions/rollover.py:Rollover:do_dry_run": {
      "curator/actions/rollover.py": {
        "Rollover.log_result": {
          "code": "    def log_result(self, result):\n        \"\"\"Log the results based on whether the index rolled over or not\"\"\"\n        dryrun_string = ''\n        if result['dry_run']:\n            dryrun_string = 'DRY-RUN: '\n        self.loggit.debug('%sResult: %s', dryrun_string, result)\n        rollover_string = f'{dryrun_string}Old index {result['old_index']} rolled over to new index {result['new_index']}'\n        success = False\n        for k in list(result['conditions'].keys()):\n            if result['conditions'][k]:\n                success = True\n        if result['dry_run'] and success:\n            self.loggit.info(rollover_string)\n        elif result['rolled_over']:\n            self.loggit.info(rollover_string)\n        else:\n            msg = f'{dryrun_string}Rollover conditions not met. Index {result['old_index']} not rolled over.'\n            self.loggit.info(msg)",
          "docstring": "Log the results based on whether the index rolled over or not",
          "signature": "def log_result(self, result):",
          "type": "Method",
          "class_signature": "class Rollover:"
        },
        "Rollover.doit": {
          "code": "    def doit(self, dry_run=False):\n        \"\"\"\n        This exists solely to prevent having to have duplicate code in both  :py:meth:`do_dry_run`\n        and :py:meth:`do_action` because :py:meth:`~.elasticsearch.client.IndicesClient.rollover`\n        has its own ``dry_run`` flag.\n        \"\"\"\n        return self.client.indices.rollover(alias=self.name, new_index=self.new_index, conditions=self.conditions, settings=self.settings, dry_run=dry_run, wait_for_active_shards=self.wait_for_active_shards)",
          "docstring": "This exists solely to prevent having to have duplicate code in both  :py:meth:`do_dry_run`\nand :py:meth:`do_action` because :py:meth:`~.elasticsearch.client.IndicesClient.rollover`\nhas its own ``dry_run`` flag.",
          "signature": "def doit(self, dry_run=False):",
          "type": "Method",
          "class_signature": "class Rollover:"
        }
      }
    }
  },
  "call_tree": {
    "tests/unit/test_action_rollover.py:TestActionRollover:test_do_dry_run": {
      "tests/unit/test_action_rollover.py:TestActionRollover:builder": {},
      "curator/actions/rollover.py:Rollover:__init__": {
        "curator/helpers/testers.py:verify_client_object": {},
        "curator/helpers/testers.py:rollable_alias": {}
      },
      "curator/actions/rollover.py:Rollover:do_dry_run": {
        "curator/actions/rollover.py:Rollover:doit": {},
        "curator/actions/rollover.py:Rollover:log_result": {}
      }
    },
    "tests/unit/test_action_rollover.py:TestActionRollover:test_init_raise_bad_client": {
      "curator/actions/rollover.py:Rollover:__init__": {
        "curator/helpers/testers.py:verify_client_object": {}
      }
    },
    "tests/unit/test_action_rollover.py:TestActionRollover:test_init_raise_bad_conditions": {
      "tests/unit/test_action_rollover.py:TestActionRollover:builder": {},
      "curator/actions/rollover.py:Rollover:__init__": {}
    },
    "tests/unit/test_action_rollover.py:TestActionRollover:test_init_raise_bad_extra_settings": {
      "tests/unit/test_action_rollover.py:TestActionRollover:builder": {},
      "curator/actions/rollover.py:Rollover:__init__": {}
    },
    "tests/unit/test_action_rollover.py:TestActionRollover:test_init_raise_non_rollable_index": {
      "tests/unit/test_action_rollover.py:TestActionRollover:builder": {},
      "curator/actions/rollover.py:Rollover:__init__": {
        "curator/helpers/testers.py:verify_client_object": {},
        "curator/helpers/testers.py:rollable_alias": {}
      }
    },
    "tests/unit/test_action_rollover.py:TestActionRollover:test_max_size_in_acceptable_verion": {
      "tests/unit/test_action_rollover.py:TestActionRollover:builder": {},
      "curator/actions/rollover.py:Rollover:__init__": {
        "curator/helpers/testers.py:verify_client_object": {},
        "curator/helpers/testers.py:rollable_alias": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_action_rollover/elasticsearch_curator-test_action_rollover/tests/integration/test_cli.py:TestCLIMethods:test_action_is_none": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_action_rollover/elasticsearch_curator-test_action_rollover/tests/integration/test_cli.py:TestCLIMethods:test_no_action": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/elasticsearch_curator-image-test_action_rollover/elasticsearch_curator-test_action_rollover/tests/integration/test_integrations.py:TestFilters:test_filter_by_alias_bad_aliases": {
      "curator/exceptions.py:ConfigurationError:ConfigurationError": {}
    }
  },
  "PRD": "# PROJECT NAME: elasticsearch_curator-test_action_rollover\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 curator/\n    \u251c\u2500\u2500 actions/\n    \u2502   \u2514\u2500\u2500 rollover.py\n    \u2502       \u251c\u2500\u2500 Rollover.__init__\n    \u2502       \u2514\u2500\u2500 Rollover.do_dry_run\n    \u2514\u2500\u2500 exceptions.py\n        \u2514\u2500\u2500 ConfigurationError.ConfigurationError\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module tests the functionality and robustness of the Rollover action within the Curator framework for Elasticsearch index management. Its primary purpose is to validate the Rollover action's behavior under various configurations and conditions, ensuring that indices can be seamlessly transitioned based on specified rollover criteria, such as size or age constraints. The module provides capabilities for verifying proper initialization with valid configurations, handling invalid inputs or unsupported scenarios, and ensuring compatibility with dry-run operations and version-specific features. This solves critical issues for developers by detecting potential misconfigurations or errors in automated index lifecycle management, thereby preventing system inefficiencies or failures in a production environment.\n\n## FILE 1: curator/actions/rollover.py\n\n- CLASS METHOD: Rollover.__init__\n  - CLASS SIGNATURE: class Rollover:\n  - SIGNATURE: def __init__(self, client, name=None, conditions=None, new_index=None, extra_settings=None, wait_for_active_shards=1):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize the Rollover action class, which handles the rollover of Elasticsearch indices based on specified conditions and settings.\n\nParameters:\n- client (Elasticsearch): An Elasticsearch client connection object used to communicate with the Elasticsearch cluster.\n- name (str, optional): The alias name linked to the index to test for rollover conditions. Defaults to None.\n- conditions (dict, optional): A dictionary defining conditions that must be met for the rollover to occur. Must be provided as a dictionary.\n- new_index (str, optional): The name of the new index to be created upon rollover. If None, no new index will be set.\n- extra_settings (dict or None, optional): Additional settings to apply to the new index on rollover; must be a dictionary or None.\n- wait_for_active_shards (int, optional): The minimum number of shards that must be active before the method returns. Defaults to 1.\n\nRaises:\n- ConfigurationError: If conditions or extra_settings are not dictionaries.\n- ValueError: If the provided alias does not map to a single index.\n\nAttributes:\n- client: Stores the provided client connection object.\n- conditions: Stores the conditions for rollover verification.\n- settings: Stores additional settings for the new index.\n- new_index: Contains the parsed version of the new index name.\n- wait_for_active_shards: Defines the expected number of active shards to wait for.\n- name: Holds the validated alias name for rollover operations.\n\nDependencies:\n- Uses `parse_date_pattern` from `curator.helpers.date_ops` to process the new_index.\n- Verifies the alias using `rollable_alias` from `curator.helpers.testers` to ensure it points to a single index.\n\"\"\"\n```\n\n- CLASS METHOD: Rollover.do_dry_run\n  - CLASS SIGNATURE: class Rollover:\n  - SIGNATURE: def do_dry_run(self):\n  - DOCSTRING: \n```python\n\"\"\"\nLog the output of a simulated index rollover operation without performing any changes.\n\nThis method logs a message indicating that it is operating in dry-run mode, meaning no actual changes will be made to the index. It then calls the `doit` method with the `dry_run` parameter set to `True`, which triggers an output detailing what would have occurred without modifying the state of the system. The results are passed to the `log_result` method for logging.\n\nNo parameters are required for this method. The expected output is a log entry showing what the rollover output would have been, including whether the rollover conditions were met.\n\nDependencies:\n- `self.loggit`: Logger instance for recording the messages.\n- `self.doit`: Method that executes the rollover action and returns a result dictionary containing details about the rollover operation.\n- `self.log_result`: Method that processes and logs the results of the rollover simulation.\n\"\"\"\n```\n\n## FILE 2: curator/exceptions.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "curator/actions/rollover.py": "\"\"\"Open index action class\"\"\"\nimport logging\nfrom curator.exceptions import ConfigurationError\nfrom curator.helpers.date_ops import parse_date_pattern\nfrom curator.helpers.testers import rollable_alias, verify_client_object\nfrom curator.helpers.utils import report_failure\n\nclass Rollover:\n    \"\"\"Rollover Action Class\"\"\"\n\n    def log_result(self, result):\n        \"\"\"Log the results based on whether the index rolled over or not\"\"\"\n        dryrun_string = ''\n        if result['dry_run']:\n            dryrun_string = 'DRY-RUN: '\n        self.loggit.debug('%sResult: %s', dryrun_string, result)\n        rollover_string = f'{dryrun_string}Old index {result['old_index']} rolled over to new index {result['new_index']}'\n        success = False\n        for k in list(result['conditions'].keys()):\n            if result['conditions'][k]:\n                success = True\n        if result['dry_run'] and success:\n            self.loggit.info(rollover_string)\n        elif result['rolled_over']:\n            self.loggit.info(rollover_string)\n        else:\n            msg = f'{dryrun_string}Rollover conditions not met. Index {result['old_index']} not rolled over.'\n            self.loggit.info(msg)\n\n    def doit(self, dry_run=False):\n        \"\"\"\n        This exists solely to prevent having to have duplicate code in both  :py:meth:`do_dry_run`\n        and :py:meth:`do_action` because :py:meth:`~.elasticsearch.client.IndicesClient.rollover`\n        has its own ``dry_run`` flag.\n        \"\"\"\n        return self.client.indices.rollover(alias=self.name, new_index=self.new_index, conditions=self.conditions, settings=self.settings, dry_run=dry_run, wait_for_active_shards=self.wait_for_active_shards)\n\n    def do_action(self):\n        \"\"\"\n        :py:meth:`~.elasticsearch.client.IndicesClient.rollover` the index referenced by alias\n        :py:attr:`name`\n        \"\"\"\n        self.loggit.info('Performing index rollover')\n        try:\n            self.log_result(self.doit())\n        except Exception as err:\n            report_failure(err)",
    "curator/exceptions.py": "\"\"\"Curator Exceptions\"\"\"\n\nclass CuratorException(Exception):\n    \"\"\"\n    Base class for all exceptions raised by Curator which are not Elasticsearch\n    exceptions.\n    \"\"\"\n\nclass ConfigurationError(CuratorException):\n    \"\"\"\n    Exception raised when a misconfiguration is detected\n    \"\"\"\n\nclass MissingArgument(CuratorException):\n    \"\"\"\n    Exception raised when a needed argument is not passed.\n    \"\"\"\n\nclass NoIndices(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty index_list\n    \"\"\"\n\nclass NoSnapshots(CuratorException):\n    \"\"\"\n    Exception raised when an operation is attempted against an empty snapshot_list\n    \"\"\"\n\nclass ActionError(CuratorException):\n    \"\"\"\n    Exception raised when an action (against an index_list or snapshot_list) cannot be taken.\n    \"\"\"\n\nclass FailedExecution(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to execute for some reason.\n    \"\"\"\n\nclass SnapshotInProgress(ActionError):\n    \"\"\"\n    Exception raised when a snapshot is already in progress\n    \"\"\"\n\nclass ActionTimeout(CuratorException):\n    \"\"\"\n    Exception raised when an action fails to complete in the allotted time\n    \"\"\"\n\nclass FailedSnapshot(CuratorException):\n    \"\"\"\n    Exception raised when a snapshot does not complete with state SUCCESS\n    \"\"\"\n\nclass FailedRestore(CuratorException):\n    \"\"\"\n    Exception raised when a Snapshot Restore does not restore all selected indices\n    \"\"\"\n\nclass FailedReindex(CuratorException):\n    \"\"\"\n    Exception raised when failures are found in the reindex task response\n    \"\"\"\n\nclass ClientException(CuratorException):\n    \"\"\"\n    Exception raised when the Elasticsearch client and/or connection is the source of the problem.\n    \"\"\"\n\nclass LoggingException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot either log or configure logging\n    \"\"\"\n\nclass RepositoryException(CuratorException):\n    \"\"\"\n    Exception raised when Curator cannot verify a snapshot repository\n    \"\"\"\n\nclass SearchableSnapshotException(CuratorException):\n    \"\"\"\n    Exception raised when Curator finds something out of order with a Searchable Snapshot\n    \"\"\""
  }
}