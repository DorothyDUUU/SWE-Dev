{
  "dir_path": "/app/pytube",
  "package_name": "pytube",
  "sample_name": "pytube-test_helpers",
  "src_dir": "pytube/",
  "test_dir": "tests/",
  "test_file": "tests/test_helpers.py",
  "test_code": "import gzip\nimport io\nimport json\nimport os\nimport pytest\nfrom unittest import mock\n\nfrom pytube import helpers\nfrom pytube.exceptions import RegexMatchError\nfrom pytube.helpers import cache, create_mock_html_json, deprecated, setup_logger\nfrom pytube.helpers import target_directory, uniqueify\n\n\ndef test_regex_search_no_match():\n    with pytest.raises(RegexMatchError):\n        helpers.regex_search(\"^a$\", \"\", group=0)\n\n\ndef test_regex_search():\n    assert helpers.regex_search(\"^a$\", \"a\", group=0) == \"a\"\n\n\ndef test_safe_filename():\n    \"\"\"Unsafe characters get stripped from generated filename\"\"\"\n    assert helpers.safe_filename(\"abc1245$$\") == \"abc1245\"\n    assert helpers.safe_filename(\"abc##\") == \"abc\"\n\n\n@mock.patch(\"warnings.warn\")\ndef test_deprecated(warn):\n    @deprecated(\"oh no\")\n    def deprecated_function():\n        return None\n\n    deprecated_function()\n    warn.assert_called_with(\n        \"Call to deprecated function deprecated_function (oh no).\",\n        category=DeprecationWarning,\n        stacklevel=2,\n    )\n\n\ndef test_cache():\n    call_count = 0\n\n    @cache\n    def cached_func(stuff):\n        nonlocal call_count\n        call_count += 1\n        return stuff\n\n    cached_func(\"hi\")\n    cached_func(\"hi\")\n    cached_func(\"bye\")\n    cached_func(\"bye\")\n\n    assert call_count == 2\n\n\n@mock.patch(\"os.path.isabs\", return_value=False)\n@mock.patch(\"os.getcwd\", return_value=\"/cwd\")\n@mock.patch(\"os.makedirs\")\ndef test_target_directory_with_relative_path(_, __, makedirs):  # noqa: PT019\n    assert target_directory(\"test\") == os.path.join(\"/cwd\", \"test\")\n    makedirs.assert_called()\n\n\n@mock.patch(\"os.path.isabs\", return_value=True)\n@mock.patch(\"os.makedirs\")\ndef test_target_directory_with_absolute_path(_, makedirs):  # noqa: PT019\n    assert target_directory(\"/test\") == \"/test\"\n    makedirs.assert_called()\n\n\n@mock.patch(\"os.getcwd\", return_value=\"/cwd\")\n@mock.patch(\"os.makedirs\")\ndef test_target_directory_with_no_path(_, makedirs):  # noqa: PT019\n    assert target_directory() == \"/cwd\"\n    makedirs.assert_called()\n\n\n@mock.patch(\"pytube.helpers.logging\")\ndef test_setup_logger(logging):\n    # Given\n    logger = logging.getLogger.return_value\n    # When\n    setup_logger(20)\n    # Then\n    logging.getLogger.assert_called_with(\"pytube\")\n    logger.addHandler.assert_called()\n    logger.setLevel.assert_called_with(20)\n\n\n@mock.patch('builtins.open', new_callable=mock.mock_open)\n@mock.patch('pytube.request.urlopen')\ndef test_create_mock_html_json(mock_url_open, mock_open):\n    video_id = '2lAe1cqCOXo'\n    gzip_html_filename = 'yt-video-%s-html.json.gz' % video_id\n\n    # Get the pytube directory in order to navigate to /tests/mocks\n    pytube_dir_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__),\n            os.path.pardir\n        )\n    )\n    pytube_mocks_path = os.path.join(pytube_dir_path, 'tests', 'mocks')\n    gzip_html_filepath = os.path.join(pytube_mocks_path, gzip_html_filename)\n\n    # Mock the responses to YouTube\n    mock_url_open_object = mock.Mock()\n\n    # Order is:\n    # 1. watch_html -- must have jsurl match\n    # 2. embed html\n    # 3. watch html\n    # 4. raw vid info\n    mock_url_open_object.read.side_effect = [\n        (b'yt.setConfig({\"PLAYER_CONFIG\":{\"args\":[]}});ytInitialData = {};ytInitialPlayerResponse = {};'  # noqa: E501\n         b'\"jsUrl\":\"/s/player/13371337/player_ias.vflset/en_US/base.js\"'),\n        b'embed_html',\n        b'watch_html',\n        b'{\\\"responseContext\\\":{}}',\n    ]\n    mock_url_open.return_value = mock_url_open_object\n\n    # Generate a json with sample html json\n    result_data = create_mock_html_json(video_id)\n\n    # Assert that a write was only made once\n    mock_open.assert_called_once_with(gzip_html_filepath, 'wb')\n\n    # The result data should look like this:\n    gzip_file = io.BytesIO()\n    with gzip.GzipFile(\n        filename=gzip_html_filename,\n        fileobj=gzip_file,\n        mode='wb'\n    ) as f:\n        f.write(json.dumps(result_data).encode('utf-8'))\n    gzip_data = gzip_file.getvalue()\n\n    file_handle = mock_open.return_value.__enter__.return_value\n\n    # For some reason, write gets called multiple times, so we have to\n    #  concatenate all the write calls to get the full data before we compare\n    #  it to the BytesIO object value.\n    full_content = b''\n    for call in file_handle.write.call_args_list:\n        args, kwargs = call\n        full_content += b''.join(args)\n\n    # The file header includes time metadata, so *occasionally* a single\n    #  byte will be off at the very beginning. In theory, this difference\n    #  should only affect bytes 5-8 (or [4:8] because of zero-indexing),\n    #  but I've excluded the 10-byte metadata header altogether from the\n    #  check, just to be safe.\n    # Source: https://en.wikipedia.org/wiki/Gzip#File_format\n    assert gzip_data[10:] == full_content[10:]\n\n\ndef test_uniqueify():\n    non_unique_list = [1, 2, 3, 3, 4, 5]\n    expected = [1, 2, 3, 4, 5]\n    result = uniqueify(non_unique_list)\n    assert result == expected\n",
  "GT_file_code": {
    "pytube/helpers.py": "\"\"\"Various helper functions implemented by pytube.\"\"\"\nimport functools\nimport gzip\nimport json\nimport logging\nimport os\nimport re\nimport warnings\nfrom typing import Any, Callable, Dict, List, Optional, TypeVar\nfrom urllib import request\n\nfrom pytube.exceptions import RegexMatchError\n\nlogger = logging.getLogger(__name__)\n\n\nclass DeferredGeneratorList:\n    \"\"\"A wrapper class for deferring list generation.\n\n    Pytube has some continuation generators that create web calls, which means\n    that any time a full list is requested, all of those web calls must be\n    made at once, which could lead to slowdowns. This will allow individual\n    elements to be queried, so that slowdowns only happen as necessary. For\n    example, you can iterate over elements in the list without accessing them\n    all simultaneously. This should allow for speed improvements for playlist\n    and channel interactions.\n    \"\"\"\n    def __init__(self, generator):\n        \"\"\"Construct a :class:`DeferredGeneratorList <DeferredGeneratorList>`.\n\n        :param generator generator:\n            The deferrable generator to create a wrapper for.\n        :param func func:\n            (Optional) A function to call on the generator items to produce the list.\n        \"\"\"\n        self.gen = generator\n        self._elements = []\n\n    def __eq__(self, other):\n        \"\"\"We want to mimic list behavior for comparison.\"\"\"\n        return list(self) == other\n\n    def __getitem__(self, key) -> Any:\n        \"\"\"Only generate items as they're asked for.\"\"\"\n        # We only allow querying with indexes.\n        if not isinstance(key, (int, slice)):\n            raise TypeError('Key must be either a slice or int.')\n\n        # Convert int keys to slice\n        key_slice = key\n        if isinstance(key, int):\n            key_slice = slice(key, key + 1, 1)\n\n        # Generate all elements up to the final item\n        while len(self._elements) < key_slice.stop:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                # If we can't find enough elements for the slice, raise an IndexError\n                raise IndexError\n            else:\n                self._elements.append(next_item)\n\n        return self._elements[key]\n\n    def __iter__(self):\n        \"\"\"Custom iterator for dynamically generated list.\"\"\"\n        iter_index = 0\n        while True:\n            try:\n                curr_item = self[iter_index]\n            except IndexError:\n                return\n            else:\n                yield curr_item\n                iter_index += 1\n\n    def __next__(self) -> Any:\n        \"\"\"Fetch next element in iterator.\"\"\"\n        try:\n            curr_element = self[self.iter_index]\n        except IndexError:\n            raise StopIteration\n        self.iter_index += 1\n        return curr_element  # noqa:R504\n\n    def __len__(self) -> int:\n        \"\"\"Return length of list of all items.\"\"\"\n        self.generate_all()\n        return len(self._elements)\n\n    def __repr__(self) -> str:\n        \"\"\"String representation of all items.\"\"\"\n        self.generate_all()\n        return str(self._elements)\n\n    def __reversed__(self):\n        self.generate_all()\n        return self._elements[::-1]\n\n    def generate_all(self):\n        \"\"\"Generate all items.\"\"\"\n        while True:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                break\n            else:\n                self._elements.append(next_item)\n\n\ndef regex_search(pattern: str, string: str, group: int) -> str:\n    \"\"\"Shortcut method to search a string for a given pattern.\n\n    :param str pattern:\n        A regular expression pattern.\n    :param str string:\n        A target string to search.\n    :param int group:\n        Index of group to return.\n    :rtype:\n        str or tuple\n    :returns:\n        Substring pattern matches.\n    \"\"\"\n    regex = re.compile(pattern)\n    results = regex.search(string)\n    if not results:\n        raise RegexMatchError(caller=\"regex_search\", pattern=pattern)\n\n    logger.debug(\"matched regex search: %s\", pattern)\n\n    return results.group(group)\n\n\ndef safe_filename(s: str, max_length: int = 255) -> str:\n    \"\"\"Sanitize a string making it safe to use as a filename.\n\n    This function was based off the limitations outlined here:\n    https://en.wikipedia.org/wiki/Filename.\n\n    :param str s:\n        A string to make safe for use as a file name.\n    :param int max_length:\n        The maximum filename character length.\n    :rtype: str\n    :returns:\n        A sanitized string.\n    \"\"\"\n    # Characters in range 0-31 (0x00-0x1F) are not allowed in ntfs filenames.\n    ntfs_characters = [chr(i) for i in range(0, 31)]\n    characters = [\n        r'\"',\n        r\"\\#\",\n        r\"\\$\",\n        r\"\\%\",\n        r\"'\",\n        r\"\\*\",\n        r\"\\,\",\n        r\"\\.\",\n        r\"\\/\",\n        r\"\\:\",\n        r'\"',\n        r\"\\;\",\n        r\"\\<\",\n        r\"\\>\",\n        r\"\\?\",\n        r\"\\\\\",\n        r\"\\^\",\n        r\"\\|\",\n        r\"\\~\",\n        r\"\\\\\\\\\",\n    ]\n    pattern = \"|\".join(ntfs_characters + characters)\n    regex = re.compile(pattern, re.UNICODE)\n    filename = regex.sub(\"\", s)\n    return filename[:max_length].rsplit(\" \", 0)[0]\n\n\ndef setup_logger(level: int = logging.ERROR, log_filename: Optional[str] = None) -> None:\n    \"\"\"Create a configured instance of logger.\n\n    :param int level:\n        Describe the severity level of the logs to handle.\n    \"\"\"\n    fmt = \"[%(asctime)s] %(levelname)s in %(module)s: %(message)s\"\n    date_fmt = \"%H:%M:%S\"\n    formatter = logging.Formatter(fmt, datefmt=date_fmt)\n\n    # https://github.com/pytube/pytube/issues/163\n    logger = logging.getLogger(\"pytube\")\n    logger.setLevel(level)\n\n    stream_handler = logging.StreamHandler()\n    stream_handler.setFormatter(formatter)\n    logger.addHandler(stream_handler)\n\n    if log_filename is not None:\n        file_handler = logging.FileHandler(log_filename)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n\nGenericType = TypeVar(\"GenericType\")\n\n\ndef cache(func: Callable[..., GenericType]) -> GenericType:\n    \"\"\" mypy compatible annotation wrapper for lru_cache\"\"\"\n    return functools.lru_cache()(func)  # type: ignore\n\n\ndef deprecated(reason: str) -> Callable:\n    \"\"\"\n    This is a decorator which can be used to mark functions\n    as deprecated. It will result in a warning being emitted\n    when the function is used.\n    \"\"\"\n\n    def decorator(func1):\n        message = \"Call to deprecated function {name} ({reason}).\"\n\n        @functools.wraps(func1)\n        def new_func1(*args, **kwargs):\n            warnings.simplefilter(\"always\", DeprecationWarning)\n            warnings.warn(\n                message.format(name=func1.__name__, reason=reason),\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            warnings.simplefilter(\"default\", DeprecationWarning)\n            return func1(*args, **kwargs)\n\n        return new_func1\n\n    return decorator\n\n\ndef target_directory(output_path: Optional[str] = None) -> str:\n    \"\"\"\n    Function for determining target directory of a download.\n    Returns an absolute path (if relative one given) or the current\n    path (if none given). Makes directory if it does not exist.\n\n    :type output_path: str\n        :rtype: str\n    :returns:\n        An absolute directory path as a string.\n    \"\"\"\n    if output_path:\n        if not os.path.isabs(output_path):\n            output_path = os.path.join(os.getcwd(), output_path)\n    else:\n        output_path = os.getcwd()\n    os.makedirs(output_path, exist_ok=True)\n    return output_path\n\n\ndef install_proxy(proxy_handler: Dict[str, str]) -> None:\n    proxy_support = request.ProxyHandler(proxy_handler)\n    opener = request.build_opener(proxy_support)\n    request.install_opener(opener)\n\n\ndef uniqueify(duped_list: List) -> List:\n    \"\"\"Remove duplicate items from a list, while maintaining list order.\n\n    :param List duped_list\n        List to remove duplicates from\n\n    :return List result\n        De-duplicated list\n    \"\"\"\n    seen: Dict[Any, bool] = {}\n    result = []\n    for item in duped_list:\n        if item in seen:\n            continue\n        seen[item] = True\n        result.append(item)\n    return result\n\n\ndef generate_all_html_json_mocks():\n    \"\"\"Regenerate the video mock json files for all current test videos.\n\n    This should automatically output to the test/mocks directory.\n    \"\"\"\n    test_vid_ids = [\n        '2lAe1cqCOXo',\n        '5YceQ8YqYMc',\n        'irauhITDrsE',\n        'm8uHb5jIGN8',\n        'QRS8MkLhQmM',\n        'WXxV9g7lsFE'\n    ]\n    for vid_id in test_vid_ids:\n        create_mock_html_json(vid_id)\n\n\ndef create_mock_html_json(vid_id) -> Dict[str, Any]:\n    \"\"\"Generate a json.gz file with sample html responses.\n\n    :param str vid_id\n        YouTube video id\n\n    :return dict data\n        Dict used to generate the json.gz file\n    \"\"\"\n    from pytube import YouTube\n    gzip_filename = 'yt-video-%s-html.json.gz' % vid_id\n\n    # Get the pytube directory in order to navigate to /tests/mocks\n    pytube_dir_path = os.path.abspath(\n        os.path.join(\n            os.path.dirname(__file__),\n            os.path.pardir\n        )\n    )\n    pytube_mocks_path = os.path.join(pytube_dir_path, 'tests', 'mocks')\n    gzip_filepath = os.path.join(pytube_mocks_path, gzip_filename)\n\n    yt = YouTube(f'https://www.youtube.com/watch?v={vid_id}')\n    html_data = {\n        'url': yt.watch_url,\n        'js': yt.js,\n        'embed_html': yt.embed_html,\n        'watch_html': yt.watch_html,\n        'vid_info': yt.vid_info\n    }\n\n    logger.info(f'Outputing json.gz file to {gzip_filepath}')\n    with gzip.open(gzip_filepath, 'wb') as f:\n        f.write(json.dumps(html_data).encode('utf-8'))\n\n    return html_data\n"
  },
  "GT_src_dict": {
    "pytube/helpers.py": {
      "regex_search": {
        "code": "def regex_search(pattern: str, string: str, group: int) -> str:\n    \"\"\"Shortcut method to search a string for a given regular expression pattern and return a specific matched group.\n\n:param str pattern: A regular expression pattern used to search within the provided string.\n:param str string: The target string in which to search for the pattern.\n:param int group: The index of the group to return from the matched results.\n:rtype: str\n:returns: The substring that matches the specified group from the regex search.\n:raises RegexMatchError: If no match is found, a RegexMatchError is raised, indicating that the pattern did not match the string.\n\nThis function leverages the `re` module for regex operations and utilizes the `RegexMatchError` class from the `pytube.exceptions` module to handle matching errors. Additionally, it logs a debug message when a successful match occurs, using the configured logger to assist with tracing and debugging.\"\"\"\n    'Shortcut method to search a string for a given pattern.\\n\\n    :param str pattern:\\n        A regular expression pattern.\\n    :param str string:\\n        A target string to search.\\n    :param int group:\\n        Index of group to return.\\n    :rtype:\\n        str or tuple\\n    :returns:\\n        Substring pattern matches.\\n    '\n    regex = re.compile(pattern)\n    results = regex.search(string)\n    if not results:\n        raise RegexMatchError(caller='regex_search', pattern=pattern)\n    logger.debug('matched regex search: %s', pattern)\n    return results.group(group)",
        "docstring": "Shortcut method to search a string for a given regular expression pattern and return a specific matched group.\n\n:param str pattern: A regular expression pattern used to search within the provided string.\n:param str string: The target string in which to search for the pattern.\n:param int group: The index of the group to return from the matched results.\n:rtype: str\n:returns: The substring that matches the specified group from the regex search.\n:raises RegexMatchError: If no match is found, a RegexMatchError is raised, indicating that the pattern did not match the string.\n\nThis function leverages the `re` module for regex operations and utilizes the `RegexMatchError` class from the `pytube.exceptions` module to handle matching errors. Additionally, it logs a debug message when a successful match occurs, using the configured logger to assist with tracing and debugging.",
        "signature": "def regex_search(pattern: str, string: str, group: int) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "safe_filename": {
        "code": "def safe_filename(s: str, max_length: int=255) -> str:\n    \"\"\"Sanitize a string to make it safe for use as a filename, ensuring compliance with NTFS filename restrictions and a specified maximum length.\n\nParameters:\n- s (str): The input string that will be sanitized to create a safe filename.\n- max_length (int, optional): The maximum allowed length for the filename (default is 255 characters).\n\nReturns:\n- str: A sanitized version of the input string, truncated to max_length if necessary.\n\nNotes:\nThis function removes any characters that are not permitted in NTFS filenames, specifically those in the range of characters 0-31 and a set of additional special characters. The sanitization process uses a regular expression pattern to identify these invalid characters and replace them with an empty string. The resulting filename is then trimmed to the specified maximum length, ensuring it adheres to filesystem constraints. If the sanitized string ends in a space, it removes that character to prevent trailing spaces in filenames.\"\"\"\n    'Sanitize a string making it safe to use as a filename.\\n\\n    This function was based off the limitations outlined here:\\n    https://en.wikipedia.org/wiki/Filename.\\n\\n    :param str s:\\n        A string to make safe for use as a file name.\\n    :param int max_length:\\n        The maximum filename character length.\\n    :rtype: str\\n    :returns:\\n        A sanitized string.\\n    '\n    ntfs_characters = [chr(i) for i in range(0, 31)]\n    characters = ['\"', '\\\\#', '\\\\$', '\\\\%', \"'\", '\\\\*', '\\\\,', '\\\\.', '\\\\/', '\\\\:', '\"', '\\\\;', '\\\\<', '\\\\>', '\\\\?', '\\\\\\\\', '\\\\^', '\\\\|', '\\\\~', '\\\\\\\\\\\\\\\\']\n    pattern = '|'.join(ntfs_characters + characters)\n    regex = re.compile(pattern, re.UNICODE)\n    filename = regex.sub('', s)\n    return filename[:max_length].rsplit(' ', 0)[0]",
        "docstring": "Sanitize a string to make it safe for use as a filename, ensuring compliance with NTFS filename restrictions and a specified maximum length.\n\nParameters:\n- s (str): The input string that will be sanitized to create a safe filename.\n- max_length (int, optional): The maximum allowed length for the filename (default is 255 characters).\n\nReturns:\n- str: A sanitized version of the input string, truncated to max_length if necessary.\n\nNotes:\nThis function removes any characters that are not permitted in NTFS filenames, specifically those in the range of characters 0-31 and a set of additional special characters. The sanitization process uses a regular expression pattern to identify these invalid characters and replace them with an empty string. The resulting filename is then trimmed to the specified maximum length, ensuring it adheres to filesystem constraints. If the sanitized string ends in a space, it removes that character to prevent trailing spaces in filenames.",
        "signature": "def safe_filename(s: str, max_length: int=255) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "setup_logger": {
        "code": "def setup_logger(level: int=logging.ERROR, log_filename: Optional[str]=None) -> None:\n    \"\"\"Create and configure a logger instance for the pytube library.\n\nThis function sets up a logger with a specified logging level and, optionally, a log file to capture log messages. The log messages are formatted to include the timestamp, severity level, module name, and message. The logger instance created is named \"pytube\" and can handle output to both the console and a specified log file.\n\nParameters:\n- level (int): The logging level to set for the logger (default is logging.ERROR).\n- log_filename (Optional[str]): If provided, the path to a file where log messages should be saved.\n\nReturns:\n- None: This function modifies the global logger configuration without returning any values.\n\nDependencies:\n- The function leverages the Python logging module to configure log output and formatting.\n\nConstants:\n- fmt: This string defines the format of log messages, including placeholders for the timestamp, log level, module name, and the log message itself.\n- date_fmt: This string is used to specify the format of the timestamp within the log messages.\"\"\"\n    'Create a configured instance of logger.\\n\\n    :param int level:\\n        Describe the severity level of the logs to handle.\\n    '\n    fmt = '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n    date_fmt = '%H:%M:%S'\n    formatter = logging.Formatter(fmt, datefmt=date_fmt)\n    logger = logging.getLogger('pytube')\n    logger.setLevel(level)\n    stream_handler = logging.StreamHandler()\n    stream_handler.setFormatter(formatter)\n    logger.addHandler(stream_handler)\n    if log_filename is not None:\n        file_handler = logging.FileHandler(log_filename)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)",
        "docstring": "Create and configure a logger instance for the pytube library.\n\nThis function sets up a logger with a specified logging level and, optionally, a log file to capture log messages. The log messages are formatted to include the timestamp, severity level, module name, and message. The logger instance created is named \"pytube\" and can handle output to both the console and a specified log file.\n\nParameters:\n- level (int): The logging level to set for the logger (default is logging.ERROR).\n- log_filename (Optional[str]): If provided, the path to a file where log messages should be saved.\n\nReturns:\n- None: This function modifies the global logger configuration without returning any values.\n\nDependencies:\n- The function leverages the Python logging module to configure log output and formatting.\n\nConstants:\n- fmt: This string defines the format of log messages, including placeholders for the timestamp, log level, module name, and the log message itself.\n- date_fmt: This string is used to specify the format of the timestamp within the log messages.",
        "signature": "def setup_logger(level: int=logging.ERROR, log_filename: Optional[str]=None) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "cache": {
        "code": "def cache(func: Callable[..., GenericType]) -> GenericType:\n    \"\"\"This function serves as a decorator that applies Python's built-in Least Recently Used (LRU) cache to the provided function, allowing for memoization of its results. \n\n:param func: A callable function that takes any number of arguments.\n:type func: Callable[..., GenericType]\n:returns: A cached version of the input function that uses an LRU caching mechanism to store results of expensive function calls.\n:rtype: GenericType\n\nThe `lru_cache` from the `functools` module optimizes function calls by storing previously computed results and returning them when the same inputs occur again, thus reducing the computation time for repeated calls. This is particularly useful in scenarios where a function is likely to be called with the same parameters multiple times, as seen in data processing or computational tasks within the broader Pytube codebase.\"\"\"\n    ' mypy compatible annotation wrapper for lru_cache'\n    return functools.lru_cache()(func)",
        "docstring": "This function serves as a decorator that applies Python's built-in Least Recently Used (LRU) cache to the provided function, allowing for memoization of its results. \n\n:param func: A callable function that takes any number of arguments.\n:type func: Callable[..., GenericType]\n:returns: A cached version of the input function that uses an LRU caching mechanism to store results of expensive function calls.\n:rtype: GenericType\n\nThe `lru_cache` from the `functools` module optimizes function calls by storing previously computed results and returning them when the same inputs occur again, thus reducing the computation time for repeated calls. This is particularly useful in scenarios where a function is likely to be called with the same parameters multiple times, as seen in data processing or computational tasks within the broader Pytube codebase.",
        "signature": "def cache(func: Callable[..., GenericType]) -> GenericType:",
        "type": "Function",
        "class_signature": null
      },
      "deprecated": {
        "code": "def deprecated(reason: str) -> Callable:\n    \"\"\"This is a decorator function `deprecated` that marks other functions as deprecated, issuing a warning whenever the deprecated function is called. \n\nParameters:\n- `reason` (str): A string explaining the reason for deprecation, which is included in the warning message to inform users of the deprecated status.\n\nReturns:\n- Callable: A wrapped version of the original function, which triggers a deprecation warning when invoked.\n\nThis function uses the `warnings` module to issue a `DeprecationWarning`, adjusting the warnings filter to ensure that the warning is emitted every time the decorated function is called. The message format includes the name of the deprecated function and the reason for its deprecation, helping developers understand why they should avoid using it. The logging behavior is configured in other parts of the code, but this function specifically handles the emission of deprecation warnings.\"\"\"\n    '\\n    This is a decorator which can be used to mark functions\\n    as deprecated. It will result in a warning being emitted\\n    when the function is used.\\n    '\n\n    def decorator(func1):\n        \"\"\"This decorator marks functions as deprecated, issuing a warning each time the decorated function is called. \n\nParameters:\n- reason (str): A message explaining the reason for deprecation.\n\nReturns:\n- Callable: A wrapped function that emits a DeprecationWarning when called, along with executing the original function.\n\nThe decorator utilizes the `warnings` module to generate the warning and `functools.wraps` to preserve the metadata of the original function. The warning message includes the name of the deprecated function and the reason for its deprecation, formatted using the `message` string.\"\"\"\n        message = 'Call to deprecated function {name} ({reason}).'\n\n        @functools.wraps(func1)\n        def new_func1(*args, **kwargs):\n            \"\"\"Wraps a callable function to emit a deprecation warning when the function is invoked.\n\nParameters:\n- *args: Positional arguments to pass to the wrapped function.\n- **kwargs: Keyword arguments to pass to the wrapped function.\n\nReturns:\n- The return value from the original wrapped function.\n\nSide Effects:\n- Emits a DeprecationWarning, which is configured to always show for the current execution context. This warning includes the name of the function being called and the reason for its deprecation, allowing users to be informed that they are using a function that may be removed in future releases.\n\nConstants:\n- `message`: A formatted string that contains the warning message, utilizing the wrapped function's name (retrieved via `func1.__name__`) and the `reason` specified when decorating the function. This constant is significant for notifying users about the deprecation of the function.\"\"\"\n            warnings.simplefilter('always', DeprecationWarning)\n            warnings.warn(message.format(name=func1.__name__, reason=reason), category=DeprecationWarning, stacklevel=2)\n            warnings.simplefilter('default', DeprecationWarning)\n            return func1(*args, **kwargs)\n        return new_func1\n    return decorator",
        "docstring": "This is a decorator function `deprecated` that marks other functions as deprecated, issuing a warning whenever the deprecated function is called. \n\nParameters:\n- `reason` (str): A string explaining the reason for deprecation, which is included in the warning message to inform users of the deprecated status.\n\nReturns:\n- Callable: A wrapped version of the original function, which triggers a deprecation warning when invoked.\n\nThis function uses the `warnings` module to issue a `DeprecationWarning`, adjusting the warnings filter to ensure that the warning is emitted every time the decorated function is called. The message format includes the name of the deprecated function and the reason for its deprecation, helping developers understand why they should avoid using it. The logging behavior is configured in other parts of the code, but this function specifically handles the emission of deprecation warnings.",
        "signature": "def deprecated(reason: str) -> Callable:",
        "type": "Function",
        "class_signature": null
      },
      "target_directory": {
        "code": "def target_directory(output_path: Optional[str]=None) -> str:\n    \"\"\"Determine the target directory for downloads, returning an absolute path. If a relative path is provided, it combines it with the current working directory. If no path is given, it defaults to the current working directory. The function ensures that the target directory exists by creating it if necessary.\n\nParameters:\n- output_path (Optional[str]): A string representing the desired output directory. If None, defaults to the current working directory.\n\nReturns:\n- str: An absolute path to the target directory.\n\nSide Effects:\n- Creates the directory specified by output_path if it does not already exist, using os.makedirs with exist_ok set to True.\n\nDependencies:\n- The function uses the os module to handle file system operations, specifically os.path.isabs to check for absolute paths and os.makedirs to create the directory.\"\"\"\n    '\\n    Function for determining target directory of a download.\\n    Returns an absolute path (if relative one given) or the current\\n    path (if none given). Makes directory if it does not exist.\\n\\n    :type output_path: str\\n        :rtype: str\\n    :returns:\\n        An absolute directory path as a string.\\n    '\n    if output_path:\n        if not os.path.isabs(output_path):\n            output_path = os.path.join(os.getcwd(), output_path)\n    else:\n        output_path = os.getcwd()\n    os.makedirs(output_path, exist_ok=True)\n    return output_path",
        "docstring": "Determine the target directory for downloads, returning an absolute path. If a relative path is provided, it combines it with the current working directory. If no path is given, it defaults to the current working directory. The function ensures that the target directory exists by creating it if necessary.\n\nParameters:\n- output_path (Optional[str]): A string representing the desired output directory. If None, defaults to the current working directory.\n\nReturns:\n- str: An absolute path to the target directory.\n\nSide Effects:\n- Creates the directory specified by output_path if it does not already exist, using os.makedirs with exist_ok set to True.\n\nDependencies:\n- The function uses the os module to handle file system operations, specifically os.path.isabs to check for absolute paths and os.makedirs to create the directory.",
        "signature": "def target_directory(output_path: Optional[str]=None) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "uniqueify": {
        "code": "def uniqueify(duped_list: List) -> List:\n    \"\"\"Remove duplicate items from a list while preserving the original order.\n\n:param List duped_list: A list from which duplicates will be removed.\n:return List result: A new list containing only unique items, in the order they first appeared in `duped_list`.\n\nThis function utilizes a dictionary named `seen` to keep track of items that have already been encountered. By checking against this dictionary, it effectively filters out duplicates without altering the order of the original list. The use of `Dict[Any, bool]` for `seen` ensures that any item type can be processed.\"\"\"\n    'Remove duplicate items from a list, while maintaining list order.\\n\\n    :param List duped_list\\n        List to remove duplicates from\\n\\n    :return List result\\n        De-duplicated list\\n    '\n    seen: Dict[Any, bool] = {}\n    result = []\n    for item in duped_list:\n        if item in seen:\n            continue\n        seen[item] = True\n        result.append(item)\n    return result",
        "docstring": "Remove duplicate items from a list while preserving the original order.\n\n:param List duped_list: A list from which duplicates will be removed.\n:return List result: A new list containing only unique items, in the order they first appeared in `duped_list`.\n\nThis function utilizes a dictionary named `seen` to keep track of items that have already been encountered. By checking against this dictionary, it effectively filters out duplicates without altering the order of the original list. The use of `Dict[Any, bool]` for `seen` ensures that any item type can be processed.",
        "signature": "def uniqueify(duped_list: List) -> List:",
        "type": "Function",
        "class_signature": null
      },
      "create_mock_html_json": {
        "code": "def create_mock_html_json(vid_id) -> Dict[str, Any]:\n    \"\"\"Generate a JSON.gz file containing sample HTML responses for a specified YouTube video.\n\n:param str vid_id: The YouTube video ID for which the mock HTML data will be generated.\n:return: A dictionary containing the video's URL, JavaScript, embed HTML, watch HTML, and video information.\n:rtype: dict\n:raises: This function interacts with the `YouTube` class from the `pytube` module to fetch video data based on the given `vid_id`. It generates a file named `yt-video-<vid_id>-html.json.gz` in the `tests/mocks` directory, which is determined based on the module's directory structure. The function logs the output file path during execution using the configured logger.\"\"\"\n    'Generate a json.gz file with sample html responses.\\n\\n    :param str vid_id\\n        YouTube video id\\n\\n    :return dict data\\n        Dict used to generate the json.gz file\\n    '\n    from pytube import YouTube\n    gzip_filename = 'yt-video-%s-html.json.gz' % vid_id\n    pytube_dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))\n    pytube_mocks_path = os.path.join(pytube_dir_path, 'tests', 'mocks')\n    gzip_filepath = os.path.join(pytube_mocks_path, gzip_filename)\n    yt = YouTube(f'https://www.youtube.com/watch?v={vid_id}')\n    html_data = {'url': yt.watch_url, 'js': yt.js, 'embed_html': yt.embed_html, 'watch_html': yt.watch_html, 'vid_info': yt.vid_info}\n    logger.info(f'Outputing json.gz file to {gzip_filepath}')\n    with gzip.open(gzip_filepath, 'wb') as f:\n        f.write(json.dumps(html_data).encode('utf-8'))\n    return html_data",
        "docstring": "Generate a JSON.gz file containing sample HTML responses for a specified YouTube video.\n\n:param str vid_id: The YouTube video ID for which the mock HTML data will be generated.\n:return: A dictionary containing the video's URL, JavaScript, embed HTML, watch HTML, and video information.\n:rtype: dict\n:raises: This function interacts with the `YouTube` class from the `pytube` module to fetch video data based on the given `vid_id`. It generates a file named `yt-video-<vid_id>-html.json.gz` in the `tests/mocks` directory, which is determined based on the module's directory structure. The function logs the output file path during execution using the configured logger.",
        "signature": "def create_mock_html_json(vid_id) -> Dict[str, Any]:",
        "type": "Function",
        "class_signature": null
      },
      "decorator": {
        "code": "    def decorator(func1):\n        \"\"\"This decorator marks functions as deprecated, issuing a warning each time the decorated function is called. \n\nParameters:\n- reason (str): A message explaining the reason for deprecation.\n\nReturns:\n- Callable: A wrapped function that emits a DeprecationWarning when called, along with executing the original function.\n\nThe decorator utilizes the `warnings` module to generate the warning and `functools.wraps` to preserve the metadata of the original function. The warning message includes the name of the deprecated function and the reason for its deprecation, formatted using the `message` string.\"\"\"\n        message = 'Call to deprecated function {name} ({reason}).'\n\n        @functools.wraps(func1)\n        def new_func1(*args, **kwargs):\n            \"\"\"Wraps a callable function to emit a deprecation warning when the function is invoked.\n\nParameters:\n- *args: Positional arguments to pass to the wrapped function.\n- **kwargs: Keyword arguments to pass to the wrapped function.\n\nReturns:\n- The return value from the original wrapped function.\n\nSide Effects:\n- Emits a DeprecationWarning, which is configured to always show for the current execution context. This warning includes the name of the function being called and the reason for its deprecation, allowing users to be informed that they are using a function that may be removed in future releases.\n\nConstants:\n- `message`: A formatted string that contains the warning message, utilizing the wrapped function's name (retrieved via `func1.__name__`) and the `reason` specified when decorating the function. This constant is significant for notifying users about the deprecation of the function.\"\"\"\n            warnings.simplefilter('always', DeprecationWarning)\n            warnings.warn(message.format(name=func1.__name__, reason=reason), category=DeprecationWarning, stacklevel=2)\n            warnings.simplefilter('default', DeprecationWarning)\n            return func1(*args, **kwargs)\n        return new_func1",
        "docstring": "This decorator marks functions as deprecated, issuing a warning each time the decorated function is called. \n\nParameters:\n- reason (str): A message explaining the reason for deprecation.\n\nReturns:\n- Callable: A wrapped function that emits a DeprecationWarning when called, along with executing the original function.\n\nThe decorator utilizes the `warnings` module to generate the warning and `functools.wraps` to preserve the metadata of the original function. The warning message includes the name of the deprecated function and the reason for its deprecation, formatted using the `message` string.",
        "signature": "def decorator(func1):",
        "type": "Function",
        "class_signature": null
      },
      "new_func1": {
        "code": "        def new_func1(*args, **kwargs):\n            \"\"\"Wraps a callable function to emit a deprecation warning when the function is invoked.\n\nParameters:\n- *args: Positional arguments to pass to the wrapped function.\n- **kwargs: Keyword arguments to pass to the wrapped function.\n\nReturns:\n- The return value from the original wrapped function.\n\nSide Effects:\n- Emits a DeprecationWarning, which is configured to always show for the current execution context. This warning includes the name of the function being called and the reason for its deprecation, allowing users to be informed that they are using a function that may be removed in future releases.\n\nConstants:\n- `message`: A formatted string that contains the warning message, utilizing the wrapped function's name (retrieved via `func1.__name__`) and the `reason` specified when decorating the function. This constant is significant for notifying users about the deprecation of the function.\"\"\"\n            warnings.simplefilter('always', DeprecationWarning)\n            warnings.warn(message.format(name=func1.__name__, reason=reason), category=DeprecationWarning, stacklevel=2)\n            warnings.simplefilter('default', DeprecationWarning)\n            return func1(*args, **kwargs)",
        "docstring": "Wraps a callable function to emit a deprecation warning when the function is invoked.\n\nParameters:\n- *args: Positional arguments to pass to the wrapped function.\n- **kwargs: Keyword arguments to pass to the wrapped function.\n\nReturns:\n- The return value from the original wrapped function.\n\nSide Effects:\n- Emits a DeprecationWarning, which is configured to always show for the current execution context. This warning includes the name of the function being called and the reason for its deprecation, allowing users to be informed that they are using a function that may be removed in future releases.\n\nConstants:\n- `message`: A formatted string that contains the warning message, utilizing the wrapped function's name (retrieved via `func1.__name__`) and the `reason` specified when decorating the function. This constant is significant for notifying users about the deprecation of the function.",
        "signature": "def new_func1(*args, **kwargs):",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "pytube/helpers.py:regex_search": {
      "pytube/exceptions.py": {
        "RegexMatchError.__init__": {
          "code": "    def __init__(self, caller: str, pattern: Union[str, Pattern]):\n        \"\"\"\n        :param str caller:\n            Calling function\n        :param str pattern:\n            Pattern that failed to match\n        \"\"\"\n        super().__init__(f\"{caller}: could not find match for {pattern}\")\n        self.caller = caller\n        self.pattern = pattern",
          "docstring": ":param str caller:\n    Calling function\n:param str pattern:\n    Pattern that failed to match",
          "signature": "def __init__(self, caller: str, pattern: Union[str, Pattern]):",
          "type": "Method",
          "class_signature": "class RegexMatchError(ExtractError):"
        }
      }
    },
    "pytube/helpers.py:new_func1": {
      "tests/test_helpers.py": {
        "deprecated_function": {
          "code": "    def deprecated_function():\n        return None",
          "docstring": "",
          "signature": "def deprecated_function():",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pytube/helpers.py:create_mock_html_json": {
      "pytube/__main__.py": {
        "YouTube.__init__": {
          "code": "    def __init__(\n        self,\n        url: str,\n        on_progress_callback: Optional[Callable[[Any, bytes, int], None]] = None,\n        on_complete_callback: Optional[Callable[[Any, Optional[str]], None]] = None,\n        proxies: Dict[str, str] = None,\n        use_oauth: bool = False,\n        allow_oauth_cache: bool = True\n    ):\n        \"\"\"Construct a :class:`YouTube <YouTube>`.\n\n        :param str url:\n            A valid YouTube watch URL.\n        :param func on_progress_callback:\n            (Optional) User defined callback function for stream download\n            progress events.\n        :param func on_complete_callback:\n            (Optional) User defined callback function for stream download\n            complete events.\n        :param dict proxies:\n            (Optional) A dict mapping protocol to proxy address which will be used by pytube.\n        :param bool use_oauth:\n            (Optional) Prompt the user to authenticate to YouTube.\n            If allow_oauth_cache is set to True, the user should only be prompted once.\n        :param bool allow_oauth_cache:\n            (Optional) Cache OAuth tokens locally on the machine. Defaults to True.\n            These tokens are only generated if use_oauth is set to True as well.\n        \"\"\"\n        self._js: Optional[str] = None  # js fetched by js_url\n        self._js_url: Optional[str] = None  # the url to the js, parsed from watch html\n\n        self._vid_info: Optional[Dict] = None  # content fetched from innertube/player\n\n        self._watch_html: Optional[str] = None  # the html of /watch?v=<video_id>\n        self._embed_html: Optional[str] = None\n        self._player_config_args: Optional[Dict] = None  # inline js in the html containing\n        self._age_restricted: Optional[bool] = None\n\n        self._fmt_streams: Optional[List[Stream]] = None\n\n        self._initial_data = None\n        self._metadata: Optional[YouTubeMetadata] = None\n\n        # video_id part of /watch?v=<video_id>\n        self.video_id = extract.video_id(url)\n\n        self.watch_url = f\"https://youtube.com/watch?v={self.video_id}\"\n        self.embed_url = f\"https://www.youtube.com/embed/{self.video_id}\"\n\n        # Shared between all instances of `Stream` (Borg pattern).\n        self.stream_monostate = Monostate(\n            on_progress=on_progress_callback, on_complete=on_complete_callback\n        )\n\n        if proxies:\n            install_proxy(proxies)\n\n        self._author = None\n        self._title = None\n        self._publish_date = None\n\n        self.use_oauth = use_oauth\n        self.allow_oauth_cache = allow_oauth_cache",
          "docstring": "Construct a :class:`YouTube <YouTube>`.\n\n:param str url:\n    A valid YouTube watch URL.\n:param func on_progress_callback:\n    (Optional) User defined callback function for stream download\n    progress events.\n:param func on_complete_callback:\n    (Optional) User defined callback function for stream download\n    complete events.\n:param dict proxies:\n    (Optional) A dict mapping protocol to proxy address which will be used by pytube.\n:param bool use_oauth:\n    (Optional) Prompt the user to authenticate to YouTube.\n    If allow_oauth_cache is set to True, the user should only be prompted once.\n:param bool allow_oauth_cache:\n    (Optional) Cache OAuth tokens locally on the machine. Defaults to True.\n    These tokens are only generated if use_oauth is set to True as well.",
          "signature": "def __init__(self, url: str, on_progress_callback: Optional[Callable[[Any, bytes, int], None]]=None, on_complete_callback: Optional[Callable[[Any, Optional[str]], None]]=None, proxies: Dict[str, str]=None, use_oauth: bool=False, allow_oauth_cache: bool=True):",
          "type": "Method",
          "class_signature": "class YouTube:"
        },
        "YouTube.watch_html": {
          "code": "    def watch_html(self):\n        if self._watch_html:\n            return self._watch_html\n        self._watch_html = request.get(url=self.watch_url)\n        return self._watch_html",
          "docstring": "",
          "signature": "def watch_html(self):",
          "type": "Method",
          "class_signature": "class YouTube:"
        },
        "YouTube.embed_html": {
          "code": "    def embed_html(self):\n        if self._embed_html:\n            return self._embed_html\n        self._embed_html = request.get(url=self.embed_url)\n        return self._embed_html",
          "docstring": "",
          "signature": "def embed_html(self):",
          "type": "Method",
          "class_signature": "class YouTube:"
        },
        "YouTube.js": {
          "code": "    def js(self):\n        if self._js:\n            return self._js\n\n        # If the js_url doesn't match the cached url, fetch the new js and update\n        #  the cache; otherwise, load the cache.\n        if pytube.__js_url__ != self.js_url:\n            self._js = request.get(self.js_url)\n            pytube.__js__ = self._js\n            pytube.__js_url__ = self.js_url\n        else:\n            self._js = pytube.__js__\n\n        return self._js",
          "docstring": "",
          "signature": "def js(self):",
          "type": "Method",
          "class_signature": "class YouTube:"
        },
        "YouTube.vid_info": {
          "code": "    def vid_info(self):\n        \"\"\"Parse the raw vid info and return the parsed result.\n\n        :rtype: Dict[Any, Any]\n        \"\"\"\n        if self._vid_info:\n            return self._vid_info\n\n        innertube = InnerTube(use_oauth=self.use_oauth, allow_cache=self.allow_oauth_cache)\n\n        innertube_response = innertube.player(self.video_id)\n        self._vid_info = innertube_response\n        return self._vid_info",
          "docstring": "Parse the raw vid info and return the parsed result.\n\n:rtype: Dict[Any, Any]",
          "signature": "def vid_info(self):",
          "type": "Method",
          "class_signature": "class YouTube:"
        }
      }
    }
  },
  "call_tree": {
    "tests/test_helpers.py:test_regex_search_no_match": {
      "pytube/helpers.py:regex_search": {
        "pytube/exceptions.py:RegexMatchError:__init__": {}
      }
    },
    "tests/test_helpers.py:test_regex_search": {
      "pytube/helpers.py:regex_search": {}
    },
    "tests/test_helpers.py:test_safe_filename": {
      "pytube/helpers.py:safe_filename": {}
    },
    "tests/test_helpers.py:test_deprecated": {
      "pytube/helpers.py:deprecated": {},
      "pytube/helpers.py:decorator": {},
      "pytube/helpers.py:new_func1": {
        "tests/test_helpers.py:deprecated_function": {}
      }
    },
    "tests/test_helpers.py:test_cache": {
      "pytube/helpers.py:cache": {},
      "tests/test_helpers.py:cached_func": {}
    },
    "../app/pytube/tests/test_helpers.py:test_target_directory_with_relative_path": {
      "../app/pytube/pytube/helpers.py:target_directory": {}
    },
    "tests/test_helpers.py:test_target_directory_with_absolute_path": {
      "pytube/helpers.py:target_directory": {}
    },
    "../app/pytube/tests/test_helpers.py:test_target_directory_with_no_path": {
      "../app/pytube/pytube/helpers.py:target_directory": {}
    },
    "tests/test_helpers.py:test_setup_logger": {
      "pytube/helpers.py:setup_logger": {}
    },
    "tests/test_helpers.py:test_create_mock_html_json": {
      "pytube/helpers.py:create_mock_html_json": {
        "pytube/__main__.py:YouTube:__init__": {
          "pytube/extract.py:video_id": {
            "pytube/helpers.py:regex_search": {}
          },
          "pytube/monostate.py:Monostate:__init__": {}
        },
        "pytube/__main__.py:YouTube:js": {
          "pytube/__main__.py:YouTube:js_url": {
            "pytube/__main__.py:YouTube:age_restricted": {
              "pytube/__main__.py:YouTube:watch_html": {
                "pytube/request.py:get": {
                  "pytube/request.py:_execute_request": {}
                }
              },
              "pytube/extract.py:is_age_restricted": {
                "pytube/helpers.py:regex_search": {
                  "pytube/exceptions.py:RegexMatchError:__init__": {}
                }
              }
            },
            "pytube/__main__.py:YouTube:watch_html": {},
            "pytube/extract.py:js_url": {
              "pytube/extract.py:get_ytplayer_config": {
                "pytube/parser.py:parse_for_object": {
                  "pytube/parser.py:parse_for_object_from_startpoint": {
                    "pytube/parser.py:find_object_from_startpoint": {}
                  }
                }
              },
              "pytube/extract.py:get_ytplayer_js": {}
            }
          },
          "pytube/request.py:get": {
            "pytube/request.py:_execute_request": {}
          }
        },
        "pytube/__main__.py:YouTube:embed_html": {
          "pytube/request.py:get": {
            "pytube/request.py:_execute_request": {}
          }
        },
        "pytube/__main__.py:YouTube:watch_html": {},
        "pytube/__main__.py:YouTube:vid_info": {
          "pytube/innertube.py:InnerTube:__init__": {},
          "pytube/innertube.py:InnerTube:player": {
            "pytube/innertube.py:InnerTube:base_url": {},
            "pytube/innertube.py:InnerTube:base_params": {},
            "pytube/innertube.py:InnerTube:base_data": {},
            "pytube/innertube.py:InnerTube:_call_api": {
              "pytube/request.py:_execute_request": {}
            }
          }
        }
      }
    },
    "tests/test_helpers.py:test_uniqueify": {
      "pytube/helpers.py:uniqueify": {}
    }
  },
  "PRD": "# PROJECT NAME: pytube-test_helpers\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pytube/\n    \u2514\u2500\u2500 helpers.py\n        \u251c\u2500\u2500 cache\n        \u251c\u2500\u2500 create_mock_html_json\n        \u251c\u2500\u2500 decorator\n        \u251c\u2500\u2500 deprecated\n        \u251c\u2500\u2500 new_func1\n        \u251c\u2500\u2500 regex_search\n        \u251c\u2500\u2500 safe_filename\n        \u251c\u2500\u2500 setup_logger\n        \u251c\u2500\u2500 target_directory\n        \u2514\u2500\u2500 uniqueify\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides utility functions to support the functionality and testing of the pytube library, specifically focusing on streamlining common operations, ensuring compatibility, and maintaining code robustness. It includes features such as regular expression search validation, generation of safe filenames by removing unsafe characters, and efficient result caching to enhance performance and reduce redundant computations. Additional capabilities include directory path handling, customizable logger setup for debugging, and tools for creating mock HTML and JSON data structures for simulating external responses. This module solves challenges related to simplifying repetitive tasks, improving code reliability, and enabling efficient testing workflows for developers working with pytube or related systems.\n\n## FILE 1: pytube/helpers.py\n\n- FUNCTION NAME: cache\n  - SIGNATURE: def cache(func: Callable[..., GenericType]) -> GenericType:\n  - DOCSTRING: \n```python\n\"\"\"\nThis function serves as a decorator that applies Python's built-in Least Recently Used (LRU) cache to the provided function, allowing for memoization of its results. \n\n:param func: A callable function that takes any number of arguments.\n:type func: Callable[..., GenericType]\n:returns: A cached version of the input function that uses an LRU caching mechanism to store results of expensive function calls.\n:rtype: GenericType\n\nThe `lru_cache` from the `functools` module optimizes function calls by storing previously computed results and returning them when the same inputs occur again, thus reducing the computation time for repeated calls. This is particularly useful in scenarios where a function is likely to be called with the same parameters multiple times, as seen in data processing or computational tasks within the broader Pytube codebase.\n\"\"\"\n```\n\n- FUNCTION NAME: create_mock_html_json\n  - SIGNATURE: def create_mock_html_json(vid_id) -> Dict[str, Any]:\n  - DOCSTRING: \n```python\n\"\"\"\nGenerate a JSON.gz file containing sample HTML responses for a specified YouTube video.\n\n:param str vid_id: The YouTube video ID for which the mock HTML data will be generated.\n:return: A dictionary containing the video's URL, JavaScript, embed HTML, watch HTML, and video information.\n:rtype: dict\n:raises: This function interacts with the `YouTube` class from the `pytube` module to fetch video data based on the given `vid_id`. It generates a file named `yt-video-<vid_id>-html.json.gz` in the `tests/mocks` directory, which is determined based on the module's directory structure. The function logs the output file path during execution using the configured logger.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/__main__.py:YouTube:embed_html\n    - pytube/__main__.py:YouTube:watch_html\n    - pytube/__main__.py:YouTube:__init__\n    - pytube/__main__.py:YouTube:js\n    - pytube/__main__.py:YouTube:vid_info\n\n- FUNCTION NAME: target_directory\n  - SIGNATURE: def target_directory(output_path: Optional[str]=None) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nDetermine the target directory for downloads, returning an absolute path. If a relative path is provided, it combines it with the current working directory. If no path is given, it defaults to the current working directory. The function ensures that the target directory exists by creating it if necessary.\n\nParameters:\n- output_path (Optional[str]): A string representing the desired output directory. If None, defaults to the current working directory.\n\nReturns:\n- str: An absolute path to the target directory.\n\nSide Effects:\n- Creates the directory specified by output_path if it does not already exist, using os.makedirs with exist_ok set to True.\n\nDependencies:\n- The function uses the os module to handle file system operations, specifically os.path.isabs to check for absolute paths and os.makedirs to create the directory.\n\"\"\"\n```\n\n- FUNCTION NAME: setup_logger\n  - SIGNATURE: def setup_logger(level: int=logging.ERROR, log_filename: Optional[str]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate and configure a logger instance for the pytube library.\n\nThis function sets up a logger with a specified logging level and, optionally, a log file to capture log messages. The log messages are formatted to include the timestamp, severity level, module name, and message. The logger instance created is named \"pytube\" and can handle output to both the console and a specified log file.\n\nParameters:\n- level (int): The logging level to set for the logger (default is logging.ERROR).\n- log_filename (Optional[str]): If provided, the path to a file where log messages should be saved.\n\nReturns:\n- None: This function modifies the global logger configuration without returning any values.\n\nDependencies:\n- The function leverages the Python logging module to configure log output and formatting.\n\nConstants:\n- fmt: This string defines the format of log messages, including placeholders for the timestamp, log level, module name, and the log message itself.\n- date_fmt: This string is used to specify the format of the timestamp within the log messages.\n\"\"\"\n```\n\n- FUNCTION NAME: uniqueify\n  - SIGNATURE: def uniqueify(duped_list: List) -> List:\n  - DOCSTRING: \n```python\n\"\"\"\nRemove duplicate items from a list while preserving the original order.\n\n:param List duped_list: A list from which duplicates will be removed.\n:return List result: A new list containing only unique items, in the order they first appeared in `duped_list`.\n\nThis function utilizes a dictionary named `seen` to keep track of items that have already been encountered. By checking against this dictionary, it effectively filters out duplicates without altering the order of the original list. The use of `Dict[Any, bool]` for `seen` ensures that any item type can be processed.\n\"\"\"\n```\n\n- FUNCTION NAME: new_func1\n  - SIGNATURE: def new_func1(*args, **kwargs):\n  - DOCSTRING: \n```python\n\"\"\"\nWraps a callable function to emit a deprecation warning when the function is invoked.\n\nParameters:\n- *args: Positional arguments to pass to the wrapped function.\n- **kwargs: Keyword arguments to pass to the wrapped function.\n\nReturns:\n- The return value from the original wrapped function.\n\nSide Effects:\n- Emits a DeprecationWarning, which is configured to always show for the current execution context. This warning includes the name of the function being called and the reason for its deprecation, allowing users to be informed that they are using a function that may be removed in future releases.\n\nConstants:\n- `message`: A formatted string that contains the warning message, utilizing the wrapped function's name (retrieved via `func1.__name__`) and the `reason` specified when decorating the function. This constant is significant for notifying users about the deprecation of the function.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/test_helpers.py:deprecated_function\n\n- FUNCTION NAME: deprecated\n  - SIGNATURE: def deprecated(reason: str) -> Callable:\n  - DOCSTRING: \n```python\n\"\"\"\nThis is a decorator function `deprecated` that marks other functions as deprecated, issuing a warning whenever the deprecated function is called. \n\nParameters:\n- `reason` (str): A string explaining the reason for deprecation, which is included in the warning message to inform users of the deprecated status.\n\nReturns:\n- Callable: A wrapped version of the original function, which triggers a deprecation warning when invoked.\n\nThis function uses the `warnings` module to issue a `DeprecationWarning`, adjusting the warnings filter to ensure that the warning is emitted every time the decorated function is called. The message format includes the name of the deprecated function and the reason for its deprecation, helping developers understand why they should avoid using it. The logging behavior is configured in other parts of the code, but this function specifically handles the emission of deprecation warnings.\n\"\"\"\n```\n\n- FUNCTION NAME: regex_search\n  - SIGNATURE: def regex_search(pattern: str, string: str, group: int) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nShortcut method to search a string for a given regular expression pattern and return a specific matched group.\n\n:param str pattern: A regular expression pattern used to search within the provided string.\n:param str string: The target string in which to search for the pattern.\n:param int group: The index of the group to return from the matched results.\n:rtype: str\n:returns: The substring that matches the specified group from the regex search.\n:raises RegexMatchError: If no match is found, a RegexMatchError is raised, indicating that the pattern did not match the string.\n\nThis function leverages the `re` module for regex operations and utilizes the `RegexMatchError` class from the `pytube.exceptions` module to handle matching errors. Additionally, it logs a debug message when a successful match occurs, using the configured logger to assist with tracing and debugging.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pytube/exceptions.py:RegexMatchError:__init__\n\n- FUNCTION NAME: decorator\n  - SIGNATURE: def decorator(func1):\n  - DOCSTRING: \n```python\n\"\"\"\nThis decorator marks functions as deprecated, issuing a warning each time the decorated function is called. \n\nParameters:\n- reason (str): A message explaining the reason for deprecation.\n\nReturns:\n- Callable: A wrapped function that emits a DeprecationWarning when called, along with executing the original function.\n\nThe decorator utilizes the `warnings` module to generate the warning and `functools.wraps` to preserve the metadata of the original function. The warning message includes the name of the deprecated function and the reason for its deprecation, formatted using the `message` string.\n\"\"\"\n```\n\n- FUNCTION NAME: safe_filename\n  - SIGNATURE: def safe_filename(s: str, max_length: int=255) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nSanitize a string to make it safe for use as a filename, ensuring compliance with NTFS filename restrictions and a specified maximum length.\n\nParameters:\n- s (str): The input string that will be sanitized to create a safe filename.\n- max_length (int, optional): The maximum allowed length for the filename (default is 255 characters).\n\nReturns:\n- str: A sanitized version of the input string, truncated to max_length if necessary.\n\nNotes:\nThis function removes any characters that are not permitted in NTFS filenames, specifically those in the range of characters 0-31 and a set of additional special characters. The sanitization process uses a regular expression pattern to identify these invalid characters and replace them with an empty string. The resulting filename is then trimmed to the specified maximum length, ensuring it adheres to filesystem constraints. If the sanitized string ends in a space, it removes that character to prevent trailing spaces in filenames.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pytube/helpers.py": "\"\"\"Various helper functions implemented by pytube.\"\"\"\nimport functools\nimport gzip\nimport json\nimport logging\nimport os\nimport re\nimport warnings\nfrom typing import Any, Callable, Dict, List, Optional, TypeVar\nfrom urllib import request\nfrom pytube.exceptions import RegexMatchError\nlogger = logging.getLogger(__name__)\n\nclass DeferredGeneratorList:\n    \"\"\"A wrapper class for deferring list generation.\n\n    Pytube has some continuation generators that create web calls, which means\n    that any time a full list is requested, all of those web calls must be\n    made at once, which could lead to slowdowns. This will allow individual\n    elements to be queried, so that slowdowns only happen as necessary. For\n    example, you can iterate over elements in the list without accessing them\n    all simultaneously. This should allow for speed improvements for playlist\n    and channel interactions.\n    \"\"\"\n\n    def __init__(self, generator):\n        \"\"\"Construct a :class:`DeferredGeneratorList <DeferredGeneratorList>`.\n\n        :param generator generator:\n            The deferrable generator to create a wrapper for.\n        :param func func:\n            (Optional) A function to call on the generator items to produce the list.\n        \"\"\"\n        self.gen = generator\n        self._elements = []\n\n    def __eq__(self, other):\n        \"\"\"We want to mimic list behavior for comparison.\"\"\"\n        return list(self) == other\n\n    def __getitem__(self, key) -> Any:\n        \"\"\"Only generate items as they're asked for.\"\"\"\n        if not isinstance(key, (int, slice)):\n            raise TypeError('Key must be either a slice or int.')\n        key_slice = key\n        if isinstance(key, int):\n            key_slice = slice(key, key + 1, 1)\n        while len(self._elements) < key_slice.stop:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                raise IndexError\n            else:\n                self._elements.append(next_item)\n        return self._elements[key]\n\n    def __iter__(self):\n        \"\"\"Custom iterator for dynamically generated list.\"\"\"\n        iter_index = 0\n        while True:\n            try:\n                curr_item = self[iter_index]\n            except IndexError:\n                return\n            else:\n                yield curr_item\n                iter_index += 1\n\n    def __next__(self) -> Any:\n        \"\"\"Fetch next element in iterator.\"\"\"\n        try:\n            curr_element = self[self.iter_index]\n        except IndexError:\n            raise StopIteration\n        self.iter_index += 1\n        return curr_element\n\n    def __len__(self) -> int:\n        \"\"\"Return length of list of all items.\"\"\"\n        self.generate_all()\n        return len(self._elements)\n\n    def __repr__(self) -> str:\n        \"\"\"String representation of all items.\"\"\"\n        self.generate_all()\n        return str(self._elements)\n\n    def __reversed__(self):\n        self.generate_all()\n        return self._elements[::-1]\n\n    def generate_all(self):\n        \"\"\"Generate all items.\"\"\"\n        while True:\n            try:\n                next_item = next(self.gen)\n            except StopIteration:\n                break\n            else:\n                self._elements.append(next_item)\nGenericType = TypeVar('GenericType')\n\ndef install_proxy(proxy_handler: Dict[str, str]) -> None:\n    proxy_support = request.ProxyHandler(proxy_handler)\n    opener = request.build_opener(proxy_support)\n    request.install_opener(opener)\n\ndef generate_all_html_json_mocks():\n    \"\"\"Regenerate the video mock json files for all current test videos.\n\n    This should automatically output to the test/mocks directory.\n    \"\"\"\n    test_vid_ids = ['2lAe1cqCOXo', '5YceQ8YqYMc', 'irauhITDrsE', 'm8uHb5jIGN8', 'QRS8MkLhQmM', 'WXxV9g7lsFE']\n    for vid_id in test_vid_ids:\n        create_mock_html_json(vid_id)"
  }
}