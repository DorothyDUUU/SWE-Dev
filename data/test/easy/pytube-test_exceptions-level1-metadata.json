{
  "dir_path": "/app/pytube",
  "package_name": "pytube",
  "sample_name": "pytube-test_exceptions",
  "src_dir": "pytube/",
  "test_dir": "tests/",
  "test_file": "tests/test_exceptions.py",
  "test_code": "import pytest\nfrom unittest import mock\n\nimport pytube.exceptions as exceptions\nfrom pytube import YouTube\n\n\ndef test_video_unavailable():\n    try:\n        raise exceptions.VideoUnavailable(video_id=\"YLnZklYFe7E\")\n    except exceptions.VideoUnavailable as e:\n        assert e.video_id == \"YLnZklYFe7E\"  # noqa: PT017\n        assert str(e) == \"YLnZklYFe7E is unavailable\"\n\n\ndef test_regex_match_error():\n    try:\n        raise exceptions.RegexMatchError(caller=\"hello\", pattern=\"*\")\n    except exceptions.RegexMatchError as e:\n        assert str(e) == \"hello: could not find match for *\"\n\n\ndef test_live_stream_error():\n    # Ensure this can be caught as generic VideoUnavailable exception\n    with pytest.raises(exceptions.VideoUnavailable):\n        raise exceptions.LiveStreamError(video_id='YLnZklYFe7E')\n    try:\n        raise exceptions.LiveStreamError(video_id='YLnZklYFe7E')\n    except exceptions.LiveStreamError as e:\n        assert e.video_id == 'YLnZklYFe7E'  # noqa: PT017\n        assert str(e) == 'YLnZklYFe7E is streaming live and cannot be loaded'\n\n\ndef test_recording_unavailable_error():\n    # Ensure this can be caught as generic VideoUnavailable exception\n    with pytest.raises(exceptions.VideoUnavailable):\n        raise exceptions.RecordingUnavailable(video_id='5YceQ8YqYMc')\n    try:\n        raise exceptions.RecordingUnavailable(video_id='5YceQ8YqYMc')\n    except exceptions.RecordingUnavailable as e:\n        assert e.video_id == '5YceQ8YqYMc'  # noqa: PT017\n        assert str(e) == '5YceQ8YqYMc does not have a live stream recording available'\n\n\ndef test_private_error():\n    # Ensure this can be caught as generic VideoUnavailable exception\n    with pytest.raises(exceptions.VideoUnavailable):\n        raise exceptions.VideoPrivate('m8uHb5jIGN8')\n    try:\n        raise exceptions.VideoPrivate('m8uHb5jIGN8')\n    except exceptions.VideoPrivate as e:\n        assert e.video_id == 'm8uHb5jIGN8'  # noqa: PT017\n        assert str(e) == 'm8uHb5jIGN8 is a private video'\n\n\ndef test_region_locked_error():\n    # Ensure this can be caught as generic VideoUnavailable exception\n    with pytest.raises(exceptions.VideoUnavailable):\n        raise exceptions.VideoRegionBlocked('hZpzr8TbF08')\n    try:\n        raise exceptions.VideoRegionBlocked('hZpzr8TbF08')\n    except exceptions.VideoRegionBlocked as e:\n        assert e.video_id == 'hZpzr8TbF08'  # noqa: PT017\n        assert str(e) == 'hZpzr8TbF08 is not available in your region'\n\n\ndef test_raises_video_private(private):\n    with mock.patch('pytube.request.urlopen') as mock_url_open:\n        # Mock the responses to YouTube\n        mock_url_open_object = mock.Mock()\n        mock_url_open_object.read.side_effect = [\n            private['watch_html'].encode('utf-8'),\n        ]\n        mock_url_open.return_value = mock_url_open_object\n        with pytest.raises(exceptions.VideoPrivate):\n            YouTube('https://youtube.com/watch?v=m8uHb5jIGN8').streams\n\n\ndef test_raises_recording_unavailable(missing_recording):\n    with mock.patch('pytube.request.urlopen') as mock_url_open:\n        # Mock the responses to YouTube\n        mock_url_open_object = mock.Mock()\n        mock_url_open_object.read.side_effect = [\n            missing_recording['watch_html'].encode('utf-8'),\n        ]\n        mock_url_open.return_value = mock_url_open_object\n        with pytest.raises(exceptions.RecordingUnavailable):\n            YouTube('https://youtube.com/watch?v=5YceQ8YqYMc').streams\n",
  "GT_file_code": {
    "pytube/exceptions.py": "\"\"\"Library specific exception definitions.\"\"\"\nfrom typing import Pattern, Union\n\n\nclass PytubeError(Exception):\n    \"\"\"Base pytube exception that all others inherit.\n\n    This is done to not pollute the built-in exceptions, which *could* result\n    in unintended errors being unexpectedly and incorrectly handled within\n    implementers code.\n    \"\"\"\n\n\nclass MaxRetriesExceeded(PytubeError):\n    \"\"\"Maximum number of retries exceeded.\"\"\"\n\n\nclass HTMLParseError(PytubeError):\n    \"\"\"HTML could not be parsed\"\"\"\n\n\nclass ExtractError(PytubeError):\n    \"\"\"Data extraction based exception.\"\"\"\n\n\nclass RegexMatchError(ExtractError):\n    \"\"\"Regex pattern did not return any matches.\"\"\"\n\n    def __init__(self, caller: str, pattern: Union[str, Pattern]):\n        \"\"\"\n        :param str caller:\n            Calling function\n        :param str pattern:\n            Pattern that failed to match\n        \"\"\"\n        super().__init__(f\"{caller}: could not find match for {pattern}\")\n        self.caller = caller\n        self.pattern = pattern\n\n\nclass VideoUnavailable(PytubeError):\n    \"\"\"Base video unavailable error.\"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.error_string)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is unavailable'\n\n\nclass AgeRestrictedError(VideoUnavailable):\n    \"\"\"Video is age restricted, and cannot be accessed without OAuth.\"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f\"{self.video_id} is age restricted, and can't be accessed without logging in.\"\n\n\nclass LiveStreamError(VideoUnavailable):\n    \"\"\"Video is a live stream.\"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is streaming live and cannot be loaded'\n\n\nclass VideoPrivate(VideoUnavailable):\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a private video'\n\n\nclass RecordingUnavailable(VideoUnavailable):\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} does not have a live stream recording available'\n\n\nclass MembersOnly(VideoUnavailable):\n    \"\"\"Video is members-only.\n\n    YouTube has special videos that are only viewable to users who have\n    subscribed to a content creator.\n    ref: https://support.google.com/youtube/answer/7544492?hl=en\n    \"\"\"\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a members-only video'\n\n\nclass VideoRegionBlocked(VideoUnavailable):\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is not available in your region'\n",
    "pytube/__main__.py": "\"\"\"\nThis module implements the core developer interface for pytube.\n\nThe problem domain of the :class:`YouTube <YouTube> class focuses almost\nexclusively on the developer interface. Pytube offloads the heavy lifting to\nsmaller peripheral modules and functions.\n\n\"\"\"\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional\n\nimport pytube\nimport pytube.exceptions as exceptions\nfrom pytube import extract, request\nfrom pytube import Stream, StreamQuery\nfrom pytube.helpers import install_proxy\nfrom pytube.innertube import InnerTube\nfrom pytube.metadata import YouTubeMetadata\nfrom pytube.monostate import Monostate\n\nlogger = logging.getLogger(__name__)\n\n\nclass YouTube:\n    \"\"\"Core developer interface for pytube.\"\"\"\n\n    def __init__(\n        self,\n        url: str,\n        on_progress_callback: Optional[Callable[[Any, bytes, int], None]] = None,\n        on_complete_callback: Optional[Callable[[Any, Optional[str]], None]] = None,\n        proxies: Dict[str, str] = None,\n        use_oauth: bool = False,\n        allow_oauth_cache: bool = True\n    ):\n        \"\"\"Construct a :class:`YouTube <YouTube>`.\n\n        :param str url:\n            A valid YouTube watch URL.\n        :param func on_progress_callback:\n            (Optional) User defined callback function for stream download\n            progress events.\n        :param func on_complete_callback:\n            (Optional) User defined callback function for stream download\n            complete events.\n        :param dict proxies:\n            (Optional) A dict mapping protocol to proxy address which will be used by pytube.\n        :param bool use_oauth:\n            (Optional) Prompt the user to authenticate to YouTube.\n            If allow_oauth_cache is set to True, the user should only be prompted once.\n        :param bool allow_oauth_cache:\n            (Optional) Cache OAuth tokens locally on the machine. Defaults to True.\n            These tokens are only generated if use_oauth is set to True as well.\n        \"\"\"\n        self._js: Optional[str] = None  # js fetched by js_url\n        self._js_url: Optional[str] = None  # the url to the js, parsed from watch html\n\n        self._vid_info: Optional[Dict] = None  # content fetched from innertube/player\n\n        self._watch_html: Optional[str] = None  # the html of /watch?v=<video_id>\n        self._embed_html: Optional[str] = None\n        self._player_config_args: Optional[Dict] = None  # inline js in the html containing\n        self._age_restricted: Optional[bool] = None\n\n        self._fmt_streams: Optional[List[Stream]] = None\n\n        self._initial_data = None\n        self._metadata: Optional[YouTubeMetadata] = None\n\n        # video_id part of /watch?v=<video_id>\n        self.video_id = extract.video_id(url)\n\n        self.watch_url = f\"https://youtube.com/watch?v={self.video_id}\"\n        self.embed_url = f\"https://www.youtube.com/embed/{self.video_id}\"\n\n        # Shared between all instances of `Stream` (Borg pattern).\n        self.stream_monostate = Monostate(\n            on_progress=on_progress_callback, on_complete=on_complete_callback\n        )\n\n        if proxies:\n            install_proxy(proxies)\n\n        self._author = None\n        self._title = None\n        self._publish_date = None\n\n        self.use_oauth = use_oauth\n        self.allow_oauth_cache = allow_oauth_cache\n\n    def __repr__(self):\n        return f'<pytube.__main__.YouTube object: videoId={self.video_id}>'\n\n    def __eq__(self, o: object) -> bool:\n        # Compare types and urls, if they're same return true, else return false.\n        return type(o) == type(self) and o.watch_url == self.watch_url\n\n    @property\n    def watch_html(self):\n        if self._watch_html:\n            return self._watch_html\n        self._watch_html = request.get(url=self.watch_url)\n        return self._watch_html\n\n    @property\n    def embed_html(self):\n        if self._embed_html:\n            return self._embed_html\n        self._embed_html = request.get(url=self.embed_url)\n        return self._embed_html\n\n    @property\n    def age_restricted(self):\n        if self._age_restricted:\n            return self._age_restricted\n        self._age_restricted = extract.is_age_restricted(self.watch_html)\n        return self._age_restricted\n\n    @property\n    def js_url(self):\n        if self._js_url:\n            return self._js_url\n\n        if self.age_restricted:\n            self._js_url = extract.js_url(self.embed_html)\n        else:\n            self._js_url = extract.js_url(self.watch_html)\n\n        return self._js_url\n\n    @property\n    def js(self):\n        if self._js:\n            return self._js\n\n        # If the js_url doesn't match the cached url, fetch the new js and update\n        #  the cache; otherwise, load the cache.\n        if pytube.__js_url__ != self.js_url:\n            self._js = request.get(self.js_url)\n            pytube.__js__ = self._js\n            pytube.__js_url__ = self.js_url\n        else:\n            self._js = pytube.__js__\n\n        return self._js\n\n    @property\n    def initial_data(self):\n        if self._initial_data:\n            return self._initial_data\n        self._initial_data = extract.initial_data(self.watch_html)\n        return self._initial_data\n\n    @property\n    def streaming_data(self):\n        \"\"\"Return streamingData from video info.\"\"\"\n        if 'streamingData' in self.vid_info:\n            return self.vid_info['streamingData']\n        else:\n            self.bypass_age_gate()\n            return self.vid_info['streamingData']\n\n    @property\n    def fmt_streams(self):\n        \"\"\"Returns a list of streams if they have been initialized.\n\n        If the streams have not been initialized, finds all relevant\n        streams and initializes them.\n        \"\"\"\n        self.check_availability()\n        if self._fmt_streams:\n            return self._fmt_streams\n\n        self._fmt_streams = []\n\n        stream_manifest = extract.apply_descrambler(self.streaming_data)\n\n        # If the cached js doesn't work, try fetching a new js file\n        # https://github.com/pytube/pytube/issues/1054\n        try:\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n        except exceptions.ExtractError:\n            # To force an update to the js file, we clear the cache and retry\n            self._js = None\n            self._js_url = None\n            pytube.__js__ = None\n            pytube.__js_url__ = None\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n\n        # build instances of :class:`Stream <Stream>`\n        # Initialize stream objects\n        for stream in stream_manifest:\n            video = Stream(\n                stream=stream,\n                monostate=self.stream_monostate,\n            )\n            self._fmt_streams.append(video)\n\n        self.stream_monostate.title = self.title\n        self.stream_monostate.duration = self.length\n\n        return self._fmt_streams\n\n    def check_availability(self):\n        \"\"\"Check whether the video is available.\n\n        Raises different exceptions based on why the video is unavailable,\n        otherwise does nothing.\n        \"\"\"\n        status, messages = extract.playability_status(self.watch_html)\n\n        for reason in messages:\n            if status == 'UNPLAYABLE':\n                if reason == (\n                    'Join this channel to get access to members-only content '\n                    'like this video, and other exclusive perks.'\n                ):\n                    raise exceptions.MembersOnly(video_id=self.video_id)\n                elif reason == 'This live stream recording is not available.':\n                    raise exceptions.RecordingUnavailable(video_id=self.video_id)\n                else:\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LOGIN_REQUIRED':\n                if reason == (\n                    'This is a private video. '\n                    'Please sign in to verify that you may see it.'\n                ):\n                    raise exceptions.VideoPrivate(video_id=self.video_id)\n            elif status == 'ERROR':\n                if reason == 'Video unavailable':\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LIVE_STREAM':\n                raise exceptions.LiveStreamError(video_id=self.video_id)\n\n    @property\n    def vid_info(self):\n        \"\"\"Parse the raw vid info and return the parsed result.\n\n        :rtype: Dict[Any, Any]\n        \"\"\"\n        if self._vid_info:\n            return self._vid_info\n\n        innertube = InnerTube(use_oauth=self.use_oauth, allow_cache=self.allow_oauth_cache)\n\n        innertube_response = innertube.player(self.video_id)\n        self._vid_info = innertube_response\n        return self._vid_info\n\n    def bypass_age_gate(self):\n        \"\"\"Attempt to update the vid_info by bypassing the age gate.\"\"\"\n        innertube = InnerTube(\n            client='ANDROID_EMBED',\n            use_oauth=self.use_oauth,\n            allow_cache=self.allow_oauth_cache\n        )\n        innertube_response = innertube.player(self.video_id)\n\n        playability_status = innertube_response['playabilityStatus'].get('status', None)\n\n        # If we still can't access the video, raise an exception\n        # (tier 3 age restriction)\n        if playability_status == 'UNPLAYABLE':\n            raise exceptions.AgeRestrictedError(self.video_id)\n\n        self._vid_info = innertube_response\n\n    @property\n    def caption_tracks(self) -> List[pytube.Caption]:\n        \"\"\"Get a list of :class:`Caption <Caption>`.\n\n        :rtype: List[Caption]\n        \"\"\"\n        raw_tracks = (\n            self.vid_info.get(\"captions\", {})\n            .get(\"playerCaptionsTracklistRenderer\", {})\n            .get(\"captionTracks\", [])\n        )\n        return [pytube.Caption(track) for track in raw_tracks]\n\n    @property\n    def captions(self) -> pytube.CaptionQuery:\n        \"\"\"Interface to query caption tracks.\n\n        :rtype: :class:`CaptionQuery <CaptionQuery>`.\n        \"\"\"\n        return pytube.CaptionQuery(self.caption_tracks)\n\n    @property\n    def streams(self) -> StreamQuery:\n        \"\"\"Interface to query both adaptive (DASH) and progressive streams.\n\n        :rtype: :class:`StreamQuery <StreamQuery>`.\n        \"\"\"\n        self.check_availability()\n        return StreamQuery(self.fmt_streams)\n\n    @property\n    def thumbnail_url(self) -> str:\n        \"\"\"Get the thumbnail url image.\n\n        :rtype: str\n        \"\"\"\n        thumbnail_details = (\n            self.vid_info.get(\"videoDetails\", {})\n            .get(\"thumbnail\", {})\n            .get(\"thumbnails\")\n        )\n        if thumbnail_details:\n            thumbnail_details = thumbnail_details[-1]  # last item has max size\n            return thumbnail_details[\"url\"]\n\n        return f\"https://img.youtube.com/vi/{self.video_id}/maxresdefault.jpg\"\n\n    @property\n    def publish_date(self):\n        \"\"\"Get the publish date.\n\n        :rtype: datetime\n        \"\"\"\n        if self._publish_date:\n            return self._publish_date\n        self._publish_date = extract.publish_date(self.watch_html)\n        return self._publish_date\n\n    @publish_date.setter\n    def publish_date(self, value):\n        \"\"\"Sets the publish date.\"\"\"\n        self._publish_date = value\n\n    @property\n    def title(self) -> str:\n        \"\"\"Get the video title.\n\n        :rtype: str\n        \"\"\"\n        if self._title:\n            return self._title\n\n        try:\n            self._title = self.vid_info['videoDetails']['title']\n        except KeyError:\n            # Check_availability will raise the correct exception in most cases\n            #  if it doesn't, ask for a report.\n            self.check_availability()\n            raise exceptions.PytubeError(\n                (\n                    f'Exception while accessing title of {self.watch_url}. '\n                    'Please file a bug report at https://github.com/pytube/pytube'\n                )\n            )\n\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        \"\"\"Sets the title value.\"\"\"\n        self._title = value\n\n    @property\n    def description(self) -> str:\n        \"\"\"Get the video description.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get(\"videoDetails\", {}).get(\"shortDescription\")\n\n    @property\n    def rating(self) -> float:\n        \"\"\"Get the video average rating.\n\n        :rtype: float\n\n        \"\"\"\n        return self.vid_info.get(\"videoDetails\", {}).get(\"averageRating\")\n\n    @property\n    def length(self) -> int:\n        \"\"\"Get the video length in seconds.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get('videoDetails', {}).get('lengthSeconds'))\n\n    @property\n    def views(self) -> int:\n        \"\"\"Get the number of the times the video has been viewed.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get(\"videoDetails\", {}).get(\"viewCount\"))\n\n    @property\n    def author(self) -> str:\n        \"\"\"Get the video author.\n        :rtype: str\n        \"\"\"\n        if self._author:\n            return self._author\n        self._author = self.vid_info.get(\"videoDetails\", {}).get(\n            \"author\", \"unknown\"\n        )\n        return self._author\n\n    @author.setter\n    def author(self, value):\n        \"\"\"Set the video author.\"\"\"\n        self._author = value\n\n    @property\n    def keywords(self) -> List[str]:\n        \"\"\"Get the video keywords.\n\n        :rtype: List[str]\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('keywords', [])\n\n    @property\n    def channel_id(self) -> str:\n        \"\"\"Get the video poster's channel id.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('channelId', None)\n\n    @property\n    def channel_url(self) -> str:\n        \"\"\"Construct the channel url for the video's poster from the channel id.\n\n        :rtype: str\n        \"\"\"\n        return f'https://www.youtube.com/channel/{self.channel_id}'\n\n    @property\n    def metadata(self) -> Optional[YouTubeMetadata]:\n        \"\"\"Get the metadata for the video.\n\n        :rtype: YouTubeMetadata\n        \"\"\"\n        if self._metadata:\n            return self._metadata\n        else:\n            self._metadata = extract.metadata(self.initial_data)\n            return self._metadata\n\n    def register_on_progress_callback(self, func: Callable[[Any, bytes, int], None]):\n        \"\"\"Register a download progress callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream``, ``chunk``,\n             and ``bytes_remaining`` as parameters.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_progress = func\n\n    def register_on_complete_callback(self, func: Callable[[Any, Optional[str]], None]):\n        \"\"\"Register a download complete callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream`` and  ``file_path``.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_complete = func\n\n    @staticmethod\n    def from_id(video_id: str) -> \"YouTube\":\n        \"\"\"Construct a :class:`YouTube <YouTube>` object from a video id.\n\n        :param str video_id:\n            The video id of the YouTube video.\n\n        :rtype: :class:`YouTube <YouTube>`\n        \n        \"\"\"\n        return YouTube(f\"https://www.youtube.com/watch?v={video_id}\")\n"
  },
  "GT_src_dict": {
    "pytube/exceptions.py": {
      "RegexMatchError.__init__": {
        "code": "    def __init__(self, caller: str, pattern: Union[str, Pattern]):\n        \"\"\"Initializes a RegexMatchError exception instance, which is raised when a regex pattern fails to find a match. \n\nParameters:\n- caller (str): The name of the calling function that triggered the error.\n- pattern (Union[str, Pattern]): The regex pattern that was expected to match but did not.\n\nThis constructor calls the superclass (ExtractError) initializer with a formatted error message indicating the caller and the pattern that failed to match. The `caller` and `pattern` are stored as instance attributes for further inspection or debugging purposes. This exception inherits from PytubeError, which allows it to be distinguished from built-in exceptions in application error handling. It is used in scenarios where data extraction relies on regex matching, indicating why certain expected data could not be retrieved.\"\"\"\n        '\\n        :param str caller:\\n            Calling function\\n        :param str pattern:\\n            Pattern that failed to match\\n        '\n        super().__init__(f'{caller}: could not find match for {pattern}')\n        self.caller = caller\n        self.pattern = pattern",
        "docstring": "Initializes a RegexMatchError exception instance, which is raised when a regex pattern fails to find a match. \n\nParameters:\n- caller (str): The name of the calling function that triggered the error.\n- pattern (Union[str, Pattern]): The regex pattern that was expected to match but did not.\n\nThis constructor calls the superclass (ExtractError) initializer with a formatted error message indicating the caller and the pattern that failed to match. The `caller` and `pattern` are stored as instance attributes for further inspection or debugging purposes. This exception inherits from PytubeError, which allows it to be distinguished from built-in exceptions in application error handling. It is used in scenarios where data extraction relies on regex matching, indicating why certain expected data could not be retrieved.",
        "signature": "def __init__(self, caller: str, pattern: Union[str, Pattern]):",
        "type": "Method",
        "class_signature": "class RegexMatchError(ExtractError):"
      },
      "VideoUnavailable.__init__": {
        "code": "    def __init__(self, video_id: str):\n        \"\"\"Initializes a VideoUnavailable exception, which indicates that a specified YouTube video is not accessible. \n\nParameters:\n    video_id (str): A YouTube video identifier that represents the video which is unavailable.\n\nThis constructor sets the instance variable `self.video_id` to the provided video ID and calls the superclass constructor with a generated error message from the `error_string` property. The `error_string` provides a descriptive error message regarding the unavailability of the video, leveraging the `video_id` for identification. There are no return values, but the instance will raise a VideoUnavailable error when instantiated.\"\"\"\n        '\\n        :param str video_id:\\n            A YouTube video identifier.\\n        '\n        self.video_id = video_id\n        super().__init__(self.error_string)",
        "docstring": "Initializes a VideoUnavailable exception, which indicates that a specified YouTube video is not accessible. \n\nParameters:\n    video_id (str): A YouTube video identifier that represents the video which is unavailable.\n\nThis constructor sets the instance variable `self.video_id` to the provided video ID and calls the superclass constructor with a generated error message from the `error_string` property. The `error_string` provides a descriptive error message regarding the unavailability of the video, leveraging the `video_id` for identification. There are no return values, but the instance will raise a VideoUnavailable error when instantiated.",
        "signature": "def __init__(self, video_id: str):",
        "type": "Method",
        "class_signature": "class VideoUnavailable(PytubeError):"
      },
      "LiveStreamError.__init__": {
        "code": "    def __init__(self, video_id: str):\n        \"\"\"Initialize a LiveStreamError instance, which represents an error encountered when attempting to access a live-streaming video on YouTube.\n\nParameters:\n- video_id (str): A unique identifier for a YouTube video, indicating the specific stream that is not accessible.\n\nThe constructor calls the parent class (VideoUnavailable) initializer with the provided video_id, which is also stored as an instance attribute. This allows for consistent error handling across different video availability issues. The error message generated will indicate that the specified video is currently live streaming and cannot be loaded.\"\"\"\n        '\\n        :param str video_id:\\n            A YouTube video identifier.\\n        '\n        self.video_id = video_id\n        super().__init__(self.video_id)",
        "docstring": "Initialize a LiveStreamError instance, which represents an error encountered when attempting to access a live-streaming video on YouTube.\n\nParameters:\n- video_id (str): A unique identifier for a YouTube video, indicating the specific stream that is not accessible.\n\nThe constructor calls the parent class (VideoUnavailable) initializer with the provided video_id, which is also stored as an instance attribute. This allows for consistent error handling across different video availability issues. The error message generated will indicate that the specified video is currently live streaming and cannot be loaded.",
        "signature": "def __init__(self, video_id: str):",
        "type": "Method",
        "class_signature": "class LiveStreamError(VideoUnavailable):"
      },
      "VideoPrivate.__init__": {
        "code": "    def __init__(self, video_id: str):\n        \"\"\"Initializes a VideoPrivate exception for indicating that a YouTube video is private and cannot be accessed.\n\nParameters:\n- video_id (str): A YouTube video identifier that specifies which video is private.\n\nThis constructor sets the video_id attribute and calls the superclass (VideoUnavailable) initializer with the video_id to maintain consistent error handling. The error message for this exception is defined in the `error_string` property of the VideoUnavailable class.\"\"\"\n        '\\n        :param str video_id:\\n            A YouTube video identifier.\\n        '\n        self.video_id = video_id\n        super().__init__(self.video_id)",
        "docstring": "Initializes a VideoPrivate exception for indicating that a YouTube video is private and cannot be accessed.\n\nParameters:\n- video_id (str): A YouTube video identifier that specifies which video is private.\n\nThis constructor sets the video_id attribute and calls the superclass (VideoUnavailable) initializer with the video_id to maintain consistent error handling. The error message for this exception is defined in the `error_string` property of the VideoUnavailable class.",
        "signature": "def __init__(self, video_id: str):",
        "type": "Method",
        "class_signature": "class VideoPrivate(VideoUnavailable):"
      },
      "RecordingUnavailable.__init__": {
        "code": "    def __init__(self, video_id: str):\n        \"\"\"Initializes a RecordingUnavailable exception for a YouTube video that does not have a live stream recording available.\n\nParameters:\n- video_id (str): A YouTube video identifier that specifies the video associated with the exception.\n\nThis method inherits from the VideoUnavailable class, which provides additional context for the unavailability of the video. Upon initialization, it also invokes the superclass's constructor with the video_id, which contributes to the error handling system by providing a meaningful message when the exception is raised.\"\"\"\n        '\\n        :param str video_id:\\n            A YouTube video identifier.\\n        '\n        self.video_id = video_id\n        super().__init__(self.video_id)",
        "docstring": "Initializes a RecordingUnavailable exception for a YouTube video that does not have a live stream recording available.\n\nParameters:\n- video_id (str): A YouTube video identifier that specifies the video associated with the exception.\n\nThis method inherits from the VideoUnavailable class, which provides additional context for the unavailability of the video. Upon initialization, it also invokes the superclass's constructor with the video_id, which contributes to the error handling system by providing a meaningful message when the exception is raised.",
        "signature": "def __init__(self, video_id: str):",
        "type": "Method",
        "class_signature": "class RecordingUnavailable(VideoUnavailable):"
      },
      "VideoRegionBlocked.__init__": {
        "code": "    def __init__(self, video_id: str):\n        \"\"\"Initializes a VideoRegionBlocked exception, indicating that a YouTube video is not available in the user's region.\n\n:param str video_id: A unique YouTube video identifier that specifies the unavailable video.\nThis parameter is stored as an attribute of the instance and is used in the error message generated by the error_string property inherited from the VideoUnavailable class.\"\"\"\n        '\\n        :param str video_id:\\n            A YouTube video identifier.\\n        '\n        self.video_id = video_id\n        super().__init__(self.video_id)",
        "docstring": "Initializes a VideoRegionBlocked exception, indicating that a YouTube video is not available in the user's region.\n\n:param str video_id: A unique YouTube video identifier that specifies the unavailable video.\nThis parameter is stored as an attribute of the instance and is used in the error message generated by the error_string property inherited from the VideoUnavailable class.",
        "signature": "def __init__(self, video_id: str):",
        "type": "Method",
        "class_signature": "class VideoRegionBlocked(VideoUnavailable):"
      }
    },
    "pytube/__main__.py": {
      "YouTube.__init__": {
        "code": "    def __init__(self, url: str, on_progress_callback: Optional[Callable[[Any, bytes, int], None]]=None, on_complete_callback: Optional[Callable[[Any, Optional[str]], None]]=None, proxies: Dict[str, str]=None, use_oauth: bool=False, allow_oauth_cache: bool=True):\n        \"\"\"This method initializes a YouTube object that serves as the core interface for interacting with YouTube videos through the Pytube library. It requires a valid YouTube watch URL, and it can optionally accept callbacks for download progress and completion events, proxy settings for network requests, and OAuth authentication settings.\n\nParameters:\n- url (str): A valid YouTube watch URL, used to extract the video ID and construct related URLs like watch and embed URLs.\n- on_progress_callback (Optional[Callable[[Any, bytes, int], None]]): A user-defined function to handle progress events during stream downloads.\n- on_complete_callback (Optional[Callable[[Any, Optional[str]], None]]): A user-defined function to handle events when a stream download is complete.\n- proxies (Optional[Dict[str, str]]): A dictionary mapping network protocols to proxy addresses for accessing YouTube.\n- use_oauth (bool): A flag indicating whether to prompt the user for OAuth authentication; defaults to False.\n- allow_oauth_cache (bool): A flag that determines if OAuth tokens should be cached locally; defaults to True.\n\nAttributes:\n- self.video_id: Stores the extracted video ID using the `extract.video_id()` function, facilitating the retrieval of video-related data.\n- self.watch_url and self.embed_url: Constructed URLs for direct access to the YouTube video and its embed version, respectively.\n- self.stream_monostate: Instantiates a Monostate object, sharing the progress and completion callback functions across all Stream instances for consistent handling of download events.\n- self._js, self._vid_info, self._watch_html, and other private attributes: Used to store various fetched data about the video, which are then accessed and processed by related methods within the class.\n\nThis initialization process sets the groundwork to interact with the YouTube video's metadata, streaming data, and other related functionalities provided by the Pytube library.\"\"\"\n        'Construct a :class:`YouTube <YouTube>`.\\n\\n        :param str url:\\n            A valid YouTube watch URL.\\n        :param func on_progress_callback:\\n            (Optional) User defined callback function for stream download\\n            progress events.\\n        :param func on_complete_callback:\\n            (Optional) User defined callback function for stream download\\n            complete events.\\n        :param dict proxies:\\n            (Optional) A dict mapping protocol to proxy address which will be used by pytube.\\n        :param bool use_oauth:\\n            (Optional) Prompt the user to authenticate to YouTube.\\n            If allow_oauth_cache is set to True, the user should only be prompted once.\\n        :param bool allow_oauth_cache:\\n            (Optional) Cache OAuth tokens locally on the machine. Defaults to True.\\n            These tokens are only generated if use_oauth is set to True as well.\\n        '\n        self._js: Optional[str] = None\n        self._js_url: Optional[str] = None\n        self._vid_info: Optional[Dict] = None\n        self._watch_html: Optional[str] = None\n        self._embed_html: Optional[str] = None\n        self._player_config_args: Optional[Dict] = None\n        self._age_restricted: Optional[bool] = None\n        self._fmt_streams: Optional[List[Stream]] = None\n        self._initial_data = None\n        self._metadata: Optional[YouTubeMetadata] = None\n        self.video_id = extract.video_id(url)\n        self.watch_url = f'https://youtube.com/watch?v={self.video_id}'\n        self.embed_url = f'https://www.youtube.com/embed/{self.video_id}'\n        self.stream_monostate = Monostate(on_progress=on_progress_callback, on_complete=on_complete_callback)\n        if proxies:\n            install_proxy(proxies)\n        self._author = None\n        self._title = None\n        self._publish_date = None\n        self.use_oauth = use_oauth\n        self.allow_oauth_cache = allow_oauth_cache",
        "docstring": "This method initializes a YouTube object that serves as the core interface for interacting with YouTube videos through the Pytube library. It requires a valid YouTube watch URL, and it can optionally accept callbacks for download progress and completion events, proxy settings for network requests, and OAuth authentication settings.\n\nParameters:\n- url (str): A valid YouTube watch URL, used to extract the video ID and construct related URLs like watch and embed URLs.\n- on_progress_callback (Optional[Callable[[Any, bytes, int], None]]): A user-defined function to handle progress events during stream downloads.\n- on_complete_callback (Optional[Callable[[Any, Optional[str]], None]]): A user-defined function to handle events when a stream download is complete.\n- proxies (Optional[Dict[str, str]]): A dictionary mapping network protocols to proxy addresses for accessing YouTube.\n- use_oauth (bool): A flag indicating whether to prompt the user for OAuth authentication; defaults to False.\n- allow_oauth_cache (bool): A flag that determines if OAuth tokens should be cached locally; defaults to True.\n\nAttributes:\n- self.video_id: Stores the extracted video ID using the `extract.video_id()` function, facilitating the retrieval of video-related data.\n- self.watch_url and self.embed_url: Constructed URLs for direct access to the YouTube video and its embed version, respectively.\n- self.stream_monostate: Instantiates a Monostate object, sharing the progress and completion callback functions across all Stream instances for consistent handling of download events.\n- self._js, self._vid_info, self._watch_html, and other private attributes: Used to store various fetched data about the video, which are then accessed and processed by related methods within the class.\n\nThis initialization process sets the groundwork to interact with the YouTube video's metadata, streaming data, and other related functionalities provided by the Pytube library.",
        "signature": "def __init__(self, url: str, on_progress_callback: Optional[Callable[[Any, bytes, int], None]]=None, on_complete_callback: Optional[Callable[[Any, Optional[str]], None]]=None, proxies: Dict[str, str]=None, use_oauth: bool=False, allow_oauth_cache: bool=True):",
        "type": "Method",
        "class_signature": "class YouTube:"
      },
      "YouTube.streams": {
        "code": "    def streams(self) -> StreamQuery:\n        \"\"\"Retrieve an interface to query both adaptive (DASH) and progressive video streams available for the YouTube video.\n\nThis method checks the availability of the video using `check_availability`, which raises exceptions if the video is unplayable or restricted. It returns an instance of `StreamQuery`, which contains a list of available streams stored in `fmt_streams`. The `fmt_streams` property is populated by initializing Stream objects based on the streaming data parsed from the `vid_info`.\n\n:rtype: :class:`StreamQuery <StreamQuery>`\"\"\"\n        'Interface to query both adaptive (DASH) and progressive streams.\\n\\n        :rtype: :class:`StreamQuery <StreamQuery>`.\\n        '\n        self.check_availability()\n        return StreamQuery(self.fmt_streams)",
        "docstring": "Retrieve an interface to query both adaptive (DASH) and progressive video streams available for the YouTube video.\n\nThis method checks the availability of the video using `check_availability`, which raises exceptions if the video is unplayable or restricted. It returns an instance of `StreamQuery`, which contains a list of available streams stored in `fmt_streams`. The `fmt_streams` property is populated by initializing Stream objects based on the streaming data parsed from the `vid_info`.\n\n:rtype: :class:`StreamQuery <StreamQuery>`",
        "signature": "def streams(self) -> StreamQuery:",
        "type": "Method",
        "class_signature": "class YouTube:"
      }
    }
  },
  "dependency_dict": {
    "pytube/exceptions.py:VideoUnavailable:__init__": {
      "pytube/exceptions.py": {
        "VideoUnavailable.error_string": {
          "code": "    def error_string(self):\n        return f'{self.video_id} is unavailable'",
          "docstring": "",
          "signature": "def error_string(self):",
          "type": "Method",
          "class_signature": "class VideoUnavailable(PytubeError):"
        }
      }
    },
    "pytube/exceptions.py:LiveStreamError:__init__": {},
    "pytube/exceptions.py:RecordingUnavailable:__init__": {},
    "pytube/exceptions.py:VideoPrivate:__init__": {},
    "pytube/exceptions.py:VideoRegionBlocked:__init__": {},
    "pytube/__main__.py:YouTube:__init__": {
      "pytube/monostate.py": {
        "Monostate.__init__": {
          "code": "    def __init__(\n        self,\n        on_progress: Optional[Callable[[Any, bytes, int], None]],\n        on_complete: Optional[Callable[[Any, Optional[str]], None]],\n        title: Optional[str] = None,\n        duration: Optional[int] = None,\n    ):\n        self.on_progress = on_progress\n        self.on_complete = on_complete\n        self.title = title\n        self.duration = duration",
          "docstring": "",
          "signature": "def __init__(self, on_progress: Optional[Callable[[Any, bytes, int], None]], on_complete: Optional[Callable[[Any, Optional[str]], None]], title: Optional[str]=None, duration: Optional[int]=None):",
          "type": "Method",
          "class_signature": "class Monostate:"
        }
      },
      "pytube/extract.py": {
        "video_id": {
          "code": "def video_id(url: str) -> str:\n    \"\"\"Extract the ``video_id`` from a YouTube url.\n\n    This function supports the following patterns:\n\n    - :samp:`https://youtube.com/watch?v={video_id}`\n    - :samp:`https://youtube.com/embed/{video_id}`\n    - :samp:`https://youtu.be/{video_id}`\n\n    :param str url:\n        A YouTube url containing a video id.\n    :rtype: str\n    :returns:\n        YouTube video id.\n    \"\"\"\n    return regex_search(r\"(?:v=|\\/)([0-9A-Za-z_-]{11}).*\", url, group=1)",
          "docstring": "Extract the ``video_id`` from a YouTube url.\n\nThis function supports the following patterns:\n\n- :samp:`https://youtube.com/watch?v={video_id}`\n- :samp:`https://youtube.com/embed/{video_id}`\n- :samp:`https://youtu.be/{video_id}`\n\n:param str url:\n    A YouTube url containing a video id.\n:rtype: str\n:returns:\n    YouTube video id.",
          "signature": "def video_id(url: str) -> str:",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "pytube/__main__.py:YouTube:streams": {
      "pytube/__main__.py": {
        "YouTube.check_availability": {
          "code": "    def check_availability(self):\n        \"\"\"Check whether the video is available.\n\n        Raises different exceptions based on why the video is unavailable,\n        otherwise does nothing.\n        \"\"\"\n        status, messages = extract.playability_status(self.watch_html)\n        for reason in messages:\n            if status == 'UNPLAYABLE':\n                if reason == 'Join this channel to get access to members-only content like this video, and other exclusive perks.':\n                    raise exceptions.MembersOnly(video_id=self.video_id)\n                elif reason == 'This live stream recording is not available.':\n                    raise exceptions.RecordingUnavailable(video_id=self.video_id)\n                else:\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LOGIN_REQUIRED':\n                if reason == 'This is a private video. Please sign in to verify that you may see it.':\n                    raise exceptions.VideoPrivate(video_id=self.video_id)\n            elif status == 'ERROR':\n                if reason == 'Video unavailable':\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LIVE_STREAM':\n                raise exceptions.LiveStreamError(video_id=self.video_id)",
          "docstring": "Check whether the video is available.\n\nRaises different exceptions based on why the video is unavailable,\notherwise does nothing.",
          "signature": "def check_availability(self):",
          "type": "Method",
          "class_signature": "class YouTube:"
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: pytube-test_exceptions\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pytube/\n    \u251c\u2500\u2500 __main__.py\n    \u2502   \u251c\u2500\u2500 YouTube.__init__\n    \u2502   \u2514\u2500\u2500 YouTube.streams\n    \u2514\u2500\u2500 exceptions.py\n        \u251c\u2500\u2500 LiveStreamError.__init__\n        \u251c\u2500\u2500 RecordingUnavailable.__init__\n        \u251c\u2500\u2500 RegexMatchError.__init__\n        \u251c\u2500\u2500 VideoPrivate.__init__\n        \u251c\u2500\u2500 VideoRegionBlocked.__init__\n        \u2514\u2500\u2500 VideoUnavailable.__init__\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and handle exceptions related to video availability in the PyTube library, ensuring reliable error management for various scenarios encountered during YouTube video processing. It provides functionality to test and identify specific cases such as videos being unavailable, private, region-locked, live streaming, or lacking a recorded stream. By categorizing and raising appropriate exceptions like `VideoUnavailable`, `VideoPrivate`, and `RecordingUnavailable`, among others, the module offers robust diagnostics and improves fault handling and transparency during video data retrieval. This enables developers to anticipate and address video accessibility issues in their applications, ultimately ensuring better user experience and system stability.\n\n## FILE 1: pytube/exceptions.py\n\n- CLASS METHOD: RegexMatchError.__init__\n  - CLASS SIGNATURE: class RegexMatchError(ExtractError):\n  - SIGNATURE: def __init__(self, caller: str, pattern: Union[str, Pattern]):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a RegexMatchError exception instance, which is raised when a regex pattern fails to find a match. \n\nParameters:\n- caller (str): The name of the calling function that triggered the error.\n- pattern (Union[str, Pattern]): The regex pattern that was expected to match but did not.\n\nThis constructor calls the superclass (ExtractError) initializer with a formatted error message indicating the caller and the pattern that failed to match. The `caller` and `pattern` are stored as instance attributes for further inspection or debugging purposes. This exception inherits from PytubeError, which allows it to be distinguished from built-in exceptions in application error handling. It is used in scenarios where data extraction relies on regex matching, indicating why certain expected data could not be retrieved.\n\"\"\"\n```\n\n- CLASS METHOD: RecordingUnavailable.__init__\n  - CLASS SIGNATURE: class RecordingUnavailable(VideoUnavailable):\n  - SIGNATURE: def __init__(self, video_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a RecordingUnavailable exception for a YouTube video that does not have a live stream recording available.\n\nParameters:\n- video_id (str): A YouTube video identifier that specifies the video associated with the exception.\n\nThis method inherits from the VideoUnavailable class, which provides additional context for the unavailability of the video. Upon initialization, it also invokes the superclass's constructor with the video_id, which contributes to the error handling system by providing a meaningful message when the exception is raised.\n\"\"\"\n```\n\n- CLASS METHOD: VideoRegionBlocked.__init__\n  - CLASS SIGNATURE: class VideoRegionBlocked(VideoUnavailable):\n  - SIGNATURE: def __init__(self, video_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a VideoRegionBlocked exception, indicating that a YouTube video is not available in the user's region.\n\n:param str video_id: A unique YouTube video identifier that specifies the unavailable video.\nThis parameter is stored as an attribute of the instance and is used in the error message generated by the error_string property inherited from the VideoUnavailable class.\n\"\"\"\n```\n\n- CLASS METHOD: LiveStreamError.__init__\n  - CLASS SIGNATURE: class LiveStreamError(VideoUnavailable):\n  - SIGNATURE: def __init__(self, video_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a LiveStreamError instance, which represents an error encountered when attempting to access a live-streaming video on YouTube.\n\nParameters:\n- video_id (str): A unique identifier for a YouTube video, indicating the specific stream that is not accessible.\n\nThe constructor calls the parent class (VideoUnavailable) initializer with the provided video_id, which is also stored as an instance attribute. This allows for consistent error handling across different video availability issues. The error message generated will indicate that the specified video is currently live streaming and cannot be loaded.\n\"\"\"\n```\n\n- CLASS METHOD: VideoUnavailable.__init__\n  - CLASS SIGNATURE: class VideoUnavailable(PytubeError):\n  - SIGNATURE: def __init__(self, video_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a VideoUnavailable exception, which indicates that a specified YouTube video is not accessible. \n\nParameters:\n    video_id (str): A YouTube video identifier that represents the video which is unavailable.\n\nThis constructor sets the instance variable `self.video_id` to the provided video ID and calls the superclass constructor with a generated error message from the `error_string` property. The `error_string` provides a descriptive error message regarding the unavailability of the video, leveraging the `video_id` for identification. There are no return values, but the instance will raise a VideoUnavailable error when instantiated.\n\"\"\"\n```\n\n- CLASS METHOD: VideoPrivate.__init__\n  - CLASS SIGNATURE: class VideoPrivate(VideoUnavailable):\n  - SIGNATURE: def __init__(self, video_id: str):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a VideoPrivate exception for indicating that a YouTube video is private and cannot be accessed.\n\nParameters:\n- video_id (str): A YouTube video identifier that specifies which video is private.\n\nThis constructor sets the video_id attribute and calls the superclass (VideoUnavailable) initializer with the video_id to maintain consistent error handling. The error message for this exception is defined in the `error_string` property of the VideoUnavailable class.\n\"\"\"\n```\n\n## FILE 2: pytube/__main__.py\n\n- CLASS METHOD: YouTube.__init__\n  - CLASS SIGNATURE: class YouTube:\n  - SIGNATURE: def __init__(self, url: str, on_progress_callback: Optional[Callable[[Any, bytes, int], None]]=None, on_complete_callback: Optional[Callable[[Any, Optional[str]], None]]=None, proxies: Dict[str, str]=None, use_oauth: bool=False, allow_oauth_cache: bool=True):\n  - DOCSTRING: \n```python\n\"\"\"\nThis method initializes a YouTube object that serves as the core interface for interacting with YouTube videos through the Pytube library. It requires a valid YouTube watch URL, and it can optionally accept callbacks for download progress and completion events, proxy settings for network requests, and OAuth authentication settings.\n\nParameters:\n- url (str): A valid YouTube watch URL, used to extract the video ID and construct related URLs like watch and embed URLs.\n- on_progress_callback (Optional[Callable[[Any, bytes, int], None]]): A user-defined function to handle progress events during stream downloads.\n- on_complete_callback (Optional[Callable[[Any, Optional[str]], None]]): A user-defined function to handle events when a stream download is complete.\n- proxies (Optional[Dict[str, str]]): A dictionary mapping network protocols to proxy addresses for accessing YouTube.\n- use_oauth (bool): A flag indicating whether to prompt the user for OAuth authentication; defaults to False.\n- allow_oauth_cache (bool): A flag that determines if OAuth tokens should be cached locally; defaults to True.\n\nAttributes:\n- self.video_id: Stores the extracted video ID using the `extract.video_id()` function, facilitating the retrieval of video-related data.\n- self.watch_url and self.embed_url: Constructed URLs for direct access to the YouTube video and its embed version, respectively.\n- self.stream_monostate: Instantiates a Monostate object, sharing the progress and completion callback functions across all Stream instances for consistent handling of download events.\n- self._js, self._vid_info, self._watch_html, and other private attributes: Used to store various fetched data about the video, which are then accessed and processed by related methods within the class.\n\nThis initialization process sets the groundwork to interact with the YouTube video's metadata, streaming data, and other related functionalities provided by the Pytube library.\n\"\"\"\n```\n\n- CLASS METHOD: YouTube.streams\n  - CLASS SIGNATURE: class YouTube:\n  - SIGNATURE: def streams(self) -> StreamQuery:\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve an interface to query both adaptive (DASH) and progressive video streams available for the YouTube video.\n\nThis method checks the availability of the video using `check_availability`, which raises exceptions if the video is unplayable or restricted. It returns an instance of `StreamQuery`, which contains a list of available streams stored in `fmt_streams`. The `fmt_streams` property is populated by initializing Stream objects based on the streaming data parsed from the `vid_info`.\n\n:rtype: :class:`StreamQuery <StreamQuery>`\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pytube/exceptions.py": "\"\"\"Library specific exception definitions.\"\"\"\nfrom typing import Pattern, Union\n\nclass PytubeError(Exception):\n    \"\"\"Base pytube exception that all others inherit.\n\n    This is done to not pollute the built-in exceptions, which *could* result\n    in unintended errors being unexpectedly and incorrectly handled within\n    implementers code.\n    \"\"\"\n\nclass MaxRetriesExceeded(PytubeError):\n    \"\"\"Maximum number of retries exceeded.\"\"\"\n\nclass HTMLParseError(PytubeError):\n    \"\"\"HTML could not be parsed\"\"\"\n\nclass ExtractError(PytubeError):\n    \"\"\"Data extraction based exception.\"\"\"\n\nclass RegexMatchError(ExtractError):\n    \"\"\"Regex pattern did not return any matches.\"\"\"\n\nclass VideoUnavailable(PytubeError):\n    \"\"\"Base video unavailable error.\"\"\"\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is unavailable'\n\nclass AgeRestrictedError(VideoUnavailable):\n    \"\"\"Video is age restricted, and cannot be accessed without OAuth.\"\"\"\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f\"{self.video_id} is age restricted, and can't be accessed without logging in.\"\n\nclass LiveStreamError(VideoUnavailable):\n    \"\"\"Video is a live stream.\"\"\"\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is streaming live and cannot be loaded'\n\nclass VideoPrivate(VideoUnavailable):\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a private video'\n\nclass RecordingUnavailable(VideoUnavailable):\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} does not have a live stream recording available'\n\nclass MembersOnly(VideoUnavailable):\n    \"\"\"Video is members-only.\n\n    YouTube has special videos that are only viewable to users who have\n    subscribed to a content creator.\n    ref: https://support.google.com/youtube/answer/7544492?hl=en\n    \"\"\"\n\n    def __init__(self, video_id: str):\n        \"\"\"\n        :param str video_id:\n            A YouTube video identifier.\n        \"\"\"\n        self.video_id = video_id\n        super().__init__(self.video_id)\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is a members-only video'\n\nclass VideoRegionBlocked(VideoUnavailable):\n\n    @property\n    def error_string(self):\n        return f'{self.video_id} is not available in your region'",
    "pytube/__main__.py": "\"\"\"\nThis module implements the core developer interface for pytube.\n\nThe problem domain of the :class:`YouTube <YouTube> class focuses almost\nexclusively on the developer interface. Pytube offloads the heavy lifting to\nsmaller peripheral modules and functions.\n\n\"\"\"\nimport logging\nfrom typing import Any, Callable, Dict, List, Optional\nimport pytube\nimport pytube.exceptions as exceptions\nfrom pytube import extract, request\nfrom pytube import Stream, StreamQuery\nfrom pytube.helpers import install_proxy\nfrom pytube.innertube import InnerTube\nfrom pytube.metadata import YouTubeMetadata\nfrom pytube.monostate import Monostate\nlogger = logging.getLogger(__name__)\n\nclass YouTube:\n    \"\"\"Core developer interface for pytube.\"\"\"\n\n    def __repr__(self):\n        return f'<pytube.__main__.YouTube object: videoId={self.video_id}>'\n\n    def __eq__(self, o: object) -> bool:\n        return type(o) == type(self) and o.watch_url == self.watch_url\n\n    @property\n    def watch_html(self):\n        if self._watch_html:\n            return self._watch_html\n        self._watch_html = request.get(url=self.watch_url)\n        return self._watch_html\n\n    @property\n    def embed_html(self):\n        if self._embed_html:\n            return self._embed_html\n        self._embed_html = request.get(url=self.embed_url)\n        return self._embed_html\n\n    @property\n    def age_restricted(self):\n        if self._age_restricted:\n            return self._age_restricted\n        self._age_restricted = extract.is_age_restricted(self.watch_html)\n        return self._age_restricted\n\n    @property\n    def js_url(self):\n        if self._js_url:\n            return self._js_url\n        if self.age_restricted:\n            self._js_url = extract.js_url(self.embed_html)\n        else:\n            self._js_url = extract.js_url(self.watch_html)\n        return self._js_url\n\n    @property\n    def js(self):\n        if self._js:\n            return self._js\n        if pytube.__js_url__ != self.js_url:\n            self._js = request.get(self.js_url)\n            pytube.__js__ = self._js\n            pytube.__js_url__ = self.js_url\n        else:\n            self._js = pytube.__js__\n        return self._js\n\n    @property\n    def initial_data(self):\n        if self._initial_data:\n            return self._initial_data\n        self._initial_data = extract.initial_data(self.watch_html)\n        return self._initial_data\n\n    @property\n    def streaming_data(self):\n        \"\"\"Return streamingData from video info.\"\"\"\n        if 'streamingData' in self.vid_info:\n            return self.vid_info['streamingData']\n        else:\n            self.bypass_age_gate()\n            return self.vid_info['streamingData']\n\n    @property\n    def fmt_streams(self):\n        \"\"\"Returns a list of streams if they have been initialized.\n\n        If the streams have not been initialized, finds all relevant\n        streams and initializes them.\n        \"\"\"\n        self.check_availability()\n        if self._fmt_streams:\n            return self._fmt_streams\n        self._fmt_streams = []\n        stream_manifest = extract.apply_descrambler(self.streaming_data)\n        try:\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n        except exceptions.ExtractError:\n            self._js = None\n            self._js_url = None\n            pytube.__js__ = None\n            pytube.__js_url__ = None\n            extract.apply_signature(stream_manifest, self.vid_info, self.js)\n        for stream in stream_manifest:\n            video = Stream(stream=stream, monostate=self.stream_monostate)\n            self._fmt_streams.append(video)\n        self.stream_monostate.title = self.title\n        self.stream_monostate.duration = self.length\n        return self._fmt_streams\n\n    def check_availability(self):\n        \"\"\"Check whether the video is available.\n\n        Raises different exceptions based on why the video is unavailable,\n        otherwise does nothing.\n        \"\"\"\n        status, messages = extract.playability_status(self.watch_html)\n        for reason in messages:\n            if status == 'UNPLAYABLE':\n                if reason == 'Join this channel to get access to members-only content like this video, and other exclusive perks.':\n                    raise exceptions.MembersOnly(video_id=self.video_id)\n                elif reason == 'This live stream recording is not available.':\n                    raise exceptions.RecordingUnavailable(video_id=self.video_id)\n                else:\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LOGIN_REQUIRED':\n                if reason == 'This is a private video. Please sign in to verify that you may see it.':\n                    raise exceptions.VideoPrivate(video_id=self.video_id)\n            elif status == 'ERROR':\n                if reason == 'Video unavailable':\n                    raise exceptions.VideoUnavailable(video_id=self.video_id)\n            elif status == 'LIVE_STREAM':\n                raise exceptions.LiveStreamError(video_id=self.video_id)\n\n    @property\n    def vid_info(self):\n        \"\"\"Parse the raw vid info and return the parsed result.\n\n        :rtype: Dict[Any, Any]\n        \"\"\"\n        if self._vid_info:\n            return self._vid_info\n        innertube = InnerTube(use_oauth=self.use_oauth, allow_cache=self.allow_oauth_cache)\n        innertube_response = innertube.player(self.video_id)\n        self._vid_info = innertube_response\n        return self._vid_info\n\n    def bypass_age_gate(self):\n        \"\"\"Attempt to update the vid_info by bypassing the age gate.\"\"\"\n        innertube = InnerTube(client='ANDROID_EMBED', use_oauth=self.use_oauth, allow_cache=self.allow_oauth_cache)\n        innertube_response = innertube.player(self.video_id)\n        playability_status = innertube_response['playabilityStatus'].get('status', None)\n        if playability_status == 'UNPLAYABLE':\n            raise exceptions.AgeRestrictedError(self.video_id)\n        self._vid_info = innertube_response\n\n    @property\n    def caption_tracks(self) -> List[pytube.Caption]:\n        \"\"\"Get a list of :class:`Caption <Caption>`.\n\n        :rtype: List[Caption]\n        \"\"\"\n        raw_tracks = self.vid_info.get('captions', {}).get('playerCaptionsTracklistRenderer', {}).get('captionTracks', [])\n        return [pytube.Caption(track) for track in raw_tracks]\n\n    @property\n    def captions(self) -> pytube.CaptionQuery:\n        \"\"\"Interface to query caption tracks.\n\n        :rtype: :class:`CaptionQuery <CaptionQuery>`.\n        \"\"\"\n        return pytube.CaptionQuery(self.caption_tracks)\n\n    @property\n    def thumbnail_url(self) -> str:\n        \"\"\"Get the thumbnail url image.\n\n        :rtype: str\n        \"\"\"\n        thumbnail_details = self.vid_info.get('videoDetails', {}).get('thumbnail', {}).get('thumbnails')\n        if thumbnail_details:\n            thumbnail_details = thumbnail_details[-1]\n            return thumbnail_details['url']\n        return f'https://img.youtube.com/vi/{self.video_id}/maxresdefault.jpg'\n\n    @property\n    def publish_date(self):\n        \"\"\"Get the publish date.\n\n        :rtype: datetime\n        \"\"\"\n        if self._publish_date:\n            return self._publish_date\n        self._publish_date = extract.publish_date(self.watch_html)\n        return self._publish_date\n\n    @publish_date.setter\n    def publish_date(self, value):\n        \"\"\"Sets the publish date.\"\"\"\n        self._publish_date = value\n\n    @property\n    def title(self) -> str:\n        \"\"\"Get the video title.\n\n        :rtype: str\n        \"\"\"\n        if self._title:\n            return self._title\n        try:\n            self._title = self.vid_info['videoDetails']['title']\n        except KeyError:\n            self.check_availability()\n            raise exceptions.PytubeError(f'Exception while accessing title of {self.watch_url}. Please file a bug report at https://github.com/pytube/pytube')\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        \"\"\"Sets the title value.\"\"\"\n        self._title = value\n\n    @property\n    def description(self) -> str:\n        \"\"\"Get the video description.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('shortDescription')\n\n    @property\n    def rating(self) -> float:\n        \"\"\"Get the video average rating.\n\n        :rtype: float\n\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('averageRating')\n\n    @property\n    def length(self) -> int:\n        \"\"\"Get the video length in seconds.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get('videoDetails', {}).get('lengthSeconds'))\n\n    @property\n    def views(self) -> int:\n        \"\"\"Get the number of the times the video has been viewed.\n\n        :rtype: int\n        \"\"\"\n        return int(self.vid_info.get('videoDetails', {}).get('viewCount'))\n\n    @property\n    def author(self) -> str:\n        \"\"\"Get the video author.\n        :rtype: str\n        \"\"\"\n        if self._author:\n            return self._author\n        self._author = self.vid_info.get('videoDetails', {}).get('author', 'unknown')\n        return self._author\n\n    @author.setter\n    def author(self, value):\n        \"\"\"Set the video author.\"\"\"\n        self._author = value\n\n    @property\n    def keywords(self) -> List[str]:\n        \"\"\"Get the video keywords.\n\n        :rtype: List[str]\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('keywords', [])\n\n    @property\n    def channel_id(self) -> str:\n        \"\"\"Get the video poster's channel id.\n\n        :rtype: str\n        \"\"\"\n        return self.vid_info.get('videoDetails', {}).get('channelId', None)\n\n    @property\n    def channel_url(self) -> str:\n        \"\"\"Construct the channel url for the video's poster from the channel id.\n\n        :rtype: str\n        \"\"\"\n        return f'https://www.youtube.com/channel/{self.channel_id}'\n\n    @property\n    def metadata(self) -> Optional[YouTubeMetadata]:\n        \"\"\"Get the metadata for the video.\n\n        :rtype: YouTubeMetadata\n        \"\"\"\n        if self._metadata:\n            return self._metadata\n        else:\n            self._metadata = extract.metadata(self.initial_data)\n            return self._metadata\n\n    def register_on_progress_callback(self, func: Callable[[Any, bytes, int], None]):\n        \"\"\"Register a download progress callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream``, ``chunk``,\n             and ``bytes_remaining`` as parameters.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_progress = func\n\n    def register_on_complete_callback(self, func: Callable[[Any, Optional[str]], None]):\n        \"\"\"Register a download complete callback function post initialization.\n\n        :param callable func:\n            A callback function that takes ``stream`` and  ``file_path``.\n\n        :rtype: None\n\n        \"\"\"\n        self.stream_monostate.on_complete = func\n\n    @staticmethod\n    def from_id(video_id: str) -> 'YouTube':\n        \"\"\"Construct a :class:`YouTube <YouTube>` object from a video id.\n\n        :param str video_id:\n            The video id of the YouTube video.\n\n        :rtype: :class:`YouTube <YouTube>`\n        \n        \"\"\"\n        return YouTube(f'https://www.youtube.com/watch?v={video_id}')"
  },
  "call_tree": {
    "tests/test_exceptions.py:test_video_unavailable": {
      "pytube/exceptions.py:VideoUnavailable:__init__": {
        "pytube/exceptions.py:VideoUnavailable:error_string": {}
      }
    },
    "tests/test_exceptions.py:test_regex_match_error": {
      "pytube/exceptions.py:RegexMatchError:__init__": {}
    },
    "tests/test_exceptions.py:test_live_stream_error": {
      "pytube/exceptions.py:LiveStreamError:__init__": {
        "pytube/exceptions.py:VideoUnavailable:__init__": {
          "pytube/exceptions.py:LiveStreamError:error_string": {}
        }
      }
    },
    "tests/test_exceptions.py:test_recording_unavailable_error": {
      "pytube/exceptions.py:RecordingUnavailable:__init__": {
        "pytube/exceptions.py:VideoUnavailable:__init__": {
          "pytube/exceptions.py:RecordingUnavailable:error_string": {}
        }
      }
    },
    "tests/test_exceptions.py:test_private_error": {
      "pytube/exceptions.py:VideoPrivate:__init__": {
        "pytube/exceptions.py:VideoUnavailable:__init__": {
          "pytube/exceptions.py:VideoPrivate:error_string": {}
        }
      }
    },
    "tests/test_exceptions.py:test_region_locked_error": {
      "pytube/exceptions.py:VideoRegionBlocked:__init__": {
        "pytube/exceptions.py:VideoUnavailable:__init__": {
          "pytube/exceptions.py:VideoRegionBlocked:error_string": {}
        }
      }
    },
    "tests/test_exceptions.py:test_raises_video_private": {
      "pytube/__main__.py:YouTube:__init__": {
        "pytube/extract.py:video_id": {
          "pytube/helpers.py:regex_search": {}
        },
        "pytube/monostate.py:Monostate:__init__": {}
      },
      "pytube/__main__.py:YouTube:streams": {
        "pytube/__main__.py:YouTube:check_availability": {
          "pytube/__main__.py:YouTube:watch_html": {
            "pytube/request.py:get": {
              "pytube/request.py:_execute_request": {}
            }
          },
          "pytube/extract.py:playability_status": {
            "pytube/extract.py:initial_player_response": {
              "pytube/parser.py:parse_for_object": {
                "pytube/parser.py:parse_for_object_from_startpoint": {
                  "pytube/parser.py:find_object_from_startpoint": {}
                }
              }
            }
          },
          "pytube/exceptions.py:VideoPrivate:__init__": {
            "pytube/exceptions.py:VideoUnavailable:__init__": {
              "pytube/exceptions.py:VideoPrivate:error_string": {}
            }
          }
        }
      }
    },
    "tests/test_exceptions.py:test_raises_recording_unavailable": {
      "pytube/__main__.py:YouTube:__init__": {
        "pytube/extract.py:video_id": {
          "pytube/helpers.py:regex_search": {}
        },
        "pytube/monostate.py:Monostate:__init__": {}
      },
      "pytube/__main__.py:YouTube:streams": {
        "pytube/__main__.py:YouTube:check_availability": {
          "pytube/__main__.py:YouTube:watch_html": {
            "pytube/request.py:get": {
              "pytube/request.py:_execute_request": {}
            }
          },
          "pytube/extract.py:playability_status": {
            "pytube/extract.py:initial_player_response": {
              "pytube/parser.py:parse_for_object": {
                "pytube/parser.py:parse_for_object_from_startpoint": {
                  "pytube/parser.py:find_object_from_startpoint": {}
                }
              }
            }
          },
          "pytube/exceptions.py:RecordingUnavailable:__init__": {
            "pytube/exceptions.py:VideoUnavailable:__init__": {
              "pytube/exceptions.py:RecordingUnavailable:error_string": {}
            }
          }
        }
      }
    }
  }
}