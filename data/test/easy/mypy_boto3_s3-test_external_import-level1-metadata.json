{
  "dir_path": "/app/mypy_boto3_s3",
  "package_name": "mypy_boto3_s3",
  "sample_name": "mypy_boto3_s3-test_external_import",
  "src_dir": "examples/",
  "test_dir": "tests/",
  "test_file": "tests/type_annotations/test_external_import.py",
  "test_code": "from botocore.paginate import Paginator as BotocorePaginator\n\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.external_import import ExternalImport\n\n\nclass TestExternalImport:\n    def setup_method(self) -> None:\n        self.result = ExternalImport(ImportString(\"module\"), \"name\")\n        self.alias = ExternalImport(ImportString(\"module\"), \"name\", \"alias\")\n\n    def test_init(self) -> None:\n        assert self.result.name == \"name\"\n        assert not self.result.alias\n        assert self.result.source.render() == \"module\"\n        assert self.result.import_record.render() == \"from module import name\"\n        assert hash(self.result)\n\n    def test_render(self) -> None:\n        assert self.result.render() == \"name\"\n        assert self.alias.render() == \"alias\"\n\n    def test_get_import_records(self) -> None:\n        import_records = sorted(self.result.get_import_records())\n        assert len(import_records) == 1\n        assert import_records[0].render() == \"from module import name\"\n\n        import_records = sorted(self.alias.get_import_records())\n        assert len(import_records) == 1\n        assert import_records[0].render() == \"from module import name as alias\"\n\n    def test_copy(self) -> None:\n        assert self.result.copy().name == \"name\"\n\n    def test_from_class(self) -> None:\n        sample = ExternalImport.from_class(ImportString)\n        assert sample.render() == \"ImportString\"\n        import_records = sorted(sample.get_import_records())\n        assert len(import_records) == 1\n        assert (\n            import_records[0].render()\n            == \"from mypy_boto3_builder.import_helpers.import_string import ImportString\"\n        )\n\n        sample = ExternalImport.from_class(str)\n        assert sample.render() == \"str\"\n        assert len(sample.get_import_records()) == 0\n\n        sample = ExternalImport.from_class(BotocorePaginator)\n        assert sample.render() == \"Paginator\"\n        import_records = sorted(sample.get_import_records())\n        assert len(import_records) == 1\n        assert import_records[0].render() == \"from botocore.paginate import Paginator\"\n",
  "GT_file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Final, Self\n\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n\n    BUILTINS: Final[str] = \"builtins\"\n    _THIRD_PARTY: Final[set[str]] = {\n        \"boto3\",\n        \"botocore\",\n        \"aioboto3\",\n        \"aiobotocore\",\n        \"s3transfer\",\n        \"awscrt\",\n    }\n\n    def __init__(self, parent: str, *parts: str) -> None:\n        all_parts = (parent, *parts)\n        if not parent and not parts:\n            raise StructureError(\"ImportString cannot be empty\")\n        has_not_empty_part = False\n        for part in all_parts:\n            if \".\" in part:\n                raise StructureError(f\"ImportString parts are not splitted correctly: {all_parts}\")\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(\n                    f\"ImportString cannot have empty parts after parents: {all_parts}\",\n                )\n\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split(\".\"))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f\"{other} is not ImportString\")\n\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    def render(self) -> str:\n        \"\"\"\n        Render to string.\n\n        Returns:\n            Ready to use import string.\n        \"\"\"\n        return \".\".join(self.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY\n",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport inspect\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        *,\n        safe: bool = False,\n    ) -> None:\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe\n\n    @classmethod\n    def from_class(cls, obj: type, alias: str = \"\", *, safe: bool = False) -> Self:\n        \"\"\"\n        Create an instance from an imported class.\n\n        Arguments:\n            value -- Any Class.\n            alias -- Local name.\n            safe -- Whether import is wrapped in try-except.\n        \"\"\"\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f\"Unknown module for {obj}\")\n\n        module_name = module.__name__\n        return cls(\n            source=ImportString.from_str(module_name),\n            name=obj.__name__,\n            alias=alias,\n            safe=safe,\n        )\n\n    @property\n    def import_record(self) -> ImportRecord:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        if self.safe:\n            return ImportRecord(\n                self.source,\n                self.name,\n                self.alias,\n                min_version=None,\n                fallback=ImportRecord(ImportString(ImportString.BUILTINS), \"object\", self.name),\n            )\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calcualte hash value based on import record.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.safe))\n\n    def render(self) -> str:\n        \"\"\"\n        Get string with local name to use.\n\n        Returns:\n            Import record local name.\n        \"\"\"\n        return self.import_record.get_local_name()\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe\n",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport functools\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: ImportString,\n        name: str = \"\",\n        alias: str = \"\",\n        min_version: tuple[int, ...] | None = None,\n        fallback: Self | None = None,\n    ) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f\"ImportRecord {self} has no name\")\n\n        if self.alias:\n            return f\"{self.name} as {self.alias}\"\n\n        return self.name\n\n    def render(self) -> str:\n        \"\"\"\n        Get rendered string.\n        \"\"\"\n        if self.name:\n            return f\"from {self.source} import {self.render_name()}\"\n        if self.alias:\n            return f\"import {self.source} as {self.alias}\"\n\n        return f\"import {self.source}\"\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash(\n            (\n                self.source,\n                self.name,\n                self.alias,\n                self.min_version,\n                self.fallback,\n            ),\n        )\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n\n        if self.source != other.source:\n            return self.source > other.source\n\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)\n",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\n\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\n\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f\"{other} is not FakeAnnotation\")\n\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: \"FakeAnnotation\") -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get all import records required for using type annotation.\n        \"\"\"\n        return {\n            import_record\n            for import_record in self._get_import_records()\n            if not import_record.source.is_builtins()\n        }\n\n    def iterate_types(self) -> Iterator[\"FakeAnnotation\"]:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def copy(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return copy.copy(self)\n\n    def get_local_types(self) -> list[\"FakeAnnotation\"]:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()\n"
  },
  "GT_src_dict": {
    "mypy_boto3_builder/import_helpers/import_string.py": {
      "ImportString.__init__": {
        "code": "    def __init__(self, parent: str, *parts: str) -> None:\n        \"\"\"Initialize an ImportString instance.\n\nThis constructor accepts a master module name (`parent`) and additional parts forming the import string. It validates that the provided parts are correctly structured, ensuring that there are no empty parts and that no part contains a dot (`.`) indicating submodules. \n\nParameters:\n- parent (str): The main module name, which cannot be empty.\n- *parts (str): Additional parts of the import string that will follow the parent module.\n\nRaises:\n- StructureError: If the `parent` is empty, if all parts are empty, or if any part contains a dot or is empty after non-empty parts.\n\nAttributes:\n- self.parts (tuple[str, ...]): A tuple containing the complete import string parts validated upon initialization.\n\nConstants:\n- Final: The attributes and methods use type hints like `Final` from `typing`, the structure of which helps to signify that certain values are intended to be constant or immutable.\"\"\"\n        all_parts = (parent, *parts)\n        if not parent and (not parts):\n            raise StructureError('ImportString cannot be empty')\n        has_not_empty_part = False\n        for part in all_parts:\n            if '.' in part:\n                raise StructureError(f'ImportString parts are not splitted correctly: {all_parts}')\n            if part:\n                has_not_empty_part = True\n            elif has_not_empty_part:\n                raise StructureError(f'ImportString cannot have empty parts after parents: {all_parts}')\n        self.parts: Final[tuple[str, ...]] = tuple(all_parts)",
        "docstring": "Initialize an ImportString instance.\n\nThis constructor accepts a master module name (`parent`) and additional parts forming the import string. It validates that the provided parts are correctly structured, ensuring that there are no empty parts and that no part contains a dot (`.`) indicating submodules. \n\nParameters:\n- parent (str): The main module name, which cannot be empty.\n- *parts (str): Additional parts of the import string that will follow the parent module.\n\nRaises:\n- StructureError: If the `parent` is empty, if all parts are empty, or if any part contains a dot or is empty after non-empty parts.\n\nAttributes:\n- self.parts (tuple[str, ...]): A tuple containing the complete import string parts validated upon initialization.\n\nConstants:\n- Final: The attributes and methods use type hints like `Final` from `typing`, the structure of which helps to signify that certain values are intended to be constant or immutable.",
        "signature": "def __init__(self, parent: str, *parts: str) -> None:",
        "type": "Method",
        "class_signature": "class ImportString:"
      },
      "ImportString.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Render the import string as a concatenated string of its parts.\n\nThis method returns a valid Python import statement by joining all parts of the import using \".\" as a separator. The parts are stored in the `self.parts` attribute, which is a tuple containing the master module name and any additional parts provided during the initialization of the `ImportString` instance.\n\nReturns:\n    str: A concatenated string representing the full import path, ready for use in import statements.\"\"\"\n        '\\n        Render to string.\\n\\n        Returns:\\n            Ready to use import string.\\n        '\n        return '.'.join(self.parts)",
        "docstring": "Render the import string as a concatenated string of its parts.\n\nThis method returns a valid Python import statement by joining all parts of the import using \".\" as a separator. The parts are stored in the `self.parts` attribute, which is a tuple containing the master module name and any additional parts provided during the initialization of the `ImportString` instance.\n\nReturns:\n    str: A concatenated string representing the full import path, ready for use in import statements.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportString:"
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py": {
      "ExternalImport.__init__": {
        "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n        \"\"\"Initialize an `ExternalImport` instance, which acts as a wrapper for type annotations sourced from external libraries, such as `boto3.service.Service`.\n\nParameters:\n- `source` (ImportString): The import string representing the module from which the type is sourced.\n- `name` (str, optional): The name of the imported entity (default is an empty string).\n- `alias` (str, optional): A local alias for the imported entity (default is an empty string).\n- `safe` (bool, optional): A flag indicating whether the import should be wrapped in a try-except block (default is False).\n\nThis constructor sets the respective attributes for the import source, name, alias, and safety designation. The `source` parameter is crucial for constructing the import record later used in type annotations through the `import_record` property. The attributes `name` and `alias` aid in local identification of the imported type during type resolution.\"\"\"\n        self.source: ImportString = source\n        self.name: str = name\n        self.alias: str = alias\n        self.safe: bool = safe",
        "docstring": "Initialize an `ExternalImport` instance, which acts as a wrapper for type annotations sourced from external libraries, such as `boto3.service.Service`.\n\nParameters:\n- `source` (ImportString): The import string representing the module from which the type is sourced.\n- `name` (str, optional): The name of the imported entity (default is an empty string).\n- `alias` (str, optional): A local alias for the imported entity (default is an empty string).\n- `safe` (bool, optional): A flag indicating whether the import should be wrapped in a try-except block (default is False).\n\nThis constructor sets the respective attributes for the import source, name, alias, and safety designation. The `source` parameter is crucial for constructing the import record later used in type annotations through the `import_record` property. The attributes `name` and `alias` aid in local identification of the imported type during type resolution.",
        "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.from_class": {
        "code": "    def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n        \"\"\"Create an instance of ExternalImport from a given class. This method extracts the module name of the provided class and constructs an ExternalImport object with the module's import string, class name, and optional alias and safety parameters.\n\nParameters:\n- cls: The class type that this method is being called on (class method).\n- obj: The class object for which to create an ExternalImport instance.\n- alias: A local name for the import (default is an empty string).\n- safe: A boolean indicating if the import will be wrapped in a try-except block (default is False).\n\nReturns:\nAn instance of ExternalImport initialized with the module name, class name, alias, and safety setting.\n\nRaises:\n- TypeAnnotationError: If the module of the provided class cannot be determined, indicating an issue with module resolution.\n\nDependencies:\nThis method relies on the `inspect` module to fetch the module information and the custom `ImportString` class to create the import string from the module name. It also uses the `TypeAnnotationError` exception from `mypy_boto3_builder.exceptions` to handle module resolution errors.\"\"\"\n        '\\n        Create an instance from an imported class.\\n\\n        Arguments:\\n            value -- Any Class.\\n            alias -- Local name.\\n            safe -- Whether import is wrapped in try-except.\\n        '\n        module = inspect.getmodule(obj)\n        if module is None:\n            raise TypeAnnotationError(f'Unknown module for {obj}')\n        module_name = module.__name__\n        return cls(source=ImportString.from_str(module_name), name=obj.__name__, alias=alias, safe=safe)",
        "docstring": "Create an instance of ExternalImport from a given class. This method extracts the module name of the provided class and constructs an ExternalImport object with the module's import string, class name, and optional alias and safety parameters.\n\nParameters:\n- cls: The class type that this method is being called on (class method).\n- obj: The class object for which to create an ExternalImport instance.\n- alias: A local name for the import (default is an empty string).\n- safe: A boolean indicating if the import will be wrapped in a try-except block (default is False).\n\nReturns:\nAn instance of ExternalImport initialized with the module name, class name, alias, and safety setting.\n\nRaises:\n- TypeAnnotationError: If the module of the provided class cannot be determined, indicating an issue with module resolution.\n\nDependencies:\nThis method relies on the `inspect` module to fetch the module information and the custom `ImportString` class to create the import string from the module name. It also uses the `TypeAnnotationError` exception from `mypy_boto3_builder.exceptions` to handle module resolution errors.",
        "signature": "def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.import_record": {
        "code": "    def import_record(self) -> ImportRecord:\n        \"\"\"Get the import record required for using the type annotation represented by the ExternalImport instance. This method generates an ImportRecord object based on whether the import is considered \"safe.\" If `safe` is True, the ImportRecord includes a fallback to a built-in 'object' type with the current instance's name. Otherwise, it directly returns a standard ImportRecord using the specified source, name, and alias.\n\nReturns:\n    ImportRecord: An instance containing information about the import, which includes the module source, local name, and alias used for type annotations.\n\nDependencies:\n    - ImportRecord: Used to create the import records.\n    - ImportString: Handles the import strings; the `ImportString.BUILTINS` constant references the built-in Python types, ensuring compatibility in the event of an error.\"\"\"\n        '\\n        Get import record required for using type annotation.\\n        '\n        if self.safe:\n            return ImportRecord(self.source, self.name, self.alias, min_version=None, fallback=ImportRecord(ImportString(ImportString.BUILTINS), 'object', self.name))\n        return ImportRecord(source=self.source, name=self.name, alias=self.alias)",
        "docstring": "Get the import record required for using the type annotation represented by the ExternalImport instance. This method generates an ImportRecord object based on whether the import is considered \"safe.\" If `safe` is True, the ImportRecord includes a fallback to a built-in 'object' type with the current instance's name. Otherwise, it directly returns a standard ImportRecord using the specified source, name, and alias.\n\nReturns:\n    ImportRecord: An instance containing information about the import, which includes the module source, local name, and alias used for type annotations.\n\nDependencies:\n    - ImportRecord: Used to create the import records.\n    - ImportString: Handles the import strings; the `ImportString.BUILTINS` constant references the built-in Python types, ensuring compatibility in the event of an error.",
        "signature": "def import_record(self) -> ImportRecord:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.__hash__": {
        "code": "    def __hash__(self) -> int:\n        \"\"\"Calculate a hash value for the ExternalImport instance based on its attributes.\n\nThis method utilizes the built-in `hash` function to generate a unique hash value by taking a tuple of the instance's attributes: `source`, `name`, `alias`, and `safe`. These attributes define the import metadata for the ExternalImport instance, where:\n- `source`: An ImportString representing the module from which the type is imported.\n- `name`: The name of the imported type.\n- `alias`: Any local alias for the imported type.\n- `safe`: A boolean indicating if the import is wrapped in try-except.\n\nThe resulting hash is used for maintaining uniqueness in collections like sets or as dictionary keys, facilitating efficient comparisons and storage of ExternalImport instances.\"\"\"\n        '\\n        Calcualte hash value based on import record.\\n        '\n        return hash((self.source, self.name, self.alias, self.safe))",
        "docstring": "Calculate a hash value for the ExternalImport instance based on its attributes.\n\nThis method utilizes the built-in `hash` function to generate a unique hash value by taking a tuple of the instance's attributes: `source`, `name`, `alias`, and `safe`. These attributes define the import metadata for the ExternalImport instance, where:\n- `source`: An ImportString representing the module from which the type is imported.\n- `name`: The name of the imported type.\n- `alias`: Any local alias for the imported type.\n- `safe`: A boolean indicating if the import is wrapped in try-except.\n\nThe resulting hash is used for maintaining uniqueness in collections like sets or as dictionary keys, facilitating efficient comparisons and storage of ExternalImport instances.",
        "signature": "def __hash__(self) -> int:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      },
      "ExternalImport.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Get the local name string for the type annotation import record. This method interacts with the `import_record` property, which generates an `ImportRecord` instance containing details about the type annotation's source module, name, and alias. It retrieves the local name via the `get_local_name()` method of `ImportRecord`, facilitating proper usage of external imports in type annotations.\"\"\"\n        '\\n        Get string with local name to use.\\n\\n        Returns:\\n            Import record local name.\\n        '\n        return self.import_record.get_local_name()",
        "docstring": "Get the local name string for the type annotation import record. This method interacts with the `import_record` property, which generates an `ImportRecord` instance containing details about the type annotation's source module, name, and alias. It retrieves the local name via the `get_local_name()` method of `ImportRecord`, facilitating proper usage of external imports in type annotations.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ExternalImport(FakeAnnotation):"
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py": {
      "ImportRecord.render": {
        "code": "    def render(self) -> str:\n        \"\"\"Get the rendered string representation of the import statement for this ImportRecord instance. \n\nThe method constructs the import statement based on the presence of `name` and `alias` attributes. If `name` is defined, it generates a statement in the form \"from {source} import {name}\" or \"import {source} as {alias}\" if only `alias` is present. If neither `name` nor `alias` is defined, it defaults to \"import {source}\". \n\nDependencies include the `source` attribute, which is expected to be an instance of `ImportString`, and the `render_name` method to format the import name when both `name` and `alias` are present.\"\"\"\n        '\\n        Get rendered string.\\n        '\n        if self.name:\n            return f'from {self.source} import {self.render_name()}'\n        if self.alias:\n            return f'import {self.source} as {self.alias}'\n        return f'import {self.source}'",
        "docstring": "Get the rendered string representation of the import statement for this ImportRecord instance. \n\nThe method constructs the import statement based on the presence of `name` and `alias` attributes. If `name` is defined, it generates a statement in the form \"from {source} import {name}\" or \"import {source} as {alias}\" if only `alias` is present. If neither `name` nor `alias` is defined, it defaults to \"import {source}\". \n\nDependencies include the `source` attribute, which is expected to be an instance of `ImportString`, and the `render_name` method to format the import name when both `name` and `alias` are present.",
        "signature": "def render(self) -> str:",
        "type": "Method",
        "class_signature": "class ImportRecord:"
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py": {
      "FakeAnnotation.get_import_records": {
        "code": "    def get_import_records(self) -> set[ImportRecord]:\n        \"\"\"Get all import records required for the usage of the type annotation.\n\nThis method collects import records from the `_get_import_records` method and filters out any records that originate from built-in sources, as determined by the `is_builtins` method of the `source` attribute in `ImportRecord`. \n\nReturns:\n    set[ImportRecord]: A set of `ImportRecord` instances that are necessary for using the type annotation, excluding built-in imports.\"\"\"\n        '\\n        Get all import records required for using type annotation.\\n        '\n        return {import_record for import_record in self._get_import_records() if not import_record.source.is_builtins()}",
        "docstring": "Get all import records required for the usage of the type annotation.\n\nThis method collects import records from the `_get_import_records` method and filters out any records that originate from built-in sources, as determined by the `is_builtins` method of the `source` attribute in `ImportRecord`. \n\nReturns:\n    set[ImportRecord]: A set of `ImportRecord` instances that are necessary for using the type annotation, excluding built-in imports.",
        "signature": "def get_import_records(self) -> set[ImportRecord]:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      },
      "FakeAnnotation.copy": {
        "code": "    def copy(self: Self) -> Self:\n        \"\"\"Create a copy of the `FakeAnnotation` instance using the `copy` module's shallow copy functionality. This method returns a new instance that is a duplicate of the original, maintaining its essential properties and attributes.\n\nReturns:\n    Self: A shallow copy of the current `FakeAnnotation` instance.\n\nDependencies:\n    - Utilizes the `copy` module to perform the copying operation, which is applicable to all subclasses of `FakeAnnotation`.\"\"\"\n        '\\n        Create a copy of type annotation wrapper.\\n        '\n        return copy.copy(self)",
        "docstring": "Create a copy of the `FakeAnnotation` instance using the `copy` module's shallow copy functionality. This method returns a new instance that is a duplicate of the original, maintaining its essential properties and attributes.\n\nReturns:\n    Self: A shallow copy of the current `FakeAnnotation` instance.\n\nDependencies:\n    - Utilizes the `copy` module to perform the copying operation, which is applicable to all subclasses of `FakeAnnotation`.",
        "signature": "def copy(self: Self) -> Self:",
        "type": "Method",
        "class_signature": "class FakeAnnotation(ABC):"
      }
    }
  },
  "dependency_dict": {
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.__init__": {
          "code": "    def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback",
          "docstring": "",
          "signature": "def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    },
    "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.render_name": {
          "code": "    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name",
          "docstring": "Get rendered import name.",
          "signature": "def render_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__str__": {
          "code": "    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()",
          "docstring": "Render as a part of a valid Python import statement.",
          "signature": "def __str__(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)",
          "docstring": "Calculate hash value based on all parts.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.get_local_name": {
          "code": "    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()",
          "docstring": "Get local import name.",
          "signature": "def get_local_name(self) -> str:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport._get_import_records": {
          "code": "    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}",
          "docstring": "Get import record required for using type annotation.",
          "signature": "def _get_import_records(self) -> set[ImportRecord]:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      },
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.is_builtins": {
          "code": "    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS",
          "docstring": "Whether import is from Python `builtins` module.",
          "signature": "def is_builtins(self) -> bool:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py": {
        "ImportRecord.__hash__": {
          "code": "    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))",
          "docstring": "Calculate hash value based on source, name and alias.",
          "signature": "def __hash__(self) -> int:",
          "type": "Method",
          "class_signature": "class ImportRecord:"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
      "mypy_boto3_builder/type_annotations/external_import.py": {
        "ExternalImport.__copy__": {
          "code": "    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)",
          "docstring": "Create a copy of type annotation wrapper.",
          "signature": "def __copy__(self) -> Self:",
          "type": "Method",
          "class_signature": "class ExternalImport(FakeAnnotation):"
        }
      }
    },
    "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
      "mypy_boto3_builder/import_helpers/import_string.py": {
        "ImportString.from_str": {
          "code": "    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))",
          "docstring": "Create from string.",
          "signature": "def from_str(cls, import_string: str) -> Self:",
          "type": "Method",
          "class_signature": "class ImportString:"
        }
      }
    }
  },
  "call_tree": {
    "tests/type_annotations/test_external_import.py:TestExternalImport:setup_method": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {},
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
    },
    "tests/type_annotations/test_external_import.py:TestExternalImport:test_init": {
      "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {},
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
      },
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__hash__": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
      }
    },
    "tests/type_annotations/test_external_import.py:TestExternalImport:test_render": {
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
      }
    },
    "tests/type_annotations/test_external_import.py:TestExternalImport:test_get_import_records": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:_get_import_records": {
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
          }
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
      }
    },
    "tests/type_annotations/test_external_import.py:TestExternalImport:test_copy": {
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:copy": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__copy__": {
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
        }
      }
    },
    "tests/type_annotations/test_external_import.py:TestExternalImport:test_from_class": {
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:from_class": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:from_str": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__init__": {}
        },
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:__init__": {}
      },
      "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:render": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:get_local_name": {}
      },
      "mypy_boto3_builder/type_annotations/fake_annotation.py:FakeAnnotation:get_import_records": {
        "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:_get_import_records": {
          "mypy_boto3_builder/type_annotations/external_import.py:ExternalImport:import_record": {
            "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__init__": {}
          },
          "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
            "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
          }
        },
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:is_builtins": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:parent": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:__hash__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__hash__": {}
        }
      },
      "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render": {
        "mypy_boto3_builder/import_helpers/import_string.py:ImportString:__str__": {
          "mypy_boto3_builder/import_helpers/import_string.py:ImportString:render": {}
        },
        "mypy_boto3_builder/import_helpers/import_record.py:ImportRecord:render_name": {}
      }
    }
  },
  "PRD": "# PROJECT NAME: mypy_boto3_s3-test_external_import\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 mypy_boto3_builder/\n    \u251c\u2500\u2500 import_helpers/\n    \u2502   \u251c\u2500\u2500 import_record.py\n    \u2502   \u2502   \u2514\u2500\u2500 ImportRecord.render\n    \u2502   \u2514\u2500\u2500 import_string.py\n    \u2502       \u251c\u2500\u2500 ImportString.__init__\n    \u2502       \u2514\u2500\u2500 ImportString.render\n    \u2514\u2500\u2500 type_annotations/\n        \u251c\u2500\u2500 external_import.py\n        \u2502   \u251c\u2500\u2500 ExternalImport.__hash__\n        \u2502   \u251c\u2500\u2500 ExternalImport.__init__\n        \u2502   \u251c\u2500\u2500 ExternalImport.from_class\n        \u2502   \u251c\u2500\u2500 ExternalImport.import_record\n        \u2502   \u2514\u2500\u2500 ExternalImport.render\n        \u2514\u2500\u2500 fake_annotation.py\n            \u251c\u2500\u2500 FakeAnnotation.copy\n            \u2514\u2500\u2500 FakeAnnotation.get_import_records\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to facilitate and standardize the creation and management of external imports within a Python codebase, particularly for use cases involving dynamic or structured import handling. It provides capabilities for representing and manipulating import statements, including support for aliases, import record generation, and rendering import strings. Additionally, it includes utilities to generate imports directly from Python classes and third-party libraries, ensuring flexibility and compatibility. By abstracting and automating the process of constructing and managing imports, the module simplifies code generation and enhances maintainability for developers working on tools or packages that rely heavily on dynamic import structures.\n\n## FILE 1: mypy_boto3_builder/import_helpers/import_string.py\n\n- CLASS METHOD: ImportString.__init__\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def __init__(self, parent: str, *parts: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an ImportString instance.\n\nThis constructor accepts a master module name (`parent`) and additional parts forming the import string. It validates that the provided parts are correctly structured, ensuring that there are no empty parts and that no part contains a dot (`.`) indicating submodules. \n\nParameters:\n- parent (str): The main module name, which cannot be empty.\n- *parts (str): Additional parts of the import string that will follow the parent module.\n\nRaises:\n- StructureError: If the `parent` is empty, if all parts are empty, or if any part contains a dot or is empty after non-empty parts.\n\nAttributes:\n- self.parts (tuple[str, ...]): A tuple containing the complete import string parts validated upon initialization.\n\nConstants:\n- Final: The attributes and methods use type hints like `Final` from `typing`, the structure of which helps to signify that certain values are intended to be constant or immutable.\n\"\"\"\n```\n\n- CLASS METHOD: ImportString.render\n  - CLASS SIGNATURE: class ImportString:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nRender the import string as a concatenated string of its parts.\n\nThis method returns a valid Python import statement by joining all parts of the import using \".\" as a separator. The parts are stored in the `self.parts` attribute, which is a tuple containing the master module name and any additional parts provided during the initialization of the `ImportString` instance.\n\nReturns:\n    str: A concatenated string representing the full import path, ready for use in import statements.\n\"\"\"\n```\n\n## FILE 2: mypy_boto3_builder/type_annotations/external_import.py\n\n- CLASS METHOD: ExternalImport.from_class\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def from_class(cls, obj: type, alias: str='', *, safe: bool=False) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate an instance of ExternalImport from a given class. This method extracts the module name of the provided class and constructs an ExternalImport object with the module's import string, class name, and optional alias and safety parameters.\n\nParameters:\n- cls: The class type that this method is being called on (class method).\n- obj: The class object for which to create an ExternalImport instance.\n- alias: A local name for the import (default is an empty string).\n- safe: A boolean indicating if the import will be wrapped in a try-except block (default is False).\n\nReturns:\nAn instance of ExternalImport initialized with the module name, class name, alias, and safety setting.\n\nRaises:\n- TypeAnnotationError: If the module of the provided class cannot be determined, indicating an issue with module resolution.\n\nDependencies:\nThis method relies on the `inspect` module to fetch the module information and the custom `ImportString` class to create the import string from the module name. It also uses the `TypeAnnotationError` exception from `mypy_boto3_builder.exceptions` to handle module resolution errors.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.render\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the local name string for the type annotation import record. This method interacts with the `import_record` property, which generates an `ImportRecord` instance containing details about the type annotation's source module, name, and alias. It retrieves the local name via the `get_local_name()` method of `ImportRecord`, facilitating proper usage of external imports in type annotations.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.import_record\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def import_record(self) -> ImportRecord:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the import record required for using the type annotation represented by the ExternalImport instance. This method generates an ImportRecord object based on whether the import is considered \"safe.\" If `safe` is True, the ImportRecord includes a fallback to a built-in 'object' type with the current instance's name. Otherwise, it directly returns a standard ImportRecord using the specified source, name, and alias.\n\nReturns:\n    ImportRecord: An instance containing information about the import, which includes the module source, local name, and alias used for type annotations.\n\nDependencies:\n    - ImportRecord: Used to create the import records.\n    - ImportString: Handles the import strings; the `ImportString.BUILTINS` constant references the built-in Python types, ensuring compatibility in the event of an error.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.__init__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __init__(self, source: ImportString, name: str='', alias: str='', *, safe: bool=False) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an `ExternalImport` instance, which acts as a wrapper for type annotations sourced from external libraries, such as `boto3.service.Service`.\n\nParameters:\n- `source` (ImportString): The import string representing the module from which the type is sourced.\n- `name` (str, optional): The name of the imported entity (default is an empty string).\n- `alias` (str, optional): A local alias for the imported entity (default is an empty string).\n- `safe` (bool, optional): A flag indicating whether the import should be wrapped in a try-except block (default is False).\n\nThis constructor sets the respective attributes for the import source, name, alias, and safety designation. The `source` parameter is crucial for constructing the import record later used in type annotations through the `import_record` property. The attributes `name` and `alias` aid in local identification of the imported type during type resolution.\n\"\"\"\n```\n\n- CLASS METHOD: ExternalImport.__hash__\n  - CLASS SIGNATURE: class ExternalImport(FakeAnnotation):\n  - SIGNATURE: def __hash__(self) -> int:\n  - DOCSTRING: \n```python\n\"\"\"\nCalculate a hash value for the ExternalImport instance based on its attributes.\n\nThis method utilizes the built-in `hash` function to generate a unique hash value by taking a tuple of the instance's attributes: `source`, `name`, `alias`, and `safe`. These attributes define the import metadata for the ExternalImport instance, where:\n- `source`: An ImportString representing the module from which the type is imported.\n- `name`: The name of the imported type.\n- `alias`: Any local alias for the imported type.\n- `safe`: A boolean indicating if the import is wrapped in try-except.\n\nThe resulting hash is used for maintaining uniqueness in collections like sets or as dictionary keys, facilitating efficient comparisons and storage of ExternalImport instances.\n\"\"\"\n```\n\n## FILE 3: mypy_boto3_builder/import_helpers/import_record.py\n\n- CLASS METHOD: ImportRecord.render\n  - CLASS SIGNATURE: class ImportRecord:\n  - SIGNATURE: def render(self) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nGet the rendered string representation of the import statement for this ImportRecord instance. \n\nThe method constructs the import statement based on the presence of `name` and `alias` attributes. If `name` is defined, it generates a statement in the form \"from {source} import {name}\" or \"import {source} as {alias}\" if only `alias` is present. If neither `name` nor `alias` is defined, it defaults to \"import {source}\". \n\nDependencies include the `source` attribute, which is expected to be an instance of `ImportString`, and the `render_name` method to format the import name when both `name` and `alias` are present.\n\"\"\"\n```\n\n## FILE 4: mypy_boto3_builder/type_annotations/fake_annotation.py\n\n- CLASS METHOD: FakeAnnotation.get_import_records\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def get_import_records(self) -> set[ImportRecord]:\n  - DOCSTRING: \n```python\n\"\"\"\nGet all import records required for the usage of the type annotation.\n\nThis method collects import records from the `_get_import_records` method and filters out any records that originate from built-in sources, as determined by the `is_builtins` method of the `source` attribute in `ImportRecord`. \n\nReturns:\n    set[ImportRecord]: A set of `ImportRecord` instances that are necessary for using the type annotation, excluding built-in imports.\n\"\"\"\n```\n\n- CLASS METHOD: FakeAnnotation.copy\n  - CLASS SIGNATURE: class FakeAnnotation(ABC):\n  - SIGNATURE: def copy(self: Self) -> Self:\n  - DOCSTRING: \n```python\n\"\"\"\nCreate a copy of the `FakeAnnotation` instance using the `copy` module's shallow copy functionality. This method returns a new instance that is a duplicate of the original, maintaining its essential properties and attributes.\n\nReturns:\n    Self: A shallow copy of the current `FakeAnnotation` instance.\n\nDependencies:\n    - Utilizes the `copy` module to perform the copying operation, which is applicable to all subclasses of `FakeAnnotation`.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "mypy_boto3_builder/import_helpers/import_string.py": "\"\"\"\nWrapper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Final, Self\nfrom mypy_boto3_builder.enums.service_module_name import ServiceModuleName\nfrom mypy_boto3_builder.exceptions import BuildInternalError, StructureError\nfrom mypy_boto3_builder.package_data import Boto3StubsPackageData, TypesAioBotocorePackageData\n\n@functools.total_ordering\nclass ImportString:\n    \"\"\"\n    Wrapper for Python import strings.\n\n    Arguments:\n        master -- Master module name\n        parts -- Other import parts\n\n    Examples::\n\n        import_string = ImportString(\"my\", \"name\")\n\n        str(import_string)\n        'my.name'\n\n        import_string.render()\n        'my.name'\n    \"\"\"\n    BUILTINS: Final[str] = 'builtins'\n    _THIRD_PARTY: Final[set[str]] = {'boto3', 'botocore', 'aioboto3', 'aiobotocore', 's3transfer', 'awscrt'}\n\n    @classmethod\n    def from_str(cls, import_string: str) -> Self:\n        \"\"\"\n        Create from string.\n        \"\"\"\n        return cls(*import_string.split('.'))\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a part of a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on all parts.\n        \"\"\"\n        return hash(self.parts)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether import strings produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportString):\n            raise BuildInternalError(f'{other} is not ImportString')\n        return self.parts == other.parts\n\n    def __gt__(self, other: Self) -> bool:\n        \"\"\"\n        Compare import strings for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.is_local() != other.is_local():\n            return self.is_local() > other.is_local()\n        if self.is_third_party() != other.is_third_party():\n            return self.is_third_party() > other.is_third_party()\n        return self.parts > other.parts\n\n    def __add__(self: Self, other: Self | str) -> Self:\n        \"\"\"\n        Create a new import string by adding another import string parts to the end.\n        \"\"\"\n        other_import_string = other if isinstance(other, ImportString) else ImportString(other)\n        return self.__class__(*self.parts, *other_import_string.parts)\n\n    @property\n    def parent(self) -> str:\n        \"\"\"\n        Get first import string part or `builtins`.\n        \"\"\"\n        return self.parts[0]\n\n    def is_local(self) -> bool:\n        \"\"\"\n        Whether import is from local module.\n        \"\"\"\n        if self.parent.startswith(Boto3StubsPackageData.SERVICE_PREFIX):\n            return True\n        if self.parent.startswith(TypesAioBotocorePackageData.SERVICE_PREFIX):\n            return True\n        return self.is_type_defs()\n\n    def is_builtins(self) -> bool:\n        \"\"\"\n        Whether import is from Python `builtins` module.\n        \"\"\"\n        return self.parent == self.BUILTINS\n\n    def is_type_defs(self) -> bool:\n        \"\"\"\n        Whether import is from `type_defs` module.\n        \"\"\"\n        if not self.parts:\n            return False\n        return self.parts[-1] == ServiceModuleName.type_defs.value\n\n    def is_third_party(self) -> bool:\n        \"\"\"\n        Whether import is from 3rd party module.\n        \"\"\"\n        return self.parent in self._THIRD_PARTY",
    "mypy_boto3_builder/type_annotations/external_import.py": "\"\"\"\nWrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport inspect\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import TypeAnnotationError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\nfrom mypy_boto3_builder.type_annotations.fake_annotation import FakeAnnotation\n\nclass ExternalImport(FakeAnnotation):\n    \"\"\"\n    Wrapper for type annotations imported from 3rd party libraries, like `boto3.service.Service`.\n\n    Arguments:\n        source -- Module import string.\n        name -- Import name.\n        alias -- Import local name.\n        safe -- Whether import is wrapped in try-except.\n    \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return {self.import_record}\n\n    def __copy__(self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n        return self.__class__(self.source, self.name, self.alias, safe=self.safe)\n\n    def copy_from(self: Self, other: Self) -> None:\n        \"\"\"\n        Copy all fileds from another instance.\n        \"\"\"\n        self.source = other.source\n        self.name = other.name\n        self.safe = other.safe",
    "mypy_boto3_builder/import_helpers/import_record.py": "\"\"\"\nHelper for Python import strings.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport functools\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import StructureError\nfrom mypy_boto3_builder.import_helpers.import_string import ImportString\n\n@functools.total_ordering\nclass ImportRecord:\n    \"\"\"\n    Helper for Python import strings.\n\n    Arguments:\n        source -- Source of import.\n        name -- Import name.\n        alias -- Import local name.\n        min_version -- Minimum Python version, used for fallback.\n        fallback -- Fallback ImportRecord.\n    \"\"\"\n\n    def __init__(self, source: ImportString, name: str='', alias: str='', min_version: tuple[int, ...] | None=None, fallback: Self | None=None) -> None:\n        self.source = source\n        self.name = name\n        self.alias = alias\n        self.min_version = min_version\n        self.fallback = fallback\n\n    def render_name(self) -> str:\n        \"\"\"\n        Get rendered import name.\n        \"\"\"\n        if not self.name:\n            raise StructureError(f'ImportRecord {self} has no name')\n        if self.alias:\n            return f'{self.name} as {self.alias}'\n        return self.name\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render as a valid Python import statement.\n        \"\"\"\n        return self.render()\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on source, name and alias.\n        \"\"\"\n        return hash((self.source, self.name, self.alias, self.min_version, self.fallback))\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two import records produce the same render.\n        \"\"\"\n        if not isinstance(other, ImportRecord):\n            return False\n        return str(self) == str(other)\n\n    def __gt__(self: Self, other: Self) -> bool:\n        \"\"\"\n        Compare two import records for sorting.\n\n        Emulates `isort` logic.\n        \"\"\"\n        if self == other:\n            return False\n        if self.min_version != other.min_version:\n            return (self.min_version or ()) > (other.min_version or ())\n        if bool(self.fallback) != bool(other.fallback):\n            return bool(self.fallback) > bool(other.fallback)\n        if self.source != other.source:\n            return self.source > other.source\n        return self.name > other.name\n\n    def get_local_name(self) -> str:\n        \"\"\"\n        Get local import name.\n        \"\"\"\n        return self.alias or self.name or self.source.render()\n\n    def needs_sys_fallback(self) -> bool:\n        \"\"\"\n        Whether ImportString requires `sys` module.\n        \"\"\"\n        return bool(self.fallback and self.min_version)",
    "mypy_boto3_builder/type_annotations/fake_annotation.py": "\"\"\"\nParent class for all type annotation wrappers.\n\nCopyright 2024 Vlad Emelianov\n\"\"\"\nimport copy\nimport functools\nfrom abc import ABC, abstractmethod\nfrom collections.abc import Iterator\nfrom typing import Self\nfrom mypy_boto3_builder.exceptions import BuildInternalError\nfrom mypy_boto3_builder.import_helpers.import_record import ImportRecord\n\n@functools.total_ordering\nclass FakeAnnotation(ABC):\n    \"\"\"\n    Parent class for all type annotation wrappers.\n    \"\"\"\n\n    def __hash__(self) -> int:\n        \"\"\"\n        Calculate hash value based on string render.\n        \"\"\"\n        return hash(self.get_sort_key())\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Whether two annotations are equal.\n        \"\"\"\n        if not isinstance(other, FakeAnnotation):\n            raise BuildInternalError(f'{other} is not FakeAnnotation')\n        return self.get_sort_key() == other.get_sort_key()\n\n    def __gt__(self: Self, other: 'FakeAnnotation') -> bool:\n        \"\"\"\n        Compare two annotations for sorting.\n        \"\"\"\n        return self.get_sort_key() > other.get_sort_key()\n\n    def get_sort_key(self) -> str:\n        \"\"\"\n        Get string to sort annotations.\n        \"\"\"\n        return str(self)\n\n    def __str__(self) -> str:\n        \"\"\"\n        Render annotation usage as a valid Python statement.\n        \"\"\"\n        return self.render()\n\n    @abstractmethod\n    def render(self) -> str:\n        \"\"\"\n        Render type annotation to a valid Python code for local usage.\n        \"\"\"\n\n    def _get_import_records(self) -> set[ImportRecord]:\n        \"\"\"\n        Get import record required for using type annotation.\n        \"\"\"\n        return set()\n\n    def iterate_types(self) -> Iterator['FakeAnnotation']:\n        \"\"\"\n        Iterate over all used type annotations recursively including self.\n        \"\"\"\n        yield self\n\n    def is_dict(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Dict` or `TypedDict`.\n        \"\"\"\n        return False\n\n    def is_list(self) -> bool:\n        \"\"\"\n        Whether type annotation is `List`.\n        \"\"\"\n        return False\n\n    def is_literal(self) -> bool:\n        \"\"\"\n        Whether type annotation is `Literal`.\n        \"\"\"\n        return False\n\n    @abstractmethod\n    def __copy__(self: Self) -> Self:\n        \"\"\"\n        Create a copy of type annotation wrapper.\n        \"\"\"\n\n    def get_local_types(self) -> list['FakeAnnotation']:\n        \"\"\"\n        Get internal types generated by builder.\n        \"\"\"\n        return []\n\n    def render_definition(self) -> str:\n        \"\"\"\n        Render type annotation for debug purposes.\n        \"\"\"\n        return self.render()"
  }
}