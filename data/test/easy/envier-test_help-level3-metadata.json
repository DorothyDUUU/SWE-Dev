{
  "dir_path": "/app/envier",
  "package_name": "envier",
  "sample_name": "envier-test_help",
  "src_dir": "envier/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_help.py",
  "test_code": "from envier import Env\nfrom envier import HelpInfo\n\n\nclass GlobalConfig(Env):\n    __prefix__ = \"myapp\"\n\n    debug_mode = Env.var(\n        bool,\n        \"debug\",\n        default=False,\n        help_type=\"Boolean\",\n        help=\"Whether to enable debug logging\",\n    )\n    url = Env.var(\n        str,\n        \"url\",\n        default=\"http://localhost:5000\",\n        help_type=\"String\",\n        help=\"The URL of the application.\",\n    )\n    no_default = Env.var(\n        str,\n        \"no_default\",\n        help_type=\"Boolean\",\n        help=\"A variable with no default value, which makes it mandatory\",\n    )\n\n    class ServiceConfig(Env):\n        __item__ = __prefix__ = \"service\"\n\n        host = Env.var(\n            str,\n            \"host\",\n            default=\"localhost\",\n            help=\"The host of the service.\",\n        )\n        port = Env.var(\n            int,\n            \"port\",\n            default=3000,\n            help=\"The port of the service.\",\n        )\n\n\ndef test_help_info(monkeypatch):\n    monkeypatch.setenv(\"MYAPP_NO_DEFAULT\", \"1\")\n\n    assert GlobalConfig.help_info() == [\n        HelpInfo(\"MYAPP_DEBUG\", \"Boolean\", \"False\", \"Whether to enable debug logging.\"),\n        HelpInfo(\n            \"MYAPP_NO_DEFAULT\",\n            \"Boolean\",\n            \"\",\n            \"A variable with no default value, which makes it mandatory.\",\n        ),\n        HelpInfo(\n            \"MYAPP_URL\",\n            \"String\",\n            \"http://localhost:5000\",\n            \"The URL of the application.\",\n        ),\n    ]\n\n\ndef test_help_info_recursive(monkeypatch):\n    monkeypatch.setenv(\"MYAPP_NO_DEFAULT\", \"1\")\n\n    assert GlobalConfig.help_info(recursive=True) == [\n        HelpInfo(\"MYAPP_DEBUG\", \"Boolean\", \"False\", \"Whether to enable debug logging.\"),\n        HelpInfo(\n            \"MYAPP_NO_DEFAULT\",\n            \"Boolean\",\n            \"\",\n            \"A variable with no default value, which makes it mandatory.\",\n        ),\n        HelpInfo(\n            \"MYAPP_URL\",\n            \"String\",\n            \"http://localhost:5000\",\n            \"The URL of the application.\",\n        ),\n        HelpInfo(\"MYAPP_SERVICE_HOST\", \"str\", \"localhost\", \"The host of the service.\"),\n        HelpInfo(\"MYAPP_SERVICE_PORT\", \"int\", \"3000\", \"The port of the service.\"),\n    ]\n",
  "GT_file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\n\nclass NoDefaultType(object):\n    def __str__(self):\n        return \"\"\n\n\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\n\n\nT = t.TypeVar(\"T\")\nK = t.TypeVar(\"K\")\nV = t.TypeVar(\"V\")\n\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple(\"HelpInfo\", (\"name\", \"type\", \"default\", \"help\"))\n\n\ndef _normalized(name: str) -> str:\n    return name.upper().replace(\".\", \"_\").rstrip(\"_\")\n\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, \"__origin__\"):\n        return isinstance(value, _type.__args__)  # type: ignore[attr-defined,union-attr]\n\n    return isinstance(value, _type)  # type: ignore[arg-type]\n\n\nclass EnvVariable(t.Generic[T]):\n    def __init__(\n        self,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> None:\n        if hasattr(type, \"__origin__\") and type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            if not isinstance(default, type.__args__):  # type: ignore[attr-defined,union-attr]\n                raise TypeError(\n                    \"default must be either of these types {}\".format(type.__args__)  # type: ignore[attr-defined,union-attr]\n                )\n        elif default is not NoDefault and not isinstance(default, type):  # type: ignore[arg-type]\n            raise TypeError(\"default must be of type {}\".format(type))\n\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n\n        self._full_name = _normalized(name)  # Will be set by the EnvMeta metaclass\n\n    @property\n    def full_name(self) -> str:\n        return f\"_{self._full_name}\" if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: \"Env\") -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(\n                T,\n                _type(  # type: ignore[operator]\n                    collection if self.map is None else map(self.map, collection)  # type: ignore[arg-type]\n                ),\n            )\n        elif _type is dict:\n            d = dict(\n                _.split(env.__value_separator__, 1)\n                for _ in raw.split(env.__item_separator__)\n            )\n            if self.map is not None:\n                d = dict(self.map(*_) for _ in d.items())\n            return t.cast(T, d)\n\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f\"cannot cast {raw} to {self.type}\"\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: \"Env\", prefix: str) -> T:\n        source = env.source\n\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f\"_{full_deprecated_name}\"\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = (\n                        \" in version %s\" % deprecated_when\n                        if deprecated_when is not None\n                        else \"\"\n                    )\n                    removed_when_message = (\n                        \" and will be removed in version %s\" % removed_when\n                        if removed_when is not None\n                        else \"\"\n                    )\n                    warnings.warn(\n                        \"%s has been deprecated%s%s. Use %s instead\"\n                        % (\n                            full_deprecated_name,\n                            deprecated_when_message,\n                            removed_when_message,\n                            full_name,\n                        ),\n                        DeprecationWarning,\n                    )\n                    break\n\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n\n            raise KeyError(\n                \"Mandatory environment variable {} is not set\".format(full_name)\n            )\n\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError(\n                    \"parser returned type {} instead of {}\".format(\n                        type(parsed), self.type\n                    )\n                )\n            return parsed\n\n        if hasattr(self.type, \"__origin__\") and self.type.__origin__ is t.Union:  # type: ignore[attr-defined,union-attr]\n            for ot in self.type.__args__:  # type: ignore[attr-defined,union-attr]\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n\n        return self._cast(self.type, raw, env)\n\n    def __call__(self, env: \"Env\", prefix: str) -> T:\n        value = self._retrieve(env, prefix)\n\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f\"Invalid value for environment variable {self.full_name}: {e}\"\n                raise ValueError(msg)\n\n        return value\n\n\nclass DerivedVariable(t.Generic[T]):\n    def __init__(self, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: \"Env\") -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError(\n                \"derivation returned type {} instead of {}\".format(\n                    type(value), self.type\n                )\n            )\n        return value\n\n\nclass EnvMeta(type):\n    def __new__(\n        cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]\n    ) -> t.Any:\n        env = t.cast(\"Env\", super().__new__(cls, name, bases, ns))\n\n        prefix = ns.get(\"__prefix__\")\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f\"{_normalized(prefix)}_{v._full_name}\".upper()\n\n        return env\n\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n\n    __truthy__ = frozenset({\"1\", \"true\", \"yes\", \"on\"})\n    __prefix__ = \"\"\n    __item__: t.Optional[str] = None\n    __item_separator__ = \",\"\n    __value_separator__ = \":\"\n\n    def __init__(\n        self,\n        source: t.Optional[t.Dict[str, str]] = None,\n        parent: t.Optional[\"Env\"] = None,\n        dynamic: t.Optional[t.Dict[str, str]] = None,\n    ) -> None:\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = (\n            {k.upper(): v.upper() for k, v in dynamic.items()}\n            if dynamic is not None\n            else {}\n        )\n\n        self._full_prefix: str = (\n            parent._full_prefix if parent is not None else \"\"\n        ) + _normalized(self.__prefix__)\n        if self._full_prefix and not self._full_prefix.endswith(\"_\"):\n            self._full_prefix += \"_\"\n\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    # Move the subclass to the __item__ attribute\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n\n        for n, d in derived:\n            setattr(self, n, d(self))\n\n    @classmethod\n    def var(\n        cls,\n        type: t.Type[T],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def v(\n        cls,\n        type: t.Union[object, t.Type[T]],\n        name: str,\n        parser: t.Optional[t.Callable[[str], T]] = None,\n        validator: t.Optional[t.Callable[[T], None]] = None,\n        map: t.Optional[MapType] = None,\n        default: t.Union[T, NoDefaultType] = NoDefault,\n        deprecations: t.Optional[t.List[DeprecationInfo]] = None,\n        private: bool = False,\n        help: t.Optional[str] = None,\n        help_type: t.Optional[str] = None,\n        help_default: t.Optional[str] = None,\n    ) -> EnvVariable[T]:\n        return EnvVariable(\n            type,\n            name,\n            parser,\n            validator,\n            map,\n            default,\n            deprecations,\n            private,\n            help,\n            help_type,\n            help_default,\n        )\n\n    @classmethod\n    def der(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(\n        cls, type: t.Type[T], derivation: t.Callable[[\"Env\"], T]\n    ) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def items(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type[\"Env\"]]] = deque()\n        path: t.Tuple[str] = tuple()  # type: ignore[assignment]\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield (\n                        \".\".join((*path, k)),\n                        t.cast(t.Union[EnvVariable, DerivedVariable], v),\n                    )\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, \"__item__\", k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))  # type: ignore[arg-type]\n\n    @classmethod\n    def keys(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def values(\n        cls, recursive: bool = False, include_derived: bool = False\n    ) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type[\"Env\"]]]:\n        \"\"\"Return the value of all the configuration items.\"\"\"\n        for _, v in cls.items(recursive, include_derived):\n            yield v\n\n    @classmethod\n    def include(\n        cls,\n        env_spec: t.Type[\"Env\"],\n        namespace: t.Optional[str] = None,\n        overwrite: bool = False,\n    ) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        # Pick only the attributes that define variables.\n        to_include = {\n            k: v\n            for k, v in env_spec.__dict__.items()\n            if isinstance(v, (EnvVariable, DerivedVariable))\n            or isinstance(v, type)\n            and issubclass(v, Env)\n        }\n\n        own_prefix = _normalized(getattr(cls, \"__prefix__\", \"\"))\n\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError(\"Namespace already in use: {}\".format(namespace))\n\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n            return None\n\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError(\"Configuration clashes detected: {}\".format(overlap))\n\n        other_prefix = getattr(env_spec, \"__prefix__\", \"\")\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1 :]  # noqa\n                    if own_prefix:\n                        v._full_name = f\"{own_prefix}_{v._full_name}\"\n\n    @classmethod\n    def help_info(\n        cls, recursive: bool = False, include_private: bool = False\n    ) -> t.List[HelpInfo]:\n        \"\"\"Extract the help information from the class.\n\n        Returns a list of all the environment variables declared by the class.\n        The format of each entry is a t.Tuple consisting of the variable name (in\n        double backtics quotes), the type, the default value, and the help text.\n\n        Set ``recursive`` to ``True`` to include variables from nested Env\n        classes.\n\n        Set ``include_private`` to ``True`` to include variables that are\n        marked as private (i.e. their name starts with an underscore).\n        \"\"\"\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted(\n                (_ for _ in config.values() if isinstance(_, EnvVariable)),\n                key=lambda v: v.name,\n            )\n\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n\n                # Add a period at the end if necessary.\n                help_message = v.help.strip() if v.help is not None else \"\"\n                if help_message and not help_message.endswith(\".\"):\n                    help_message += \".\"\n\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__  # type: ignore[attr-defined]\n                    except AttributeError:\n                        # typing.t.Union[<type>, NoneType]\n                        help_type = v.type.__args__[0].__name__  # type: ignore[attr-defined]\n\n                private_prefix = \"_\" if v.private else \"\"\n\n                entries.append(\n                    HelpInfo(\n                        f\"{private_prefix}{full_prefix}{_normalized(v.name)}\",\n                        help_type,  # type: ignore[attr-defined]\n                        (\n                            v.help_default\n                            if v.help_default is not None\n                            else str(v.default)\n                        ),\n                        help_message,\n                    )\n                )\n\n        configs = [(\"\", cls)]\n\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and not new_prefix.endswith(\"_\"):\n                new_prefix += \"_\"\n            add_entries(new_prefix, config)\n\n            if not recursive:\n                break\n\n            subconfigs = sorted(\n                (\n                    (new_prefix, v)\n                    for k, v in config.__dict__.items()\n                    if isinstance(v, type) and issubclass(v, Env) and k != \"parent\"\n                ),\n                key=lambda _: _[1].__prefix__,\n            )\n\n            configs[0:0] = subconfigs  # DFS\n\n        return entries\n"
  },
  "GT_src_dict": {
    "envier/env.py": {
      "NoDefaultType.__str__": {
        "code": "    def __str__(self):\n        \"\"\"This method returns an empty string representation of the NoDefaultType instance.\n\nIt overrides the __str__ method from the default object behavior to provide a specific output for instances of this class, which is used to signify the absence of a default value in the context of environment variable management within the EnvVariable class. The NoDefault class serves as a marker for cases where a default value is not set, allowing the EnvVariable class to handle mandatory environment variables appropriately.\"\"\"\n        return ''",
        "docstring": "This method returns an empty string representation of the NoDefaultType instance.\n\nIt overrides the __str__ method from the default object behavior to provide a specific output for instances of this class, which is used to signify the absence of a default value in the context of environment variable management within the EnvVariable class. The NoDefault class serves as a marker for cases where a default value is not set, allowing the EnvVariable class to handle mandatory environment variables appropriately.",
        "signature": "def __str__(self):",
        "type": "Method",
        "class_signature": "class NoDefaultType(object):"
      },
      "_normalized": {
        "code": "def _normalized(name: str) -> str:\n    \"\"\"Normalize the input string by converting it to uppercase, replacing periods with underscores, and removing trailing underscores.\n\nParameters:\n- name (str): The input string to be normalized.\n\nReturns:\n- str: The normalized version of the input string with the specified transformations applied.\n\nThis function is used in the `EnvVariable` class to standardize environment variable names for consistent handling within the environment configuration system.\"\"\"\n    return name.upper().replace('.', '_').rstrip('_')",
        "docstring": "Normalize the input string by converting it to uppercase, replacing periods with underscores, and removing trailing underscores.\n\nParameters:\n- name (str): The input string to be normalized.\n\nReturns:\n- str: The normalized version of the input string with the specified transformations applied.\n\nThis function is used in the `EnvVariable` class to standardize environment variable names for consistent handling within the environment configuration system.",
        "signature": "def _normalized(name: str) -> str:",
        "type": "Function",
        "class_signature": null
      },
      "EnvVariable.__init__": {
        "code": "    def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:\n        \"\"\"Initialize an environment variable descriptor for the Env class.\n\nThis initializer sets up the properties of an EnvVariable, defining its type, name, and various optional parameters for parsing, validation, mapping, and documentation. It checks the compatibility of the default value with the specified type and prepares the full name for environment variable retrieval, adhering to the naming conventions defined in the _normalized function. This function interacts with the Env class, allowing users to define environment variables that can be managed and retrieved safely.\n\nParameters:\n- type (t.Union[object, t.Type[T]]): The expected data type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (Optional[t.Callable[[str], T]]): A function for parsing the raw string value into the expected type.\n- validator (Optional[t.Callable[[T], None]]): A function for validating the parsed value.\n- map (Optional[MapType]): A mapping function for transforming the value.\n- default (t.Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault.\n- deprecations (Optional[t.List[DeprecationInfo]]): A list of deprecation warnings associated with this variable.\n- private (bool): A flag indicating if the variable is private (prefixed with an underscore).\n- help (Optional[str]): Help text associated with the variable.\n- help_type (Optional[str]): Help text describing the type of the variable.\n- help_default (Optional[str]): Help message for the default value.\n\nRaises:\n- TypeError: If the default value is not compatible with the specified type.\n\nAttributes:\n- self.type: Stores the expected type of the environment variable.\n- self.name: The environment variable's name.\n- self.parser: The optional parser for type conversion.\n- self.validator: The optional validator for value checking.\n- self.default: The default value for the environment variable.\n- self.private: Indicates if the variable is private.\n\nThe _normalized function is used to transform the variable name into a standardized format, which is crucial for consistency when accessing environment variables.\"\"\"\n        if hasattr(type, '__origin__') and type.__origin__ is t.Union:\n            if not isinstance(default, type.__args__):\n                raise TypeError('default must be either of these types {}'.format(type.__args__))\n        elif default is not NoDefault and (not isinstance(default, type)):\n            raise TypeError('default must be of type {}'.format(type))\n        self.type = type\n        self.name = name\n        self.parser = parser\n        self.validator = validator\n        self.map = map\n        self.default = default\n        self.deprecations = deprecations\n        self.private = private\n        self.help = help\n        self.help_type = help_type\n        self.help_default = help_default\n        self._full_name = _normalized(name)",
        "docstring": "Initialize an environment variable descriptor for the Env class.\n\nThis initializer sets up the properties of an EnvVariable, defining its type, name, and various optional parameters for parsing, validation, mapping, and documentation. It checks the compatibility of the default value with the specified type and prepares the full name for environment variable retrieval, adhering to the naming conventions defined in the _normalized function. This function interacts with the Env class, allowing users to define environment variables that can be managed and retrieved safely.\n\nParameters:\n- type (t.Union[object, t.Type[T]]): The expected data type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (Optional[t.Callable[[str], T]]): A function for parsing the raw string value into the expected type.\n- validator (Optional[t.Callable[[T], None]]): A function for validating the parsed value.\n- map (Optional[MapType]): A mapping function for transforming the value.\n- default (t.Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault.\n- deprecations (Optional[t.List[DeprecationInfo]]): A list of deprecation warnings associated with this variable.\n- private (bool): A flag indicating if the variable is private (prefixed with an underscore).\n- help (Optional[str]): Help text associated with the variable.\n- help_type (Optional[str]): Help text describing the type of the variable.\n- help_default (Optional[str]): Help message for the default value.\n\nRaises:\n- TypeError: If the default value is not compatible with the specified type.\n\nAttributes:\n- self.type: Stores the expected type of the environment variable.\n- self.name: The environment variable's name.\n- self.parser: The optional parser for type conversion.\n- self.validator: The optional validator for value checking.\n- self.default: The default value for the environment variable.\n- self.private: Indicates if the variable is private.\n\nThe _normalized function is used to transform the variable name into a standardized format, which is crucial for consistency when accessing environment variables.",
        "signature": "def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:",
        "type": "Method",
        "class_signature": "class EnvVariable(t.Generic[T]):"
      },
      "EnvMeta.__new__": {
        "code": "    def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:\n        \"\"\"This method is a custom metaclass for the Env class, facilitating the creation of environment variable bindings. It initializes a new Env instance, allowing for the configuration of environment variables within a given namespace.\n\nParameters:\n- cls: The metaclass itself, usually passed implicitly.\n- name: The name of the class being created.\n- bases: A tuple containing the base classes of the class being created.\n- ns: A dictionary containing the namespace (attributes and methods) of the class being created.\n\nReturns:\n- An instance of the Env class, populated with its environment variables and prefixed appropriately.\n\nSide Effects:\n- If the class has a `__prefix__` attribute, this method updates the `_full_name` for each EnvVariable in the environment to include the prefix, normalized to uppercase and formatted with underscores. This affects how environment variables are looked up and ensures consistency in naming conventions.\n\nDependencies:\n- The `_normalized` function is used to transform the prefix and variable names into a suitable format for environment variable handling.\n- It leverages the `values` method to gather all EnvVariables defined in the Env class, setting their full names according to the defined prefix.\"\"\"\n        env = t.cast('Env', super().__new__(cls, name, bases, ns))\n        prefix = ns.get('__prefix__')\n        if prefix:\n            for v in env.values(recursive=True):\n                if isinstance(v, EnvVariable):\n                    v._full_name = f'{_normalized(prefix)}_{v._full_name}'.upper()\n        return env",
        "docstring": "This method is a custom metaclass for the Env class, facilitating the creation of environment variable bindings. It initializes a new Env instance, allowing for the configuration of environment variables within a given namespace.\n\nParameters:\n- cls: The metaclass itself, usually passed implicitly.\n- name: The name of the class being created.\n- bases: A tuple containing the base classes of the class being created.\n- ns: A dictionary containing the namespace (attributes and methods) of the class being created.\n\nReturns:\n- An instance of the Env class, populated with its environment variables and prefixed appropriately.\n\nSide Effects:\n- If the class has a `__prefix__` attribute, this method updates the `_full_name` for each EnvVariable in the environment to include the prefix, normalized to uppercase and formatted with underscores. This affects how environment variables are looked up and ensures consistency in naming conventions.\n\nDependencies:\n- The `_normalized` function is used to transform the prefix and variable names into a suitable format for environment variable handling.\n- It leverages the `values` method to gather all EnvVariables defined in the Env class, setting their full names according to the defined prefix.",
        "signature": "def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:",
        "type": "Method",
        "class_signature": "class EnvMeta(type):"
      },
      "Env.var": {
        "code": "    def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        \"\"\"Register an environment variable within the Env subclass.\n\nThis method is used to declare a mapping between an attribute of the subclass and an environment variable. It creates an instance of the `EnvVariable` class, which handles the retrieval and validation of the environment variable.\n\nParameters:\n- `type` (t.Type[T]): The expected type of the environment variable.\n- `name` (str): The name of the environment variable.\n- `parser` (Optional[t.Callable[[str], T]]): An optional function to parse the raw string value.\n- `validator` (Optional[t.Callable[[T], None]]): An optional function to validate the parsed value. It should raise a ValueError for invalid values.\n- `map` (Optional[MapType]): A function to map raw values before returning them.\n- `default` (Union[T, NoDefaultType]): A default value if the environment variable is not set. Must be of the specified type unless using `NoDefault`.\n- `deprecations` (Optional[t.List[DeprecationInfo]]): A list of tuples providing deprecation information for the variable.\n- `private` (bool): If True, the variable will be treated as private, prefixing the full name with an underscore.\n- `help` (Optional[str]): A help message for the variable.\n- `help_type` (Optional[str]): A description of the expected type for the variable.\n- `help_default` (Optional[str]): A message describing the default value if it is used.\n\nReturns:\n- EnvVariable[T]: An instance of `EnvVariable` which can be used to fetch the environment variable value.\n\nThis method utilizes the `NoDefaultType` constant to differentiate between provided default values and the absence of a default. It interacts closely with the `EnvVariable` class, which defines the behavior for retrieving and validating the environment variable's value.\"\"\"\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)",
        "docstring": "Register an environment variable within the Env subclass.\n\nThis method is used to declare a mapping between an attribute of the subclass and an environment variable. It creates an instance of the `EnvVariable` class, which handles the retrieval and validation of the environment variable.\n\nParameters:\n- `type` (t.Type[T]): The expected type of the environment variable.\n- `name` (str): The name of the environment variable.\n- `parser` (Optional[t.Callable[[str], T]]): An optional function to parse the raw string value.\n- `validator` (Optional[t.Callable[[T], None]]): An optional function to validate the parsed value. It should raise a ValueError for invalid values.\n- `map` (Optional[MapType]): A function to map raw values before returning them.\n- `default` (Union[T, NoDefaultType]): A default value if the environment variable is not set. Must be of the specified type unless using `NoDefault`.\n- `deprecations` (Optional[t.List[DeprecationInfo]]): A list of tuples providing deprecation information for the variable.\n- `private` (bool): If True, the variable will be treated as private, prefixing the full name with an underscore.\n- `help` (Optional[str]): A help message for the variable.\n- `help_type` (Optional[str]): A description of the expected type for the variable.\n- `help_default` (Optional[str]): A message describing the default value if it is used.\n\nReturns:\n- EnvVariable[T]: An instance of `EnvVariable` which can be used to fetch the environment variable value.\n\nThis method utilizes the `NoDefaultType` constant to differentiate between provided default values and the absence of a default. It interacts closely with the `EnvVariable` class, which defines the behavior for retrieving and validating the environment variable's value.",
        "signature": "def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      },
      "Env.items": {
        "code": "    def items(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n        \"\"\"Returns an iterator over the environment variable items declared in the Env class.\n\nThe method retrieves both `EnvVariable` and `DerivedVariable` items from the Env class, optionally including derived variables based on the `include_derived` flag. If `recursive` is set to True, it will also traverse any nested subclass instances of Env and include their variables. Each yield produces a tuple containing the full path to the variable (as a dot-separated string) and the variable itself.\n\nParameters:\n- cls: The Env subclass from which to retrieve the variable items.\n- recursive (bool): Indicates whether to include variables from nested Env subclasses.\n- include_derived (bool): When True, includes derived variables in the output.\n\nReturns:\nAn iterator of tuples, where each tuple contains the full name of the variable and the corresponding variable instance (either EnvVariable or DerivedVariable).\n\nInternal Usage:\n- `q`: A deque used for breadth-first traversal of subclasses to gather variables.\n- `classes`: A tuple determining which variable types to include in the results based on the `include_derived` flag.\"\"\"\n        classes = (EnvVariable, DerivedVariable) if include_derived else (EnvVariable,)\n        q: t.Deque[t.Tuple[t.Tuple[str], t.Type['Env']]] = deque()\n        path: t.Tuple[str] = tuple()\n        q.append((path, cls))\n        while q:\n            path, env = q.popleft()\n            for k, v in env.__dict__.items():\n                if isinstance(v, classes):\n                    yield ('.'.join((*path, k)), t.cast(t.Union[EnvVariable, DerivedVariable], v))\n                elif isinstance(v, type) and issubclass(v, Env) and recursive:\n                    item_name = getattr(v, '__item__', k)\n                    if item_name is None:\n                        item_name = k\n                    q.append(((*path, item_name), v))",
        "docstring": "Returns an iterator over the environment variable items declared in the Env class.\n\nThe method retrieves both `EnvVariable` and `DerivedVariable` items from the Env class, optionally including derived variables based on the `include_derived` flag. If `recursive` is set to True, it will also traverse any nested subclass instances of Env and include their variables. Each yield produces a tuple containing the full path to the variable (as a dot-separated string) and the variable itself.\n\nParameters:\n- cls: The Env subclass from which to retrieve the variable items.\n- recursive (bool): Indicates whether to include variables from nested Env subclasses.\n- include_derived (bool): When True, includes derived variables in the output.\n\nReturns:\nAn iterator of tuples, where each tuple contains the full name of the variable and the corresponding variable instance (either EnvVariable or DerivedVariable).\n\nInternal Usage:\n- `q`: A deque used for breadth-first traversal of subclasses to gather variables.\n- `classes`: A tuple determining which variable types to include in the results based on the `include_derived` flag.",
        "signature": "def items(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      },
      "Env.values": {
        "code": "    def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:\n        \"\"\"Return an iterator over the values of all configuration items defined in the class.\n\nParameters:\n- recursive (bool): If set to True, this parameter allows the method to traverse and include values from nested Env subclasses. Defaults to False.\n- include_derived (bool): If set to True, this parameter enables the inclusion of derived variables in the results. Defaults to False.\n\nReturns:\n- Iterator[Union[EnvVariable, DerivedVariable, Type[Env]]]: An iterator yielding values of type EnvVariable, DerivedVariable, or the type of the Env subclass itself.\n\nThis method interacts with the `items` method to retrieve the configuration items, and it is designed to work within the class context of Env, which manages environment variable definitions. The method facilitates access to environment configurations, enhancing data retrieval from various Env subclasses.\"\"\"\n        'Return the value of all the configuration items.'\n        for _, v in cls.items(recursive, include_derived):\n            yield v",
        "docstring": "Return an iterator over the values of all configuration items defined in the class.\n\nParameters:\n- recursive (bool): If set to True, this parameter allows the method to traverse and include values from nested Env subclasses. Defaults to False.\n- include_derived (bool): If set to True, this parameter enables the inclusion of derived variables in the results. Defaults to False.\n\nReturns:\n- Iterator[Union[EnvVariable, DerivedVariable, Type[Env]]]: An iterator yielding values of type EnvVariable, DerivedVariable, or the type of the Env subclass itself.\n\nThis method interacts with the `items` method to retrieve the configuration items, and it is designed to work within the class context of Env, which manages environment variable definitions. The method facilitates access to environment configurations, enhancing data retrieval from various Env subclasses.",
        "signature": "def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      },
      "Env.help_info": {
        "code": "    def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:\n        \"\"\"Extracts help information from the environment configuration class.\n\nParameters:\n- cls (Type[Env]): The class from which to extract environment variable information.\n- recursive (bool): If True, includes environment variables from nested Env classes.\n- include_private (bool): If True, includes variables marked as private (name starts with an underscore).\n\nReturns:\n- List[HelpInfo]: A list of tuples containing the variable name (formatted for display), type, default value, and help text for each environment variable declared in the class.\n\nThis method relies on the `EnvVariable` class for its entries and uses the `_normalized` function to format variable names consistently. It also appends a period to help messages if needed and gathers help information in a depth-first manner from nested Env classes when `recursive` is set to True.\"\"\"\n        'Extract the help information from the class.\\n\\n        Returns a list of all the environment variables declared by the class.\\n        The format of each entry is a t.Tuple consisting of the variable name (in\\n        double backtics quotes), the type, the default value, and the help text.\\n\\n        Set ``recursive`` to ``True`` to include variables from nested Env\\n        classes.\\n\\n        Set ``include_private`` to ``True`` to include variables that are\\n        marked as private (i.e. their name starts with an underscore).\\n        '\n        entries = []\n\n        def add_entries(full_prefix: str, config: t.Type[Env]) -> None:\n            vars = sorted((_ for _ in config.values() if isinstance(_, EnvVariable)), key=lambda v: v.name)\n            for v in vars:\n                if not include_private and v.private:\n                    continue\n                help_message = v.help.strip() if v.help is not None else ''\n                if help_message and (not help_message.endswith('.')):\n                    help_message += '.'\n                if v.help_type is not None:\n                    help_type = v.help_type\n                else:\n                    try:\n                        help_type = v.type.__name__\n                    except AttributeError:\n                        help_type = v.type.__args__[0].__name__\n                private_prefix = '_' if v.private else ''\n                entries.append(HelpInfo(f'{private_prefix}{full_prefix}{_normalized(v.name)}', help_type, v.help_default if v.help_default is not None else str(v.default), help_message))\n        configs = [('', cls)]\n        while configs:\n            full_prefix, config = configs.pop()\n            new_prefix = full_prefix + _normalized(config.__prefix__)\n            if new_prefix and (not new_prefix.endswith('_')):\n                new_prefix += '_'\n            add_entries(new_prefix, config)\n            if not recursive:\n                break\n            subconfigs = sorted(((new_prefix, v) for k, v in config.__dict__.items() if isinstance(v, type) and issubclass(v, Env) and (k != 'parent')), key=lambda _: _[1].__prefix__)\n            configs[0:0] = subconfigs\n        return entries",
        "docstring": "Extracts help information from the environment configuration class.\n\nParameters:\n- cls (Type[Env]): The class from which to extract environment variable information.\n- recursive (bool): If True, includes environment variables from nested Env classes.\n- include_private (bool): If True, includes variables marked as private (name starts with an underscore).\n\nReturns:\n- List[HelpInfo]: A list of tuples containing the variable name (formatted for display), type, default value, and help text for each environment variable declared in the class.\n\nThis method relies on the `EnvVariable` class for its entries and uses the `_normalized` function to format variable names consistently. It also appends a period to help messages if needed and gathers help information in a depth-first manner from nested Env classes when `recursive` is set to True.",
        "signature": "def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:",
        "type": "Method",
        "class_signature": "class Env(metaclass=EnvMeta):"
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: envier-test_help\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 envier/\n    \u2514\u2500\u2500 env.py\n        \u251c\u2500\u2500 Env.add_entries\n        \u251c\u2500\u2500 Env.help_info\n        \u251c\u2500\u2500 Env.items\n        \u251c\u2500\u2500 Env.values\n        \u251c\u2500\u2500 Env.var\n        \u251c\u2500\u2500 EnvMeta.__new__\n        \u251c\u2500\u2500 EnvVariable.EnvVariable\n        \u251c\u2500\u2500 EnvVariable.__init__\n        \u251c\u2500\u2500 NoDefaultType.__str__\n        \u2514\u2500\u2500 _normalized\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a centralized configuration management system for an application, enabling both global and service-specific configuration variables to be defined, accessed, and documented. It supports defining environment variables with type enforcement, default values, and detailed descriptions to ensure clarity and ease of use. The module allows recursive documentation of all available configuration variables, making it easier for developers to understand and manage application settings. By standardizing configuration handling and providing built-in help documentation, the module simplifies environment setup, reduces misconfiguration errors, and improves developer productivity.\n\n## FILE 1: envier/env.py\n\n- CLASS METHOD: Env.var\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def var(cls, type: t.Type[T], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n  - DOCSTRING: \n```python\n\"\"\"\nRegister an environment variable within the Env subclass.\n\nThis method is used to declare a mapping between an attribute of the subclass and an environment variable. It creates an instance of the `EnvVariable` class, which handles the retrieval and validation of the environment variable.\n\nParameters:\n- `type` (t.Type[T]): The expected type of the environment variable.\n- `name` (str): The name of the environment variable.\n- `parser` (Optional[t.Callable[[str], T]]): An optional function to parse the raw string value.\n- `validator` (Optional[t.Callable[[T], None]]): An optional function to validate the parsed value. It should raise a ValueError for invalid values.\n- `map` (Optional[MapType]): A function to map raw values before returning them.\n- `default` (Union[T, NoDefaultType]): A default value if the environment variable is not set. Must be of the specified type unless using `NoDefault`.\n- `deprecations` (Optional[t.List[DeprecationInfo]]): A list of tuples providing deprecation information for the variable.\n- `private` (bool): If True, the variable will be treated as private, prefixing the full name with an underscore.\n- `help` (Optional[str]): A help message for the variable.\n- `help_type` (Optional[str]): A description of the expected type for the variable.\n- `help_default` (Optional[str]): A message describing the default value if it is used.\n\nReturns:\n- EnvVariable[T]: An instance of `EnvVariable` which can be used to fetch the environment variable value.\n\nThis method utilizes the `NoDefaultType` constant to differentiate between provided default values and the absence of a default. It interacts closely with the `EnvVariable` class, which defines the behavior for retrieving and validating the environment variable's value.\n\"\"\"\n```\n\n- CLASS METHOD: EnvMeta.__new__\n  - CLASS SIGNATURE: class EnvMeta(type):\n  - SIGNATURE: def __new__(cls, name: str, bases: t.Tuple[t.Type], ns: t.Dict[str, t.Any]) -> t.Any:\n  - DOCSTRING: \n```python\n\"\"\"\nThis method is a custom metaclass for the Env class, facilitating the creation of environment variable bindings. It initializes a new Env instance, allowing for the configuration of environment variables within a given namespace.\n\nParameters:\n- cls: The metaclass itself, usually passed implicitly.\n- name: The name of the class being created.\n- bases: A tuple containing the base classes of the class being created.\n- ns: A dictionary containing the namespace (attributes and methods) of the class being created.\n\nReturns:\n- An instance of the Env class, populated with its environment variables and prefixed appropriately.\n\nSide Effects:\n- If the class has a `__prefix__` attribute, this method updates the `_full_name` for each EnvVariable in the environment to include the prefix, normalized to uppercase and formatted with underscores. This affects how environment variables are looked up and ensures consistency in naming conventions.\n\nDependencies:\n- The `_normalized` function is used to transform the prefix and variable names into a suitable format for environment variable handling.\n- It leverages the `values` method to gather all EnvVariables defined in the Env class, setting their full names according to the defined prefix.\n\"\"\"\n```\n\n- CLASS METHOD: Env.values\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def values(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Union[EnvVariable, DerivedVariable, t.Type['Env']]]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturn an iterator over the values of all configuration items defined in the class.\n\nParameters:\n- recursive (bool): If set to True, this parameter allows the method to traverse and include values from nested Env subclasses. Defaults to False.\n- include_derived (bool): If set to True, this parameter enables the inclusion of derived variables in the results. Defaults to False.\n\nReturns:\n- Iterator[Union[EnvVariable, DerivedVariable, Type[Env]]]: An iterator yielding values of type EnvVariable, DerivedVariable, or the type of the Env subclass itself.\n\nThis method interacts with the `items` method to retrieve the configuration items, and it is designed to work within the class context of Env, which manages environment variable definitions. The method facilitates access to environment configurations, enhancing data retrieval from various Env subclasses.\n\"\"\"\n```\n\n- CLASS METHOD: Env.help_info\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def help_info(cls, recursive: bool=False, include_private: bool=False) -> t.List[HelpInfo]:\n  - DOCSTRING: \n```python\n\"\"\"\nExtracts help information from the environment configuration class.\n\nParameters:\n- cls (Type[Env]): The class from which to extract environment variable information.\n- recursive (bool): If True, includes environment variables from nested Env classes.\n- include_private (bool): If True, includes variables marked as private (name starts with an underscore).\n\nReturns:\n- List[HelpInfo]: A list of tuples containing the variable name (formatted for display), type, default value, and help text for each environment variable declared in the class.\n\nThis method relies on the `EnvVariable` class for its entries and uses the `_normalized` function to format variable names consistently. It also appends a period to help messages if needed and gathers help information in a depth-first manner from nested Env classes when `recursive` is set to True.\n\"\"\"\n```\n\n- CLASS METHOD: Env.items\n  - CLASS SIGNATURE: class Env(metaclass=EnvMeta):\n  - SIGNATURE: def items(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[t.Tuple[str, t.Union[EnvVariable, DerivedVariable]]]:\n  - DOCSTRING: \n```python\n\"\"\"\nReturns an iterator over the environment variable items declared in the Env class.\n\nThe method retrieves both `EnvVariable` and `DerivedVariable` items from the Env class, optionally including derived variables based on the `include_derived` flag. If `recursive` is set to True, it will also traverse any nested subclass instances of Env and include their variables. Each yield produces a tuple containing the full path to the variable (as a dot-separated string) and the variable itself.\n\nParameters:\n- cls: The Env subclass from which to retrieve the variable items.\n- recursive (bool): Indicates whether to include variables from nested Env subclasses.\n- include_derived (bool): When True, includes derived variables in the output.\n\nReturns:\nAn iterator of tuples, where each tuple contains the full name of the variable and the corresponding variable instance (either EnvVariable or DerivedVariable).\n\nInternal Usage:\n- `q`: A deque used for breadth-first traversal of subclasses to gather variables.\n- `classes`: A tuple determining which variable types to include in the results based on the `include_derived` flag.\n\"\"\"\n```\n\n- FUNCTION NAME: _normalized\n  - SIGNATURE: def _normalized(name: str) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nNormalize the input string by converting it to uppercase, replacing periods with underscores, and removing trailing underscores.\n\nParameters:\n- name (str): The input string to be normalized.\n\nReturns:\n- str: The normalized version of the input string with the specified transformations applied.\n\nThis function is used in the `EnvVariable` class to standardize environment variable names for consistent handling within the environment configuration system.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - envier/env.py:EnvMeta:__new__\n    - envier/env.py:Env:help_info\n\n- CLASS METHOD: EnvVariable.__init__\n  - CLASS SIGNATURE: class EnvVariable(t.Generic[T]):\n  - SIGNATURE: def __init__(self, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an environment variable descriptor for the Env class.\n\nThis initializer sets up the properties of an EnvVariable, defining its type, name, and various optional parameters for parsing, validation, mapping, and documentation. It checks the compatibility of the default value with the specified type and prepares the full name for environment variable retrieval, adhering to the naming conventions defined in the _normalized function. This function interacts with the Env class, allowing users to define environment variables that can be managed and retrieved safely.\n\nParameters:\n- type (t.Union[object, t.Type[T]]): The expected data type of the environment variable.\n- name (str): The name of the environment variable.\n- parser (Optional[t.Callable[[str], T]]): A function for parsing the raw string value into the expected type.\n- validator (Optional[t.Callable[[T], None]]): A function for validating the parsed value.\n- map (Optional[MapType]): A mapping function for transforming the value.\n- default (t.Union[T, NoDefaultType]): The default value if the environment variable is not set. Defaults to NoDefault.\n- deprecations (Optional[t.List[DeprecationInfo]]): A list of deprecation warnings associated with this variable.\n- private (bool): A flag indicating if the variable is private (prefixed with an underscore).\n- help (Optional[str]): Help text associated with the variable.\n- help_type (Optional[str]): Help text describing the type of the variable.\n- help_default (Optional[str]): Help message for the default value.\n\nRaises:\n- TypeError: If the default value is not compatible with the specified type.\n\nAttributes:\n- self.type: Stores the expected type of the environment variable.\n- self.name: The environment variable's name.\n- self.parser: The optional parser for type conversion.\n- self.validator: The optional validator for value checking.\n- self.default: The default value for the environment variable.\n- self.private: Indicates if the variable is private.\n\nThe _normalized function is used to transform the variable name into a standardized format, which is crucial for consistency when accessing environment variables.\n\"\"\"\n```\n\n- CLASS METHOD: NoDefaultType.__str__\n  - CLASS SIGNATURE: class NoDefaultType(object):\n  - SIGNATURE: def __str__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nThis method returns an empty string representation of the NoDefaultType instance.\n\nIt overrides the __str__ method from the default object behavior to provide a specific output for instances of this class, which is used to signify the absence of a default value in the context of environment variable management within the EnvVariable class. The NoDefault class serves as a marker for cases where a default value is not set, allowing the EnvVariable class to handle mandatory environment variables appropriately.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "envier/env.py": "from collections import deque\nfrom collections import namedtuple\nimport os\nimport typing as t\nimport warnings\n\nclass NoDefaultType(object):\nNoDefault = NoDefaultType()\nDeprecationInfo = t.Tuple[str, str, str]\nT = t.TypeVar('T')\nK = t.TypeVar('K')\nV = t.TypeVar('V')\nMapType = t.Union[t.Callable[[str], V], t.Callable[[str, str], t.Tuple[K, V]]]\nHelpInfo = namedtuple('HelpInfo', ('name', 'type', 'default', 'help'))\n\ndef _check_type(value: t.Any, _type: t.Union[object, t.Type[T]]) -> bool:\n    if hasattr(_type, '__origin__'):\n        return isinstance(value, _type.__args__)\n    return isinstance(value, _type)\n\nclass EnvVariable(t.Generic[T]):\n\n    @property\n    def full_name(self) -> str:\n        return f'_{self._full_name}' if self.private else self._full_name\n\n    def _cast(self, _type: t.Any, raw: str, env: 'Env') -> t.Any:\n        if _type is bool:\n            return t.cast(T, raw.lower() in env.__truthy__)\n        elif _type in (list, tuple, set):\n            collection = raw.split(env.__item_separator__)\n            return t.cast(T, _type(collection if self.map is None else map(self.map, collection)))\n        elif _type is dict:\n            d = dict((_.split(env.__value_separator__, 1) for _ in raw.split(env.__item_separator__)))\n            if self.map is not None:\n                d = dict((self.map(*_) for _ in d.items()))\n            return t.cast(T, d)\n        if _check_type(raw, _type):\n            return t.cast(T, raw)\n        try:\n            return _type(raw)\n        except Exception as e:\n            msg = f'cannot cast {raw} to {self.type}'\n            raise TypeError(msg) from e\n\n    def _retrieve(self, env: 'Env', prefix: str) -> T:\n        source = env.source\n        full_name = self.full_name\n        raw = source.get(full_name.format(**env.dynamic))\n        if raw is None and self.deprecations:\n            for name, deprecated_when, removed_when in self.deprecations:\n                full_deprecated_name = prefix + _normalized(name)\n                if self.private:\n                    full_deprecated_name = f'_{full_deprecated_name}'\n                raw = source.get(full_deprecated_name.format(**env.dynamic))\n                if raw is not None:\n                    deprecated_when_message = ' in version %s' % deprecated_when if deprecated_when is not None else ''\n                    removed_when_message = ' and will be removed in version %s' % removed_when if removed_when is not None else ''\n                    warnings.warn('%s has been deprecated%s%s. Use %s instead' % (full_deprecated_name, deprecated_when_message, removed_when_message, full_name), DeprecationWarning)\n                    break\n        if raw is None:\n            if not isinstance(self.default, NoDefaultType):\n                return self.default\n            raise KeyError('Mandatory environment variable {} is not set'.format(full_name))\n        if self.parser is not None:\n            parsed = self.parser(raw)\n            if not _check_type(parsed, self.type):\n                raise TypeError('parser returned type {} instead of {}'.format(type(parsed), self.type))\n            return parsed\n        if hasattr(self.type, '__origin__') and self.type.__origin__ is t.Union:\n            for ot in self.type.__args__:\n                try:\n                    return t.cast(T, self._cast(ot, raw, env))\n                except TypeError:\n                    pass\n        return self._cast(self.type, raw, env)\n\n    def __call__(self, env: 'Env', prefix: str) -> T:\n        value = self._retrieve(env, prefix)\n        if self.validator is not None:\n            try:\n                self.validator(value)\n            except ValueError as e:\n                msg = f'Invalid value for environment variable {self.full_name}: {e}'\n                raise ValueError(msg)\n        return value\n\nclass DerivedVariable(t.Generic[T]):\n\n    def __init__(self, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> None:\n        self.type = type\n        self.derivation = derivation\n\n    def __call__(self, env: 'Env') -> T:\n        value = self.derivation(env)\n        if not _check_type(value, self.type):\n            raise TypeError('derivation returned type {} instead of {}'.format(type(value), self.type))\n        return value\n\nclass EnvMeta(type):\n\nclass Env(metaclass=EnvMeta):\n    \"\"\"Env base class.\n\n    This class is meant to be subclassed. The configuration is declared by using\n    the ``Env.var`` and ``Env.der`` class methods. The former declares a mapping\n    between attributes of the instance of the subclass with the environment\n    variables. The latter declares derived attributes that are computed using\n    a given derivation function.\n\n    If variables share a common prefix, this can be specified with the\n    ``__prefix__`` class attribute. t.Any dots in the prefix or the variable names\n    will be replaced with underscores. The variable names will be uppercased\n    before being looked up in the environment.\n\n    By default, boolean variables evaluate to true if their lower-case value is\n    one of ``true``, ``yes``, ``on`` or ``1``. This can be overridden by either\n    passing a custom parser to the variable declaration, or by overriding the\n    ``__truthy__`` class attribute, which is a set of lower-case strings that\n    are considered to be a representation of ``True``.\n\n    There is also basic support for collections. An item of type ``list``,\n    ``t.Tuple`` or ``set`` will be parsed using ``,`` as item separator.\n    Similarly, an item of type ``dict`` will be parsed with ``,`` as item\n    separator, and ``:`` as value separator. These can be changed by overriding\n    the ``__item_separator__`` and ``__value_separator__`` class attributes\n    respectively. All the elements in the collections, including key and values\n    for dictionaries, will be of type string. For more advanced control over\n    the final type, a custom ``parser`` can be passed instead.\n    \"\"\"\n    __truthy__ = frozenset({'1', 'true', 'yes', 'on'})\n    __prefix__ = ''\n    __item__: t.Optional[str] = None\n    __item_separator__ = ','\n    __value_separator__ = ':'\n\n    def __init__(self, source: t.Optional[t.Dict[str, str]]=None, parent: t.Optional['Env']=None, dynamic: t.Optional[t.Dict[str, str]]=None) -> None:\n        self.source = source or os.environ\n        self.parent = parent\n        self.dynamic = {k.upper(): v.upper() for k, v in dynamic.items()} if dynamic is not None else {}\n        self._full_prefix: str = (parent._full_prefix if parent is not None else '') + _normalized(self.__prefix__)\n        if self._full_prefix and (not self._full_prefix.endswith('_')):\n            self._full_prefix += '_'\n        self.spec = self.__class__\n        derived = []\n        for name, e in list(self.__class__.__dict__.items()):\n            if isinstance(e, EnvVariable):\n                setattr(self, name, e(self, self._full_prefix))\n            elif isinstance(e, type) and issubclass(e, Env):\n                if e.__item__ is not None and e.__item__ != name:\n                    setattr(self.spec, e.__item__, e)\n                    delattr(self.spec, name)\n                    name = e.__item__\n                setattr(self, name, e(source, self))\n            elif isinstance(e, DerivedVariable):\n                derived.append((name, e))\n        for n, d in derived:\n            setattr(self, n, d(self))\n\n    @classmethod\n    def v(cls, type: t.Union[object, t.Type[T]], name: str, parser: t.Optional[t.Callable[[str], T]]=None, validator: t.Optional[t.Callable[[T], None]]=None, map: t.Optional[MapType]=None, default: t.Union[T, NoDefaultType]=NoDefault, deprecations: t.Optional[t.List[DeprecationInfo]]=None, private: bool=False, help: t.Optional[str]=None, help_type: t.Optional[str]=None, help_default: t.Optional[str]=None) -> EnvVariable[T]:\n        return EnvVariable(type, name, parser, validator, map, default, deprecations, private, help, help_type, help_default)\n\n    @classmethod\n    def der(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def d(cls, type: t.Type[T], derivation: t.Callable[['Env'], T]) -> DerivedVariable[T]:\n        return DerivedVariable(type, derivation)\n\n    @classmethod\n    def keys(cls, recursive: bool=False, include_derived: bool=False) -> t.Iterator[str]:\n        \"\"\"Return the name of all the configuration items.\"\"\"\n        for k, _ in cls.items(recursive, include_derived):\n            yield k\n\n    @classmethod\n    def include(cls, env_spec: t.Type['Env'], namespace: t.Optional[str]=None, overwrite: bool=False) -> None:\n        \"\"\"Include variables from another Env subclass.\n\n        The new items can be merged at the top level, or parented to a\n        namespace. By default, the method raises a ``ValueError`` if the\n        operation would result in some variables being overwritten. This can\n        be disabled by setting the ``overwrite`` argument to ``True``.\n        \"\"\"\n        to_include = {k: v for k, v in env_spec.__dict__.items() if isinstance(v, (EnvVariable, DerivedVariable)) or (isinstance(v, type) and issubclass(v, Env))}\n        own_prefix = _normalized(getattr(cls, '__prefix__', ''))\n        if namespace is not None:\n            if not overwrite and hasattr(cls, namespace):\n                raise ValueError('Namespace already in use: {}'.format(namespace))\n            if getattr(cls, namespace, None) is not env_spec:\n                setattr(cls, namespace, env_spec)\n                if own_prefix:\n                    for _, v in to_include.items():\n                        if isinstance(v, EnvVariable):\n                            v._full_name = f'{own_prefix}_{v._full_name}'\n            return None\n        if not overwrite:\n            overlap = set(cls.__dict__.keys()) & set(to_include.keys())\n            if overlap:\n                raise ValueError('Configuration clashes detected: {}'.format(overlap))\n        other_prefix = getattr(env_spec, '__prefix__', '')\n        for k, v in to_include.items():\n            if getattr(cls, k, None) is not v:\n                setattr(cls, k, v)\n                if isinstance(v, EnvVariable):\n                    if other_prefix:\n                        v._full_name = v._full_name[len(other_prefix) + 1:]\n                    if own_prefix:\n                        v._full_name = f'{own_prefix}_{v._full_name}'"
  },
  "call_tree": {
    "modified_testcases/test_help.py:ServiceConfig:GlobalConfig": {
      "envier/env.py:Env:var": {
        "envier/env.py:EnvVariable:__init__": {
          "envier/env.py:_normalized": {}
        }
      },
      "modified_testcases/test_help.py:ServiceConfig:ServiceConfig": {
        "envier/env.py:Env:var": {
          "envier/env.py:EnvVariable:__init__": {
            "envier/env.py:_normalized": {}
          }
        }
      },
      "envier/env.py:EnvMeta:__new__": {
        "envier/env.py:Env:values": {
          "envier/env.py:Env:items": {}
        },
        "envier/env.py:_normalized": {}
      }
    },
    "modified_testcases/test_help.py:test_help_info": {
      "envier/env.py:Env:help_info": {
        "envier/env.py:_normalized": {},
        "envier/env.py:Env:add_entries": {
          "envier/env.py:EnvVariable:EnvVariable": {},
          "envier/env.py:Env:values": {
            "envier/env.py:Env:items": {}
          },
          "envier/env.py:_normalized": {},
          "envier/env.py:NoDefaultType:__str__": {}
        }
      }
    },
    "modified_testcases/test_help.py:test_help_info_recursive": {
      "envier/env.py:Env:help_info": {
        "envier/env.py:_normalized": {},
        "envier/env.py:Env:add_entries": {
          "envier/env.py:Env:values": {
            "envier/env.py:Env:items": {}
          },
          "envier/env.py:_normalized": {},
          "envier/env.py:NoDefaultType:__str__": {}
        }
      }
    }
  }
}