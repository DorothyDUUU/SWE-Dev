{
  "dir_path": "/app/pathvalidate",
  "package_name": "pathvalidate",
  "sample_name": "pathvalidate-test_ltsv",
  "src_dir": "pathvalidate/",
  "test_dir": "test/",
  "test_file": "test/test_ltsv.py",
  "test_code": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport itertools\n\nimport pytest\n\nfrom pathvalidate import sanitize_ltsv_label, validate_ltsv_label\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom ._common import INVALID_WIN_FILENAME_CHARS, alphanum_chars\n\n\nVALID_LABEL_CHARS = alphanum_chars + (\"_\", \".\", \"-\")\nINVALID_LABEL_CHARS = INVALID_WIN_FILENAME_CHARS + (\n    \"!\",\n    \"#\",\n    \"$\",\n    \"&\",\n    \"'\",\n    \"=\",\n    \"~\",\n    \"^\",\n    \"@\",\n    \"`\",\n    \"[\",\n    \"]\",\n    \"+\",\n    \";\",\n    \"{\",\n    \"}\",\n    \",\",\n    \"(\",\n    \")\",\n    \"%\",\n    \" \",\n    \"\\t\",\n    \"\\n\",\n    \"\\r\",\n    \"\\f\",\n    \"\\v\",\n)\n\n\nclass Test_validate_ltsv_label:\n    VALID_CHARS = alphanum_chars\n    INVALID_CHARS = INVALID_LABEL_CHARS\n\n    @pytest.mark.parametrize(\n        [\"value\"], [[\"abc\" + valid_char + \"hoge123\"] for valid_char in VALID_CHARS]\n    )\n    def test_normal(self, value):\n        validate_ltsv_label(value)\n\n    @pytest.mark.parametrize(\n        [\"value\"],\n        [[\"abc\" + invalid_char + \"hoge123\"] for invalid_char in INVALID_CHARS]\n        + [[\"\u3042\u3044\u3046\u3048\u304a\"], [\"\u30e9\u30d9\u30eb\"]],\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_ltsv_label(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n\nclass Test_sanitize_ltsv_label:\n    TARGET_CHARS = INVALID_LABEL_CHARS\n    NOT_TARGET_CHARS = alphanum_chars\n    REPLACE_TEXT_LIST = [\"\", \"_\"]\n\n    @pytest.mark.parametrize(\n        [\"value\", \"replace_text\", \"expected\"],\n        [\n            [\"A\" + c + \"B\", rep, \"A\" + rep + \"B\"]\n            for c, rep in itertools.product(TARGET_CHARS, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [\"A\" + c + \"B\", rep, \"A\" + c + \"B\"]\n            for c, rep in itertools.product(NOT_TARGET_CHARS, REPLACE_TEXT_LIST)\n        ],\n    )\n    def test_normal(self, value, replace_text, expected):\n        assert sanitize_ltsv_label(value, replace_text) == expected\n\n    @pytest.mark.parametrize([\"value\", \"expected\"], [[\"a\u3042\u3044b\u3046\u3048c\u304a\", \"abc\"]])\n    def test_normal_multibyte(self, value, expected):\n        sanitize_ltsv_label(value)\n\n    @pytest.mark.parametrize(\n        [\"value\", \"expected\"],\n        [\n            [\"\", ValidationError],\n            [None, ValidationError],\n            [1, TypeError],\n            [True, TypeError],\n        ],\n    )\n    def test_abnormal(self, value, expected):\n        with pytest.raises(expected):\n            sanitize_ltsv_label(value)\n",
  "GT_file_code": {
    "pathvalidate/_common.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport ntpath\nimport platform\nimport re\nimport string\nimport sys\nfrom pathlib import PurePath\nfrom typing import Any, List, Optional\n\nfrom ._const import Platform\nfrom ._types import PathType, PlatformType\n\n\n_re_whitespaces = re.compile(r\"^[\\s]+$\")\n\n\ndef validate_pathtype(\n    text: PathType, allow_whitespaces: bool = False, error_msg: Optional[str] = None\n) -> None:\n    from .error import ErrorReason, ValidationError\n\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n\n    raise TypeError(f\"text must be a string: actual={type(text)}\")\n\n\ndef to_str(name: PathType) -> str:\n    if isinstance(name, PurePath):\n        return str(name)\n\n    return name\n\n\ndef is_nt_abspath(value: str) -> bool:\n    ver_info = sys.version_info[:2]\n    if ver_info <= (3, 10):\n        if value.startswith(\"\\\\\\\\\"):\n            return True\n    elif ver_info >= (3, 13):\n        return ntpath.isabs(value)\n\n    drive, _tail = ntpath.splitdrive(value)\n\n    return ntpath.isabs(value) and len(drive) > 0\n\n\ndef is_null_string(value: Any) -> bool:\n    if value is None:\n        return True\n\n    try:\n        return len(value.strip()) == 0\n    except AttributeError:\n        return False\n\n\ndef _is_not_null_string(value: Any) -> bool:\n    try:\n        return len(value.strip()) > 0\n    except AttributeError:\n        return False\n\n\ndef _get_unprintable_ascii_chars() -> List[str]:\n    return [chr(c) for c in range(128) if chr(c) not in string.printable]\n\n\nunprintable_ascii_chars = tuple(_get_unprintable_ascii_chars())\n\n\ndef _get_ascii_symbols() -> List[str]:\n    symbol_list: List[str] = []\n\n    for i in range(128):\n        c = chr(i)\n\n        if c in unprintable_ascii_chars or c in string.digits + string.ascii_letters:\n            continue\n\n        symbol_list.append(c)\n\n    return symbol_list\n\n\nascii_symbols = tuple(_get_ascii_symbols())\n\n__RE_UNPRINTABLE_CHARS = re.compile(\n    \"[{}]\".format(re.escape(\"\".join(unprintable_ascii_chars))), re.UNICODE\n)\n__RE_ANSI_ESCAPE = re.compile(\n    r\"(?:\\x1B[@-Z\\\\-_]|[\\x80-\\x9A\\x9C-\\x9F]|(?:\\x1B\\[|\\x9B)[0-?]*[ -/]*[@-~])\"\n)\n\n\ndef validate_unprintable_char(text: str) -> None:\n    from .error import InvalidCharError\n\n    match_list = __RE_UNPRINTABLE_CHARS.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f\"unprintable character found: {match_list}\")\n\n\ndef replace_unprintable_char(text: str, replacement_text: str = \"\") -> str:\n    try:\n        return __RE_UNPRINTABLE_CHARS.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError(\"text must be a string\")\n\n\ndef replace_ansi_escape(text: str, replacement_text: str = \"\") -> str:\n    try:\n        return __RE_ANSI_ESCAPE.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError(\"text must be a string\")\n\n\ndef normalize_platform(name: Optional[PlatformType]) -> Platform:\n    if isinstance(name, Platform):\n        return name\n\n    if not name:\n        return Platform.UNIVERSAL\n\n    platform_str = name.strip().casefold()\n\n    if platform_str == \"posix\":\n        return Platform.POSIX\n\n    if platform_str == \"auto\":\n        platform_str = platform.system().casefold()\n\n    if platform_str in [\"linux\"]:\n        return Platform.LINUX\n\n    if platform_str and platform_str.startswith(\"win\"):\n        return Platform.WINDOWS\n\n    if platform_str in [\"mac\", \"macos\", \"darwin\"]:\n        return Platform.MACOS\n\n    return Platform.UNIVERSAL\n\n\ndef findall_to_str(match: List[Any]) -> str:\n    return \", \".join([repr(text) for text in match])\n\n\ndef truncate_str(text: str, encoding: str, max_bytes: int) -> str:\n    str_bytes = text.encode(encoding)\n    str_bytes = str_bytes[:max_bytes]\n    # last char might be malformed, ignore it\n    return str_bytes.decode(encoding, \"ignore\")\n",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport enum\nfrom typing import Dict, Optional\n\nfrom ._const import Platform\n\n\ndef _to_error_code(code: int) -> str:\n    return f\"PV{code:04d}\"\n\n\nclass ErrorAttrKey:\n    BYTE_COUNT = \"byte_count\"\n    DESCRIPTION = \"description\"\n    FS_ENCODING = \"fs_encoding\"\n    PLATFORM = \"platform\"\n    REASON = \"reason\"\n    RESERVED_NAME = \"reserved_name\"\n    REUSABLE_NAME = \"reusable_name\"\n\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n\n    NULL_NAME = (_to_error_code(1001), \"NULL_NAME\", \"the value must not be an empty string\")\n    RESERVED_NAME = (\n        _to_error_code(1002),\n        \"RESERVED_NAME\",\n        \"found a reserved name by a platform\",\n    )\n    INVALID_CHARACTER = (\n        _to_error_code(1100),\n        \"INVALID_CHARACTER\",\n        \"invalid characters found\",\n    )\n    INVALID_LENGTH = (\n        _to_error_code(1101),\n        \"INVALID_LENGTH\",\n        \"found an invalid string length\",\n    )\n    FOUND_ABS_PATH = (\n        _to_error_code(1200),\n        \"FOUND_ABS_PATH\",\n        \"found an absolute path where must be a relative path\",\n    )\n    MALFORMED_ABS_PATH = (\n        _to_error_code(1201),\n        \"MALFORMED_ABS_PATH\",\n        \"found a malformed absolute path\",\n    )\n    INVALID_AFTER_SANITIZE = (\n        _to_error_code(2000),\n        \"INVALID_AFTER_SANITIZE\",\n        \"found invalid value after sanitizing\",\n    )\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f\"[{self.__code}] {self.__description}\"\n\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def reason(self) -> ErrorReason:\n        \"\"\"\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\n        \"\"\"\n        return self.__reason\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f\"{ErrorAttrKey.REASON} must be specified\")\n\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, \"\")\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n\n        slog: Dict[str, str] = {\n            \"code\": self.reason.code,\n            ErrorAttrKey.DESCRIPTION: self.reason.description,\n        }\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n\n        if self.platform:\n            item_list.append(f\"{ErrorAttrKey.PLATFORM}={self.platform.value}\")\n        if self.description:\n            item_list.append(f\"{ErrorAttrKey.DESCRIPTION}={self.description}\")\n        if self.__reusable_name is not None:\n            item_list.append(f\"{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}\")\n        if self.__fs_encoding:\n            item_list.append(f\"{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}\")\n        if self.__byte_count is not None:\n            item_list.append(f\"{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}\")\n\n        if item_list:\n            header += \": \"\n\n        return header + \", \".join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n\n        super().__init__(args, **kwargs)\n\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n\n        super().__init__(args, **kwargs)\n\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n\n        super().__init__(args, **kwargs)\n\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n\n        super().__init__(args, **kwargs)\n",
    "pathvalidate/_ltsv.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\n\nimport re\n\nfrom ._common import to_str, validate_pathtype\nfrom .error import InvalidCharError\n\n\n__RE_INVALID_LTSV_LABEL = re.compile(\"[^0-9A-Za-z_.-]\", re.UNICODE)\n\n\ndef validate_ltsv_label(label: str) -> None:\n    \"\"\"\n    Verifying whether ``label`` is a valid\n    `Labeled Tab-separated Values (LTSV) <http://ltsv.org/>`__ label or not.\n\n    :param label: Label to validate.\n    :raises pathvalidate.ValidationError:\n        If invalid character(s) found in the ``label`` for a LTSV format label.\n    \"\"\"\n\n    validate_pathtype(label, allow_whitespaces=False)\n\n    match_list = __RE_INVALID_LTSV_LABEL.findall(to_str(label))\n    if match_list:\n        raise InvalidCharError(f\"invalid character found for a LTSV format label: {match_list}\")\n\n\ndef sanitize_ltsv_label(label: str, replacement_text: str = \"\") -> str:\n    \"\"\"\n    Replace all of the symbols in text.\n\n    :param label: Input text.\n    :param replacement_text: Replacement text.\n    :return: A replacement string.\n    :rtype: str\n    \"\"\"\n\n    validate_pathtype(label, allow_whitespaces=False)\n\n    return __RE_INVALID_LTSV_LABEL.sub(replacement_text, to_str(label))\n"
  },
  "GT_src_dict": {
    "pathvalidate/_common.py": {
      "validate_pathtype": {
        "code": "def validate_pathtype(text: PathType, allow_whitespaces: bool=False, error_msg: Optional[str]=None) -> None:\n    \"\"\"Validate the type of a given path input.\n\nThis function checks if the provided `text` is a valid path. It supports checking for strings, `PurePath` instances, and has an option to allow whitespace-only inputs. If the validation fails, it raises a `ValidationError` with a reason if the input is a null string, or a `TypeError` if the input type is incorrect.\n\nParameters:\n- text (PathType): The input to validate, where `PathType` can be a string or `PurePath`.\n- allow_whitespaces (bool, optional): If set to True, whitespace-only strings are considered valid. Defaults to False.\n- error_msg (Optional[str], optional): Custom error message (not utilized in the current implementation).\n\nReturns:\n- None: This function does not return any value; it raises exceptions when validation fails.\n\nDependencies:\n- Utilizes `_is_not_null_string` and `is_null_string` for validating string contents.\n- Uses the `ValidationError` and `ErrorReason` classes from the `.error` module for error handling.\n- Uses the `_re_whitespaces` regex defined as a regular expression for matching whitespace strings.\"\"\"\n    from .error import ErrorReason, ValidationError\n    if _is_not_null_string(text) or isinstance(text, PurePath):\n        return\n    if allow_whitespaces and _re_whitespaces.search(str(text)):\n        return\n    if is_null_string(text):\n        raise ValidationError(reason=ErrorReason.NULL_NAME)\n    raise TypeError(f'text must be a string: actual={type(text)}')",
        "docstring": "Validate the type of a given path input.\n\nThis function checks if the provided `text` is a valid path. It supports checking for strings, `PurePath` instances, and has an option to allow whitespace-only inputs. If the validation fails, it raises a `ValidationError` with a reason if the input is a null string, or a `TypeError` if the input type is incorrect.\n\nParameters:\n- text (PathType): The input to validate, where `PathType` can be a string or `PurePath`.\n- allow_whitespaces (bool, optional): If set to True, whitespace-only strings are considered valid. Defaults to False.\n- error_msg (Optional[str], optional): Custom error message (not utilized in the current implementation).\n\nReturns:\n- None: This function does not return any value; it raises exceptions when validation fails.\n\nDependencies:\n- Utilizes `_is_not_null_string` and `is_null_string` for validating string contents.\n- Uses the `ValidationError` and `ErrorReason` classes from the `.error` module for error handling.\n- Uses the `_re_whitespaces` regex defined as a regular expression for matching whitespace strings.",
        "signature": "def validate_pathtype(text: PathType, allow_whitespaces: bool=False, error_msg: Optional[str]=None) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "to_str": {
        "code": "def to_str(name: PathType) -> str:\n    \"\"\"Converts a given input to a string representation.\n\nParameters:\n    name (PathType): The input value to be converted. This can be a string or an instance of PurePath.\n\nReturns:\n    str: The string representation of the input value. If the input is of type PurePath, it is converted to a string; otherwise, the input is returned directly as a string.\n\nNotes:\n    - PathType can be any type that represents a path, including strings and PurePath instances.\n    - This function simplifies the handling of path representations within the context of file and directory operations in the code.\"\"\"\n    if isinstance(name, PurePath):\n        return str(name)\n    return name",
        "docstring": "Converts a given input to a string representation.\n\nParameters:\n    name (PathType): The input value to be converted. This can be a string or an instance of PurePath.\n\nReturns:\n    str: The string representation of the input value. If the input is of type PurePath, it is converted to a string; otherwise, the input is returned directly as a string.\n\nNotes:\n    - PathType can be any type that represents a path, including strings and PurePath instances.\n    - This function simplifies the handling of path representations within the context of file and directory operations in the code.",
        "signature": "def to_str(name: PathType) -> str:",
        "type": "Function",
        "class_signature": null
      }
    },
    "pathvalidate/error.py": {
      "ValidationError.reason": {
        "code": "    def reason(self) -> ErrorReason:\n        \"\"\"@property\ndef reason(self) -> ErrorReason:\"\"\"\n        '\\n        :py:class:`~pathvalidate.error.ErrorReason`: The cause of the error.\\n        '\n        return self.__reason",
        "docstring": "@property\ndef reason(self) -> ErrorReason:",
        "signature": "def reason(self) -> ErrorReason:",
        "type": "Method",
        "class_signature": "class ValidationError(ValueError):"
      },
      "InvalidCharError.__init__": {
        "code": "    def __init__(self, *args, **kwargs) -> None:\n        \"\"\"Initialize an instance of the InvalidCharError exception.\n\nThis constructor sets the error reason to ErrorReason.INVALID_CHARACTER,\nindicating that the exception is raised due to the presence of invalid\ncharacters in a string. It forwards additional arguments and keyword \narguments to the parent ValidationError class for further processing.\n\nParameters:\n    *args: Any additional positional arguments to be passed to the \n           ValidationError constructor.\n    **kwargs: Any additional keyword arguments to be passed to the \n              ValidationError constructor. An important keyword is \n              'description', providing more context about the error.\n\nAttributes:\n    Sets the 'reason' attribute of the ValidationError instance\n    to ErrorReason.INVALID_CHARACTER, which is defined in the ErrorReason \n    enum class. This allows for standardized error handling and reporting\n    across the validation framework.\"\"\"\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.INVALID_CHARACTER\n        super().__init__(args, **kwargs)",
        "docstring": "Initialize an instance of the InvalidCharError exception.\n\nThis constructor sets the error reason to ErrorReason.INVALID_CHARACTER,\nindicating that the exception is raised due to the presence of invalid\ncharacters in a string. It forwards additional arguments and keyword \narguments to the parent ValidationError class for further processing.\n\nParameters:\n    *args: Any additional positional arguments to be passed to the \n           ValidationError constructor.\n    **kwargs: Any additional keyword arguments to be passed to the \n              ValidationError constructor. An important keyword is \n              'description', providing more context about the error.\n\nAttributes:\n    Sets the 'reason' attribute of the ValidationError instance\n    to ErrorReason.INVALID_CHARACTER, which is defined in the ErrorReason \n    enum class. This allows for standardized error handling and reporting\n    across the validation framework.",
        "signature": "def __init__(self, *args, **kwargs) -> None:",
        "type": "Method",
        "class_signature": "class InvalidCharError(ValidationError):"
      }
    },
    "pathvalidate/_ltsv.py": {
      "validate_ltsv_label": {
        "code": "def validate_ltsv_label(label: str) -> None:\n    \"\"\"Verifies if the provided ``label`` is a valid Labeled Tab-separated Values (LTSV) label. This function checks for invalid characters using a predefined regular expression (`__RE_INVALID_LTSV_LABEL`), which matches any character that is not a digit, letter, underscore, period, or hyphen. If the label contains any invalid characters, an `InvalidCharError` is raised, providing details of the offending characters.\n\n:param label: The LTSV label to validate, which should not contain whitespace.\n:raises pathvalidate.ValidationError: If the input label is not a valid path type.\n:raises InvalidCharError: If invalid character(s) are found in the label.\"\"\"\n    '\\n    Verifying whether ``label`` is a valid\\n    `Labeled Tab-separated Values (LTSV) <http://ltsv.org/>`__ label or not.\\n\\n    :param label: Label to validate.\\n    :raises pathvalidate.ValidationError:\\n        If invalid character(s) found in the ``label`` for a LTSV format label.\\n    '\n    validate_pathtype(label, allow_whitespaces=False)\n    match_list = __RE_INVALID_LTSV_LABEL.findall(to_str(label))\n    if match_list:\n        raise InvalidCharError(f'invalid character found for a LTSV format label: {match_list}')",
        "docstring": "Verifies if the provided ``label`` is a valid Labeled Tab-separated Values (LTSV) label. This function checks for invalid characters using a predefined regular expression (`__RE_INVALID_LTSV_LABEL`), which matches any character that is not a digit, letter, underscore, period, or hyphen. If the label contains any invalid characters, an `InvalidCharError` is raised, providing details of the offending characters.\n\n:param label: The LTSV label to validate, which should not contain whitespace.\n:raises pathvalidate.ValidationError: If the input label is not a valid path type.\n:raises InvalidCharError: If invalid character(s) are found in the label.",
        "signature": "def validate_ltsv_label(label: str) -> None:",
        "type": "Function",
        "class_signature": null
      },
      "sanitize_ltsv_label": {
        "code": "def sanitize_ltsv_label(label: str, replacement_text: str='') -> str:\n    \"\"\"Sanitizes a Labeled Tab-separated Values (LTSV) label by replacing invalid symbols with a specified replacement string.\n\n:param label: The input string representing the LTSV label to be sanitized.\n:param replacement_text: The string to replace invalid characters with; defaults to an empty string.\n:return: A sanitized version of the input label with invalid characters replaced.\n:rtype: str\n\nThis function validates the `label` using the `validate_pathtype` function to ensure it complies with the required format for LTSV labels (disallowing whitespace). It utilizes the `__RE_INVALID_LTSV_LABEL` regular expression, which is defined in the code to match any character not allowed in an LTSV label. Invalid characters are substituted with `replacement_text`, resulting in a string suitable for LTSV format.\"\"\"\n    '\\n    Replace all of the symbols in text.\\n\\n    :param label: Input text.\\n    :param replacement_text: Replacement text.\\n    :return: A replacement string.\\n    :rtype: str\\n    '\n    validate_pathtype(label, allow_whitespaces=False)\n    return __RE_INVALID_LTSV_LABEL.sub(replacement_text, to_str(label))",
        "docstring": "Sanitizes a Labeled Tab-separated Values (LTSV) label by replacing invalid symbols with a specified replacement string.\n\n:param label: The input string representing the LTSV label to be sanitized.\n:param replacement_text: The string to replace invalid characters with; defaults to an empty string.\n:return: A sanitized version of the input label with invalid characters replaced.\n:rtype: str\n\nThis function validates the `label` using the `validate_pathtype` function to ensure it complies with the required format for LTSV labels (disallowing whitespace). It utilizes the `__RE_INVALID_LTSV_LABEL` regular expression, which is defined in the code to match any character not allowed in an LTSV label. Invalid characters are substituted with `replacement_text`, resulting in a string suitable for LTSV format.",
        "signature": "def sanitize_ltsv_label(label: str, replacement_text: str='') -> str:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {},
  "PRD": "# PROJECT NAME: pathvalidate-test_ltsv\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 pathvalidate/\n    \u251c\u2500\u2500 _common.py\n    \u2502   \u251c\u2500\u2500 to_str\n    \u2502   \u2514\u2500\u2500 validate_pathtype\n    \u251c\u2500\u2500 _ltsv.py\n    \u2502   \u251c\u2500\u2500 sanitize_ltsv_label\n    \u2502   \u2514\u2500\u2500 validate_ltsv_label\n    \u2514\u2500\u2500 error.py\n        \u251c\u2500\u2500 InvalidCharError.__init__\n        \u2514\u2500\u2500 ValidationError.reason\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module provides functionality for validating and sanitizing label strings intended for Labeled Tab-Separated Value (LTSV) data. It ensures that labels conform to specified character restrictions by validating against a predefined set of valid and invalid characters, throwing appropriate exceptions when validation fails. Additionally, it enables the sanitization of labels by replacing invalid characters with acceptable alternatives or removing them entirely, including support for handling multibyte characters. By facilitating clean, consistent, and compliant LTSV labels, the module reduces the risk of data processing errors, ensuring compatibility and reliability for systems or developers working with LTSV-formatted data.\n\n## FILE 1: pathvalidate/_common.py\n\n- FUNCTION NAME: to_str\n  - SIGNATURE: def to_str(name: PathType) -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a given input to a string representation.\n\nParameters:\n    name (PathType): The input value to be converted. This can be a string or an instance of PurePath.\n\nReturns:\n    str: The string representation of the input value. If the input is of type PurePath, it is converted to a string; otherwise, the input is returned directly as a string.\n\nNotes:\n    - PathType can be any type that represents a path, including strings and PurePath instances.\n    - This function simplifies the handling of path representations within the context of file and directory operations in the code.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_ltsv.py:sanitize_ltsv_label\n    - pathvalidate/_ltsv.py:validate_ltsv_label\n\n- FUNCTION NAME: validate_pathtype\n  - SIGNATURE: def validate_pathtype(text: PathType, allow_whitespaces: bool=False, error_msg: Optional[str]=None) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nValidate the type of a given path input.\n\nThis function checks if the provided `text` is a valid path. It supports checking for strings, `PurePath` instances, and has an option to allow whitespace-only inputs. If the validation fails, it raises a `ValidationError` with a reason if the input is a null string, or a `TypeError` if the input type is incorrect.\n\nParameters:\n- text (PathType): The input to validate, where `PathType` can be a string or `PurePath`.\n- allow_whitespaces (bool, optional): If set to True, whitespace-only strings are considered valid. Defaults to False.\n- error_msg (Optional[str], optional): Custom error message (not utilized in the current implementation).\n\nReturns:\n- None: This function does not return any value; it raises exceptions when validation fails.\n\nDependencies:\n- Utilizes `_is_not_null_string` and `is_null_string` for validating string contents.\n- Uses the `ValidationError` and `ErrorReason` classes from the `.error` module for error handling.\n- Uses the `_re_whitespaces` regex defined as a regular expression for matching whitespace strings.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/error.py:ValidationError:__init__\n    - pathvalidate/_common.py:is_null_string\n    - pathvalidate/_common.py:_is_not_null_string\n    - pathvalidate/_ltsv.py:validate_ltsv_label\n    - pathvalidate/_ltsv.py:sanitize_ltsv_label\n\n## FILE 2: pathvalidate/error.py\n\n- CLASS METHOD: ValidationError.reason\n  - CLASS SIGNATURE: class ValidationError(ValueError):\n  - SIGNATURE: def reason(self) -> ErrorReason:\n  - DOCSTRING: \n```python\n\"\"\"\n@property\ndef reason(self) -> ErrorReason:\n\"\"\"\n```\n\n- CLASS METHOD: InvalidCharError.__init__\n  - CLASS SIGNATURE: class InvalidCharError(ValidationError):\n  - SIGNATURE: def __init__(self, *args, **kwargs) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize an instance of the InvalidCharError exception.\n\nThis constructor sets the error reason to ErrorReason.INVALID_CHARACTER,\nindicating that the exception is raised due to the presence of invalid\ncharacters in a string. It forwards additional arguments and keyword \narguments to the parent ValidationError class for further processing.\n\nParameters:\n    *args: Any additional positional arguments to be passed to the \n           ValidationError constructor.\n    **kwargs: Any additional keyword arguments to be passed to the \n              ValidationError constructor. An important keyword is \n              'description', providing more context about the error.\n\nAttributes:\n    Sets the 'reason' attribute of the ValidationError instance\n    to ErrorReason.INVALID_CHARACTER, which is defined in the ErrorReason \n    enum class. This allows for standardized error handling and reporting\n    across the validation framework.\n\"\"\"\n```\n\n## FILE 3: pathvalidate/_ltsv.py\n\n- FUNCTION NAME: validate_ltsv_label\n  - SIGNATURE: def validate_ltsv_label(label: str) -> None:\n  - DOCSTRING: \n```python\n\"\"\"\nVerifies if the provided ``label`` is a valid Labeled Tab-separated Values (LTSV) label. This function checks for invalid characters using a predefined regular expression (`__RE_INVALID_LTSV_LABEL`), which matches any character that is not a digit, letter, underscore, period, or hyphen. If the label contains any invalid characters, an `InvalidCharError` is raised, providing details of the offending characters.\n\n:param label: The LTSV label to validate, which should not contain whitespace.\n:raises pathvalidate.ValidationError: If the input label is not a valid path type.\n:raises InvalidCharError: If invalid character(s) are found in the label.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/error.py:InvalidCharError:__init__\n    - pathvalidate/_common.py:validate_pathtype\n\n- FUNCTION NAME: sanitize_ltsv_label\n  - SIGNATURE: def sanitize_ltsv_label(label: str, replacement_text: str='') -> str:\n  - DOCSTRING: \n```python\n\"\"\"\nSanitizes a Labeled Tab-separated Values (LTSV) label by replacing invalid symbols with a specified replacement string.\n\n:param label: The input string representing the LTSV label to be sanitized.\n:param replacement_text: The string to replace invalid characters with; defaults to an empty string.\n:return: A sanitized version of the input label with invalid characters replaced.\n:rtype: str\n\nThis function validates the `label` using the `validate_pathtype` function to ensure it complies with the required format for LTSV labels (disallowing whitespace). It utilizes the `__RE_INVALID_LTSV_LABEL` regular expression, which is defined in the code to match any character not allowed in an LTSV label. Invalid characters are substituted with `replacement_text`, resulting in a string suitable for LTSV format.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - pathvalidate/_common.py:to_str\n    - pathvalidate/_common.py:validate_pathtype\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "pathvalidate/_common.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport ntpath\nimport platform\nimport re\nimport string\nimport sys\nfrom pathlib import PurePath\nfrom typing import Any, List, Optional\nfrom ._const import Platform\nfrom ._types import PathType, PlatformType\n_re_whitespaces = re.compile('^[\\\\s]+$')\n\ndef is_nt_abspath(value: str) -> bool:\n    ver_info = sys.version_info[:2]\n    if ver_info <= (3, 10):\n        if value.startswith('\\\\\\\\'):\n            return True\n    elif ver_info >= (3, 13):\n        return ntpath.isabs(value)\n    drive, _tail = ntpath.splitdrive(value)\n    return ntpath.isabs(value) and len(drive) > 0\n\ndef is_null_string(value: Any) -> bool:\n    if value is None:\n        return True\n    try:\n        return len(value.strip()) == 0\n    except AttributeError:\n        return False\n\ndef _is_not_null_string(value: Any) -> bool:\n    try:\n        return len(value.strip()) > 0\n    except AttributeError:\n        return False\n\ndef _get_unprintable_ascii_chars() -> List[str]:\n    return [chr(c) for c in range(128) if chr(c) not in string.printable]\nunprintable_ascii_chars = tuple(_get_unprintable_ascii_chars())\n\ndef _get_ascii_symbols() -> List[str]:\n    symbol_list: List[str] = []\n    for i in range(128):\n        c = chr(i)\n        if c in unprintable_ascii_chars or c in string.digits + string.ascii_letters:\n            continue\n        symbol_list.append(c)\n    return symbol_list\nascii_symbols = tuple(_get_ascii_symbols())\n__RE_UNPRINTABLE_CHARS = re.compile('[{}]'.format(re.escape(''.join(unprintable_ascii_chars))), re.UNICODE)\n__RE_ANSI_ESCAPE = re.compile('(?:\\\\x1B[@-Z\\\\\\\\-_]|[\\\\x80-\\\\x9A\\\\x9C-\\\\x9F]|(?:\\\\x1B\\\\[|\\\\x9B)[0-?]*[ -/]*[@-~])')\n\ndef validate_unprintable_char(text: str) -> None:\n    from .error import InvalidCharError\n    match_list = __RE_UNPRINTABLE_CHARS.findall(to_str(text))\n    if match_list:\n        raise InvalidCharError(f'unprintable character found: {match_list}')\n\ndef replace_unprintable_char(text: str, replacement_text: str='') -> str:\n    try:\n        return __RE_UNPRINTABLE_CHARS.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError('text must be a string')\n\ndef replace_ansi_escape(text: str, replacement_text: str='') -> str:\n    try:\n        return __RE_ANSI_ESCAPE.sub(replacement_text, text)\n    except (TypeError, AttributeError):\n        raise TypeError('text must be a string')\n\ndef normalize_platform(name: Optional[PlatformType]) -> Platform:\n    if isinstance(name, Platform):\n        return name\n    if not name:\n        return Platform.UNIVERSAL\n    platform_str = name.strip().casefold()\n    if platform_str == 'posix':\n        return Platform.POSIX\n    if platform_str == 'auto':\n        platform_str = platform.system().casefold()\n    if platform_str in ['linux']:\n        return Platform.LINUX\n    if platform_str and platform_str.startswith('win'):\n        return Platform.WINDOWS\n    if platform_str in ['mac', 'macos', 'darwin']:\n        return Platform.MACOS\n    return Platform.UNIVERSAL\n\ndef findall_to_str(match: List[Any]) -> str:\n    return ', '.join([repr(text) for text in match])\n\ndef truncate_str(text: str, encoding: str, max_bytes: int) -> str:\n    str_bytes = text.encode(encoding)\n    str_bytes = str_bytes[:max_bytes]\n    return str_bytes.decode(encoding, 'ignore')",
    "pathvalidate/error.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport enum\nfrom typing import Dict, Optional\nfrom ._const import Platform\n\ndef _to_error_code(code: int) -> str:\n    return f'PV{code:04d}'\n\nclass ErrorAttrKey:\n    BYTE_COUNT = 'byte_count'\n    DESCRIPTION = 'description'\n    FS_ENCODING = 'fs_encoding'\n    PLATFORM = 'platform'\n    REASON = 'reason'\n    RESERVED_NAME = 'reserved_name'\n    REUSABLE_NAME = 'reusable_name'\n\n@enum.unique\nclass ErrorReason(enum.Enum):\n    \"\"\"\n    Validation error reasons.\n    \"\"\"\n    NULL_NAME = (_to_error_code(1001), 'NULL_NAME', 'the value must not be an empty string')\n    RESERVED_NAME = (_to_error_code(1002), 'RESERVED_NAME', 'found a reserved name by a platform')\n    INVALID_CHARACTER = (_to_error_code(1100), 'INVALID_CHARACTER', 'invalid characters found')\n    INVALID_LENGTH = (_to_error_code(1101), 'INVALID_LENGTH', 'found an invalid string length')\n    FOUND_ABS_PATH = (_to_error_code(1200), 'FOUND_ABS_PATH', 'found an absolute path where must be a relative path')\n    MALFORMED_ABS_PATH = (_to_error_code(1201), 'MALFORMED_ABS_PATH', 'found a malformed absolute path')\n    INVALID_AFTER_SANITIZE = (_to_error_code(2000), 'INVALID_AFTER_SANITIZE', 'found invalid value after sanitizing')\n\n    @property\n    def code(self) -> str:\n        \"\"\"str: Error code.\"\"\"\n        return self.__code\n\n    @property\n    def name(self) -> str:\n        \"\"\"str: Error reason name.\"\"\"\n        return self.__name\n\n    @property\n    def description(self) -> str:\n        \"\"\"str: Error reason description.\"\"\"\n        return self.__description\n\n    def __init__(self, code: str, name: str, description: str) -> None:\n        self.__name = name\n        self.__code = code\n        self.__description = description\n\n    def __str__(self) -> str:\n        return f'[{self.__code}] {self.__description}'\n\nclass ValidationError(ValueError):\n    \"\"\"\n    Exception class of validation errors.\n    \"\"\"\n\n    @property\n    def platform(self) -> Optional[Platform]:\n        \"\"\"\n        :py:class:`~pathvalidate.Platform`: Platform information.\n        \"\"\"\n        return self.__platform\n\n    @property\n    def description(self) -> Optional[str]:\n        \"\"\"Optional[str]: Error description.\"\"\"\n        return self.__description\n\n    @property\n    def reserved_name(self) -> str:\n        \"\"\"str: Reserved name.\"\"\"\n        return self.__reserved_name\n\n    @property\n    def reusable_name(self) -> Optional[bool]:\n        \"\"\"Optional[bool]: Whether the name is reusable or not.\"\"\"\n        return self.__reusable_name\n\n    @property\n    def fs_encoding(self) -> Optional[str]:\n        \"\"\"Optional[str]: File system encoding.\"\"\"\n        return self.__fs_encoding\n\n    @property\n    def byte_count(self) -> Optional[int]:\n        \"\"\"Optional[int]: Byte count of the path.\"\"\"\n        return self.__byte_count\n\n    def __init__(self, *args, **kwargs) -> None:\n        if ErrorAttrKey.REASON not in kwargs:\n            raise ValueError(f'{ErrorAttrKey.REASON} must be specified')\n        self.__reason: ErrorReason = kwargs.pop(ErrorAttrKey.REASON)\n        self.__byte_count: Optional[int] = kwargs.pop(ErrorAttrKey.BYTE_COUNT, None)\n        self.__platform: Optional[Platform] = kwargs.pop(ErrorAttrKey.PLATFORM, None)\n        self.__description: Optional[str] = kwargs.pop(ErrorAttrKey.DESCRIPTION, None)\n        self.__reserved_name: str = kwargs.pop(ErrorAttrKey.RESERVED_NAME, '')\n        self.__reusable_name: Optional[bool] = kwargs.pop(ErrorAttrKey.REUSABLE_NAME, None)\n        self.__fs_encoding: Optional[str] = kwargs.pop(ErrorAttrKey.FS_ENCODING, None)\n        try:\n            super().__init__(*args[0], **kwargs)\n        except IndexError:\n            super().__init__(*args, **kwargs)\n\n    def as_slog(self) -> Dict[str, str]:\n        \"\"\"Return a dictionary representation of the error.\n\n        Returns:\n            Dict[str, str]: A dictionary representation of the error.\n        \"\"\"\n        slog: Dict[str, str] = {'code': self.reason.code, ErrorAttrKey.DESCRIPTION: self.reason.description}\n        if self.platform:\n            slog[ErrorAttrKey.PLATFORM] = self.platform.value\n        if self.description:\n            slog[ErrorAttrKey.DESCRIPTION] = self.description\n        if self.__reusable_name is not None:\n            slog[ErrorAttrKey.REUSABLE_NAME] = str(self.__reusable_name)\n        if self.__fs_encoding:\n            slog[ErrorAttrKey.FS_ENCODING] = self.__fs_encoding\n        if self.__byte_count:\n            slog[ErrorAttrKey.BYTE_COUNT] = str(self.__byte_count)\n        return slog\n\n    def __str__(self) -> str:\n        item_list = []\n        header = str(self.reason)\n        if Exception.__str__(self):\n            item_list.append(Exception.__str__(self))\n        if self.platform:\n            item_list.append(f'{ErrorAttrKey.PLATFORM}={self.platform.value}')\n        if self.description:\n            item_list.append(f'{ErrorAttrKey.DESCRIPTION}={self.description}')\n        if self.__reusable_name is not None:\n            item_list.append(f'{ErrorAttrKey.REUSABLE_NAME}={self.reusable_name}')\n        if self.__fs_encoding:\n            item_list.append(f'{ErrorAttrKey.FS_ENCODING}={self.__fs_encoding}')\n        if self.__byte_count is not None:\n            item_list.append(f'{ErrorAttrKey.BYTE_COUNT}={self.__byte_count:,d}')\n        if item_list:\n            header += ': '\n        return header + ', '.join(item_list).strip()\n\n    def __repr__(self) -> str:\n        return self.__str__()\n\nclass NullNameError(ValidationError):\n    \"\"\"[Deprecated]\n    Exception raised when a name is empty.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.NULL_NAME\n        super().__init__(args, **kwargs)\n\nclass InvalidCharError(ValidationError):\n    \"\"\"\n    Exception raised when includes invalid character(s) within a string.\n    \"\"\"\n\nclass ReservedNameError(ValidationError):\n    \"\"\"\n    Exception raised when a string matched a reserved name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REASON] = ErrorReason.RESERVED_NAME\n        super().__init__(args, **kwargs)\n\nclass ValidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    However, it can be used as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = True\n        super().__init__(args, **kwargs)\n\nclass InvalidReservedNameError(ReservedNameError):\n    \"\"\"[Deprecated]\n    Exception raised when a string matched a reserved name.\n    Moreover, the reserved name is invalid as a name.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        kwargs[ErrorAttrKey.REUSABLE_NAME] = False\n        super().__init__(args, **kwargs)",
    "pathvalidate/_ltsv.py": "\"\"\"\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n\"\"\"\nimport re\nfrom ._common import to_str, validate_pathtype\nfrom .error import InvalidCharError\n__RE_INVALID_LTSV_LABEL = re.compile('[^0-9A-Za-z_.-]', re.UNICODE)"
  },
  "call_tree": {
    "test/test_ltsv.py:Test_validate_ltsv_label:test_normal": {
      "pathvalidate/_ltsv.py:validate_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_ltsv.py:Test_validate_ltsv_label:test_exception_invalid_char": {
      "pathvalidate/_ltsv.py:validate_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {},
        "pathvalidate/error.py:InvalidCharError:__init__": {
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      },
      "pathvalidate/error.py:ValidationError:reason": {}
    },
    "test/test_ltsv.py:Test_sanitize_ltsv_label:test_normal": {
      "pathvalidate/_ltsv.py:sanitize_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_ltsv.py:Test_sanitize_ltsv_label:test_normal_multibyte": {
      "pathvalidate/_ltsv.py:sanitize_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {}
        },
        "pathvalidate/_common.py:to_str": {}
      }
    },
    "test/test_ltsv.py:Test_sanitize_ltsv_label:test_abnormal": {
      "pathvalidate/_ltsv.py:sanitize_ltsv_label": {
        "pathvalidate/_common.py:validate_pathtype": {
          "pathvalidate/_common.py:_is_not_null_string": {},
          "pathvalidate/_common.py:is_null_string": {},
          "pathvalidate/error.py:ValidationError:__init__": {}
        }
      }
    }
  }
}