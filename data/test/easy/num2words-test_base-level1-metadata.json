{
  "dir_path": "/app/num2words",
  "package_name": "num2words",
  "sample_name": "num2words-test_base",
  "src_dir": "num2words/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_base.py",
  "test_code": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nfrom decimal import Decimal\nfrom unittest import TestCase\nfrom num2words.base import Num2Word_Base\n\nclass Num2WordBaseTest(TestCase):\n    @classmethod\n    def setUpClass(cls):\n        super(Num2WordBaseTest, cls).setUpClass()\n        cls.base = Num2Word_Base()\n\n    def test_to_currency_not_implemented(self):\n        with self.assertRaises(NotImplementedError):\n            self.base.to_currency(Decimal('1.00'), currency='EUR')\n\n    def test_error_to_cardinal_float(self):\n        with self.assertRaises(TypeError):\n            self.base.to_cardinal_float(\"a\")\n\n    def test_error_merge(self):\n        with self.assertRaises(NotImplementedError):\n            self.base.merge(2, 3)\n\n    def test_is_title(self):\n        self.assertEqual(self.base.title(\"one\"), \"one\")\n        self.base.is_title = True\n        self.assertEqual(self.base.title(\"one\"), \"One\")\n        self.base.exclude_title.append('one')\n        self.assertEqual(self.base.title(\"one\"), \"one\")\n\n    def test_set_high_numwords_not_implemented(self):\n        with self.assertRaises(NotImplementedError):\n            self.base.set_high_numwords()\n\n    def test_to_ordinal_num(self):\n        self.assertEqual(self.base.to_ordinal_num(1), 1)\n        self.assertEqual(self.base.to_ordinal_num(100), 100)\n        self.assertEqual(self.base.to_ordinal_num(1000), 1000)\n\n    def test_pluralize_not_implemented(self):\n        with self.assertRaises(NotImplementedError):\n            self.base.pluralize(n=None, forms=None)\n\n# If the test runner is needed, you can uncomment the following:\n# if __name__ == '__main__':\n#     unittest.main()",
  "GT_file_code": {
    "num2words/base.py": "# -*- coding: utf-8 -*-\n# Copyright (c) 2003, Taro Ogawa.  All Rights Reserved.\n# Copyright (c) 2013, Savoir-faire Linux inc.  All Rights Reserved.\n\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation; either\n# version 2.1 of the License, or (at your option) any later version.\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# Lesser General Public License for more details.\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n# MA 02110-1301 USA\n\nfrom __future__ import unicode_literals\n\nimport math\nfrom collections import OrderedDict\nfrom decimal import Decimal\n\nfrom .compat import to_s\nfrom .currency import parse_currency_parts, prefix_currency\n\n\nclass Num2Word_Base(object):\n    CURRENCY_FORMS = {}\n    CURRENCY_ADJECTIVES = {}\n\n    def __init__(self):\n        self.is_title = False\n        self.precision = 2\n        self.exclude_title = []\n        self.negword = \"(-) \"\n        self.pointword = \"(.)\"\n        self.errmsg_nonnum = \"type(%s) not in [long, int, float]\"\n        self.errmsg_floatord = \"Cannot treat float %s as ordinal.\"\n        self.errmsg_negord = \"Cannot treat negative num %s as ordinal.\"\n        self.errmsg_toobig = \"abs(%s) must be less than %s.\"\n\n        self.setup()\n\n        # uses cards\n        if any(hasattr(self, field) for field in\n               ['high_numwords', 'mid_numwords', 'low_numwords']):\n            self.cards = OrderedDict()\n            self.set_numwords()\n            self.MAXVAL = 1000 * list(self.cards.keys())[0]\n\n    def set_numwords(self):\n        self.set_high_numwords(self.high_numwords)\n        self.set_mid_numwords(self.mid_numwords)\n        self.set_low_numwords(self.low_numwords)\n\n    def set_high_numwords(self, *args):\n        raise NotImplementedError\n\n    def set_mid_numwords(self, mid):\n        for key, val in mid:\n            self.cards[key] = val\n\n    def set_low_numwords(self, numwords):\n        for word, n in zip(numwords, range(len(numwords) - 1, -1, -1)):\n            self.cards[n] = word\n\n    def splitnum(self, value):\n        for elem in self.cards:\n            if elem > value:\n                continue\n\n            out = []\n            if value == 0:\n                div, mod = 1, 0\n            else:\n                div, mod = divmod(value, elem)\n\n            if div == 1:\n                out.append((self.cards[1], 1))\n            else:\n                if div == value:  # The system tallies, eg Roman Numerals\n                    return [(div * self.cards[elem], div*elem)]\n                out.append(self.splitnum(div))\n\n            out.append((self.cards[elem], elem))\n\n            if mod:\n                out.append(self.splitnum(mod))\n\n            return out\n\n    def parse_minus(self, num_str):\n        \"\"\"Detach minus and return it as symbol with new num_str.\"\"\"\n        if num_str.startswith('-'):\n            # Extra spacing to compensate if there is no minus.\n            return '%s ' % self.negword.strip(), num_str[1:]\n        return '', num_str\n\n    def str_to_number(self, value):\n        return Decimal(value)\n\n    def to_cardinal(self, value):\n        try:\n            assert int(value) == value\n        except (ValueError, TypeError, AssertionError):\n            return self.to_cardinal_float(value)\n\n        out = \"\"\n        if value < 0:\n            value = abs(value)\n            out = \"%s \" % self.negword.strip()\n\n        if value >= self.MAXVAL:\n            raise OverflowError(self.errmsg_toobig % (value, self.MAXVAL))\n\n        val = self.splitnum(value)\n        words, num = self.clean(val)\n        return self.title(out + words)\n\n    def float2tuple(self, value):\n        pre = int(value)\n\n        # Simple way of finding decimal places to update the precision\n        self.precision = abs(Decimal(str(value)).as_tuple().exponent)\n\n        post = abs(value - pre) * 10**self.precision\n        if abs(round(post) - post) < 0.01:\n            # We generally floor all values beyond our precision (rather than\n            # rounding), but in cases where we have something like 1.239999999,\n            # which is probably due to python's handling of floats, we actually\n            # want to consider it as 1.24 instead of 1.23\n            post = int(round(post))\n        else:\n            post = int(math.floor(post))\n\n        return pre, post\n\n    def to_cardinal_float(self, value):\n        try:\n            float(value) == value\n        except (ValueError, TypeError, AssertionError, AttributeError):\n            raise TypeError(self.errmsg_nonnum % value)\n\n        pre, post = self.float2tuple(float(value))\n\n        post = str(post)\n        post = '0' * (self.precision - len(post)) + post\n\n        out = [self.to_cardinal(pre)]\n        if self.precision:\n            out.append(self.title(self.pointword))\n\n        for i in range(self.precision):\n            curr = int(post[i])\n            out.append(to_s(self.to_cardinal(curr)))\n\n        return \" \".join(out)\n\n    def merge(self, curr, next):\n        raise NotImplementedError\n\n    def clean(self, val):\n        out = val\n        while len(val) != 1:\n            out = []\n            left, right = val[:2]\n            if isinstance(left, tuple) and isinstance(right, tuple):\n                out.append(self.merge(left, right))\n                if val[2:]:\n                    out.append(val[2:])\n            else:\n                for elem in val:\n                    if isinstance(elem, list):\n                        if len(elem) == 1:\n                            out.append(elem[0])\n                        else:\n                            out.append(self.clean(elem))\n                    else:\n                        out.append(elem)\n            val = out\n        return out[0]\n\n    def title(self, value):\n        if self.is_title:\n            out = []\n            value = value.split()\n            for word in value:\n                if word in self.exclude_title:\n                    out.append(word)\n                else:\n                    out.append(word[0].upper() + word[1:])\n            value = \" \".join(out)\n        return value\n\n    def verify_ordinal(self, value):\n        if not value == int(value):\n            raise TypeError(self.errmsg_floatord % value)\n        if not abs(value) == value:\n            raise TypeError(self.errmsg_negord % value)\n\n    def to_ordinal(self, value):\n        return self.to_cardinal(value)\n\n    def to_ordinal_num(self, value):\n        return value\n\n    # Trivial version\n    def inflect(self, value, text):\n        text = text.split(\"/\")\n        if value == 1:\n            return text[0]\n        return \"\".join(text)\n\n    # //CHECK: generalise? Any others like pounds/shillings/pence?\n    def to_splitnum(self, val, hightxt=\"\", lowtxt=\"\", jointxt=\"\",\n                    divisor=100, longval=True, cents=True):\n        out = []\n\n        if isinstance(val, float):\n            high, low = self.float2tuple(val)\n        else:\n            try:\n                high, low = val\n            except TypeError:\n                high, low = divmod(val, divisor)\n\n        if high:\n            hightxt = self.title(self.inflect(high, hightxt))\n            out.append(self.to_cardinal(high))\n            if low:\n                if longval:\n                    if hightxt:\n                        out.append(hightxt)\n                    if jointxt:\n                        out.append(self.title(jointxt))\n            elif hightxt:\n                out.append(hightxt)\n\n        if low:\n            if cents:\n                out.append(self.to_cardinal(low))\n            else:\n                out.append(\"%02d\" % low)\n            if lowtxt and longval:\n                out.append(self.title(self.inflect(low, lowtxt)))\n\n        return \" \".join(out)\n\n    def to_year(self, value, **kwargs):\n        return self.to_cardinal(value)\n\n    def pluralize(self, n, forms):\n        \"\"\"\n        Should resolve gettext form:\n        http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html\n        \"\"\"\n        raise NotImplementedError\n\n    def _money_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_terse(self, number, currency):\n        return \"%02d\" % number\n\n    def to_currency(self, val, currency='EUR', cents=True, separator=',',\n                    adjective=False):\n        \"\"\"\n        Args:\n            val: Numeric value\n            currency (str): Currency code\n            cents (bool): Verbose cents\n            separator (str): Cent separator\n            adjective (bool): Prefix currency name with adjective\n        Returns:\n            str: Formatted string\n\n        \"\"\"\n        left, right, is_negative = parse_currency_parts(val)\n\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n\n        except KeyError:\n            raise NotImplementedError(\n                'Currency code \"%s\" not implemented for \"%s\"' %\n                (currency, self.__class__.__name__))\n\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n\n        minus_str = \"%s \" % self.negword.strip() if is_negative else \"\"\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) \\\n            if cents else self._cents_terse(right, currency)\n\n        return u'%s%s %s%s %s %s' % (\n            minus_str,\n            money_str,\n            self.pluralize(left, cr1),\n            separator,\n            cents_str,\n            self.pluralize(right, cr2)\n        )\n\n    def setup(self):\n        pass\n"
  },
  "GT_src_dict": {
    "num2words/base.py": {
      "Num2Word_Base.__init__": {
        "code": "    def __init__(self):\n        \"\"\"Initialize a Num2Word_Base instance, setting up essential attributes for converting numerical values into words. This constructor initializes the following attributes:\n\n- `is_title`: A boolean indicating if the output should be title-cased.\n- `precision`: An integer representing the number of decimal places to consider, defaulting to 2.\n- `exclude_title`: A list of words to exclude from title casing.\n- `negword`: A string representing the symbol for negative numbers.\n- `pointword`: A string representing the symbol for decimal points.\n- `errmsg_nonnum`, `errmsg_floatord`, `errmsg_negord`, `errmsg_toobig`: Strings used for error messages for various exceptional cases.\n\nAfter setting these attributes, the `setup()` method is called to perform any necessary initialization. If the instance has attributes related to number words (`high_numwords`, `mid_numwords`, `low_numwords`), it initializes an `OrderedDict` for cardinal numbers (`cards`) and calculates `MAXVAL` based on the highest numerical key available.\n\nConstants such as `self.negword` and `self.pointword` provide standard representations of negative and decimal values, respectively, which are crucial for formatting output correctly. The initialization ensures the instance is ready to convert numbers into their corresponding verbal forms, preparing values for further processing in methods that handle numerical conversions.\"\"\"\n        self.is_title = False\n        self.precision = 2\n        self.exclude_title = []\n        self.negword = '(-) '\n        self.pointword = '(.)'\n        self.errmsg_nonnum = 'type(%s) not in [long, int, float]'\n        self.errmsg_floatord = 'Cannot treat float %s as ordinal.'\n        self.errmsg_negord = 'Cannot treat negative num %s as ordinal.'\n        self.errmsg_toobig = 'abs(%s) must be less than %s.'\n        self.setup()\n        if any((hasattr(self, field) for field in ['high_numwords', 'mid_numwords', 'low_numwords'])):\n            self.cards = OrderedDict()\n            self.set_numwords()\n            self.MAXVAL = 1000 * list(self.cards.keys())[0]",
        "docstring": "Initialize a Num2Word_Base instance, setting up essential attributes for converting numerical values into words. This constructor initializes the following attributes:\n\n- `is_title`: A boolean indicating if the output should be title-cased.\n- `precision`: An integer representing the number of decimal places to consider, defaulting to 2.\n- `exclude_title`: A list of words to exclude from title casing.\n- `negword`: A string representing the symbol for negative numbers.\n- `pointword`: A string representing the symbol for decimal points.\n- `errmsg_nonnum`, `errmsg_floatord`, `errmsg_negord`, `errmsg_toobig`: Strings used for error messages for various exceptional cases.\n\nAfter setting these attributes, the `setup()` method is called to perform any necessary initialization. If the instance has attributes related to number words (`high_numwords`, `mid_numwords`, `low_numwords`), it initializes an `OrderedDict` for cardinal numbers (`cards`) and calculates `MAXVAL` based on the highest numerical key available.\n\nConstants such as `self.negword` and `self.pointword` provide standard representations of negative and decimal values, respectively, which are crucial for formatting output correctly. The initialization ensures the instance is ready to convert numbers into their corresponding verbal forms, preparing values for further processing in methods that handle numerical conversions.",
        "signature": "def __init__(self):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.set_high_numwords": {
        "code": "    def set_high_numwords(self, *args):\n        \"\"\"Sets the high number words used for cardinal number conversion in the Num2Word_Base class.\n\nParameters:\n    *args: Variable length argument list that should typically contain high number words.\n\nReturns:\n    None. This method is intended to be overridden in subclasses to provide specific implementations for high number words.\n\nRaises:\n    NotImplementedError: This is a placeholder method meant to be implemented in derived classes, allowing for different languages or number representations.\n\nThis method interacts with the overall conversion system of cardinal numbers to words by preparing a set of high number words which will be used in the conversion logic defined in the Num2Word_Base class and its derived classes.\"\"\"\n        raise NotImplementedError",
        "docstring": "Sets the high number words used for cardinal number conversion in the Num2Word_Base class.\n\nParameters:\n    *args: Variable length argument list that should typically contain high number words.\n\nReturns:\n    None. This method is intended to be overridden in subclasses to provide specific implementations for high number words.\n\nRaises:\n    NotImplementedError: This is a placeholder method meant to be implemented in derived classes, allowing for different languages or number representations.\n\nThis method interacts with the overall conversion system of cardinal numbers to words by preparing a set of high number words which will be used in the conversion logic defined in the Num2Word_Base class and its derived classes.",
        "signature": "def set_high_numwords(self, *args):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.to_cardinal_float": {
        "code": "    def to_cardinal_float(self, value):\n        \"\"\"Converts a float number into its cardinal representation as a string. The function handles both the integer and fractional parts of the number. It first verifies that the input is a numeric type, and then separates the number into its whole and decimal components using the `float2tuple` method. The whole part is converted to its cardinal form using the `to_cardinal` method, and the fractional part is formatted according to the specified precision.\n\nParameters:\n- value (float): The numeric value to be converted into cardinal form.\n\nReturns:\n- str: A string representation of the number in cardinal form, including the fractional part if applicable.\n\nDependencies:\n- The method depends on `self.float2tuple` for separating the integer and decimal parts and `self.to_cardinal` for converting numbers to their cardinal representations. It also uses `self.title` for formatting titles and `self.precision`, which defines the number of decimal places to consider.\"\"\"\n        try:\n            float(value) == value\n        except (ValueError, TypeError, AssertionError, AttributeError):\n            raise TypeError(self.errmsg_nonnum % value)\n        pre, post = self.float2tuple(float(value))\n        post = str(post)\n        post = '0' * (self.precision - len(post)) + post\n        out = [self.to_cardinal(pre)]\n        if self.precision:\n            out.append(self.title(self.pointword))\n        for i in range(self.precision):\n            curr = int(post[i])\n            out.append(to_s(self.to_cardinal(curr)))\n        return ' '.join(out)",
        "docstring": "Converts a float number into its cardinal representation as a string. The function handles both the integer and fractional parts of the number. It first verifies that the input is a numeric type, and then separates the number into its whole and decimal components using the `float2tuple` method. The whole part is converted to its cardinal form using the `to_cardinal` method, and the fractional part is formatted according to the specified precision.\n\nParameters:\n- value (float): The numeric value to be converted into cardinal form.\n\nReturns:\n- str: A string representation of the number in cardinal form, including the fractional part if applicable.\n\nDependencies:\n- The method depends on `self.float2tuple` for separating the integer and decimal parts and `self.to_cardinal` for converting numbers to their cardinal representations. It also uses `self.title` for formatting titles and `self.precision`, which defines the number of decimal places to consider.",
        "signature": "def to_cardinal_float(self, value):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.merge": {
        "code": "    def merge(self, curr, next):\n        \"\"\"Merges two numerical components into a single representation.\n\n    Args:\n        curr: The first component to merge, expected to be a tuple \n              containing numerical representations.\n        next: The second component to merge, also expected to be a \n              tuple containing numerical representations.\n\n    Returns:\n        NotImplementedError: This method must be implemented in a derived \n        class as it serves as a placeholder for custom merging logic \n        specific to the subclass's requirements.\n\n    This method is essential for the `clean` method, which processes \n    numerical representations. The merging logic is expected to provide \n    meaningful combinations of numerical parts based on the context of \n    usage, such as combining different levels of cardinal numbers or \n    handling special cases in numbering formats.\"\"\"\n        raise NotImplementedError",
        "docstring": "Merges two numerical components into a single representation.\n\nArgs:\n    curr: The first component to merge, expected to be a tuple \n          containing numerical representations.\n    next: The second component to merge, also expected to be a \n          tuple containing numerical representations.\n\nReturns:\n    NotImplementedError: This method must be implemented in a derived \n    class as it serves as a placeholder for custom merging logic \n    specific to the subclass's requirements.\n\nThis method is essential for the `clean` method, which processes \nnumerical representations. The merging logic is expected to provide \nmeaningful combinations of numerical parts based on the context of \nusage, such as combining different levels of cardinal numbers or \nhandling special cases in numbering formats.",
        "signature": "def merge(self, curr, next):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.title": {
        "code": "    def title(self, value):\n        \"\"\"Convert the given string value to title case if the `is_title` attribute is set to True.\n\n    Parameters:\n        value (str): A string that may contain multiple words.\n\n    Returns:\n        str: The input string converted to title case, where each word starts with an uppercase letter, \n              except for words present in the `exclude_title` list, which remain unchanged.\n\n    Notes:\n        - The `is_title` attribute controls whether the title case transformation is applied.\n        - The `exclude_title` attribute is a list of words that should not be capitalized.\n        - This method contributes to the overall functionality of the `Num2Word_Base` class by allowing\n          formatted output for numerical words, ensuring proper capitalization based on context.\"\"\"\n        if self.is_title:\n            out = []\n            value = value.split()\n            for word in value:\n                if word in self.exclude_title:\n                    out.append(word)\n                else:\n                    out.append(word[0].upper() + word[1:])\n            value = ' '.join(out)\n        return value",
        "docstring": "Convert the given string value to title case if the `is_title` attribute is set to True.\n\nParameters:\n    value (str): A string that may contain multiple words.\n\nReturns:\n    str: The input string converted to title case, where each word starts with an uppercase letter, \n          except for words present in the `exclude_title` list, which remain unchanged.\n\nNotes:\n    - The `is_title` attribute controls whether the title case transformation is applied.\n    - The `exclude_title` attribute is a list of words that should not be capitalized.\n    - This method contributes to the overall functionality of the `Num2Word_Base` class by allowing\n      formatted output for numerical words, ensuring proper capitalization based on context.",
        "signature": "def title(self, value):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.to_ordinal_num": {
        "code": "    def to_ordinal_num(self, value):\n        \"\"\"Convert a numeric value to its ordinal representation. \n\n    Args:\n        value (int or float): The numeric value to be converted to an ordinal number. \n\n    Returns:\n        int or float: The input value unchanged; this method currently serves as a placeholder or trivial implementation.\n\n    Note:\n        This method does not perform any conversion or processing; it simply returns the input value as is. It is intended to be overridden in subclasses that implement specific ordinal formatting.\"\"\"\n        return value",
        "docstring": "Convert a numeric value to its ordinal representation. \n\nArgs:\n    value (int or float): The numeric value to be converted to an ordinal number. \n\nReturns:\n    int or float: The input value unchanged; this method currently serves as a placeholder or trivial implementation.\n\nNote:\n    This method does not perform any conversion or processing; it simply returns the input value as is. It is intended to be overridden in subclasses that implement specific ordinal formatting.",
        "signature": "def to_ordinal_num(self, value):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.pluralize": {
        "code": "    def pluralize(self, n, forms):\n        \"\"\"Resolve plural forms based on the given count 'n' and the specified 'forms'.\n\n    Args:\n        n (int): The numeric value that determines which form to return.\n        forms (list): A list of string forms for singular and plural representations, \n                      typically containing at least two elements: the singular form \n                      at index 0 and the plural form at index 1.\n\n    Returns:\n        str: The appropriate form based on the value of 'n'. If 'n' is 1, the \n             singular form is returned; otherwise, the plural form is returned.\n\n    Note:\n        The method is marked as NotImplementedError; it requires an implementation \n        specific to how pluralization should be handled in the derived classes.\"\"\"\n        '\\n        Should resolve gettext form:\\n        http://docs.translatehouse.org/projects/localization-guide/en/latest/l10n/pluralforms.html\\n        '\n        raise NotImplementedError",
        "docstring": "Resolve plural forms based on the given count 'n' and the specified 'forms'.\n\nArgs:\n    n (int): The numeric value that determines which form to return.\n    forms (list): A list of string forms for singular and plural representations, \n                  typically containing at least two elements: the singular form \n                  at index 0 and the plural form at index 1.\n\nReturns:\n    str: The appropriate form based on the value of 'n'. If 'n' is 1, the \n         singular form is returned; otherwise, the plural form is returned.\n\nNote:\n    The method is marked as NotImplementedError; it requires an implementation \n    specific to how pluralization should be handled in the derived classes.",
        "signature": "def pluralize(self, n, forms):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      },
      "Num2Word_Base.to_currency": {
        "code": "    def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):\n        \"\"\"Converts a numeric value to a currency string formatted according to specified parameters.\n\nArgs:\n    val (numeric): The numeric value to format as currency.\n    currency (str): The currency code (default is 'EUR'). It is used to determine the appropriate currency formatting. Should correspond to keys in the CURRENCY_FORMS dictionary.\n    cents (bool): If True, formats the cents in a verbose manner; if False, formats them tersely (default is True).\n    separator (str): The string used to separate the units from the cents (default is ',').\n    adjective (bool): If True, prefixes the currency name with an adjective based on the CURRENCY_ADJECTIVES dictionary if available.\n\nReturns:\n    str: A formatted currency string that includes the appropriate adjective, monetary amount, and cents.\n\nThe method relies on the CURRENCY_FORMS dictionary, which maps currency codes to their respective formatted representations. Additionally, it uses the CURRENCY_ADJECTIVES for generating currency names with adjectives, if applicable. The method also calls _money_verbose and _cents_verbose (or _cents_terse) for custom formatting of monetary amounts and cents, respectively. If the currency code provided is not implemented, a NotImplementedError is raised.\"\"\"\n        '\\n        Args:\\n            val: Numeric value\\n            currency (str): Currency code\\n            cents (bool): Verbose cents\\n            separator (str): Cent separator\\n            adjective (bool): Prefix currency name with adjective\\n        Returns:\\n            str: Formatted string\\n\\n        '\n        left, right, is_negative = parse_currency_parts(val)\n        try:\n            cr1, cr2 = self.CURRENCY_FORMS[currency]\n        except KeyError:\n            raise NotImplementedError('Currency code \"%s\" not implemented for \"%s\"' % (currency, self.__class__.__name__))\n        if adjective and currency in self.CURRENCY_ADJECTIVES:\n            cr1 = prefix_currency(self.CURRENCY_ADJECTIVES[currency], cr1)\n        minus_str = '%s ' % self.negword.strip() if is_negative else ''\n        money_str = self._money_verbose(left, currency)\n        cents_str = self._cents_verbose(right, currency) if cents else self._cents_terse(right, currency)\n        return u'%s%s %s%s %s %s' % (minus_str, money_str, self.pluralize(left, cr1), separator, cents_str, self.pluralize(right, cr2))",
        "docstring": "Converts a numeric value to a currency string formatted according to specified parameters.\n\nArgs:\n    val (numeric): The numeric value to format as currency.\n    currency (str): The currency code (default is 'EUR'). It is used to determine the appropriate currency formatting. Should correspond to keys in the CURRENCY_FORMS dictionary.\n    cents (bool): If True, formats the cents in a verbose manner; if False, formats them tersely (default is True).\n    separator (str): The string used to separate the units from the cents (default is ',').\n    adjective (bool): If True, prefixes the currency name with an adjective based on the CURRENCY_ADJECTIVES dictionary if available.\n\nReturns:\n    str: A formatted currency string that includes the appropriate adjective, monetary amount, and cents.\n\nThe method relies on the CURRENCY_FORMS dictionary, which maps currency codes to their respective formatted representations. Additionally, it uses the CURRENCY_ADJECTIVES for generating currency names with adjectives, if applicable. The method also calls _money_verbose and _cents_verbose (or _cents_terse) for custom formatting of monetary amounts and cents, respectively. If the currency code provided is not implemented, a NotImplementedError is raised.",
        "signature": "def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):",
        "type": "Method",
        "class_signature": "class Num2Word_Base(object):"
      }
    }
  },
  "dependency_dict": {
    "num2words/base.py:Num2Word_Base:__init__": {
      "num2words/base.py": {
        "Num2Word_Base.setup": {
          "code": "    def setup(self):\n        pass",
          "docstring": "",
          "signature": "def setup(self):",
          "type": "Method",
          "class_signature": "class Num2Word_Base(object):"
        }
      }
    },
    "num2words/base.py:Num2Word_Base:to_currency": {
      "num2words/currency.py": {
        "parse_currency_parts": {
          "code": "def parse_currency_parts(value, is_int_with_cents=True):\n    if isinstance(value, int):\n        if is_int_with_cents:\n            # assume cents if value is integer\n            negative = value < 0\n            value = abs(value)\n            integer, cents = divmod(value, 100)\n        else:\n            negative = value < 0\n            integer, cents = abs(value), 0\n\n    else:\n        value = Decimal(value)\n        value = value.quantize(\n            Decimal('.01'),\n            rounding=ROUND_HALF_UP\n        )\n        negative = value < 0\n        value = abs(value)\n        integer, fraction = divmod(value, 1)\n        integer = int(integer)\n        cents = int(fraction * 100)\n\n    return integer, cents, negative",
          "docstring": "",
          "signature": "def parse_currency_parts(value, is_int_with_cents=True):",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: num2words-test_base\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 num2words/\n    \u2514\u2500\u2500 base.py\n        \u251c\u2500\u2500 Num2Word_Base.__init__\n        \u251c\u2500\u2500 Num2Word_Base.merge\n        \u251c\u2500\u2500 Num2Word_Base.pluralize\n        \u251c\u2500\u2500 Num2Word_Base.set_high_numwords\n        \u251c\u2500\u2500 Num2Word_Base.title\n        \u251c\u2500\u2500 Num2Word_Base.to_cardinal_float\n        \u251c\u2500\u2500 Num2Word_Base.to_currency\n        \u2514\u2500\u2500 Num2Word_Base.to_ordinal_num\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides a foundational framework for converting numerical values into language-based representations, designed to support the development of multilingual or locale-specific number-to-word conversion functionalities. It defines a base class, `Num2Word_Base`, which outlines core methods such as converting numbers to ordinals, cardinals, or currency representations, while also allowing for customization like title formatting and pluralization rules. By offering a structured interface and robust error handling around unimplemented or unsupported features, it ensures extensibility and serves as a reliable backbone for developers implementing specific or localized number-to-word conversion logic. This module addresses the challenge of creating consistent, reusable, and testable mechanisms for linguistic number representation, streamlining the process for applications requiring this functionality.\n\n## FILE 1: num2words/base.py\n\n- CLASS METHOD: Num2Word_Base.to_cardinal_float\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def to_cardinal_float(self, value):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a float number into its cardinal representation as a string. The function handles both the integer and fractional parts of the number. It first verifies that the input is a numeric type, and then separates the number into its whole and decimal components using the `float2tuple` method. The whole part is converted to its cardinal form using the `to_cardinal` method, and the fractional part is formatted according to the specified precision.\n\nParameters:\n- value (float): The numeric value to be converted into cardinal form.\n\nReturns:\n- str: A string representation of the number in cardinal form, including the fractional part if applicable.\n\nDependencies:\n- The method depends on `self.float2tuple` for separating the integer and decimal parts and `self.to_cardinal` for converting numbers to their cardinal representations. It also uses `self.title` for formatting titles and `self.precision`, which defines the number of decimal places to consider.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.pluralize\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def pluralize(self, n, forms):\n  - DOCSTRING: \n```python\n\"\"\"\nResolve plural forms based on the given count 'n' and the specified 'forms'.\n\nArgs:\n    n (int): The numeric value that determines which form to return.\n    forms (list): A list of string forms for singular and plural representations, \n                  typically containing at least two elements: the singular form \n                  at index 0 and the plural form at index 1.\n\nReturns:\n    str: The appropriate form based on the value of 'n'. If 'n' is 1, the \n         singular form is returned; otherwise, the plural form is returned.\n\nNote:\n    The method is marked as NotImplementedError; it requires an implementation \n    specific to how pluralization should be handled in the derived classes.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.set_high_numwords\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def set_high_numwords(self, *args):\n  - DOCSTRING: \n```python\n\"\"\"\nSets the high number words used for cardinal number conversion in the Num2Word_Base class.\n\nParameters:\n    *args: Variable length argument list that should typically contain high number words.\n\nReturns:\n    None. This method is intended to be overridden in subclasses to provide specific implementations for high number words.\n\nRaises:\n    NotImplementedError: This is a placeholder method meant to be implemented in derived classes, allowing for different languages or number representations.\n\nThis method interacts with the overall conversion system of cardinal numbers to words by preparing a set of high number words which will be used in the conversion logic defined in the Num2Word_Base class and its derived classes.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.title\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def title(self, value):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert the given string value to title case if the `is_title` attribute is set to True.\n\nParameters:\n    value (str): A string that may contain multiple words.\n\nReturns:\n    str: The input string converted to title case, where each word starts with an uppercase letter, \n          except for words present in the `exclude_title` list, which remain unchanged.\n\nNotes:\n    - The `is_title` attribute controls whether the title case transformation is applied.\n    - The `exclude_title` attribute is a list of words that should not be capitalized.\n    - This method contributes to the overall functionality of the `Num2Word_Base` class by allowing\n      formatted output for numerical words, ensuring proper capitalization based on context.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.__init__\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def __init__(self):\n  - DOCSTRING: \n```python\n\"\"\"\nInitialize a Num2Word_Base instance, setting up essential attributes for converting numerical values into words. This constructor initializes the following attributes:\n\n- `is_title`: A boolean indicating if the output should be title-cased.\n- `precision`: An integer representing the number of decimal places to consider, defaulting to 2.\n- `exclude_title`: A list of words to exclude from title casing.\n- `negword`: A string representing the symbol for negative numbers.\n- `pointword`: A string representing the symbol for decimal points.\n- `errmsg_nonnum`, `errmsg_floatord`, `errmsg_negord`, `errmsg_toobig`: Strings used for error messages for various exceptional cases.\n\nAfter setting these attributes, the `setup()` method is called to perform any necessary initialization. If the instance has attributes related to number words (`high_numwords`, `mid_numwords`, `low_numwords`), it initializes an `OrderedDict` for cardinal numbers (`cards`) and calculates `MAXVAL` based on the highest numerical key available.\n\nConstants such as `self.negword` and `self.pointword` provide standard representations of negative and decimal values, respectively, which are crucial for formatting output correctly. The initialization ensures the instance is ready to convert numbers into their corresponding verbal forms, preparing values for further processing in methods that handle numerical conversions.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.to_ordinal_num\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def to_ordinal_num(self, value):\n  - DOCSTRING: \n```python\n\"\"\"\nConvert a numeric value to its ordinal representation. \n\nArgs:\n    value (int or float): The numeric value to be converted to an ordinal number. \n\nReturns:\n    int or float: The input value unchanged; this method currently serves as a placeholder or trivial implementation.\n\nNote:\n    This method does not perform any conversion or processing; it simply returns the input value as is. It is intended to be overridden in subclasses that implement specific ordinal formatting.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.merge\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def merge(self, curr, next):\n  - DOCSTRING: \n```python\n\"\"\"\nMerges two numerical components into a single representation.\n\nArgs:\n    curr: The first component to merge, expected to be a tuple \n          containing numerical representations.\n    next: The second component to merge, also expected to be a \n          tuple containing numerical representations.\n\nReturns:\n    NotImplementedError: This method must be implemented in a derived \n    class as it serves as a placeholder for custom merging logic \n    specific to the subclass's requirements.\n\nThis method is essential for the `clean` method, which processes \nnumerical representations. The merging logic is expected to provide \nmeaningful combinations of numerical parts based on the context of \nusage, such as combining different levels of cardinal numbers or \nhandling special cases in numbering formats.\n\"\"\"\n```\n\n- CLASS METHOD: Num2Word_Base.to_currency\n  - CLASS SIGNATURE: class Num2Word_Base(object):\n  - SIGNATURE: def to_currency(self, val, currency='EUR', cents=True, separator=',', adjective=False):\n  - DOCSTRING: \n```python\n\"\"\"\nConverts a numeric value to a currency string formatted according to specified parameters.\n\nArgs:\n    val (numeric): The numeric value to format as currency.\n    currency (str): The currency code (default is 'EUR'). It is used to determine the appropriate currency formatting. Should correspond to keys in the CURRENCY_FORMS dictionary.\n    cents (bool): If True, formats the cents in a verbose manner; if False, formats them tersely (default is True).\n    separator (str): The string used to separate the units from the cents (default is ',').\n    adjective (bool): If True, prefixes the currency name with an adjective based on the CURRENCY_ADJECTIVES dictionary if available.\n\nReturns:\n    str: A formatted currency string that includes the appropriate adjective, monetary amount, and cents.\n\nThe method relies on the CURRENCY_FORMS dictionary, which maps currency codes to their respective formatted representations. Additionally, it uses the CURRENCY_ADJECTIVES for generating currency names with adjectives, if applicable. The method also calls _money_verbose and _cents_verbose (or _cents_terse) for custom formatting of monetary amounts and cents, respectively. If the currency code provided is not implemented, a NotImplementedError is raised.\n\"\"\"\n```\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "num2words/base.py": "from __future__ import unicode_literals\nimport math\nfrom collections import OrderedDict\nfrom decimal import Decimal\nfrom .compat import to_s\nfrom .currency import parse_currency_parts, prefix_currency\n\nclass Num2Word_Base(object):\n    CURRENCY_FORMS = {}\n    CURRENCY_ADJECTIVES = {}\n\n    def set_numwords(self):\n        self.set_high_numwords(self.high_numwords)\n        self.set_mid_numwords(self.mid_numwords)\n        self.set_low_numwords(self.low_numwords)\n\n    def set_mid_numwords(self, mid):\n        for key, val in mid:\n            self.cards[key] = val\n\n    def set_low_numwords(self, numwords):\n        for word, n in zip(numwords, range(len(numwords) - 1, -1, -1)):\n            self.cards[n] = word\n\n    def splitnum(self, value):\n        for elem in self.cards:\n            if elem > value:\n                continue\n            out = []\n            if value == 0:\n                div, mod = (1, 0)\n            else:\n                div, mod = divmod(value, elem)\n            if div == 1:\n                out.append((self.cards[1], 1))\n            else:\n                if div == value:\n                    return [(div * self.cards[elem], div * elem)]\n                out.append(self.splitnum(div))\n            out.append((self.cards[elem], elem))\n            if mod:\n                out.append(self.splitnum(mod))\n            return out\n\n    def parse_minus(self, num_str):\n        \"\"\"Detach minus and return it as symbol with new num_str.\"\"\"\n        if num_str.startswith('-'):\n            return ('%s ' % self.negword.strip(), num_str[1:])\n        return ('', num_str)\n\n    def str_to_number(self, value):\n        return Decimal(value)\n\n    def to_cardinal(self, value):\n        try:\n            assert int(value) == value\n        except (ValueError, TypeError, AssertionError):\n            return self.to_cardinal_float(value)\n        out = ''\n        if value < 0:\n            value = abs(value)\n            out = '%s ' % self.negword.strip()\n        if value >= self.MAXVAL:\n            raise OverflowError(self.errmsg_toobig % (value, self.MAXVAL))\n        val = self.splitnum(value)\n        words, num = self.clean(val)\n        return self.title(out + words)\n\n    def float2tuple(self, value):\n        pre = int(value)\n        self.precision = abs(Decimal(str(value)).as_tuple().exponent)\n        post = abs(value - pre) * 10 ** self.precision\n        if abs(round(post) - post) < 0.01:\n            post = int(round(post))\n        else:\n            post = int(math.floor(post))\n        return (pre, post)\n\n    def clean(self, val):\n        out = val\n        while len(val) != 1:\n            out = []\n            left, right = val[:2]\n            if isinstance(left, tuple) and isinstance(right, tuple):\n                out.append(self.merge(left, right))\n                if val[2:]:\n                    out.append(val[2:])\n            else:\n                for elem in val:\n                    if isinstance(elem, list):\n                        if len(elem) == 1:\n                            out.append(elem[0])\n                        else:\n                            out.append(self.clean(elem))\n                    else:\n                        out.append(elem)\n            val = out\n        return out[0]\n\n    def verify_ordinal(self, value):\n        if not value == int(value):\n            raise TypeError(self.errmsg_floatord % value)\n        if not abs(value) == value:\n            raise TypeError(self.errmsg_negord % value)\n\n    def to_ordinal(self, value):\n        return self.to_cardinal(value)\n\n    def inflect(self, value, text):\n        text = text.split('/')\n        if value == 1:\n            return text[0]\n        return ''.join(text)\n\n    def to_splitnum(self, val, hightxt='', lowtxt='', jointxt='', divisor=100, longval=True, cents=True):\n        out = []\n        if isinstance(val, float):\n            high, low = self.float2tuple(val)\n        else:\n            try:\n                high, low = val\n            except TypeError:\n                high, low = divmod(val, divisor)\n        if high:\n            hightxt = self.title(self.inflect(high, hightxt))\n            out.append(self.to_cardinal(high))\n            if low:\n                if longval:\n                    if hightxt:\n                        out.append(hightxt)\n                    if jointxt:\n                        out.append(self.title(jointxt))\n            elif hightxt:\n                out.append(hightxt)\n        if low:\n            if cents:\n                out.append(self.to_cardinal(low))\n            else:\n                out.append('%02d' % low)\n            if lowtxt and longval:\n                out.append(self.title(self.inflect(low, lowtxt)))\n        return ' '.join(out)\n\n    def to_year(self, value, **kwargs):\n        return self.to_cardinal(value)\n\n    def _money_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_verbose(self, number, currency):\n        return self.to_cardinal(number)\n\n    def _cents_terse(self, number, currency):\n        return '%02d' % number\n\n    def setup(self):\n        pass"
  },
  "call_tree": {
    "modified_testcases/test_base.py:Num2WordBaseTest:setUpClass": {
      "num2words/base.py:Num2Word_Base:__init__": {
        "num2words/base.py:Num2Word_Base:setup": {}
      }
    },
    "modified_testcases/test_base.py:Num2WordBaseTest:test_error_merge": {
      "num2words/base.py:Num2Word_Base:merge": {}
    },
    "modified_testcases/test_base.py:Num2WordBaseTest:test_error_to_cardinal_float": {
      "num2words/base.py:Num2Word_Base:to_cardinal_float": {}
    },
    "modified_testcases/test_base.py:Num2WordBaseTest:test_is_title": {
      "num2words/base.py:Num2Word_Base:title": {}
    },
    "modified_testcases/test_base.py:Num2WordBaseTest:test_pluralize_not_implemented": {
      "num2words/base.py:Num2Word_Base:pluralize": {}
    },
    "modified_testcases/test_base.py:Num2WordBaseTest:test_set_high_numwords_not_implemented": {
      "num2words/base.py:Num2Word_Base:set_high_numwords": {}
    },
    "modified_testcases/test_base.py:Num2WordBaseTest:test_to_currency_not_implemented": {
      "num2words/base.py:Num2Word_Base:to_currency": {
        "num2words/currency.py:parse_currency_parts": {}
      }
    },
    "modified_testcases/test_base.py:Num2WordBaseTest:test_to_ordinal_num": {
      "num2words/base.py:Num2Word_Base:to_ordinal_num": {}
    }
  }
}