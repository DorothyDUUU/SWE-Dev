{
  "dir_path": "/app/yamllint",
  "package_name": "yamllint",
  "sample_name": "yamllint-test_comments_indentation",
  "src_dir": "yamllint/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/rules/test_comments_indentation.py",
  "test_code": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom tests.common import RuleTestCase\n\n\nclass CommentsIndentationTestCase(RuleTestCase):\n    rule_id = 'comments-indentation'\n\n    def test_disable(self):\n        conf = 'comments-indentation: disable'\n        self.check('---\\n'\n                   ' # line 1\\n'\n                   '# line 2\\n'\n                   '  # line 3\\n'\n                   '  # line 4\\n'\n                   '\\n'\n                   'obj:\\n'\n                   ' # these\\n'\n                   '   # are\\n'\n                   '  # [good]\\n'\n                   '# bad\\n'\n                   '      # comments\\n'\n                   '  a: b\\n'\n                   '\\n'\n                   'obj1:\\n'\n                   '  a: 1\\n'\n                   '  # comments\\n'\n                   '\\n'\n                   'obj2:\\n'\n                   '  b: 2\\n'\n                   '\\n'\n                   '# empty\\n'\n                   '#\\n'\n                   '# comment\\n'\n                   '...\\n', conf)\n\n    def test_enabled(self):\n        conf = 'comments-indentation: enable'\n        self.check('---\\n'\n                   '# line 1\\n'\n                   '# line 2\\n', conf)\n        self.check('---\\n'\n                   ' # line 1\\n'\n                   '# line 2\\n', conf, problem=(2, 2))\n        self.check('---\\n'\n                   '  # line 1\\n'\n                   '  # line 2\\n', conf, problem1=(2, 3))\n        self.check('---\\n'\n                   'obj:\\n'\n                   '  # normal\\n'\n                   '  a: b\\n', conf)\n        self.check('---\\n'\n                   'obj:\\n'\n                   ' # bad\\n'\n                   '  a: b\\n', conf, problem=(3, 2))\n        self.check('---\\n'\n                   'obj:\\n'\n                   '# bad\\n'\n                   '  a: b\\n', conf, problem=(3, 1))\n        self.check('---\\n'\n                   'obj:\\n'\n                   '   # bad\\n'\n                   '  a: b\\n', conf, problem=(3, 4))\n        self.check('---\\n'\n                   'obj:\\n'\n                   ' # these\\n'\n                   '   # are\\n'\n                   '  # [good]\\n'\n                   '# bad\\n'\n                   '      # comments\\n'\n                   '  a: b\\n', conf,\n                   problem1=(3, 2), problem2=(4, 4),\n                   problem3=(6, 1), problem4=(7, 7))\n        self.check('---\\n'\n                   'obj1:\\n'\n                   '  a: 1\\n'\n                   '  # the following line is disabled\\n'\n                   '  # b: 2\\n', conf)\n        self.check('---\\n'\n                   'obj1:\\n'\n                   '  a: 1\\n'\n                   '  # b: 2\\n'\n                   '\\n'\n                   'obj2:\\n'\n                   '  b: 2\\n', conf)\n        self.check('---\\n'\n                   'obj1:\\n'\n                   '  a: 1\\n'\n                   '  # b: 2\\n'\n                   '# this object is useless\\n'\n                   'obj2: \"no\"\\n', conf)\n        self.check('---\\n'\n                   'obj1:\\n'\n                   '  a: 1\\n'\n                   '# this object is useless\\n'\n                   '  # b: 2\\n'\n                   'obj2: \"no\"\\n', conf, problem=(5, 3))\n        self.check('---\\n'\n                   'obj1:\\n'\n                   '  a: 1\\n'\n                   '  # comments\\n'\n                   '  b: 2\\n', conf)\n        self.check('---\\n'\n                   'my list for today:\\n'\n                   '  - todo 1\\n'\n                   '  - todo 2\\n'\n                   '  # commented for now\\n'\n                   '  # - todo 3\\n'\n                   '...\\n', conf)\n\n    def test_first_line(self):\n        conf = 'comments-indentation: enable'\n        self.check('# comment\\n', conf)\n        self.check('  # comment\\n', conf, problem=(1, 3))\n\n    def test_no_newline_at_end(self):\n        conf = ('comments-indentation: enable\\n'\n                'new-line-at-end-of-file: disable\\n')\n        self.check('# comment', conf)\n        self.check('  # comment', conf, problem=(1, 3))\n\n    def test_empty_comment(self):\n        conf = 'comments-indentation: enable'\n        self.check('---\\n'\n                   '# hey\\n'\n                   '# normal\\n'\n                   '#\\n', conf)\n        self.check('---\\n'\n                   '# hey\\n'\n                   '# normal\\n'\n                   ' #\\n', conf, problem=(4, 2))\n\n    def test_inline_comment(self):\n        conf = 'comments-indentation: enable'\n        self.check('---\\n'\n                   '- a  # inline\\n'\n                   '# ok\\n', conf)\n        self.check('---\\n'\n                   '- a  # inline\\n'\n                   ' # not ok\\n', conf, problem=(3, 2))\n        self.check('---\\n'\n                   ' # not ok\\n'\n                   '- a  # inline\\n', conf, problem=(2, 2))\n",
  "GT_file_code": {
    "yamllint/linter.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport io\nimport re\n\nimport yaml\n\nfrom yamllint import parser\n\nPROBLEM_LEVELS = {\n    0: None,\n    1: 'warning',\n    2: 'error',\n    None: 0,\n    'warning': 1,\n    'error': 2,\n}\n\nDISABLE_RULE_PATTERN = re.compile(r'^# yamllint disable( rule:\\S+)*\\s*$')\nENABLE_RULE_PATTERN = re.compile(r'^# yamllint enable( rule:\\S+)*\\s*$')\n\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n    def __init__(self, line, column, desc='<no description>', rule=None):\n        #: Line on which the problem was found (starting at 1)\n        self.line = line\n        #: Column on which the problem was found (starting at 1)\n        self.column = column\n        #: Human-readable description of the problem\n        self.desc = desc\n        #: Identifier of the rule that detected the problem\n        self.rule = rule\n        self.level = None\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __eq__(self, other):\n        return (self.line == other.line and\n                self.column == other.column and\n                self.rule == other.rule)\n\n    def __lt__(self, other):\n        return (self.line < other.line or\n                (self.line == other.line and self.column < other.column))\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n\n    # Split token rules from line rules\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n        def process_comment(self, comment):\n            comment = str(comment)\n\n            if re.match(r'^# yamllint disable-line( rule:\\S+)*\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n\n    # Use a cache to store problems and flush it only when an end of line is\n    # found. This allows the use of yamllint directive to disable some rules on\n    # some lines.\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf,\n                                          elem.curr, elem.prev, elem.next,\n                                          elem.nextnext,\n                                          context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n\n            # This is the last token/comment/line of this line, let's flush the\n            # problems found (but filter them according to the directives)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or\n                        disabled.is_disabled_by_directive(problem)):\n                    yield problem\n\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1,\n                              e.problem_mark.column + 1,\n                              'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem\n\n\ndef _run(buffer, conf, filepath):\n    assert hasattr(buffer, '__getitem__'), \\\n        '_run() argument must be a buffer, not a stream'\n\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match(r'^#\\s*yamllint disable-file\\s*$', first_line):\n        return\n\n    # If the document contains a syntax error, save it and yield it at the\n    # right line\n    syntax_error = get_syntax_error(buffer)\n\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        # Insert the syntax error (if any) at the right place...\n        if (syntax_error and syntax_error.line <= problem.line and\n                syntax_error.column <= problem.column):\n            yield syntax_error\n\n            # Discard the problem since it is at the same place as the syntax\n            # error and is probably redundant (and maybe it's just a 'warning',\n            # in which case the script won't even exit with a failure status).\n            syntax_error = None\n            continue\n\n        yield problem\n\n    if syntax_error:\n        yield syntax_error\n\n\ndef run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source.\n\n    Returns a generator of LintProblem objects.\n\n    :param input: buffer, string or stream to read from\n    :param conf: yamllint configuration object\n    \"\"\"\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        # We need to have everything in memory to parse correctly\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')\n",
    "yamllint/parser.py": "# Copyright (C) 2016 Adrien Verg\u00e9\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport yaml\n\n\nclass Line:\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\n\nclass Token:\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\n\nclass Comment:\n    def __init__(self, line_no, column_no, buffer, pointer,\n                 token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\0', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return (isinstance(other, Comment) and\n                self.line_no == other.line_no and\n                self.column_no == other.column_no and\n                str(self) == str(other))\n\n    def is_inline(self):\n        return (\n            not isinstance(self.token_before, yaml.StreamStartToken) and\n            self.line_no == self.token_before.end_mark.line + 1 and\n            # sometimes token end marks are on the next line\n            self.buffer[self.token_before.end_mark.pointer - 1] != '\\n'\n        )\n\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif (token1.end_mark.line == token2.start_mark.line and\n          not isinstance(token1, yaml.StreamStartToken) and\n          not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:\n                                     token2.start_mark.pointer]\n\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos,\n                              token1.end_mark.buffer, pointer + pos,\n                              token1, token2, comment_before)\n            yield comment\n\n            comment_before = comment\n\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = (yaml_loader.peek_token()\n                        if yaml_loader.check_token() else None)\n\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n\n            yield from comments_between_tokens(curr, next)\n\n            prev = curr\n            curr = next\n\n    except yaml.scanner.ScannerError:\n        pass\n\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and\n                                  tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)\n"
  },
  "GT_src_dict": {
    "yamllint/linter.py": {
      "LintProblem.__init__": {
        "code": "    def __init__(self, line, column, desc='<no description>', rule=None):\n        \"\"\"Initializes a LintProblem instance, which represents a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the problem was detected (1-indexed).\n- column (int): The column number where the problem was detected (1-indexed).\n- desc (str, optional): A human-readable description of the problem (default is '<no description>').\n- rule (str, optional): The identifier of the lint rule that detected the problem (default is None).\n\nAttributes:\n- level (int or None): The severity level of the problem, which can be set later based on the rule configuration.\n\nThis class interacts with PROBLEM_LEVELS to classify the severity of the identified problems during YAML linting processes defined in the `get_cosmetic_problems` function. It also integrates seamlessly with the rest of the linting operations, allowing for a structured representation of lint issues.\"\"\"\n        self.line = line\n        self.column = column\n        self.desc = desc\n        self.rule = rule\n        self.level = None",
        "docstring": "Initializes a LintProblem instance, which represents a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the problem was detected (1-indexed).\n- column (int): The column number where the problem was detected (1-indexed).\n- desc (str, optional): A human-readable description of the problem (default is '<no description>').\n- rule (str, optional): The identifier of the lint rule that detected the problem (default is None).\n\nAttributes:\n- level (int or None): The severity level of the problem, which can be set later based on the rule configuration.\n\nThis class interacts with PROBLEM_LEVELS to classify the severity of the identified problems during YAML linting processes defined in the `get_cosmetic_problems` function. It also integrates seamlessly with the rest of the linting operations, allowing for a structured representation of lint issues.",
        "signature": "def __init__(self, line, column, desc='<no description>', rule=None):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__eq__": {
        "code": "    def __eq__(self, other):\n        \"\"\"Checks equality between two LintProblem instances.\n\nThis method compares the line, column, and rule attributes of the current instance with another LintProblem instance to determine if they are equivalent.\n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare with the current instance.\n\nReturns:\n- bool: True if the line, column, and rule of both instances are equal; otherwise, False.\n\nAttributes used:\n- self.line: The line number of the issue detected.\n- self.column: The column number of the issue detected.\n- self.rule: The identifier for the rule that detected the issue.\"\"\"\n        return self.line == other.line and self.column == other.column and (self.rule == other.rule)",
        "docstring": "Checks equality between two LintProblem instances.\n\nThis method compares the line, column, and rule attributes of the current instance with another LintProblem instance to determine if they are equivalent.\n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare with the current instance.\n\nReturns:\n- bool: True if the line, column, and rule of both instances are equal; otherwise, False.\n\nAttributes used:\n- self.line: The line number of the issue detected.\n- self.column: The column number of the issue detected.\n- self.rule: The identifier for the rule that detected the issue.",
        "signature": "def __eq__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "LintProblem.__lt__": {
        "code": "    def __lt__(self, other):\n        \"\"\"Compares two LintProblem instances based on their line and column attributes.\n\nThis method defines the less-than comparison between two LintProblem objects, allowing for sorting or ordering by line number first, and by column number second when lines are the same. \n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare against.\n\nReturns:\n- bool: True if the current instance is less than the other based on line and column attributes; otherwise, False.\n\nThis method relies on the line and column attributes defined in the LintProblem class, which represent the position of the linting problem in the YAML document.\"\"\"\n        return self.line < other.line or (self.line == other.line and self.column < other.column)",
        "docstring": "Compares two LintProblem instances based on their line and column attributes.\n\nThis method defines the less-than comparison between two LintProblem objects, allowing for sorting or ordering by line number first, and by column number second when lines are the same. \n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare against.\n\nReturns:\n- bool: True if the current instance is less than the other based on line and column attributes; otherwise, False.\n\nThis method relies on the line and column attributes defined in the LintProblem class, which represent the position of the linting problem in the YAML document.",
        "signature": "def __lt__(self, other):",
        "type": "Method",
        "class_signature": "class LintProblem:"
      },
      "_run": {
        "code": "def _run(buffer, conf, filepath):\n    \"\"\"Runs the linting process on a provided YAML buffer, checking for cosmetic problems and syntax errors. If the buffer contains a syntax error, it is identified and yielded at the appropriate line. The function relies on the `parser.line_generator()` to retrieve lines and on the `get_cosmetic_problems()` to gather linting issues based on the provided configuration.\n\nParameters:\n- buffer: A buffer-like object expected to support indexing; must contain the YAML source code.\n- conf: The yamllint configuration object that defines the rules and directives.\n- filepath: An optional string specifying the file path of the YAML file being linted, used for rule configuration.\n\nReturns:\n- A generator yielding instances of `LintProblem`, which encapsulate issues found in the YAML.\n\nDependencies:\n- Uses `get_syntax_error()` to identify syntax errors.\n- Interacts with `get_cosmetic_problems()` to detect stylistic issues based on enabled rules.\n- The function ensures that any problems reported do not overlap with syntax errors, preventing redundant output.\"\"\"\n    assert hasattr(buffer, '__getitem__'), '_run() argument must be a buffer, not a stream'\n    first_line = next(parser.line_generator(buffer)).content\n    if re.match('^#\\\\s*yamllint disable-file\\\\s*$', first_line):\n        return\n    syntax_error = get_syntax_error(buffer)\n    for problem in get_cosmetic_problems(buffer, conf, filepath):\n        if syntax_error and syntax_error.line <= problem.line and (syntax_error.column <= problem.column):\n            yield syntax_error\n            syntax_error = None\n            continue\n        yield problem\n    if syntax_error:\n        yield syntax_error",
        "docstring": "Runs the linting process on a provided YAML buffer, checking for cosmetic problems and syntax errors. If the buffer contains a syntax error, it is identified and yielded at the appropriate line. The function relies on the `parser.line_generator()` to retrieve lines and on the `get_cosmetic_problems()` to gather linting issues based on the provided configuration.\n\nParameters:\n- buffer: A buffer-like object expected to support indexing; must contain the YAML source code.\n- conf: The yamllint configuration object that defines the rules and directives.\n- filepath: An optional string specifying the file path of the YAML file being linted, used for rule configuration.\n\nReturns:\n- A generator yielding instances of `LintProblem`, which encapsulate issues found in the YAML.\n\nDependencies:\n- Uses `get_syntax_error()` to identify syntax errors.\n- Interacts with `get_cosmetic_problems()` to detect stylistic issues based on enabled rules.\n- The function ensures that any problems reported do not overlap with syntax errors, preventing redundant output.",
        "signature": "def _run(buffer, conf, filepath):",
        "type": "Function",
        "class_signature": null
      },
      "run": {
        "code": "def run(input, conf, filepath=None):\n    \"\"\"Lints a YAML source by analyzing the input for potential problems according to specified linting rules.\n\nParameters:\n- input: A buffer, string, or stream representing the YAML content to be linted.\n- conf: A configuration object for yamllint that specifies which rules to apply and any file-specific settings.\n- filepath: An optional parameter representing the path of the file being linted, used to check if the file is ignored by linting rules.\n\nReturns:\n- A generator that yields LintProblem objects, which represent the linting issues found in the YAML content.\n\nThe function interacts with the `PROBLEM_LEVELS` constant to categorize linting problem levels and with several internal helper functions such as `_run` and `get_cosmetic_problems` that perform the core linting logic. It also relies on the `parser` module to process the YAML content into manageable tokens and comments for analysis. If the input YAML document contains a syntax error, that problem is yielded alongside cosmetic issues while avoiding redundancy.\"\"\"\n    'Lints a YAML source.\\n\\n    Returns a generator of LintProblem objects.\\n\\n    :param input: buffer, string or stream to read from\\n    :param conf: yamllint configuration object\\n    '\n    if filepath is not None and conf.is_file_ignored(filepath):\n        return ()\n    if isinstance(input, (bytes, str)):\n        return _run(input, conf, filepath)\n    elif isinstance(input, io.IOBase):\n        content = input.read()\n        return _run(content, conf, filepath)\n    else:\n        raise TypeError('input should be a string or a stream')",
        "docstring": "Lints a YAML source by analyzing the input for potential problems according to specified linting rules.\n\nParameters:\n- input: A buffer, string, or stream representing the YAML content to be linted.\n- conf: A configuration object for yamllint that specifies which rules to apply and any file-specific settings.\n- filepath: An optional parameter representing the path of the file being linted, used to check if the file is ignored by linting rules.\n\nReturns:\n- A generator that yields LintProblem objects, which represent the linting issues found in the YAML content.\n\nThe function interacts with the `PROBLEM_LEVELS` constant to categorize linting problem levels and with several internal helper functions such as `_run` and `get_cosmetic_problems` that perform the core linting logic. It also relies on the `parser` module to process the YAML content into manageable tokens and comments for analysis. If the input YAML document contains a syntax error, that problem is yielded alongside cosmetic issues while avoiding redundancy.",
        "signature": "def run(input, conf, filepath=None):",
        "type": "Function",
        "class_signature": null
      }
    },
    "yamllint/parser.py": {}
  },
  "dependency_dict": {
    "yamllint/linter.py:run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:_run": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      },
      "yamllint/parser.py": {
        "Line.content": {
          "code": "    def content(self):\n        return self.buffer[self.start:self.end]",
          "docstring": "",
          "signature": "def content(self):",
          "type": "Method",
          "class_signature": "class Line:"
        },
        "line_generator": {
          "code": "def line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))",
          "docstring": "",
          "signature": "def line_generator(buffer):",
          "type": "Function",
          "class_signature": null
        }
      },
      "yamllint/linter.py": {
        "get_cosmetic_problems": {
          "code": "def get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []",
          "docstring": "",
          "signature": "def get_cosmetic_problems(buffer, conf, filepath):",
          "type": "Function",
          "class_signature": null
        },
        "get_syntax_error": {
          "code": "def get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
          "docstring": "",
          "signature": "def get_syntax_error(buffer):",
          "type": "Function",
          "class_signature": null
        }
      }
    },
    "yamllint/linter.py:LintProblem:__init__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__eq__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    },
    "yamllint/linter.py:LintProblem:__lt__": {
      "tests/common.py": {
        "RuleTestCase.check": {
          "code": "    def check(self, source, conf, **kwargs):\n        expected_problems = []\n        for key in kwargs:\n            assert key.startswith('problem')\n            if len(kwargs[key]) > 2:\n                if kwargs[key][2] == 'syntax':\n                    rule_id = None\n                else:\n                    rule_id = kwargs[key][2]\n            else:\n                rule_id = self.rule_id\n            expected_problems.append(linter.LintProblem(\n                kwargs[key][0], kwargs[key][1], rule=rule_id))\n        expected_problems.sort()\n\n        real_problems = list(linter.run(source, self.build_fake_config(conf)))\n        self.assertEqual(real_problems, expected_problems)",
          "docstring": "",
          "signature": "def check(self, source, conf, **kwargs):",
          "type": "Method",
          "class_signature": "class RuleTestCase(unittest.TestCase):"
        }
      }
    }
  },
  "call_tree": {
    "modified_testcases/rules/test_comments_indentation.py:CommentsIndentationTestCase:test_disable": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {
                "yamllint/config.py:YamlLintConfig:YamlLintConfig": {}
              }
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {
                  "yamllint/parser.py:Comment:__init__": {}
                }
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/rules/comments.py:check": {
              "yamllint/parser.py:Comment:is_inline": {}
            },
            "yamllint/linter.py:process_comment": {
              "yamllint/parser.py:Comment:__str__": {}
            },
            "yamllint/parser.py:Comment:is_inline": {}
          }
        }
      }
    },
    "modified_testcases/rules/test_comments_indentation.py:CommentsIndentationTestCase:test_empty_comment": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {
                  "yamllint/parser.py:Comment:__init__": {}
                }
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {},
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {},
            "yamllint/rules/truthy.py:check": {},
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/rules/comments.py:check": {
              "yamllint/parser.py:Comment:is_inline": {}
            },
            "yamllint/rules/comments_indentation.py:check": {
              "yamllint/rules/common.py:get_line_indent": {},
              "yamllint/parser.py:Comment:is_inline": {},
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/linter.py:process_comment": {
              "yamllint/parser.py:Comment:__str__": {}
            },
            "yamllint/parser.py:Comment:is_inline": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_comments_indentation.py:CommentsIndentationTestCase:test_enabled": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {
                  "yamllint/parser.py:Comment:__init__": {}
                }
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {
              "yamllint/rules/common.py:is_explicit_key": {},
              "yamllint/rules/common.py:spaces_before": {},
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {},
                "yamllint/rules/common.py:is_explicit_key": {},
                "yamllint/rules/indentation.py:detect_indent": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/rules/comments.py:check": {
              "yamllint/parser.py:Comment:is_inline": {}
            },
            "yamllint/rules/comments_indentation.py:check": {
              "yamllint/rules/common.py:get_line_indent": {},
              "yamllint/parser.py:Comment:is_inline": {},
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/linter.py:process_comment": {
              "yamllint/parser.py:Comment:__str__": {}
            },
            "yamllint/parser.py:Comment:is_inline": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {},
        "yamllint/linter.py:LintProblem:__lt__": {}
      }
    },
    "modified_testcases/rules/test_comments_indentation.py:CommentsIndentationTestCase:test_first_line": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {
                  "yamllint/parser.py:Comment:__init__": {}
                }
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {},
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {},
            "yamllint/rules/truthy.py:check": {},
            "yamllint/rules/comments.py:check": {
              "yamllint/parser.py:Comment:is_inline": {}
            },
            "yamllint/rules/comments_indentation.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/linter.py:process_comment": {
              "yamllint/parser.py:Comment:__str__": {}
            },
            "yamllint/parser.py:Comment:is_inline": {},
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_comments_indentation.py:CommentsIndentationTestCase:test_inline_comment": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {
                  "yamllint/parser.py:Comment:__init__": {}
                }
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {},
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {
              "yamllint/rules/common.py:spaces_after": {}
            },
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {},
                "yamllint/rules/common.py:get_real_end_line": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {
              "yamllint/rules/key_duplicates.py:Parent:__init__": {}
            },
            "yamllint/rules/truthy.py:check": {
              "yamllint/rules/truthy.py:yaml_spec_version_for_document": {}
            },
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_line_at_end_of_file.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/rules/comments.py:check": {
              "yamllint/parser.py:Comment:is_inline": {}
            },
            "yamllint/rules/comments_indentation.py:check": {
              "yamllint/rules/common.py:get_line_indent": {},
              "yamllint/parser.py:Comment:is_inline": {},
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/linter.py:process_comment": {
              "yamllint/parser.py:Comment:__str__": {}
            },
            "yamllint/parser.py:Comment:is_inline": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "modified_testcases/rules/test_comments_indentation.py:CommentsIndentationTestCase:test_no_newline_at_end": {
      "tests/common.py:RuleTestCase:check": {
        "tests/common.py:RuleTestCase:build_fake_config": {
          "yamllint/config.py:YamlLintConfig:__init__": {
            "yamllint/config.py:YamlLintConfig:parse": {
              "yamllint/config.py:get_extended_config_file": {},
              "yamllint/config.py:YamlLintConfig:__init__": {
                "[ignored_or_cut_off]": "..."
              },
              "yamllint/config.py:YamlLintConfig:extend": {}
            },
            "yamllint/config.py:YamlLintConfig:validate": {
              "yamllint/rules/__init__.py:get": {},
              "yamllint/config.py:validate_rule_conf": {}
            }
          }
        },
        "yamllint/linter.py:run": {},
        "yamllint/linter.py:_run": {
          "yamllint/parser.py:line_generator": {
            "yamllint/parser.py:Line:__init__": {}
          },
          "yamllint/parser.py:Line:content": {},
          "yamllint/linter.py:get_syntax_error": {},
          "yamllint/linter.py:get_cosmetic_problems": {
            "yamllint/config.py:YamlLintConfig:enabled_rules": {
              "yamllint/rules/__init__.py:get": {}
            },
            "yamllint/linter.py:DisableDirective": {},
            "yamllint/linter.py:DisableLineDirective": {},
            "yamllint/linter.py:__init__": {},
            "yamllint/parser.py:token_or_comment_or_line_generator": {
              "yamllint/parser.py:token_or_comment_generator": {
                "yamllint/parser.py:Token:__init__": {},
                "yamllint/parser.py:comments_between_tokens": {
                  "yamllint/parser.py:Comment:__init__": {}
                }
              },
              "yamllint/parser.py:line_generator": {
                "yamllint/parser.py:Line:__init__": {}
              }
            },
            "yamllint/rules/anchors.py:check": {},
            "yamllint/rules/braces.py:check": {},
            "yamllint/rules/brackets.py:check": {},
            "yamllint/rules/colons.py:check": {},
            "yamllint/rules/commas.py:check": {},
            "yamllint/rules/document_start.py:check": {},
            "yamllint/rules/hyphens.py:check": {},
            "yamllint/rules/indentation.py:check": {
              "yamllint/rules/indentation.py:_check": {
                "yamllint/rules/indentation.py:Parent:__init__": {}
              }
            },
            "yamllint/rules/key_duplicates.py:check": {},
            "yamllint/rules/truthy.py:check": {},
            "yamllint/rules/comments.py:check": {
              "yamllint/parser.py:Comment:is_inline": {}
            },
            "yamllint/rules/comments_indentation.py:check": {
              "yamllint/linter.py:LintProblem:__init__": {}
            },
            "yamllint/linter.py:process_comment": {
              "yamllint/parser.py:Comment:__str__": {}
            },
            "yamllint/parser.py:Comment:is_inline": {},
            "yamllint/rules/empty_lines.py:check": {},
            "yamllint/rules/line_length.py:check": {},
            "yamllint/rules/new_lines.py:check": {},
            "yamllint/rules/trailing_spaces.py:check": {},
            "yamllint/linter.py:is_disabled_by_directive": {}
          }
        },
        "yamllint/linter.py:LintProblem:__init__": {},
        "yamllint/linter.py:LintProblem:__eq__": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_comments_indentation/yamllint-test_comments_indentation/tests/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    },
    "/mnt/sfs_turbo/yaxindu/tmp/yamllint-image-test_comments_indentation/yamllint-test_comments_indentation/modified_testcases/test_parser.py:ParserTestCase:test_token_or_comment_generator": {
      "yamllint/parser.py:Comment:Comment": {}
    }
  },
  "PRD": "# PROJECT NAME: yamllint-test_comments_indentation\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 yamllint/\n    \u251c\u2500\u2500 linter.py\n    \u2502   \u251c\u2500\u2500 LintProblem.__eq__\n    \u2502   \u251c\u2500\u2500 LintProblem.__init__\n    \u2502   \u251c\u2500\u2500 LintProblem.__lt__\n    \u2502   \u251c\u2500\u2500 _run\n    \u2502   \u2514\u2500\u2500 run\n    \u2514\u2500\u2500 parser.py\n        \u2514\u2500\u2500 Comment.Comment\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module is designed to validate and enforce proper indentation and alignment of comments in YAML files, ensuring consistency and adherence to defined formatting rules. It provides capabilities to detect and report misaligned comments, differentiate between acceptable and problematic comment placements, and accommodate configurations for enabling or disabling specific formatting checks. By standardizing the formatting of comments, the module helps developers maintain readability and structure within YAML files, reducing errors and ambiguities caused by poorly formatted or inconsistent comments. This streamlines collaborative development workflows and supports organizations in adhering to best practices for code quality.\n\n## FILE 1: yamllint/linter.py\n\n- FUNCTION NAME: run\n  - SIGNATURE: def run(input, conf, filepath=None):\n  - DOCSTRING: \n```python\n\"\"\"\nLints a YAML source by analyzing the input for potential problems according to specified linting rules.\n\nParameters:\n- input: A buffer, string, or stream representing the YAML content to be linted.\n- conf: A configuration object for yamllint that specifies which rules to apply and any file-specific settings.\n- filepath: An optional parameter representing the path of the file being linted, used to check if the file is ignored by linting rules.\n\nReturns:\n- A generator that yields LintProblem objects, which represent the linting issues found in the YAML content.\n\nThe function interacts with the `PROBLEM_LEVELS` constant to categorize linting problem levels and with several internal helper functions such as `_run` and `get_cosmetic_problems` that perform the core linting logic. It also relies on the `parser` module to process the YAML content into manageable tokens and comments for analysis. If the input YAML document contains a syntax error, that problem is yielded alongside cosmetic issues while avoiding redundancy.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n\n- CLASS METHOD: LintProblem.__init__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __init__(self, line, column, desc='<no description>', rule=None):\n  - DOCSTRING: \n```python\n\"\"\"\nInitializes a LintProblem instance, which represents a linting issue found in a YAML document.\n\nParameters:\n- line (int): The line number where the problem was detected (1-indexed).\n- column (int): The column number where the problem was detected (1-indexed).\n- desc (str, optional): A human-readable description of the problem (default is '<no description>').\n- rule (str, optional): The identifier of the lint rule that detected the problem (default is None).\n\nAttributes:\n- level (int or None): The severity level of the problem, which can be set later based on the rule configuration.\n\nThis class interacts with PROBLEM_LEVELS to classify the severity of the identified problems during YAML linting processes defined in the `get_cosmetic_problems` function. It also integrates seamlessly with the rest of the linting operations, allowing for a structured representation of lint issues.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__eq__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __eq__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nChecks equality between two LintProblem instances.\n\nThis method compares the line, column, and rule attributes of the current instance with another LintProblem instance to determine if they are equivalent.\n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare with the current instance.\n\nReturns:\n- bool: True if the line, column, and rule of both instances are equal; otherwise, False.\n\nAttributes used:\n- self.line: The line number of the issue detected.\n- self.column: The column number of the issue detected.\n- self.rule: The identifier for the rule that detected the issue.\n\"\"\"\n```\n\n- CLASS METHOD: LintProblem.__lt__\n  - CLASS SIGNATURE: class LintProblem:\n  - SIGNATURE: def __lt__(self, other):\n  - DOCSTRING: \n```python\n\"\"\"\nCompares two LintProblem instances based on their line and column attributes.\n\nThis method defines the less-than comparison between two LintProblem objects, allowing for sorting or ordering by line number first, and by column number second when lines are the same. \n\nParameters:\n- other (LintProblem): Another instance of LintProblem to compare against.\n\nReturns:\n- bool: True if the current instance is less than the other based on line and column attributes; otherwise, False.\n\nThis method relies on the line and column attributes defined in the LintProblem class, which represent the position of the linting problem in the YAML document.\n\"\"\"\n```\n\n- FUNCTION NAME: _run\n  - SIGNATURE: def _run(buffer, conf, filepath):\n  - DOCSTRING: \n```python\n\"\"\"\nRuns the linting process on a provided YAML buffer, checking for cosmetic problems and syntax errors. If the buffer contains a syntax error, it is identified and yielded at the appropriate line. The function relies on the `parser.line_generator()` to retrieve lines and on the `get_cosmetic_problems()` to gather linting issues based on the provided configuration.\n\nParameters:\n- buffer: A buffer-like object expected to support indexing; must contain the YAML source code.\n- conf: The yamllint configuration object that defines the rules and directives.\n- filepath: An optional string specifying the file path of the YAML file being linted, used for rule configuration.\n\nReturns:\n- A generator yielding instances of `LintProblem`, which encapsulate issues found in the YAML.\n\nDependencies:\n- Uses `get_syntax_error()` to identify syntax errors.\n- Interacts with `get_cosmetic_problems()` to detect stylistic issues based on enabled rules.\n- The function ensures that any problems reported do not overlap with syntax errors, preventing redundant output.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - tests/common.py:RuleTestCase:check\n    - yamllint/parser.py:Line:content\n    - yamllint/parser.py:line_generator\n    - yamllint/linter.py:get_cosmetic_problems\n    - yamllint/linter.py:get_syntax_error\n\n## FILE 2: yamllint/parser.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "yamllint/linter.py": "import io\nimport re\nimport yaml\nfrom yamllint import parser\nPROBLEM_LEVELS = {0: None, 1: 'warning', 2: 'error', None: 0, 'warning': 1, 'error': 2}\nDISABLE_RULE_PATTERN = re.compile('^# yamllint disable( rule:\\\\S+)*\\\\s*$')\nENABLE_RULE_PATTERN = re.compile('^# yamllint enable( rule:\\\\S+)*\\\\s*$')\n\nclass LintProblem:\n    \"\"\"Represents a linting problem found by yamllint.\"\"\"\n\n    @property\n    def message(self):\n        if self.rule is not None:\n            return f'{self.desc} ({self.rule})'\n        return self.desc\n\n    def __repr__(self):\n        return f'{self.line}:{self.column}: {self.message}'\n\ndef get_cosmetic_problems(buffer, conf, filepath):\n    rules = conf.enabled_rules(filepath)\n    token_rules = [r for r in rules if r.TYPE == 'token']\n    comment_rules = [r for r in rules if r.TYPE == 'comment']\n    line_rules = [r for r in rules if r.TYPE == 'line']\n    context = {}\n    for rule in token_rules:\n        context[rule.ID] = {}\n\n    class DisableDirective:\n\n        def __init__(self):\n            self.rules = set()\n            self.all_rules = {r.ID for r in rules}\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if DISABLE_RULE_PATTERN.match(comment):\n                items = comment[18:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n            elif ENABLE_RULE_PATTERN.match(comment):\n                items = comment[17:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules.clear()\n                else:\n                    for id in rules:\n                        self.rules.discard(id)\n\n        def is_disabled_by_directive(self, problem):\n            return problem.rule in self.rules\n\n    class DisableLineDirective(DisableDirective):\n\n        def process_comment(self, comment):\n            comment = str(comment)\n            if re.match('^# yamllint disable-line( rule:\\\\S+)*\\\\s*$', comment):\n                items = comment[23:].rstrip().split(' ')\n                rules = [item[5:] for item in items][1:]\n                if len(rules) == 0:\n                    self.rules = self.all_rules.copy()\n                else:\n                    for id in rules:\n                        if id in self.all_rules:\n                            self.rules.add(id)\n    cache = []\n    disabled = DisableDirective()\n    disabled_for_line = DisableLineDirective()\n    disabled_for_next_line = DisableLineDirective()\n    for elem in parser.token_or_comment_or_line_generator(buffer):\n        if isinstance(elem, parser.Token):\n            for rule in token_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem.curr, elem.prev, elem.next, elem.nextnext, context[rule.ID]):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n        elif isinstance(elem, parser.Comment):\n            for rule in comment_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            disabled.process_comment(elem)\n            if elem.is_inline():\n                disabled_for_line.process_comment(elem)\n            else:\n                disabled_for_next_line.process_comment(elem)\n        elif isinstance(elem, parser.Line):\n            for rule in line_rules:\n                rule_conf = conf.rules[rule.ID]\n                for problem in rule.check(rule_conf, elem):\n                    problem.rule = rule.ID\n                    problem.level = rule_conf['level']\n                    cache.append(problem)\n            for problem in cache:\n                if not (disabled_for_line.is_disabled_by_directive(problem) or disabled.is_disabled_by_directive(problem)):\n                    yield problem\n            disabled_for_line = disabled_for_next_line\n            disabled_for_next_line = DisableLineDirective()\n            cache = []\n\ndef get_syntax_error(buffer):\n    try:\n        list(yaml.parse(buffer, Loader=yaml.BaseLoader))\n    except yaml.error.MarkedYAMLError as e:\n        problem = LintProblem(e.problem_mark.line + 1, e.problem_mark.column + 1, 'syntax error: ' + e.problem + ' (syntax)')\n        problem.level = 'error'\n        return problem",
    "yamllint/parser.py": "import yaml\n\nclass Line:\n\n    def __init__(self, line_no, buffer, start, end):\n        self.line_no = line_no\n        self.start = start\n        self.end = end\n        self.buffer = buffer\n\n    @property\n    def content(self):\n        return self.buffer[self.start:self.end]\n\nclass Token:\n\n    def __init__(self, line_no, curr, prev, next, nextnext):\n        self.line_no = line_no\n        self.curr = curr\n        self.prev = prev\n        self.next = next\n        self.nextnext = nextnext\n\nclass Comment:\n\n    def __init__(self, line_no, column_no, buffer, pointer, token_before=None, token_after=None, comment_before=None):\n        self.line_no = line_no\n        self.column_no = column_no\n        self.buffer = buffer\n        self.pointer = pointer\n        self.token_before = token_before\n        self.token_after = token_after\n        self.comment_before = comment_before\n\n    def __str__(self):\n        end = self.buffer.find('\\n', self.pointer)\n        if end == -1:\n            end = self.buffer.find('\\x00', self.pointer)\n        if end != -1:\n            return self.buffer[self.pointer:end]\n        return self.buffer[self.pointer:]\n\n    def __eq__(self, other):\n        return isinstance(other, Comment) and self.line_no == other.line_no and (self.column_no == other.column_no) and (str(self) == str(other))\n\n    def is_inline(self):\n        return not isinstance(self.token_before, yaml.StreamStartToken) and self.line_no == self.token_before.end_mark.line + 1 and (self.buffer[self.token_before.end_mark.pointer - 1] != '\\n')\n\ndef line_generator(buffer):\n    line_no = 1\n    cur = 0\n    next = buffer.find('\\n')\n    while next != -1:\n        if next > 0 and buffer[next - 1] == '\\r':\n            yield Line(line_no, buffer, start=cur, end=next - 1)\n        else:\n            yield Line(line_no, buffer, start=cur, end=next)\n        cur = next + 1\n        next = buffer.find('\\n', cur)\n        line_no += 1\n    yield Line(line_no, buffer, start=cur, end=len(buffer))\n\ndef comments_between_tokens(token1, token2):\n    \"\"\"Find all comments between two tokens\"\"\"\n    if token2 is None:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:]\n    elif token1.end_mark.line == token2.start_mark.line and (not isinstance(token1, yaml.StreamStartToken)) and (not isinstance(token2, yaml.StreamEndToken)):\n        return\n    else:\n        buf = token1.end_mark.buffer[token1.end_mark.pointer:token2.start_mark.pointer]\n    line_no = token1.end_mark.line + 1\n    column_no = token1.end_mark.column + 1\n    pointer = token1.end_mark.pointer\n    comment_before = None\n    for line in buf.split('\\n'):\n        pos = line.find('#')\n        if pos != -1:\n            comment = Comment(line_no, column_no + pos, token1.end_mark.buffer, pointer + pos, token1, token2, comment_before)\n            yield comment\n            comment_before = comment\n        pointer += len(line) + 1\n        line_no += 1\n        column_no = 1\n\ndef token_or_comment_generator(buffer):\n    yaml_loader = yaml.BaseLoader(buffer)\n    try:\n        prev = None\n        curr = yaml_loader.get_token()\n        while curr is not None:\n            next = yaml_loader.get_token()\n            nextnext = yaml_loader.peek_token() if yaml_loader.check_token() else None\n            yield Token(curr.start_mark.line + 1, curr, prev, next, nextnext)\n            yield from comments_between_tokens(curr, next)\n            prev = curr\n            curr = next\n    except yaml.scanner.ScannerError:\n        pass\n\ndef token_or_comment_or_line_generator(buffer):\n    \"\"\"Generator that mixes tokens and lines, ordering them by line number\"\"\"\n    tok_or_com_gen = token_or_comment_generator(buffer)\n    line_gen = line_generator(buffer)\n    tok_or_com = next(tok_or_com_gen, None)\n    line = next(line_gen, None)\n    while tok_or_com is not None or line is not None:\n        if tok_or_com is None or (line is not None and tok_or_com.line_no > line.line_no):\n            yield line\n            line = next(line_gen, None)\n        else:\n            yield tok_or_com\n            tok_or_com = next(tok_or_com_gen, None)"
  }
}