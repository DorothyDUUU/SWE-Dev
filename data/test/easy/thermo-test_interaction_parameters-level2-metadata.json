{
  "dir_path": "/app/thermo",
  "package_name": "thermo",
  "sample_name": "thermo-test_interaction_parameters",
  "src_dir": "thermo/",
  "test_dir": "tests/",
  "test_file": "modified_testcases/test_interaction_parameters.py",
  "test_code": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2017 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'''\n\nfrom fluids.numerics import assert_close, assert_close2d, assert_close3d\n\nfrom thermo.interaction_parameters import IPDB\n\n\ndef run_validate_db():\n    from thermo.interaction_parameters import ip_files\n\n    for name in ip_files.keys():\n        IPDB.validate_table(name)\n\ndef test_basic_chemsep_PR():\n    kij = IPDB.get_ip_specific('ChemSep PR', ['124-38-9', '67-56-1'], 'kij')\n    assert_close(kij, 0.0583)\n\n    kij_auto = IPDB.get_ip_automatic(['124-38-9', '67-56-1'], 'PR kij', 'kij')\n    assert_close(kij, kij_auto)\n\n    kij_missing = IPDB.get_ip_specific('ChemSep PR', ['1249-38-9', '67-56-1'], 'kij')\n    assert kij_missing == 0\n    assert False is IPDB.has_ip_specific('ChemSep PR', ['1249-38-9', '67-56-1'], 'kij')\n    assert True is IPDB.has_ip_specific('ChemSep PR', ['124-38-9', '67-56-1'], 'kij')\n\n    assert IPDB.get_tables_with_type('PR kij') == ['ChemSep PR']\n\n    # interaction parameter matrix\n    kij_C1C4 = IPDB.get_ip_symmetric_matrix('ChemSep PR', ['74-82-8', '74-84-0', '74-98-6', '106-97-8'], 'kij')\n    kij_C1C4_known = [[0.0, -0.0059, 0.0119, 0.0185],\n                     [-0.0059, 0.0, 0.0011, 0.0089],\n                     [0.0119, 0.0011, 0.0, 0.0033],\n                     [0.0185, 0.0089, 0.0033, 0.0]]\n    assert_close2d(kij_C1C4, kij_C1C4_known)\n    # Test for asymetric works the same since the model is asymmetric\n    kij_C1C4 = IPDB.get_ip_symmetric_matrix('ChemSep PR', ['74-82-8', '74-84-0', '74-98-6', '106-97-8'], 'kij')\n    assert_close2d(kij_C1C4, kij_C1C4_known)\n\n\ndef test_basic_chemsep_NRTL():\n    # ethanol water, converted to metric, simple T dependence\n    bijs = IPDB.get_ip_asymmetric_matrix('ChemSep NRTL', ['64-17-5', '7732-18-5'], 'bij')\n    assert_close2d(bijs, [[0.0, -29.166654483541816], [624.8676222389441, 0.0]], rtol=1e-7)\n    alphas_known = [[0.0, 0.2937, 0.3009], [0.2937, 0.0, 0.2999], [0.3009, 0.2999, 0.0]]\n    # Test is works both symmetric and asymmetric\n    alphas = IPDB.get_ip_asymmetric_matrix('ChemSep NRTL', ['64-17-5', '7732-18-5', '67-56-1'], 'alphaij')\n    assert_close2d(alphas, alphas_known)\n    alphas = IPDB.get_ip_symmetric_matrix('ChemSep NRTL', ['64-17-5', '7732-18-5', '67-56-1'], 'alphaij')\n    assert_close2d(alphas, alphas_known)\n\n\n\ndef test_basic_chemsep_UNIQUAC():\n    tausB = IPDB.get_ip_asymmetric_matrix(name='ChemSep UNIQUAC', CASs=['64-17-5', '7732-18-5'], ip='bij')\n    assert_close2d(tausB, [[0.0, -87.46005814161899], [-55.288075960115854, 0.0]], rtol=1e-5)\n\n\ndef test_henry_Rolf_Sander_2023():\n    CASs = ['7732-18-5', '74-82-8', '7782-44-7', '64-17-5']\n    henry_const_test = [IPDB.get_ip_asymmetric_matrix('Sander Const', CASs, p) for p in ('A', 'B', 'C', 'D', 'E', 'F')]\n\n    henry_const_expect = [[[0.0, 0.0, 0.0, 0.0], [21.975256193524245, 0.0, 0.0, 0.0], [22.191168101425834, 0.0, 0.0, 0.0], [10.575956940357607, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]]]\n    assert_close3d(henry_const_expect, henry_const_test, rtol=.05)\n\n    henry_T_dep_test = [IPDB.get_ip_asymmetric_matrix('Sander T dep', CASs, p) for p in ('A', 'B', 'C', 'D', 'E', 'F')]\n    henry_T_dep_expect = [[[0.0, 0.0, 0.0, 0.0], [28.007050169351437, 0.0, 0.0, 0.0], [27.563639475880688, 0.0, 0.0, 0.0], [30.606359873543198, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [-1730.7202544017841, 0.0, 0.0, 0.0], [-1601.8023402937147, 0.0, 0.0, 0.0], [-6045.389393215481, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]], [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]]]\n    assert_close3d(henry_T_dep_test, henry_T_dep_expect, rtol=.05)\n",
  "GT_file_code": {
    "thermo/interaction_parameters.py": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2017, 2018, 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nThis module contains a small database of interaction parameters.\nOnly two data sets are currently included, both from ChemSep. If you would\nlike to add parameters to this project please make a referenced compilation of\nvalues and submit them on GitHub.\n\n\nFor reporting bugs, adding feature requests, or submitting pull requests,\nplease use the `GitHub issue tracker <https://github.com/CalebBell/thermo/>`_.\n\n.. contents:: :local:\n\n.. autoclass:: InteractionParameterDB\n    :members:\n\n.. autodata:: IPDB\n\n   Exmple database with NRTL and PR values from ChemSep. This is lazy-loaded,\n   access it as `thermo.interaction_parameters.IPDB`.\n\n.. autoclass:: ScalarParameterDB\n\nSPDB\n\n    Example scalar parameters for models. This is lazy-loaded,\n    access it as `thermo.interaction_parameters.SPDB`.\n'''\n\n\n__all__ = ['InteractionParameterDB', 'ScalarParameterDB']\n\nimport os\nfrom math import isnan\n\nfrom chemicals.identifiers import check_CAS, sorted_CAS_key\nfrom chemicals.utils import PY37, can_load_data\n\n\nclass InteractionParameterDB:\n    '''Basic database framework for interaction parameters.\n    '''\n\n    def __init__(self):\n        self.tables = {}\n        self.metadata = {}\n\n    def load_json(self, file, name):\n        '''Load a json file from disk containing interaction\n        coefficients.\n\n        The format for the file is as follows:\n\n        A `data` key containing a dictionary with a key:\n\n            * `CAS1 CAS2` : str\n               The CAS numbers of both components, sorted from small to high\n               as integers; they should have the '-' symbols still in them\n               and have a single space between them; if these are ternary or\n               higher parameters, follow the same format for the other CAS\n               numbers, [-]\n\n            * values : dict[str : various]\n                All of the values listed in the metadata element\n                `necessary keys`; they are None if missing.\n\n        A `metadata` key containing:\n\n            * `symmetric` : bool\n               Whether or not the interaction coefficients are missing.\n            * `source` : str\n               Where the data came from.\n            * `components` : int\n               The number of components each interaction parameter is for;\n               2 for binary, 3 for ternary, etc.\n            * `necessary keys` : list[str]\n               Which elements are required in the data.\n            * `P dependent` : bool\n               Whether or not the interaction parameters are pressure dependent.\n            * `missing` : dict[str : float]\n               Values which are missing are returned with these values\n            * `type` : One of 'PR kij', 'SRK kij', etc; used to group data but not\n               tied into anything else.\n            * `T dependent` : bool\n               Whether or not the data is T-dependent.\n\n        Parameters\n        ----------\n        file : str\n            Path to json file on disk which contains interaction coefficients, [-]\n        name : str\n            Name that the data read should be referred to by, [-]\n        '''\n        import json\n        f = open(file).read()\n        dat = json.loads(f)\n        self.tables[name] = dat['data']\n        self.metadata[name] = dat['metadata']\n\n    def validate_table(self, name):\n        '''Basic method which checks that all CAS numbers are valid, and that\n        all elements of the data have non-nan values.\n        Raises an exception if any of the data is missing or is a nan value.\n        '''\n        table = self.tables[name]\n        meta = self.metadata[name]\n        components = meta['components']\n        necessary_keys = meta['necessary keys']\n        # Check the CASs\n        for key in table:\n            CASs = key.split(' ')\n            # Check the key is the right length\n            assert len(CASs) == components\n            # Check all CAS number keys are valid\n            assert all(check_CAS(i) for i in CASs)\n\n            values = table[key]\n            for i in necessary_keys:\n                # Assert all necessary keys are present\n                assert i in values\n                val = values[i]\n                # Check they are not None\n                assert val is not None\n                # Check they are not nan\n                assert not isnan(val)\n\n\n    def has_ip_specific(self, name, CASs, ip):\n        '''Check if a bip exists in a table.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CASs : Iterable[str]\n            CAS numbers; they do not need to be sorted, [-]\n        ip : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        present : bool\n            Whether or not the data is included in the table, [-]\n\n        Examples\n        --------\n        Check if nitrogen-ethane as a PR BIP:\n\n        >>> from thermo.interaction_parameters import IPDB\n        >>> IPDB.has_ip_specific('ChemSep PR', ['7727-37-9', '74-84-0'], 'kij')\n        True\n        '''\n        if self.metadata[name]['symmetric']:\n            key = ' '.join(sorted_CAS_key(CASs))\n        else:\n            key = ' '.join(CASs)\n        table = self.tables[name]\n        if key not in table:\n            return False\n        return ip in table[key]\n\n    def get_ip_specific(self, name, CASs, ip):\n        '''Get an interaction parameter from a table. If the specified\n        parameter is missing, the default `missing` value as defined in\n        the data file is returned instead.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CASs : Iterable[str]\n            CAS numbers; they do not need to be sorted, [-]\n        ip : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        value : float\n            Interaction parameter specified by `ip`, [-]\n\n        Examples\n        --------\n        Check if nitrogen-ethane as a PR BIP:\n\n        >>> from thermo.interaction_parameters import IPDB\n        >>> IPDB.get_ip_specific('ChemSep PR', ['7727-37-9', '74-84-0'], 'kij')\n        0.0533\n        '''\n        if self.metadata[name]['symmetric']:\n            key = ' '.join(sorted_CAS_key(CASs))\n        else:\n            key = ' '.join(CASs)\n        try:\n            return self.tables[name][key][ip]\n        except KeyError:\n            return self.metadata[name]['missing'][ip]\n\n    def get_tables_with_type(self, ip_type):\n        '''Get a list of tables which have a type of a parameter.\n\n        Parameters\n        ----------\n        ip_type : str\n            Name of the parameter type, [-]\n\n        Returns\n        -------\n        table_names : list[str]\n            Interaction parameter tables including `ip`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import IPDB\n        >>> IPDB.get_tables_with_type('PR kij')\n        ['ChemSep PR']\n        '''\n        tables = []\n        for key, d in self.metadata.items():\n            if d['type'] == ip_type:\n                tables.append(key)\n        return tables\n\n    def get_ip_automatic(self, CASs, ip_type, ip):\n        '''Get an interaction parameter for the first table containing the\n        value.\n\n        Parameters\n        ----------\n        CASs : Iterable[str]\n            CAS numbers; they do not need to be sorted, [-]\n        ip_type : str\n            Name of the parameter type, [-]\n        ip : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        value : float\n            Interaction parameter specified by `ip`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import IPDB\n        >>> IPDB.get_ip_automatic(CASs=['7727-37-9', '74-84-0'], ip_type='PR kij', ip='kij')\n        0.0533\n        '''\n        table = self.get_tables_with_type(ip_type)[0]\n        return self.get_ip_specific(table, CASs, ip)\n\n    def get_ip_symmetric_matrix(self, name, CASs, ip, T=298.15):\n        '''Get a table of interaction parameters from a specified source\n        for the specified parameters. This method assumes symmetric\n        parameters for speed.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CASs : Iterable[str]\n            CAS numbers; they do not need to be sorted, [-]\n        ip : str\n            Name of the parameter to retrieve, [-]\n        T : float, optional\n            Temperature of the system, [-]\n\n        Returns\n        -------\n        values : list[list[float]]\n            Interaction parameters specified by `ip`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import IPDB\n        >>> IPDB.get_ip_symmetric_matrix(name='ChemSep PR', CASs=['7727-37-9', '74-84-0', '74-98-6'], ip='kij')\n        [[0.0, 0.0533, 0.0878], [0.0533, 0.0, 0.0011], [0.0878, 0.0011, 0.0]]\n        '''\n        table = self.tables[name]\n        N = len(CASs)\n        values = [[None for i in range(N)] for j in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    i_ip = 0.0\n                elif values[j][i] is not None:\n                    continue # already set\n                else:\n                    i_ip = self.get_ip_specific(name, [CASs[i], CASs[j]], ip)\n                values[i][j] = values[j][i] = i_ip\n        return values\n\n    def get_ip_asymmetric_matrix(self, name, CASs, ip, T=298.15):\n        '''Get a table of interaction parameters from a specified source\n        for the specified parameters.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CASs : Iterable[str]\n            CAS numbers; they do not need to be sorted, [-]\n        ip : str\n            Name of the parameter to retrieve, [-]\n        T : float, optional\n            Temperature of the system, [-]\n\n        Returns\n        -------\n        values : list[list[float]]\n            Interaction parameters specified by `ip`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import IPDB\n        >>> IPDB.get_ip_symmetric_matrix(name='ChemSep NRTL', CASs=['64-17-5', '7732-18-5', '67-56-1'], ip='alphaij')\n        [[0.0, 0.2937, 0.3009], [0.2937, 0.0, 0.2999], [0.3009, 0.2999, 0.0]]\n        '''\n        table = self.tables[name]\n        N = len(CASs)\n        values = [[None for i in range(N)] for j in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    i_ip = 0.0\n                else:\n                    i_ip = self.get_ip_specific(name, [CASs[i], CASs[j]], ip)\n                values[i][j] = i_ip\n        return values\n\nclass ScalarParameterDB:\n    '''Basic database framework for scalar parameters of various thermodynamic\n    models. The following keys are used:\n\n    **Peng-Robinson**\n\n    :obj:`Twu Volume-translated Peng-Robinson <thermo.eos_mix.PRMIXTranslatedConsistent>`:\n    `TwuPRL`, `TwuPRM`, `TwuPRN`, `TwuPRc`\n\n    :obj:`Volume-translated Peng-Robinson <thermo.eos_mix.PRMIXTranslated>`:\n    `PRc`\n\n    :obj:`Peng-Robinson-Stryjek-Vera  <thermo.eos_mix.PRSVMIX>`:\n    `PRSVkappa1`\n\n    :obj:`Peng-Robinson-Stryjek-Vera 2  <thermo.eos_mix.PRSV2MIX>`:\n    `PRSV2kappa1`, `PRSV2kappa2`, `PRSV2kappa3`\n\n    **SRK**\n\n    :obj:`Twu Volume-translated Peng-Robinson <thermo.eos_mix.SRKMIXTranslatedConsistent>`:\n    `TwuSRKL`, `TwuSRKM`, `TwuSRKN`, `TwuSRKc`\n\n    :obj:`Volume-translated Peng-Robinson <thermo.eos_mix.SRKMIXTranslated>`:\n    `SRKc`\n\n    :obj:`Refinery Soave-Redlich-Kwong  <thermo.eos_mix.APISRKMIX>`:\n    `APISRKS1`, `APISRKS2`\n\n    :obj:`MSRK  <thermo.eos_mix.MSRKMIXTranslated>`:\n    `MSRKM`, `MSRKN`, `MSRKc`\n\n    :obj:`Predictive Soave-Redlich-Kwong <thermo.eos_mix.PSRK>`:\n    `MCSRKC1`, `MCSRKC2`, `MCSRKC3`\n\n\n    **Excess Gibbs Energy Models**\n\n    :obj:`Regular Solution <thermo.regular_solution.RegularSolution>`:\n    `RegularSolutionV`, `RegularSolutionSP`\n\n\n    '''\n\n    def __init__(self):\n        self.tables = {}\n        self.metadata = {}\n    def load_json(self, file, name):\n\n        import json\n        f = open(file).read()\n        dat = json.loads(f)\n        self.tables[name] = dat['data']\n        self.metadata[name] = dat['metadata']\n\n    def get_parameter_specific(self, name, CAS, parameter):\n        '''Get a parameter from a table. If the specified\n        parameter is missing, the default `missing` value as defined in\n        the data file is returned instead.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CAS : str\n            CAS number, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        value : float\n            Interaction parameter specified by `ip`, [-]\n\n        Examples\n        --------\n        Get the `L` Twu parameter for PR from Pi\u00f1a-Martinez (2021):\n\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_parameter_specific('PRTwu_PinaMartinez', '7727-37-9', 'TwuPRL')\n        0.1243\n        '''\n        try:\n            return self.tables[name][CAS][parameter]\n        except KeyError:\n            return self.metadata[name]['missing'][parameter]\n\n    def has_parameter_specific(self, name, CAS, parameter):\n        '''Check if a parameter exists in a table.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CAS : str\n            CAS number, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        present : bool\n            Whether or not the data is included in the table, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.has_parameter_specific('PRTwu_PinaMartinez', '7727-37-9', 'TwuPRL')\n        True\n        >>> SPDB.has_parameter_specific('PRTwu_PinaMartinez', '7439-89-6', 'TwuPRL')\n        False\n        '''\n        table = self.tables[name]\n        if CAS not in table:\n            return False\n        return parameter in table[CAS]\n\n    def get_tables_with_type(self, parameter):\n        '''Get a list of tables which have a parameter.\n\n        Parameters\n        ----------\n        parameter : str\n            Name of the parameter, [-]\n\n        Returns\n        -------\n        table_names : list[str]\n            Interaction parameter tables including `parameter`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_tables_with_type('TwuPRL')\n        ['PRTwu_PinaMartinez', 'PRTwu_ibell_2018']\n        '''\n        tables = []\n        for key, d in self.metadata.items():\n            if parameter in d['missing']:\n                tables.append(key)\n        return tables\n\n    def get_parameter_automatic(self, CAS, parameter):\n        '''Get an interaction parameter for the first table containing the\n        value.\n\n        Parameters\n        ----------\n        CAS : str\n            CAS number, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        value : float\n            Parameter value specified by `parameter`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_parameter_automatic('7727-37-9', parameter='TwuPRL')\n        0.1243\n        '''\n        table = self.get_tables_with_type(parameter)[0]\n        return self.get_parameter_specific(table, CAS, parameter)\n\n    def get_parameter_vector(self, name, CASs, parameter):\n        '''Get a list of parameters from a specified source\n        for the specified parameter.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CASs : Iterable[str]\n            CAS numbers; the returned values will be in this order, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        values : list[float]\n            Parameter specified by `parameter`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_parameter_vector(name='PRTwu_PinaMartinez', CASs=['7727-37-9', '74-84-0', '74-98-6'], parameter='TwuPRL')\n        [0.1243, 0.3053, 0.7455]\n        >>> SPDB.get_parameter_vector(name='PRVolumeTranslation_PinaMartinez', CASs=['7727-37-9', '74-84-0', '74-98-6'], parameter='PRc')\n        [-3.643e-06, -3.675e-06, -3.735e-06]\n        '''\n        table = self.tables[name]\n        N = len(CASs)\n        values = [None]*N\n        for i in range(N):\n            values[i] = self.get_parameter_specific(name, CASs[i], parameter)\n        return values\n\n\n_loaded_interactions = False\ndef load_all_interaction_parameters():\n    global IPDB, _loaded_interactions\n\n    folder = os.path.join(os.path.dirname(__file__), 'Interaction Parameters')\n    chemsep_db_path = os.path.join(folder, 'ChemSep')\n    ip_files = {'ChemSep PR': os.path.join(chemsep_db_path, 'pr.json'),\n                'ChemSep NRTL': os.path.join(chemsep_db_path, 'nrtl.json'),\n                'ChemSep UNIQUAC': os.path.join(chemsep_db_path, 'uniquac.json'),\n                'ChemSep Wilson': os.path.join(chemsep_db_path, 'wilson.json'),\n\n                'ChemSep Henry': os.path.join(chemsep_db_path, 'henry.json'),\n                'Sander Const': os.path.join(folder, 'Sander_henry_const.json'),\n                'Sander T dep': os.path.join(folder, 'Sander_henry_T_dep.json'),\n                'PRTranslated Henry Best': os.path.join(folder, 'PRTranslated_best_henry_T_dep.json'),\n                }\n\n\n    IPDB = InteractionParameterDB()\n    for name, file in ip_files.items():\n        IPDB.load_json(file, name)\n\n    _loaded_interactions = True\n\n_loaded_scalars = False\ndef load_all_scalar_parameters():\n    global SPDB, _loaded_scalars\n\n    folder = os.path.join(os.path.dirname(__file__), 'Scalar Parameters')\n    sp_files = {'PRTwu_PinaMartinez': os.path.join(folder, 'PRTwu_PinaMartinez.json'),\n                'SRKTwu_PinaMartinez': os.path.join(folder, 'SRKTwu_PinaMartinez.json'),\n                'PRVolumeTranslation_PinaMartinez': os.path.join(folder, 'PRVolumeTranslation_PinaMartinez.json'),\n                'SRKVolumeTranslation_PinaMartinez': os.path.join(folder, 'SRKVolumeTranslation_PinaMartinez.json'),\n                'PRTwu_ibell_2018': os.path.join(folder, 'PRTwu_ibell_2018.json'),\n\n                'chemsep_regular_solution': os.path.join(folder, 'chemsep_regular_solution.json'),\n                'chemsep_PSRK_matthias_copeman': os.path.join(folder, 'chemsep_PSRK_matthias_copeman.json'),\n                'chemsep_APISRK': os.path.join(folder, 'chemsep_APISRK.json'),\n                }\n\n\n    SPDB = ScalarParameterDB()\n    for name, file in sp_files.items():\n        SPDB.load_json(file, name)\n\n    _loaded_scalars = True\n\nif PY37:\n    def __getattr__(name):\n        if name in ('IPDB',):\n            load_all_interaction_parameters()\n            return globals()[name]\n        if name in ('SPDB',):\n            load_all_scalar_parameters()\n            return globals()[name]\n        raise AttributeError(f\"module {__name__} has no attribute {name}\")\nelse:\n    if can_load_data:\n        load_all_interaction_parameters()\n        load_all_scalar_parameters()\n",
    "thermo/phases/iapws_phase.py": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n'''\n\n__all__ = ['IAPWS95', 'IAPWS95Gas', 'IAPWS95Liquid', 'IAPWS97', 'IAPWS06']\n\nfrom cmath import log as logc\nfrom math import exp\n\nfrom chemicals import iapws\nfrom chemicals.interface import sigma_IAPWS\nfrom chemicals.thermal_conductivity import k_IAPWS\nfrom chemicals.utils import Vm_to_rho, rho_to_Vm\nfrom chemicals.viscosity import mu_IAPWS\nfrom fluids.numerics import secant\n\nfrom thermo.phases.gibbs_eos import GibbsEOS\nfrom thermo.phases.helmholtz_eos import HelmholtzEOS\nfrom thermo.phases.phase import Phase\n\n# from thermo.chemical_package import iapws_correlations\n\nclass IAPWS95(HelmholtzEOS):\n    model_name = 'iapws95'\n    _MW = iapws.iapws95_MW\n    Tc = iapws.iapws95_Tc\n    Pc = iapws.iapws95_Pc\n    rhoc_mass = iapws.iapws95_rhoc\n    rhoc_mass_inv = 1.0/rhoc_mass\n\n    Hfs = [-241822.0]\n    Sfs = [-44.5]\n    Gfs = [-228554.325]\n\n    N = 1\n    rhoc_inv = rho_to_Vm(rhoc_mass, _MW)\n    rhoc = 1.0/rhoc_inv\n\n    rho_red = rhoc\n    rho_red_inv = rhoc_inv\n\n    T_red = Tc\n    T_fixed_transport = 1.5*T_red\n\n    _MW_kg = _MW*1e-3\n    R = _MW_kg*iapws.iapws95_R # This is just the gas constant 8.314... but matching iapws to their decimals\n    R_inv = 1.0/R\n    R2 = R*R\n\n    #R = property_mass_to_molar(iapws95_R, iapws95_MW)\n    zs = [1.0]\n    cmps = [0]\n    # HeatCapacityGases = iapws_correlations.HeatCapacityGases\n\n    T_MAX_FLASH = T_MAX_FIXED = 5000.0\n    T_MIN_FLASH = T_MIN_FIXED = 243.0 # PU has flash failures at < 242 ish K\n\n    _d4Ar_ddelta2dtau2_func = staticmethod(iapws.iapws95_d4Ar_ddelta2dtau2)\n    _d3Ar_ddeltadtau2_func = staticmethod(iapws.iapws95_d3Ar_ddeltadtau2)\n    _d3Ar_ddelta2dtau_func = staticmethod(iapws.iapws95_d3Ar_ddelta2dtau)\n    _d2Ar_ddeltadtau_func = staticmethod(iapws.iapws95_d2Ar_ddeltadtau)\n    _d2Ar_dtau2_func = staticmethod(iapws.iapws95_d2Ar_dtau2)\n    _dAr_dtau_func = staticmethod(iapws.iapws95_dAr_dtau)\n    _d3Ar_ddelta3_func = staticmethod(iapws.iapws95_d3Ar_ddelta3)\n    _d2Ar_ddelta2_func = staticmethod(iapws.iapws95_d2Ar_ddelta2)\n    _dAr_ddelta_func = staticmethod(iapws.iapws95_dAr_ddelta)\n    _Ar_func = staticmethod(iapws.iapws95_Ar)\n\n\n    def __init__(self, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        self.tau = tau = self.Tc/T\n        self.delta = delta = rho_mass*self.rhoc_mass_inv\n        self.A0, self.dA0_dtau, self.d2A0_dtau2, self.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n\n    def to_TP_zs(self, T, P, zs):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.T = T\n        new.P = P\n        new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        new.tau = tau = new.Tc/T\n        new.delta = delta = rho_mass*new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None and P is not None:\n            new.T = T\n            new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n            new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n            new.P = P\n        elif T is not None and V is not None:\n            new.T = T\n            new._rho_mass = rho_mass = 1e-3*self._MW/V\n            P = iapws.iapws95_P(T, rho_mass)\n            new._V = V\n            new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws95_T(P, rho_mass)\n            new._V = V\n            new.P = P\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        new.P = P\n        new.T = T\n        new.tau = tau = new.Tc/T\n        new.delta = delta = rho_mass*new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n\n        return new\n\n\n    def mu(self):\n        r'''Calculate and return the viscosity of water according to the IAPWS.\n        For details, see :obj:`chemicals.viscosity.mu_IAPWS`.\n\n        Returns\n        -------\n        mu : float\n            Viscosity of water, [Pa*s]\n        '''\n        try:\n            return self._mu\n        except:\n            pass\n        self.__mu_k()\n        return self._mu\n\n    def k(self):\n        r'''Calculate and return the thermal conductivity of water according to the IAPWS.\n        For details, see :obj:`chemicals.thermal_conductivity.k_IAPWS`.\n\n        Returns\n        -------\n        k : float\n            Thermal conductivity of water, [W/m/K]\n        '''\n        try:\n            return self._k\n        except:\n            pass\n        self.__mu_k()\n        return self._k\n\n    def __mu_k(self):\n        drho_mass_dP = self.drho_mass_dP()\n\n        # TODO: curve fit drho_dP_Tr better than IAPWS did (mpmath)\n        drho_dP_Tr = self.to(T=self.T_fixed_transport, V=self._V, zs=self.zs).drho_mass_dP()\n        self._mu = mu_IAPWS(T=self.T, rho=self._rho_mass, drho_dP=drho_mass_dP,\n                        drho_dP_Tr=drho_dP_Tr)\n\n        self._k = k_IAPWS(T=self.T, rho=self._rho_mass, Cp=self.Cp_mass(), Cv=self.Cv_mass(),\n                       mu=self._mu, drho_dP=drho_mass_dP, drho_dP_Tr=drho_dP_Tr)\n\n\n\nclass IAPWS95Gas(IAPWS95):\n    is_gas = True\n    is_liquid = False\n    force_phase = 'g'\n\nclass IAPWS95Liquid(IAPWS95):\n    force_phase = 'l'\n    is_gas = False\n    is_liquid = True\n\n    def sigma(self):\n        try:\n            return self._sigma\n        except:\n            pass\n\n        self._sigma = sigma_IAPWS(self.T)\n        return self._sigma\n\nclass IAPWS97(Phase):\n    model_name = 'iapws97'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    R = 461.526\n    Tc = 647.096\n    Pc = 22.064E6\n    rhoc = 322.\n    zs = [1.0]\n    cmps = [0]\n    def mu(self):\n        return mu_IAPWS(T=self.T, rho=self._rho_mass)\n\n    def k(self):\n        # TODO add properties; even industrial formulation recommends them\n        return k_IAPWS(T=self.T, rho=self._rho_mass)\n\n    ### Region 1,2,5 Gibbs\n    def G(self):\n        try:\n            return self._G\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            G = iapws.iapws97_G_region1(tau, pi)\n        elif region == 2:\n            G = iapws.iapws97_Gr_region2(tau, pi) + iapws.iapws97_G0_region2(tau, pi)\n        elif region == 5:\n            G = iapws.iapws97_Gr_region5(tau, pi) + iapws.iapws97_G0_region5(tau, pi)\n        elif region == 4:\n            G = self.H() - self.T*self.S()\n        self._G = G\n        return G\n\n\n    def dG_dpi(self):\n        try:\n            return self._dG_dpi\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            dG_dpi = iapws.iapws97_dG_dpi_region1(tau, pi)\n        elif region == 2:\n            dG_dpi = 1.0/pi + iapws.iapws97_dGr_dpi_region2(tau, pi)\n        elif region == 5:\n            dG_dpi = 1.0/pi + iapws.iapws97_dGr_dpi_region5(tau, pi)\n        self._dG_dpi = dG_dpi\n        return dG_dpi\n\n    def d2G_d2pi(self):\n        try:\n            return self._d2G_d2pi\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            d2G_d2pi = iapws.iapws97_d2G_dpi2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2pi = -1.0/(pi*pi) + iapws.iapws97_d2Gr_dpi2_region2(tau, pi)\n        elif region == 5:\n            d2G_d2pi = -1.0/(pi*pi) + iapws.iapws97_d2Gr_dpi2_region5(tau, pi)\n        self._d2G_d2pi = d2G_d2pi\n        return d2G_d2pi\n\n    def dG_dtau(self):\n        try:\n            return self._dG_dtau\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            dG_dtau = iapws.iapws97_dG_dtau_region1(tau, pi)\n        elif region == 2:\n            dG_dtau = iapws.iapws97_dG0_dtau_region2(tau, pi) + iapws.iapws97_dGr_dtau_region2(tau, pi)\n        elif region == 5:\n            dG_dtau = iapws.iapws97_dG0_dtau_region5(tau, pi) + iapws.iapws97_dGr_dtau_region5(tau, pi)\n        self._dG_dtau = dG_dtau\n        return dG_dtau\n\n    def d2G_d2tau(self):\n        try:\n            return self._d2G_d2tau\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            d2G_d2tau = iapws.iapws97_d2G_dtau2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2tau = (iapws.iapws97_d2Gr_dtau2_region2(tau, pi)\n                         + iapws.iapws97_d2G0_dtau2_region2(tau, pi))\n        elif region == 5:\n            d2G_d2tau = (iapws.iapws97_d2Gr_dtau2_region5(tau, pi)\n                         + iapws.iapws97_d2G0_dtau2_region5(tau, pi))\n        self._d2G_d2tau = d2G_d2tau\n        return d2G_d2tau\n\n    def d2G_dpidtau(self):\n        try:\n            return self._d2G_dpidtau\n        except:\n            pass\n        tau, pi, region = self.tau, self.pi, self.region\n        if region == 1:\n            d2G_dpidtau = iapws.iapws97_d2G_dpidtau_region1(tau, pi)\n        elif region == 2:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region2(tau, pi)\n        elif region == 5:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region5(tau, pi)\n        self._d2G_dpidtau = d2G_dpidtau\n        return d2G_dpidtau\n\n\n    ### Region 3 Helmholtz\n    def A_region3(self):\n        try:\n            return self._A_region3\n        except:\n            pass\n        self._A_region3 = A_region3 = iapws.iapws97_A_region3_region3(self.tau, self.delta)\n        return A_region3\n\n    def dA_ddelta(self):\n        try:\n            return self._dA_ddelta\n        except:\n            pass\n        self._dA_ddelta = dA_ddelta = iapws.iapws97_dA_ddelta_region3(self.tau, self.delta)\n        return dA_ddelta\n\n    def d2A_d2delta(self):\n        try:\n            return self._d2A_d2delta\n        except:\n            pass\n        self._d2A_d2delta = d2A_d2delta = iapws.iapws97_d2A_d2delta_region3(self.tau, self.delta)\n        return d2A_d2delta\n\n    def dA_dtau(self):\n        try:\n            return self._dA_dtau\n        except:\n            pass\n        self._dA_dtau = dA_dtau = iapws.iapws97_dA_dtau_region3(self.tau, self.delta)\n        return dA_dtau\n\n    def d2A_d2tau(self):\n        try:\n            return self._d2A_d2tau\n        except:\n            pass\n        self._d2A_d2tau = d2A_d2tau = iapws.iapws97_d2A_d2tau_region3(self.tau, self.delta)\n        return d2A_d2tau\n\n    def d2A_ddeltadtau(self):\n        try:\n            return self._d2A_ddeltadtau\n        except:\n            pass\n        self._d2A_ddeltadtau = d2A_ddeltadtau = iapws.iapws97_d2A_ddeltadtau_region3(self.tau, self.delta)\n        return d2A_ddeltadtau\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P*6.049606775559589e-08 #1/16.53E6\n            self.tau = 1386.0/T\n            self.Pref = 16.53E6\n            self.Tref = 1386.0\n        elif region == 2:\n            self.pi = P*1e-6\n            self.tau = 540.0/T\n            self.Pref = 1e6\n            self.Tref = 540.0\n        elif region == 3:\n            self.tau = self.Tc/T\n            self.Tref = self.Tc\n            self.delta = self._rho_mass*0.003105590062111801 # 1/322.0\n            self.rhoref = 322.0\n        elif region == 5:\n            self.pi = P*1e-6\n            self.tau = 1000.0/T\n            self.Tref = 1000.0\n            self.Pref = 1e6\n\n\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P*6.049606775559589e-08 #1/16.53E6\n            self.tau = 1386.0/T\n        elif region == 2:\n            self.pi = P*1e-6\n            self.tau = 540.0/T\n        elif region == 3:\n            self.tau = self.Tc/T\n            self.delta = self._rho_mass*0.003105590062111801 # 1/322.0\n        elif region == 5:\n            self.pi = P*1e-6\n            self.tau = 1000.0/T\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new._rho_mass = rho_mass = iapws.iapws97_rho(T, P)\n                new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n                new.P = P\n            elif V is not None:\n                new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n                P = iapws.iapws97_P(T, rho_mass)\n                new.V = V\n                new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws97_T(P, rho_mass)\n            new.V = V\n            new.P = P\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        new.region = region = iapws.iapws97_identify_region_TP(new.T, new.P)\n        if region == 1:\n            new.pi = P*6.049606775559589e-08 #1/16.53E6\n            new.tau = 1386.0/T\n            new.Pref = 16.53E6\n            new.Tref = 1386.0\n        elif region == 2:\n            new.pi = P*1e-6\n            new.tau = 540.0/T\n            new.Pref = 1e6\n            new.Tref = 540.0\n        elif region == 3:\n            new.tau = new.Tc/T\n            new.Tref = new.Tc\n            new.delta = new._rho_mass*0.003105590062111801 # 1/322.0\n            new.rhoref = 322.0\n        elif region == 5:\n            new.pi = P*1e-6\n            new.tau = 1000.0/T\n            new.Tref = 1000.0\n            new.Pref = 1e6\n\n        new.P = P\n        new.T = T\n\n        return new\n\n    def V(self):\n        return self._V\n\n    def U(self):\n        try:\n            return self._U\n        except:\n            pass\n\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            U = self.R*self.T(*self.tau*dG_dtau - self.pi*dG_dpi)\n        self._U = U\n        return U\n\n    def S(self):\n        try:\n            return self._S\n        except:\n            pass\n        if self.region != 3:\n            try:\n                G = self._G\n            except:\n                G = self.G()\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            S = self.R*(self.tau*dG_dtau - G)\n        self._S = S\n        return S\n\n    def H(self):\n        try:\n            return self._H\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            H = self.R*self.T*self.tau*dG_dtau\n        self._H = H\n        return H\n\n    def Cv(self):\n        try:\n            return self._Cv\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2tau = self._d2G_d2tau\n            except:\n                d2G_d2tau = self.d2G_d2tau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n\n            tau = self.tau\n            x0 = (dG_dpi - tau*d2G_dpidtau)\n            Cv = self.R*(-tau*tau*d2G_d2tau + x0*x0/d2G_d2pi)\n\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except:\n            pass\n\n        if self.region == 3:\n            tau, delta = self.tau, self.delta # attributes set on init\n            try:\n                dA_ddelta = self._dA_ddelta\n            except:\n                dA_ddelta = self.dA_ddelta()\n            try:\n                d2A_ddeltadtau = self._d2A_ddeltadtau\n            except:\n                d2A_ddeltadtau = self.d2A_ddeltadtau()\n            try:\n                d2A_d2delta = self._d2A_d2delta\n            except:\n                d2A_d2delta = self.d2A_d2delta()\n            try:\n                d2A_d2tau = self._d2A_d2tau\n            except:\n                d2A_d2tau = self.d2A_d2tau()\n\n            x0 = (delta*dA_ddelta - delta*tau*d2A_ddeltadtau)\n            Cp = self.R*(-tau*tau*d2A_d2tau + x0*x0/(delta*(2.0*dA_ddelta + delta*d2A_d2delta)))\n\n#        self.Cp = (-self.tau**2*self.ddA_ddtau + (self.delta*self.dA_ddelta - self.delta*self.tau*self.ddA_ddelta_dtau)**2\\\n#                  /(2*self.delta*self.dA_ddelta + self.delta**2*self.ddA_dddelta))*R\n\n        else:\n            tau = self.tau\n            Cp = -self.R*tau*tau*self.d2G_d2tau()\n        Cp *= self._MW*1e-3\n        self._Cp = Cp\n        return Cp\n\n    dH_dT = dH_dT_P = Cp\n\n    ### Derivatives\n    def dV_dP(self):\n        '''\n        from sympy import *\n        R, T, MW, P, Pref, Tref = symbols('R, T, MW, P, Pref, Tref')\n        dG_dpif = symbols('dG_dpi', cls=Function)\n        pi = P/Pref\n        tau = Tref/T\n        dG_dpi = dG_dpif(tau, pi)\n        V = (R*T*pi*dG_dpi*MW)/(1000*P)\n        print(diff(V, P))\n\n        MW*R*T*Subs(Derivative(dG_dpi(Tref/T, _xi_2), _xi_2), _xi_2, P/Pref)/(1000*Pref**2)\n        '''\n        try:\n            return self._dV_dP\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n            dV_dP = self._MW*self.R*self.T*d2G_d2pi/(1000.0*self.Pref*self.Pref)\n\n        self._dV_dP = dV_dP\n        return dV_dP\n\n    def dV_dT(self):\n        # similar to dV_dP\n        try:\n            return self._dV_dT\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n\n\n            dV_dT = (self._MW*self.R*dG_dpi/(1000*self.Pref)\n            - self._MW*self.R*self.Tref*d2G_dpidtau/(1000*self.Pref*self.T))\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except:\n            pass\n        if self.region != 3:\n            dP_dT = -self.dV_dT()/self.dV_dP()\n        self._dP_dT = dP_dT\n        return dP_dT\n\n    def dP_dV(self):\n        return 1.0/self.dV_dP()\n\n\nclass IAPWS06(GibbsEOS):\n    T_MAX_FLASH = T_MAX_FIXED = 273.16 # Above this ice does not form\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n\n    model_name = 'iapws06'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    zs = [1.0]\n    cmps = [0]\n    R06 = iapws.iapws95_R\n    R06_inv = 1.0/R06\n\n    _MW_kg = _MW*1e-3\n    R = _MW_kg*iapws.iapws95_R # This is just the gas constant 8.314... but matching iapws to their decimals\n    R_inv = 1.0/R\n    R2 = R*R\n\n    Tt = 273.16\n    Tt_inv = 1.0/Tt\n    p0 = 101325.\n    pt = 611.657\n    pt_inv = 1.0/pt\n    pi0 = p0/pt\n\n    g0n = [-0.632020233335886E6, 0.655022213658955, -0.189369929326131E-7,\n        0.339746123271053E-14, -0.556464869058991E-21]\n    g0n_rev = g0n[::-1]\n\n    s0 = -0.332733756492168E4 # IAPWS value not \"absolute\"\n    t1 = 0.368017112855051E-1 + 0.510878114959572E-1j\n    r1 = 0.447050716285388E2 + 0.656876847463481E2j\n    t2 = 0.337315741065416 + 0.335449415919309j\n    r2n = [-0.725974574329220E2 - 0.781008427112870E2j,\n        -0.557107698030123E-4 + 0.464578634580806E-4j,\n        0.234801409215913E-10 - 0.285651142904972E-10j]\n    r2n_rev = r2n[::-1]\n    r2np_rev = [(7.677551608692879e-14-9.340239477516712e-14j),\n                (-9.108171704568459e-08+7.595411065038183e-08j)]\n\n    g0p_coeffs = [-3.6390648292032365e-24, 1.666356094695489e-17, -6.192030151739651e-11, 0.0010708979275295713]\n    g0pp_coeffs = [-1.7848556441943294e-26, 5.44866189611331e-20, -1.0123370045204503e-13]\n\n    r2pp = r2n[2]*2.0/(pt*pt) # (1.2552053861384531e-16-1.5270387615144944e-16j)\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._set_core()\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new._set_core()\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new.P = P\n                new._set_core()\n            elif V is not None:\n                def V_err(P):\n                    new.P = P\n                    new._set_core()\n                    return new._V - V\n                P = secant(V_err, 1e5, xtol=1e-12, bisection=True)\n                new.P = P\n                new._set_core()\n        elif P is not None and V is not None:\n            new.P = P\n            def V_err(T):\n                new.T = T\n                new._set_core()\n                return new._V - V\n            T = secant(V_err, 250.0, xtol=1e-12, bisection=True)\n            new.T = T\n            new._set_core()\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        new.P = P\n        new.T = T\n        return new\n\n\n    def _set_core(self):\n        T, P = self.T, self.P\n        self.tau = T*self.Tt_inv\n        self.pi = P*self.pt_inv\n\n        pi, tau = self.pi, self.tau # for convenience\n        R06_inv = self.R06_inv\n        t1, t2, pi0 = self.t1, self.t2, self.pi0\n        s0, Tt, r1 = self.s0, self.Tt, self.r1\n\n\n\n        tau2 = tau*tau\n        v0 = pi - pi0\n        r2 = (v0*(v0*(2.34801409215913e-11 - 2.85651142904972e-11j)\n                     + (-5.57107698030123e-5 + 4.64578634580806e-5j))\n                     + (-72.597457432922 - 78.100842711287j))\n\n        r2p = (v0*(7.677551608692879e-14-9.340239477516712e-14j)\n               + (-9.108171704568459e-08+7.595411065038183e-08j))\n        g0 = (v0*(v0*(v0*(-5.56464869058991e-22*v0 + 3.39746123271053e-15)\n               - 1.89369929326131e-8) + 0.655022213658955) - 632020.233335886)\n        g0p = (v0*(v0*(-3.6390648292032365e-24*v0 + 1.666356094695489e-17)\n                - 6.192030151739651e-11) + 0.0010708979275295713)\n        g0pp = ((-1.7848556441943294e-26*v0 + 5.44866189611331e-20)*v0\n                - 1.0123370045204503e-13)\n\n\n        log_t1_tau = logc(t1 + tau)\n        log_t1_n_tau = logc(t1 - tau)\n        log_t2_tau = logc(t2 + tau)\n        log_t2_n_tau = logc(t2 - tau)\n\n        log_t1 = logc(t1)\n        log_t2 = logc(t2)\n\n        t2_inv = 1.0/t2\n        t1_inv = 1.0/t1\n\n        tau_t2inv = tau*t2_inv\n        t2_log_t2 = t2*log_t2\n        t2_log_t2_2 = t2_log_t2 + t2_log_t2\n\n        g_real_sum = (r1*((t1-tau)*log_t1_n_tau + (t1+tau)*log_t1_tau - 2.0*t1*log_t1 - tau2*t1_inv)\n                   + (r2*((t2-tau)*log_t2_n_tau + (t2+tau)*log_t2_tau - t2_log_t2_2 - tau2*t2_inv))).real\n        g = g0 - s0*Tt*tau + Tt*g_real_sum\n\n\n        g_T_real_sum = (r1*(-log_t1_n_tau + log_t1_tau - 2.0*tau*t1_inv) + r2*( -log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_T = -s0 + g_T_real_sum\n\n        g_TT_real_sum = (r1*(1./(t1-tau) + 1./(t1+tau) - t1_inv - t1_inv)\n                       + r2*(1./(t2-tau) + 1./(t2+tau) - t2_inv - t2_inv)).real\n        g_TT = 0.0036608581051398447*g_TT_real_sum #1.0/Tt*g_TT_real_sum\n\n        x0 = (t2-tau)*log_t2_n_tau + (t2+tau)*log_t2_tau - t2_log_t2_2 - tau2*t2_inv\n\n        g_P_real_sum = (r2p*(x0)).real\n        g_P = g0p + Tt*g_P_real_sum\n        g_PP_real_sum = (self.r2pp*(x0)).real\n        g_PP = g0pp + Tt*g_PP_real_sum\n\n        g_TP_real_sum = (r2p*(-log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_TP = g_TP_real_sum\n\n\n\n        self._rho_mass = rho_mass = 1.0/g_P\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n\n        # self.g0, self.g0p, self.g0pp, self.r2, self.r2p = g0, g0p, g0pp, r2, r2p\n\n        fact = self._MW_kg\n\n        self._G = g*fact\n        self._dG_dT = g_T*fact\n        self._d2G_dT2 = g_TT*fact\n        self._dG_dP = g_P*fact\n        self._d2G_dP2 = g_PP*fact\n        self._d2G_dTdP = g_TP*fact\n\n    def G(self):\n        return self._G\n\n    def dG_dT(self):\n        return self._dG_dT\n\n    def d2G_dT2(self):\n        return self._d2G_dT2\n\n    def dG_dP(self):\n        return self._dG_dP\n\n    def d2G_dP2(self):\n        return self._d2G_dP2\n\n    def d2G_dTdP(self):\n        return self._d2G_dTdP\n\n    d2G_dPdT = d2G_dTdP\n\n    def P_sub(self):\n        return iapws.iapws11_Psub(self.T)\n\n    def vapor_fugacity_coefficient(self):\n        # model does not allow for extrapolation to 1 K so cannot be used\n        # marginal impact to accuracy because of the low pressure\n        # if experimental sublimation pressure does not incorporate this factor,\n        # this factor should be set to 1 anyway!\n        return 1.0\n\n    def fugacities(self):\n        P_sub = self.P_sub()\n        phi = self.vapor_fugacity_coefficient()\n        # Correct with Poynting factor\n        # Gibbs can be used if consistent byt can be very challenging and it requires an offset\n        # Gibbs which is hard to extrapolate\n        # If it is consistent, the equation is phi*P_sub*exp(((self.G()-G_ideal_gas)/self.R/self.T))\n        fugacity = phi*P_sub*exp(self.V()/(self.R*self.T)*(self.P -  P_sub))\n        return [fugacity]\n",
    "thermo/phases/gibbs_excess.py": "'''Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n'''\n__all__ = ['GibbsExcessLiquid', 'GibbsExcessSolid']\n\nfrom math import isinf, isnan\n\nfrom chemicals.solubility import Henry_constants, d2Henry_constants_dT2, dHenry_constants_dT\nfrom chemicals.utils import phase_identification_parameter\nfrom fluids.constants import R, R_inv\nfrom fluids.numerics import derivative, evaluate_linear_fits, evaluate_linear_fits_d, evaluate_linear_fits_d2, exp, horner_and_der2, log, secant, trunc_exp\nfrom fluids.numerics import numpy as np\n\nfrom thermo.activity import IdealSolution\nfrom thermo.heat_capacity import HeatCapacityGas, HeatCapacityLiquid\nfrom thermo.nrtl import nrtl_d2taus_dT2 as d2ln_henries_dT2\nfrom thermo.nrtl import nrtl_dtaus_dT as dln_henries_dT\nfrom thermo.nrtl import nrtl_taus as ln_henries\nfrom thermo.phase_change import EnthalpySublimation, EnthalpyVaporization\nfrom thermo.phases.phase import Phase\nfrom thermo.utils import POLY_FIT, TRANSFORM_SECOND_DERIVATIVE_RATIO, TRANSFORM_SECOND_LOG_DERIVATIVE, TRANSFORM_DERIVATIVE_RATIO, TRANSFORM_LOG_DERIVATIVE, TRANSFORM_LOG\nfrom thermo.vapor_pressure import SublimationPressure, VaporPressure\nfrom thermo.volume import VolumeLiquid, VolumeSolid\n\ntry:\n    zeros, array = np.zeros, np.array\nexcept:\n    pass\n\nclass GibbsExcessLiquid(Phase):\n    r'''Phase based on combining Raoult's law with a\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model, optionally\n    including saturation fugacity coefficient corrections (if the vapor phase\n    is a cubic equation of state) and Poynting correction factors (if more\n    accuracy is desired).\n\n    The equilibrium equation options (controlled by `equilibrium_basis`)\n    are as follows:\n\n    * 'Psat': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat}}{P}`\n    * 'Poynting&PhiSat': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat} \\phi_i^{sat} \\text{Poynting}_i}{P}`\n    * 'Poynting': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat}\\text{Poynting}_i}{P}`\n    * 'PhiSat': :math:`\\phi_i = \\frac{\\gamma_i P_{i}^{sat} \\phi_i^{sat}}{P}`\n\n    In all cases, the activity coefficient is derived from the\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model specified as\n    input; use the :obj:`IdealSolution <thermo.activity.IdealSolution>`\n    class as an input to set the activity coefficients to one.\n\n    The enthalpy `H` and entropy `S` (and other caloric properties `U`, `G`, `A`)\n    equation options are similar to the equilibrium ones. If the same option\n    is selected for `equilibrium_basis` and `caloric_basis`, the phase will be\n    `thermodynamically consistent`. This is recommended for many reasons.\n    The full 'Poynting&PhiSat' equations for `H` and `S` are as follows; see\n    :obj:`GibbsExcessLiquid.H` and :obj:`GibbsExcessLiquid.S` for all of the\n    other equations:\n\n    .. math::\n        H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n        \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n        + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n        + \\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}} \\right)\n        + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n    .. math::\n        S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n        - \\sum_i z_i\\left[R\\left(\n        T \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n        + T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n        + T\\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}}\n        + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\text{Poynting}\\cdot\\phi_{\\text{sat},i}}{P}\\right)\n        \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n    An additional caloric mode is `Hvap`, which uses enthalpy of vaporization;\n    this mode can never be thermodynamically consistent, but is still widely\n    used.\n\n    .. math::\n        H = H_{\\text{excess}} + \\sum_i z_i\\left[-H_{vap,i}\n        + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n    .. math::\n        S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n        - \\sum_i z_i\\left[R\\left(\\ln P_{\\text{sat},i} + \\ln\\left(\\frac{1}{P}\\right)\\right)\n        + \\frac{H_{vap,i}}{T}\n        - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n\n    .. warning::\n        Note that above the critical point, there is no definition for what vapor\n        pressure is. The vapor pressure also tends to reach zero at temperatures\n        in the 4-20 K range. These aspects mean extrapolation in the supercritical and\n        very low temperature region is critical to ensure the equations will still\n        converge. Extrapolation can be performed using either the equation\n        :math:`P^{\\text{sat}} = \\exp\\left(A - \\frac{B}{T}\\right)` or\n        :math:`P^{\\text{sat}} = \\exp\\left(A + \\frac{B}{T} + C\\cdot \\ln T\\right)` by\n        setting `Psat_extrpolation` to either 'AB' or 'ABC' respectively.\n        The extremely low temperature region's issue is solved by calculating the\n        logarithm of vapor pressures instead of the actual value. While floating\n        point values in Python (doubles) can reach a minimum value of around\n        1e-308, if only the logarithm of that number is computed no issues arise.\n        Both of these features only work when the vapor pressure correlations are\n        polynomials.\n\n    .. warning::\n        When using 'PhiSat' as an option, note that the factor cannot be\n        calculated when a compound is supercritical,\n        as there is no longer any vapor-liquid pure-component equilibrium\n        (by definition).\n\n    Parameters\n    ----------\n    VaporPressures : list[:obj:`thermo.vapor_pressure.VaporPressure`]\n        Objects holding vapor pressure data and methods, [-]\n    VolumeLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods; required for Poynting\n        factors and volumetric properties, [-]\n    HeatCapacityGases : list[:obj:`thermo.heat_capacity.HeatCapacityGas`], optional\n        Objects proiding pure-component heat capacity correlations; required\n        for caloric properties, [-]\n    GibbsExcessModel : :obj:`GibbsExcess <thermo.activity.GibbsExcess>`, optional\n        Configured instance for calculating activity coefficients and excess properties;\n        set to :obj:`IdealSolution <thermo.activity.IdealSolution>` if not provided, [-]\n    eos_pure_instances : list[:obj:`thermo.eos.GCEOS`], optional\n        Cubic equation of state object instances for each pure component, [-]\n    EnthalpyVaporizations : list[:obj:`thermo.phase_change.EnthalpyVaporization`], optional\n        Objects holding enthalpy of vaporization data and methods; used only\n        with the 'Hvap' optional, [-]\n    HeatCapacityLiquids : list[:obj:`thermo.heat_capacity.HeatCapacityLiquid`], optional\n        Objects holding liquid heat capacity data and methods; not used at\n        present, [-]\n    VolumeSupercriticalLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods but that are used for\n        supercritical temperatures on a per-component basis only; required for\n        Poynting factors and volumetric properties at supercritical conditions;\n        `VolumeLiquids` is used if not provided, [-]\n    Hfs : list[float], optional\n        Molar ideal-gas standard heats of formation at 298.15 K and 1 atm,\n        [J/mol]\n    Gfs : list[float], optional\n        Molar ideal-gas standard Gibbs energies of formation at 298.15 K and\n        1 atm, [J/mol]\n    T : float, optional\n        Temperature, [K]\n    P : float, optional\n        Pressure, [Pa]\n    zs : list[float], optional\n        Mole fractions of each component, [-]\n    equilibrium_basis : str, optional\n        Which set of equilibrium equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', [-]\n    caloric_basis : str, optional\n        Which set of caloric equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', 'Hvap' [-]\n    Psat_extrpolation : str, optional\n        One of 'AB' or 'ABC'; configures extrapolation for vapor pressure, [-]\n    henry_abcdef : tuple[list[list[float]], 6], optional\n        Contains the parameters used for henry's law constant, [-]\n    henry_as : list[list[float]], optional\n        `a` parameters used in calculating henry's law constant, [-]\n    henry_bs : list[list[float]], optional\n        `b` parameters used in calculating henry's law constant, [K]\n    henry_cs : list[list[float]], optional\n        `c` parameters used in calculating henry's law constant, [-]\n    henry_ds : list[list[float]], optional\n        `d` paraemeters used in calculating henry's law constant, [1/K]\n    henry_es : list[list[float]], optional\n        `e` parameters used in calculating henry's law constant, [K^2]\n    henry_fs : list[list[float]], optional\n        `f` parameters used in calculating henry's law constant, [1/K^2]\n    henry_mode : str\n        The setting for henry's law. 'solvents' to consider all\n        components set not to be henry's law components a solvent (if\n        any parameters are missing this will not make sense at all);\n        'solvents_with_parameters' to consider only the solvents with\n        parameters (vapor pressures will be used if a component has\n        no solvents whatsoever)\n\n    use_Hvap_caloric : bool, optional\n        If True, enthalpy and entropy will be calculated using ideal-gas\n        heat capacity and the heat of vaporization of the fluid only. This\n        forces enthalpy to be pressure-independent. This supersedes other\n        options which would otherwise impact these properties. The molar volume\n        of the fluid has no impact on enthalpy or entropy if this option is\n        True. This option is not thermodynamically consistent, but is still\n        often an assumption that is made.\n\n    '''\n\n    PIP_INCALCULABLE_VALUE = 2\n    force_phase = 'l'\n    phase = 'l'\n    is_gas = False\n    is_liquid = True\n    P_DEPENDENT_H_LIQ = True\n    PHI_SAT_IDEAL_TR = 0.1\n    _Psats_data = None\n    _Vms_sat_data = None\n    _Hvap_data = None\n\n    use_IG_Cp = True # Deprecated! Remove with S_old and H_old\n\n    ideal_gas_basis = True\n    supercritical_volumes = False\n\n    Cpls_poly_fit = False\n    _Cpls_data = None\n\n    _Tait_B_data = None\n    _Tait_C_data = None\n\n    pure_references = ('HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids',\n                       'EnthalpyVaporizations')\n    pure_reference_types = (HeatCapacityGas, VolumeLiquid, VaporPressure, HeatCapacityLiquid,\n                            EnthalpyVaporization)\n\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel',\n                        'eos_pure_instances', 'use_Poynting', 'use_phis_sat',\n                        'use_Tait', 'use_eos_volume', 'henry_components',\n                        'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs','henry_mode',\n                        'Psat_extrpolation') + pure_references\n\n    obj_references = ('GibbsExcessModel', 'eos_pure_instances', 'result', 'constants', 'correlations',\n                        'HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids',\n                                        'EnthalpyVaporizations')\n\n\n    # Not sure how this will progress\n    __slots__ = ('VaporPressures', 'Psats_poly_fit', 'Psat_extrpolation', 'N', 'HeatCapacityGases', 'Cpgs_poly_fit',\n     '_Cpgs_data', 'HeatCapacityLiquids', 'use_eos_volume', 'VolumeLiquids', 'Vms_sat_poly_fit', 'VolumeSupercriticalLiquids',\n      'Vms_supercritical_poly_fit', 'incompressible', 'use_Tait', 'EnthalpyVaporizations', 'Hvap_poly_fit', 'GibbsExcessModel',\n       'eos_pure_instances', 'equilibrium_basis', 'caloric_basis', 'use_phis_sat', 'use_Poynting', 'use_phis_sat_caloric',\n        'use_Poynting_caloric', 'use_Hvap_caloric', 'has_henry_components', 'henry_components',\n        'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs','henry_mode',\n         'composition_independent',\n        'Hfs', 'Gfs', 'Sfs', 'model_id', 'T', 'P', 'zs', '_model_hash_ignore_phase', '_model_hash')\n\n    def __repr__(self):\n        r'''Method to create a string representation of the phase object, with\n        the goal of making it easy to obtain standalone code which reproduces\n        the current state of the phase. This is extremely helpful in creating\n        new test cases.\n\n        Returns\n        -------\n        recreation : str\n            String which is valid Python and recreates the current state of\n            the object if ran, [-]\n\n        '''\n        pure_strs = ''\n        for k in self.pure_references:\n            v = getattr(self, k)\n            if v is not None:\n                try:\n                    s = '[' + ', '.join(str(o) for o in v) + ']'\n                except:\n                    continue\n                pure_strs += f'{k}={s}, '\n\n\n        base = f\"\"\"{self.__class__.__name__}(GibbsExcessModel={self.GibbsExcessModel},\n               equilibrium_basis={self.equilibrium_basis}, caloric_basis={self.caloric_basis},\n               eos_pure_instances={self.eos_pure_instances}, {pure_strs}\"\"\"\n        for s in ('Hfs', 'Gfs', 'Sfs', 'T', 'P', 'zs'):\n            if hasattr(self, s) and getattr(self, s) is not None:\n                base += f'{s}={getattr(self, s)}, '\n        if base[-2:] == ', ':\n            base = base[:-2]\n        base += ')'\n        return base\n\n\n    def __init__(self, VaporPressures, VolumeLiquids=None,\n                 HeatCapacityGases=None,\n                 GibbsExcessModel=None,\n                 eos_pure_instances=None,\n                 EnthalpyVaporizations=None,\n                 HeatCapacityLiquids=None,\n                 VolumeSupercriticalLiquids=None,\n\n                 use_Hvap_caloric=False,\n                 use_Poynting=False,\n                 use_phis_sat=False,\n                 use_Tait=False,\n                 use_eos_volume=False,\n\n                 Hfs=None, Gfs=None, Sfs=None,\n\n                 henry_components=None,\n                 henry_abcdef=None,\n                 henry_as=None, henry_bs=None,\n                 henry_cs=None, henry_ds=None,\n                 henry_es=None, henry_fs=None,\n                 henry_mode='solvents_with_parameters',\n\n                 T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None,\n                 Psat_extrpolation='AB',\n                 equilibrium_basis=None,\n                 caloric_basis=None,\n                 ):\n        '''It is quite possible to introduce a PVT relation ship for liquid\n        density and remain thermodynamically consistent. However, must be\n        applied on a per-component basis! This class cannot have an\n        equation-of-state or VolumeLiquidMixture for a liquid MIXTURE!\n\n        (it might still be nice to generalize the handling; maybe even allow)\n        pure EOSs to be used too, and as a form/template for which functions to\n        use).\n\n        In conclusion, you have\n        1) The standard H/S model\n        2) The H/S model with all pressure correction happening at P\n        3) The inconsistent model which has no pressure dependence whatsover in H/S\n           This model is required due to its popularity, not its consistency (but still volume dependency)\n\n        All mixture volumetric properties have to be averages of the pure\n        components properties and derivatives. A Multiphase will be needed to\n        allow flashes with different properties from different phases.\n        '''\n        self.N = N = len(VaporPressures)\n        if zs is None:\n            zs = [1.0/N]*N\n        if henry_components is None:\n            henry_components = [False]*self.N\n        self.has_henry_components = any(henry_components)\n        self.henry_components = henry_components\n\n        self.VaporPressures = VaporPressures\n        self.Psats_poly_fit = (all(i.method == POLY_FIT for i in VaporPressures) and not self.has_henry_components) if VaporPressures is not None else False\n        self.Psat_extrpolation = Psat_extrpolation\n        if self.Psats_poly_fit:\n            Psats_data = [[i.poly_fit_Tmin for i in VaporPressures],\n                               [i.poly_fit_Tmin_slope for i in VaporPressures],\n                               [i.poly_fit_Tmin_value for i in VaporPressures],\n                               [i.poly_fit_Tmax for i in VaporPressures],\n                               [i.poly_fit_Tmax_slope for i in VaporPressures],\n                               [i.poly_fit_Tmax_value for i in VaporPressures],\n                               [i.poly_fit_coeffs for i in VaporPressures],\n                               [i.poly_fit_d_coeffs for i in VaporPressures],\n                               [i.poly_fit_d2_coeffs for i in VaporPressures],\n                               [i.DIPPR101_ABC for i in VaporPressures]]\n            if Psat_extrpolation == 'AB':\n                Psats_data.append([i.poly_fit_AB_high_ABC_compat + [0.0] for i in VaporPressures])\n            elif Psat_extrpolation == 'ABC':\n                Psats_data.append([i.DIPPR101_ABC_high for i in VaporPressures])\n            # Other option: raise?\n            self._Psats_data = Psats_data\n\n\n        if self.vectorized:\n            zero_coeffs = zeros((N, N))\n        else:\n            zero_coeffs = [[0.0]*N for _ in range(N)]\n\n        self.HeatCapacityGases = HeatCapacityGases\n        self.Cpgs_poly_fit, self._Cpgs_data = self._setup_Cpigs(HeatCapacityGases)\n\n        self.HeatCapacityLiquids = HeatCapacityLiquids\n        if HeatCapacityLiquids is not None:\n            self.Cpls_poly_fit, self._Cpls_data = self._setup_Cpigs(HeatCapacityLiquids)\n            T_REF_IG = self.T_REF_IG\n            T_REF_IG_INV = 1.0/T_REF_IG\n            self.Hvaps_T_ref = [obj(T_REF_IG) for obj in EnthalpyVaporizations]\n            self.dSvaps_T_ref = [T_REF_IG_INV*dH for dH in self.Hvaps_T_ref]\n\n        self.use_eos_volume = use_eos_volume\n        self.VolumeLiquids = VolumeLiquids\n        self.Vms_sat_poly_fit = ((not use_eos_volume and all(i.method == POLY_FIT for i in VolumeLiquids)) if VolumeLiquids is not None else False)\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_data = [[i.poly_fit_Tmin for i in VolumeLiquids],\n                                 [i.poly_fit_Tmin_slope for i in VolumeLiquids],\n                                 [i.poly_fit_Tmin_value for i in VolumeLiquids],\n                                 [i.poly_fit_Tmax for i in VolumeLiquids],\n                                 [i.poly_fit_Tmax_slope for i in VolumeLiquids],\n                                 [i.poly_fit_Tmax_value for i in VolumeLiquids],\n                                 [i.poly_fit_coeffs for i in VolumeLiquids],\n                                 [i.poly_fit_d_coeffs for i in VolumeLiquids],\n                                 [i.poly_fit_d2_coeffs for i in VolumeLiquids],\n                                 [i.poly_fit_Tmin_quadratic for i in VolumeLiquids],\n                                 ]\n#            low_fits = self._Vms_sat_data[9]\n#            for i in range(self.N):\n#                low_fits[i][0] = max(0, low_fits[i][0])\n\n        self.VolumeSupercriticalLiquids = VolumeSupercriticalLiquids\n        self.Vms_supercritical_poly_fit = all(i.method == POLY_FIT for i in VolumeSupercriticalLiquids) if VolumeSupercriticalLiquids is not None else False\n        if self.Vms_supercritical_poly_fit:\n            self.Vms_supercritical_data = [[i.poly_fit_Tmin for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmin_slope for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmin_value for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmax for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmax_slope for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmax_value for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_coeffs for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_d_coeffs for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_d2_coeffs for i in VolumeSupercriticalLiquids],\n                                 [i.poly_fit_Tmin_quadratic for i in VolumeSupercriticalLiquids],\n                                 ]\n\n\n        self.incompressible = not use_Tait\n        self.use_Tait = use_Tait\n        if self.use_Tait:\n            Tait_B_data, Tait_C_data = [[] for i in range(9)], [[] for i in range(9)]\n            for v in VolumeLiquids:\n                for (d, store) in zip(v.Tait_data(), [Tait_B_data, Tait_C_data]):\n                    for i in range(len(d)):\n                        store[i].append(d[i])\n            self._Tait_B_data = Tait_B_data\n            self._Tait_C_data = Tait_C_data\n\n\n        self.EnthalpyVaporizations = EnthalpyVaporizations\n        self.Hvap_poly_fit = all(i.method == POLY_FIT for i in EnthalpyVaporizations) if EnthalpyVaporizations is not None else False\n        if self.Hvap_poly_fit:\n            self._Hvap_data = [[i.poly_fit_Tmin for i in EnthalpyVaporizations],\n                              [i.poly_fit_Tmax for i in EnthalpyVaporizations],\n                              [i.poly_fit_Tc for i in EnthalpyVaporizations],\n                              [1.0/i.poly_fit_Tc for i in EnthalpyVaporizations],\n                              [i.poly_fit_coeffs for i in EnthalpyVaporizations]]\n\n\n\n        if GibbsExcessModel is None:\n            GibbsExcessModel = IdealSolution(T=T, xs=zs)\n\n        self.GibbsExcessModel = GibbsExcessModel\n        self.eos_pure_instances = eos_pure_instances\n\n        self.equilibrium_basis = equilibrium_basis\n        self.caloric_basis = caloric_basis\n\n        if equilibrium_basis is not None:\n            if equilibrium_basis == 'Poynting':\n                self.use_Poynting = True\n                self.use_phis_sat = False\n            elif equilibrium_basis == 'Poynting&PhiSat':\n                self.use_Poynting = True\n                self.use_phis_sat = True\n            elif equilibrium_basis == 'PhiSat':\n                self.use_phis_sat = True\n                self.use_Poynting = False\n            elif equilibrium_basis == 'Psat':\n                self.use_phis_sat = False\n                self.use_Poynting = False\n        else:\n            self.use_Poynting = use_Poynting\n            self.use_phis_sat = use_phis_sat\n\n        if caloric_basis is not None:\n            if caloric_basis == 'Poynting':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Poynting&PhiSat':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = True\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'PhiSat':\n                self.use_phis_sat_caloric = True\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Psat':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Hvap':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = True\n        else:\n            self.use_Poynting_caloric = use_Poynting\n            self.use_phis_sat_caloric = use_phis_sat\n            self.use_Hvap_caloric = use_Hvap_caloric\n\n\n\n\n        if henry_mode not in ('solvents', 'solvents_with_parameters'):\n            raise ValueError(\"Henry's law model setting not recognized\")\n        self.henry_mode = henry_mode\n\n\n        multiple_henry_inputs = (henry_as, henry_bs, henry_cs, henry_ds, henry_es, henry_fs)\n        input_count_henry = (henry_abcdef is not None) + (any(i is not None for i in multiple_henry_inputs))\n        if input_count_henry > 1:\n            raise ValueError(\"Input only one of henry_abcdef, or (henry_as...henry_fs)\")\n        if henry_abcdef is not None:\n            if self.vectorized:\n                self.henry_as = array(henry_abcdef[:,:,0], order='C', copy=True)\n                self.henry_bs = array(henry_abcdef[:,:,1], order='C', copy=True)\n                self.henry_cs = array(henry_abcdef[:,:,2], order='C', copy=True)\n                self.henry_ds = array(henry_abcdef[:,:,3], order='C', copy=True)\n                self.henry_es = array(henry_abcdef[:,:,4], order='C', copy=True)\n                self.henry_fs = array(henry_abcdef[:,:,5], order='C', copy=True)\n            else:\n                self.henry_as = [[i[0] for i in l] for l in henry_abcdef]\n                self.henry_bs = [[i[1] for i in l] for l in henry_abcdef]\n                self.henry_cs = [[i[2] for i in l] for l in henry_abcdef]\n                self.henry_ds = [[i[3] for i in l] for l in henry_abcdef]\n                self.henry_es = [[i[4] for i in l] for l in henry_abcdef]\n                self.henry_fs = [[i[5] for i in l] for l in henry_abcdef]\n        else:\n            if henry_abcdef is None:\n                henry_abcdef = multiple_henry_inputs\n            henry_abcdef_len = 0 if henry_abcdef is None else len(henry_abcdef)\n            if not henry_abcdef_len or henry_abcdef[0] is None:\n                self.henry_as = zero_coeffs\n            else:\n                self.henry_as = henry_abcdef[0]\n            if not henry_abcdef_len or henry_abcdef[1] is None:\n                self.henry_bs = zero_coeffs\n            else:\n                self.henry_bs = henry_abcdef[1]\n            if not henry_abcdef_len or henry_abcdef[2] is None:\n                self.henry_cs = zero_coeffs\n            else:\n                self.henry_cs = henry_abcdef[2]\n            if not henry_abcdef_len or henry_abcdef[3] is None:\n                self.henry_ds = zero_coeffs\n            else:\n                self.henry_ds = henry_abcdef[3]\n            if not henry_abcdef_len or henry_abcdef[4] is None:\n                self.henry_es = zero_coeffs\n            else:\n                self.henry_es = henry_abcdef[4]\n            if not henry_abcdef_len or henry_abcdef[5] is None:\n                self.henry_fs = zero_coeffs\n            else:\n                self.henry_fs = henry_abcdef[5]\n\n        self.composition_independent = isinstance(GibbsExcessModel, IdealSolution) and not self.has_henry_components\n\n        self.Hfs = Hfs\n        self.Gfs = Gfs\n        self.Sfs = Sfs\n\n        self.model_id = 20000 + GibbsExcessModel.model_id\n\n        if T is not None and P is not None and zs is not None:\n            self.T = T\n            self.P = P\n            self.zs = zs\n\n    def to_TP_zs(self, T, P, zs):\n        T_equal = hasattr(self, 'T') and T == self.T\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new.N = self.N\n\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n\n    def to(self, zs, T=None, P=None, V=None):\n        try:\n            T_equal = T == self.T\n        except:\n            T_equal = False\n\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.N = self.N\n\n        if T is not None:\n            if P is not None:\n                new.T = T\n                new.P = P\n            elif V is not None:\n                def to_solve(P):\n                    return self.to_TP_zs(T, P, zs).V() - V\n                P = secant(to_solve, 0.0002, xtol=1e-8, ytol=1e-10)\n                new.P = P\n        elif P is not None and V is not None:\n            def to_solve(T):\n                return self.to_TP_zs(T, P, zs).V() - V\n            T = secant(to_solve, 300, xtol=1e-9, ytol=1e-5)\n            new.T = T\n        else:\n            raise ValueError(\"Two of T, P, or V are needed\")\n\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n    def transfer_data(self, new, zs, T, T_equal):\n        new.VaporPressures = self.VaporPressures\n        new.VolumeLiquids = self.VolumeLiquids\n        new.eos_pure_instances = self.eos_pure_instances\n        new.HeatCapacityGases = self.HeatCapacityGases\n        new.EnthalpyVaporizations = self.EnthalpyVaporizations\n        new.HeatCapacityLiquids = self.HeatCapacityLiquids\n\n\n        new.Psats_poly_fit = self.Psats_poly_fit\n        new._Psats_data = self._Psats_data\n        new.Psat_extrpolation = self.Psat_extrpolation\n\n        new.Cpgs_poly_fit = self.Cpgs_poly_fit\n        new._Cpgs_data = self._Cpgs_data\n\n        new.Cpls_poly_fit = self.Cpls_poly_fit\n        new._Cpls_data = self._Cpls_data\n\n        new.Vms_sat_poly_fit = self.Vms_sat_poly_fit\n        new._Vms_sat_data = self._Vms_sat_data\n\n        new._Hvap_data = self._Hvap_data\n        new.Hvap_poly_fit = self.Hvap_poly_fit\n\n        new.incompressible = self.incompressible\n\n        new.equilibrium_basis = self.equilibrium_basis\n        new.caloric_basis = self.caloric_basis\n\n        new.use_phis_sat = self.use_phis_sat\n        new.use_Poynting = self.use_Poynting\n        new.P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n        new.use_eos_volume = self.use_eos_volume\n        new.use_Hvap_caloric = self.use_Hvap_caloric\n\n        new.Hfs = self.Hfs\n        new.Gfs = self.Gfs\n        new.Sfs = self.Sfs\n\n        new.henry_as = self.henry_as\n        new.henry_bs = self.henry_bs\n        new.henry_cs = self.henry_cs\n        new.henry_ds = self.henry_ds\n        new.henry_es = self.henry_es\n        new.henry_fs = self.henry_fs\n        new.henry_components = self.henry_components\n        new.has_henry_components = self.has_henry_components\n        new.henry_mode = self.henry_mode\n\n        new.composition_independent = self.composition_independent\n        new.model_id = self.model_id\n\n        new.use_Tait = self.use_Tait\n        new._Tait_B_data = self._Tait_B_data\n        new._Tait_C_data = self._Tait_C_data\n\n\n        if T_equal and (self.composition_independent or self.zs is zs):\n            # Allow the composition inconsistency as it is harmless\n            new.GibbsExcessModel = self.GibbsExcessModel\n        else:\n            new.GibbsExcessModel = self.GibbsExcessModel.to_T_xs(T=T, xs=zs)\n\n        try:\n            if T_equal:\n                if not self.has_henry_components:\n                    try:\n                        new._Psats = self._Psats\n                        new._dPsats_dT = self._dPsats_dT\n                        new._d2Psats_dT2 = self._d2Psats_dT2\n                    except:\n                        pass\n                    try:\n                        new._lnPsats = self._lnPsats\n                        new._dPsats_dT_over_Psats = self._dPsats_dT_over_Psats\n                    except:\n                        pass\n                else:\n                    try:\n                        new._lnHenry_matrix = self._lnHenry_matrix\n                        new._dlnHenry_matrix_dT = self._dlnHenry_matrix_dT\n                        new._d2lnHenry_matrix_dT2 = self._d2lnHenry_matrix_dT2\n                    except:\n                        pass\n\n                try:\n                    new._Vms_sat = self._Vms_sat\n                    new._Vms_sat_dT = self._Vms_sat_dT\n                    new._d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n                except:\n                    pass\n                try:\n                    new._Cpigs = self._Cpigs\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_pure = self._Cpig_integrals_pure\n                except:\n                    pass\n        except:\n            pass\n        return new\n\n    supports_lnphis_args = False\n\n    def lnphis_args(self):\n        try:\n            return self._lnphis_args\n        except:\n            pass\n        lnPsats = self.lnPsats()\n        Poyntings = self.Poyntings()\n        phis_sat = self.phis_sat()\n        activity_args = self.GibbsExcessModel.gammas_args()\n        lnphis = zeros(self.N) if self.vectorized else [0.0]*self.N\n        self._lnphis_args = (self.model_id, self.T, self.P, self.N, lnPsats, Poyntings, phis_sat) + activity_args +(lnphis,)\n        return self._lnphis_args\n\n\n    def lnHenry_matrix(self):\n        r'''Method to calculate and return the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        .. math::\n            \\ln \\text{H}_{i,j} = A_{ij}+\\frac{B_{ij}}{T}+C_{ij}\\ln T + D_{ij}T\n            + \\frac{E_{ij}}{T^2} + F_{ij}{T^2}\n\n        Returns\n        -------\n        lnHenry_matrix : list[list[float]]\n            Henry's law interaction parameters, [log(Pa)]\n\n        Notes\n        -----\n        Solvent/solvent and gas/gas values are all 0.\n        '''\n        try:\n            return self._lnHenry_matrix\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            lnHenry_matrix = zeros((N, N))\n        else:\n            lnHenry_matrix = [[0.0]*N for _ in range(N)]\n\n        lnHenry_matrix = ln_henries(self.T, N, self.henry_as, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, lnHenry_matrix)\n        self._lnHenry_matrix = lnHenry_matrix\n        return lnHenry_matrix\n\n    def dlnHenry_matrix_dT(self):\n        r'''Method to calculate and return the first temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        dlnHenry_matrix_dT : list[list[float]]\n            First temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._dlnHenry_matrix_dT\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            dlnHenry_matrix_dT = zeros((N, N))\n        else:\n            dlnHenry_matrix_dT = [[0.0]*N for _ in range(N)]\n        dlnHenry_matrix_dT = dln_henries_dT(self.T, N, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, dlnHenry_matrix_dT)\n        self._dlnHenry_matrix_dT = dlnHenry_matrix_dT\n        return dlnHenry_matrix_dT\n\n    def d2lnHenry_matrix_dT2(self):\n        r'''Method to calculate and return the second temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        d2lnHenry_matrix_dT2 : list[list[float]]\n            Second temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._d2lnHenry_matrix_dT2\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            d2lnHenry_matrix_dT2 = zeros((N, N))\n        else:\n            d2lnHenry_matrix_dT2 = [[0.0]*N for _ in range(N)]\n        d2lnHenry_matrix_dT2 = d2ln_henries_dT2(self.T, N, self.henry_bs, self.henry_cs, self.henry_es, self.henry_fs, d2lnHenry_matrix_dT2)\n        self._d2lnHenry_matrix_dT2 = d2lnHenry_matrix_dT2\n        return d2lnHenry_matrix_dT2\n\n    def Henry_constants(self):\n        zs, vectorized, N, henry_components, henry_mode = self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        Hs = zeros(N) if vectorized else [0.0]*N\n        Henry_constants(lnHenry_matrix, zs, henry_components, solvents_with_parameters, Hs)\n        return Hs\n        dHenry_constants_dT\n\n    def dHenry_constants_dT(self):\n        zs, vectorized, N, henry_components, henry_mode = self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        dHs = zeros(N) if vectorized else [0.0]*N\n        dHenry_constants_dT(lnHenry_matrix, dlnHenry_matrix_dT, zs, henry_components, solvents_with_parameters, dHs)\n        return dHs\n\n    def d2Henry_constants_dT2(self):\n        zs, vectorized, N, henry_components, henry_mode = self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        d2lnHenry_matrix_dT2 = self.d2lnHenry_matrix_dT2()\n        d2Hs = zeros(N) if vectorized else [0.0]*N\n        d2Henry_constants_dT2(lnHenry_matrix, dlnHenry_matrix_dT, d2lnHenry_matrix_dT2, zs, henry_components, solvents_with_parameters, d2Hs)\n        return d2Hs\n\n\n    def Psats_T_ref(self):\n        try:\n            return self._Psats_T_ref\n        except AttributeError:\n            pass\n        VaporPressures, N = self.VaporPressures, self.N\n        T_REF_IG = self.T_REF_IG\n        if self.has_henry_components:\n            self._Psats_T_ref = self.to(T=T_REF_IG, P=self.P, zs=self.zs).Psats()\n        else:\n            self._Psats_T_ref = [VaporPressures[i](T_REF_IG) for i in range(N)]\n        return self._Psats_T_ref\n\n    def Psats_at(self, T):\n        if self.Psats_poly_fit:\n            return self._Psats_at_poly_fit(T, self._Psats_data, range(self.N))\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).Psats()\n        VaporPressures = self.VaporPressures\n        return [VaporPressures[i](T) for i in range(self.N)]\n\n    @staticmethod\n    def _Psats_at_poly_fit(T, Psats_data, cmps):\n        Psats = []\n        T_inv = 1.0/T\n        logT = log(T)\n        Tmins, Tmaxes, coeffs = Psats_data[0], Psats_data[3], Psats_data[6]\n        for i in cmps:\n            if T < Tmins[i]:\n                A, B, C = Psats_data[9][i]\n                Psat = (A + B*T_inv + C*logT)\n#                    A, B = _Psats_data[9][i]\n#                    Psat = (A - B*T_inv)\n#                    Psat = (T - Tmins[i])*_Psats_data[1][i] + _Psats_data[2][i]\n            elif T > Tmaxes[i]:\n                A, B, C = Psats_data[10][i]\n                Psat = (A + B*T_inv + C*logT)\n#                A, B = _Psats_data[10][i]\n#                Psat = (A - B*T_inv)\n#                Psat = (T - Tmaxes[i])*_Psats_data[4][i] + _Psats_data[5][i]\n            else:\n                Psat = 0.0\n                for c in coeffs[i]:\n                    Psat = Psat*T + c\n            try:\n                Psats.append(exp(Psat))\n            except:\n                Psats.append(1.6549840276802644e+300)\n\n        return Psats\n\n    def Psats(self):\n        try:\n            return self._Psats\n        except AttributeError:\n            pass\n        N = self.N\n        T, cmps = self.T, range(N)\n        if self.Psats_poly_fit:\n            self._Psats = Psats = self._Psats_at_poly_fit(T, self._Psats_data, cmps)\n#            _Psats_data = self._Psats_data\n#            Tmins, Tmaxes, coeffs = _Psats_data[0], _Psats_data[3], _Psats_data[6]\n#            for i in cmps:\n#                if T < Tmins[i]:\n#                    A, B, C = _Psats_data[9][i]\n#                    Psat = (A + B*T_inv + C*logT)\n##                    A, B = _Psats_data[9][i]\n##                    Psat = (A - B*T_inv)\n##                    Psat = (T - Tmins[i])*_Psats_data[1][i] + _Psats_data[2][i]\n#                elif T > Tmaxes[i]:\n#                    Psat = (T - Tmaxes[i])*_Psats_data[4][i] + _Psats_data[5][i]\n#                else:\n#                    Psat = 0.0\n#                    for c in coeffs[i]:\n#                        Psat = Psat*T + c\n#                Psats.append(exp(Psat))\n        else:\n            self._Psats = Psats = []\n            for i in self.VaporPressures:\n                Psats.append(i.T_dependent_property(T))\n\n        if self.has_henry_components:\n            Hs, henry_components = self.Henry_constants(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    Psats[i] = Hs[i]\n        return Psats\n\n    def PIP(self):\n        dP_dT = self.dP_dT()\n        if dP_dT == 0:\n            return self.PIP_INCALCULABLE_VALUE\n        return phase_identification_parameter(self.V(), self.dP_dT(), self.dP_dV(),\n                                              self.d2P_dV2(), self.d2P_dTdV())\n\n    @staticmethod\n    def _dPsats_dT_at_poly_fit(T, Psats_data, cmps, Psats):\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        dPsats_dT = []\n        Tmins, Tmaxes, dcoeffs, coeffs_low, coeffs_high = Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10]\n        for i in cmps:\n            if T < Tmins[i]:\n#                    A, B = _Psats_data[9][i]\n#                    dPsat_dT = B*Tinv2*Psats[i]\n                dPsat_dT = Psats[i]*(-coeffs_low[i][1]*Tinv2 + coeffs_low[i][2]*T_inv)\n#                    dPsat_dT = _Psats_data[1][i]*Psats[i]#*exp((T - Tmins[i])*_Psats_data[1][i]\n                                             #   + _Psats_data[2][i])\n            elif T > Tmaxes[i]:\n                dPsat_dT = Psats[i]*(-coeffs_high[i][1]*Tinv2 + coeffs_high[i][2]*T_inv)\n\n#                dPsat_dT = _Psats_data[4][i]*Psats[i]#*exp((T - Tmaxes[i])\n#                                                    #*_Psats_data[4][i]\n#                                                    #+ _Psats_data[5][i])\n            else:\n                dPsat_dT = 0.0\n                for c in dcoeffs[i]:\n                    dPsat_dT = dPsat_dT*T + c\n#                    v, der = horner_and_der(coeffs[i], T)\n                dPsat_dT *= Psats[i]\n            dPsats_dT.append(dPsat_dT)\n        return dPsats_dT\n\n    def dPsats_dT_at(self, T, Psats=None):\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if self.Psats_poly_fit:\n            return self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(self.N), Psats)\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).dPsats_dT()\n        return [VaporPressure.T_dependent_property_derivative(T=T)\n                     for VaporPressure in self.VaporPressures]\n\n    def dPsats_dT(self):\n        try:\n            return self._dPsats_dTT_dependent_property_derivative\n        except:\n            pass\n        T, N = self.T, self.N\n        # Need to reset the method because for the T bounded solver,\n        # will normally get a different than prefered method as it starts\n        # at the boundaries\n        if self.Psats_poly_fit:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            self._dPsats_dT = dPsats_dT = self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(N), Psats)\n            return dPsats_dT\n\n        self._dPsats_dT = dPsats_dT = [VaporPressure.T_dependent_property_derivative(T=T)\n                     for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            dHs, henry_components = self.dHenry_constants_dT(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    dPsats_dT[i] = dHs[i]\n        return dPsats_dT\n\n    def d2Psats_dT2(self):\n        try:\n            return self._d2Psats_dT2\n        except:\n            pass\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        T_inv2 = T_inv*T_inv\n        # Tinv3 = T_inv*T_inv*T_inv\n\n        self._d2Psats_dT2 = d2Psats_dT2 = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = Psats_data[0], Psats_data[3], Psats_data[8]\n            for i in range(N):\n                if T < Tmins[i]:\n#                    A, B = _Psats_data[9][i]\n#                    d2Psat_dT2 = B*Psats[i]*(B*T_inv - 2.0)*Tinv3\n                    A, B, C = Psats_data[9][i]\n                    x0 = (B*T_inv - C)\n                    d2Psat_dT2 = Psats[i]*(2.0*B*T_inv - C + x0*x0)*T_inv2\n#                    d2Psat_dT2 = _Psats_data[1][i]*dPsats_dT[i]\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    x0 = (B*T_inv - C)\n                    d2Psat_dT2 = Psats[i]*(2.0*B*T_inv - C + x0*x0)*T_inv2\n#                    d2Psat_dT2 = _Psats_data[4][i]*dPsats_dT[i]\n                else:\n                    d2Psat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2Psat_dT2 = d2Psat_dT2*T + c\n                    d2Psat_dT2 = (dPsats_dT[i]*dPsats_dT[i]/Psats[i] + Psats[i]*d2Psat_dT2)\n                d2Psats_dT2.append(d2Psat_dT2)\n            return d2Psats_dT2\n\n        self._d2Psats_dT2 = d2Psats_dT2 = [VaporPressure.T_dependent_property_derivative(T=T, order=2)\n                     for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            d2Hs, henry_components = self.d2Henry_constants_dT2(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psats_dT2[i] = d2Hs[i]\n        return d2Psats_dT2\n\n    def lnPsats(self):\n        try:\n            return self._lnPsats\n        except AttributeError:\n            pass\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        logT = log(T)\n        lnPsats = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, coeffs = Psats_data[0], Psats_data[3], Psats_data[6]\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    Psat = (A + B*T_inv + C*logT)\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    Psat = (A + B*T_inv + C*logT)\n#                    Psat = (T - Tmaxes[i])*_Psats_data[4][i] + _Psats_data[5][i]\n                else:\n                    Psat = 0.0\n                    for c in coeffs[i]:\n                        Psat = Psat*T + c\n                lnPsats.append(Psat)\n            self._lnPsats = lnPsats\n            return lnPsats\n\n        self._lnPsats = lnPsats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG)\n                                   for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, henry_components = self.Henry_constants(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    lnPsats[i] = log(Hs[i])\n        return lnPsats\n\n    def dlnPsats_dT(self):\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs = Psats_data[0], Psats_data[3], Psats_data[7]\n            dlnPsats_dT = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    dPsat_dT = (-B*Tinv2 + C*T_inv)\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    dPsat_dT = (-B*Tinv2 + C*T_inv)\n#                    dPsat_dT = _Psats_data[4][i]\n                else:\n                    dPsat_dT = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT = dPsat_dT*T + c\n                dlnPsats_dT.append(dPsat_dT)\n            return dlnPsats_dT\n        dlnPsats_dT = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, henry_components = self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    dlnPsats_dT[i] = dHs[i]/Hs[i]\n\n        return dlnPsats_dT\n\n    def d2lnPsats_dT2(self):\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        T_inv2 = T_inv*T_inv\n        # Tinv3 = T_inv*T_inv*T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = Psats_data[0], Psats_data[3], Psats_data[8]\n            d2lnPsats_dT2 = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    d2lnPsat_dT2 = (2.0*B*T_inv - C)*T_inv2\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    d2lnPsat_dT2 = (2.0*B*T_inv - C)*T_inv2\n#                    d2lnPsat_dT2 = 0.0\n                else:\n                    d2lnPsat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2lnPsat_dT2 = d2lnPsat_dT2*T + c\n                d2lnPsats_dT2.append(d2lnPsat_dT2)\n            return d2lnPsats_dT2\n        d2lnPsats_dT2 = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, d2Hs, henry_components = self.Henry_constants(), self.dHenry_constants_dT(), self.d2Henry_constants_dT2(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    d2lnPsats_dT2[i] = (d2Hs[i] - dHs[i]*dHs[i]/Hs[i])/Hs[i]\n\n        return d2lnPsats_dT2\n\n    def dPsats_dT_over_Psats(self):\n        try:\n            return self._dPsats_dT_over_Psats\n        except AttributeError:\n            pass\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        if self.Psats_poly_fit:\n            dPsat_dT_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10]\n            for i in range(N):\n                if T < Tmins[i]:\n                    dPsat_dT_over_Psat = (-low_coeffs[i][1]*Tinv2 + low_coeffs[i][2]*T_inv)\n                elif T > Tmaxes[i]:\n                    dPsat_dT_over_Psat = (-high_coeffs[i][1]*Tinv2 + high_coeffs[i][2]*T_inv)\n#                    dPsat_dT_over_Psat = _Psats_data[4][i]\n                else:\n                    dPsat_dT_over_Psat = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT_over_Psat = dPsat_dT_over_Psat*T + c\n                dPsat_dT_over_Psats.append(dPsat_dT_over_Psat)\n            self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n            return dPsat_dT_over_Psats\n\n        # dPsat_dT_over_Psats = [i/j for i, j in zip(self.dPsats_dT(), self.Psats())]\n        dPsat_dT_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n\n        if self.has_henry_components:\n            Hs, dHenry_constants_dT, henry_components = self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    dPsat_dT_over_Psats[i] = dHenry_constants_dT[i]/Hs[i]\n\n        self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n        return dPsat_dT_over_Psats\n\n    def d2Psats_dT2_over_Psats(self):\n        try:\n            return self._d2Psats_dT2_over_Psats\n        except AttributeError:\n            pass\n        T, N = self.T, self.N\n        T_inv = 1.0/T\n        Tinv2 = T_inv*T_inv\n        Tinv4 = Tinv2*Tinv2\n        c0 = (T + T)*Tinv4\n        if self.Psats_poly_fit:\n            d2Psat_dT2_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10]\n            for i in range(N):\n                if T < Tmins[i]:\n                    B, C = low_coeffs[i][1], low_coeffs[i][2]\n                    x0 = (B - C*T)\n                    d2Psat_dT2_over_Psat = c0*B - C*Tinv2 + x0*x0*Tinv4\n#                    d2Psat_dT2_over_Psat = (2*B*T - C*T**2 + (B - C*T)**2)/T**4\n                elif T > Tmaxes[i]:\n                    B, C = high_coeffs[i][1], high_coeffs[i][2]\n                    x0 = (B - C*T)\n                    d2Psat_dT2_over_Psat = c0*B - C*Tinv2 + x0*x0*Tinv4\n                else:\n                    dPsat_dT = 0.0\n                    d2Psat_dT2 = 0.0\n                    for a in dcoeffs[i]:\n                        d2Psat_dT2 = T*d2Psat_dT2 + dPsat_dT\n                        dPsat_dT = T*dPsat_dT + a\n                    d2Psat_dT2_over_Psat = dPsat_dT*dPsat_dT + d2Psat_dT2\n\n                d2Psat_dT2_over_Psats.append(d2Psat_dT2_over_Psat)\n            self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n            return d2Psat_dT2_over_Psats\n\n        # d2Psat_dT2_over_Psats = [i/j for i, j in zip(self.d2Psats_dT2(), self.Psats())]\n        d2Psat_dT2_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, d2Henry_constants_dT2, henry_components = self.Henry_constants(), self.d2Henry_constants_dT2(), self.henry_components\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psat_dT2_over_Psats[i] = d2Henry_constants_dT2[i]/Hs[i]\n\n        self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n        return d2Psat_dT2_over_Psats\n\n    @staticmethod\n    def _Vms_sat_at(T, Vms_sat_data, cmps):\n        Tmins, Tmaxes, coeffs, coeffs_Tmin = Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[6], Vms_sat_data[9]\n        Vms_sat = []\n        for i in cmps:\n            if T < Tmins[i]:\n                Vm = 0.0\n                for c in coeffs_Tmin[i]:\n                    Vm = Vm*T + c\n#                    Vm = (T - Tmins[i])*Vms_sat_data[1][i] + Vms_sat_data[2][i]\n            elif T > Tmaxes[i]:\n                Vm = (T - Tmaxes[i])*Vms_sat_data[4][i] + Vms_sat_data[5][i]\n            else:\n                Vm = 0.0\n                for c in coeffs[i]:\n                    Vm = Vm*T + c\n            Vms_sat.append(Vm)\n        return Vms_sat\n\n    def Vms_sat_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n        VolumeLiquids = self.VolumeLiquids\n        return [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n\n    def Vms_sat(self):\n        try:\n            return self._Vms_sat\n        except AttributeError:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n#            self._Vms_sat = evaluate_linear_fits(self._Vms_sat_data, T)\n#            return self._Vms_sat\n            self._Vms_sat = Vms_sat = self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n            return Vms_sat\n        elif self.use_eos_volume:\n            Vms = []\n            eoss = self.eos_pure_instances\n            Psats = self.Psats()\n            for i, e in enumerate(eoss):\n                if T < e.Tc:\n                    Vms.append(e.V_l_sat(T))\n                else:\n                    e = e.to(T=T, P=Psats[i])\n                    try:\n                        Vms.append(e.V_l)\n                    except:\n                        Vms.append(e.V_g)\n            self._Vms_sat = Vms\n            return Vms\n\n\n        VolumeLiquids = self.VolumeLiquids\n#        Psats = self.Psats()\n#        self._Vms_sat = [VolumeLiquids[i](T, Psats[i]) for i in range(self.N)]\n        self._Vms_sat = [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n        return self._Vms_sat\n\n    @staticmethod\n    def _dVms_sat_dT_at(T, Vms_sat_data, cmps):\n        Vms_sat_dT = []\n        Tmins, Tmaxes, dcoeffs = Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[7]\n        for i in cmps:\n            if T < Tmins[i]:\n                dVm = horner_and_der2(Vms_sat_data[9][i], T)[1]\n            elif T > Tmaxes[i]:\n                dVm = Vms_sat_data[4][i]\n            else:\n                dVm = 0.0\n                for c in dcoeffs[i]:\n                    dVm = dVm*T + c\n            Vms_sat_dT.append(dVm)\n        return Vms_sat_dT\n\n    def dVms_sat_dT_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n        return [obj.T_dependent_property_derivative(T=T) for obj in self.VolumeLiquids]\n\n    def dVms_sat_dT(self):\n        try:\n            return self._Vms_sat_dT\n        except:\n            pass\n        T = self.T\n\n        if self.Vms_sat_poly_fit:\n#            self._Vms_sat_dT = evaluate_linear_fits_d(self._Vms_sat_data, T)\n            self._Vms_sat_dT = self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n            return self._Vms_sat_dT\n\n        VolumeLiquids = self.VolumeLiquids\n        self._Vms_sat_dT = Vms_sat_dT = [obj.T_dependent_property_derivative(T=T) for obj in VolumeLiquids]\n        return Vms_sat_dT\n\n    def d2Vms_sat_dT2(self):\n        try:\n            return self._d2Vms_sat_dT2\n        except:\n            pass\n\n        T = self.T\n\n        if self.Vms_sat_poly_fit:\n#            self._d2Vms_sat_dT2 = evaluate_linear_fits_d2(self._Vms_sat_data, T)\n#            return self._d2Vms_sat_dT2\n            d2Vms_sat_dT2 = self._d2Vms_sat_dT2 = []\n\n            Vms_sat_data = self._Vms_sat_data\n            Tmins, Tmaxes, d2coeffs = Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[8]\n            for i in range(self.N):\n                d2Vm = 0.0\n                if Tmins[i] < T < Tmaxes[i]:\n                    for c in d2coeffs[i]:\n                        d2Vm = d2Vm*T + c\n                elif T < Tmins[i]:\n                    d2Vm = horner_and_der2(Vms_sat_data[9][i], T)[2]\n                d2Vms_sat_dT2.append(d2Vm)\n            return d2Vms_sat_dT2\n\n        VolumeLiquids = self.VolumeLiquids\n        self._d2Vms_sat_dT2 = [obj.T_dependent_property_derivative(T=T, order=2) for obj in VolumeLiquids]\n        return self._d2Vms_sat_dT2\n\n    def Vms_sat_T_ref(self):\n        try:\n            return self._Vms_sat_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_T_ref = evaluate_linear_fits(self._Vms_sat_data, T_REF_IG)\n        else:\n            VolumeLiquids, cmps = self.VolumeLiquids, range(self.N)\n            self._Vms_sat_T_ref = [VolumeLiquids[i].T_dependent_property(T_REF_IG) for i in cmps]\n        return self._Vms_sat_T_ref\n\n    def dVms_sat_dT_T_ref(self):\n        try:\n            return self._dVms_sat_dT_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._dVms_sat_dT_T_ref = evaluate_linear_fits_d(self._Vms_sat_data, self.T)\n        else:\n            VolumeLiquids, cmps = self.VolumeLiquids, range(self.N)\n            self._dVms_sat_dT_T_ref = [VolumeLiquids[i].T_dependent_property_derivative(T_REF_IG) for i in cmps]\n        return self._dVms_sat_dT_T_ref\n\n    def Vms(self):\n        # Fill in tait/eos function to be called instead of Vms_sat\n        return self.Vms_sat()\n\n    def dVms_dT(self):\n        return self.dVms_sat_dT()\n\n    def d2Vms_dT2(self):\n        return self.d2Vms_sat_dT2()\n\n    def dVms_dP(self):\n        return [0.0]*self.N\n\n    def d2Vms_dP2(self):\n        return [0.0]*self.N\n\n    def d2Vms_dPdT(self):\n        return [0.0]*self.N\n\n    def Hvaps(self):\n        try:\n            return self._Hvaps\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = self.T, self.EnthalpyVaporizations, range(self.N)\n\n        self._Hvaps = Hvaps = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = Hvap_data[2], Hvap_data[3], Hvap_data[4]\n            for i in cmps:\n                Hvap = 0.0\n                if T < Tcs[i]:\n                    x = log(1.0 - T*Tcs_inv[i])\n                    for c in coeffs[i]:\n                        Hvap = Hvap*x + c\n    #                    Vm = horner(coeffs[i], log(1.0 - T*Tcs_inv[i])\n                Hvaps.append(Hvap)\n            return Hvaps\n\n        self._Hvaps = Hvaps = [EnthalpyVaporizations[i](T) for i in cmps]\n        for i in cmps:\n            if Hvaps[i] is None:\n                Hvaps[i] = 0.0\n        return Hvaps\n\n    def dHvaps_dT(self):\n        try:\n            return self._dHvaps_dT\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = self.T, self.EnthalpyVaporizations, range(self.N)\n\n        self._dHvaps_dT = dHvaps_dT = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = Hvap_data[2], Hvap_data[3], Hvap_data[4]\n            for i in cmps:\n                dHvap_dT = 0.0\n                if T < Tcs[i]:\n                    p = log((Tcs[i] - T)*Tcs_inv[i])\n                    x = 1.0\n                    a = 1.0\n                    for c in coeffs[i][-2::-1]:\n                        dHvap_dT += a*c*x\n                        x *= p\n                        a += 1.0\n                    dHvap_dT /= T - Tcs[i]\n\n                dHvaps_dT.append(dHvap_dT)\n            return dHvaps_dT\n\n        self._dHvaps_dT = dHvaps_dT = [EnthalpyVaporizations[i].T_dependent_property_derivative(T) for i in cmps]\n        for i in cmps:\n            if dHvaps_dT[i] is None:\n                dHvaps_dT[i] = 0.0\n        return dHvaps_dT\n\n    def Hvaps_T_ref(self):\n        try:\n            return self._Hvaps_T_ref\n        except AttributeError:\n            pass\n        EnthalpyVaporizations, cmps = self.EnthalpyVaporizations, range(self.N)\n        T_REF_IG = self.T_REF_IG\n        self._Hvaps_T_ref = [EnthalpyVaporizations[i](T_REF_IG) for i in cmps]\n        return self._Hvaps_T_ref\n\n    def Poyntings_at(self, T, P, Psats=None, Vms=None):\n        if not self.use_Poynting:\n            return [1.0]*self.N\n\n        cmps = range(self.N)\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n        RT_inv = 1.0/(R*T)\n        return [exp(Vms[i]*(P-Psats[i])*RT_inv) for i in cmps]\n\n    def Poyntings(self):\n        r'''Method to calculate and return the Poynting pressure correction\n        factors of the phase, [-].\n\n        .. math::\n            \\text{Poynting}_i = \\exp\\left(\\frac{V_{m,i}(P-P_{sat})}{RT}\\right)\n\n        Returns\n        -------\n        Poyntings : list[float]\n            Poynting pressure correction factors, [-]\n\n        Notes\n        -----\n        The above formula is correct for pressure-independent molar volumes.\n        When the volume does depend on pressure, the full expression is:\n\n        .. math::\n            \\text{Poynting} = \\exp\\left[\\frac{\\int_{P_i^{sat}}^P V_i^l dP}{RT}\\right]\n\n        When a specified model e.g. the Tait equation is used, an analytical\n        integral of this term is normally available.\n\n        '''\n        try:\n            return self._Poyntings\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._Poyntings = [1.0]*self.N\n            return self._Poyntings\n\n        T, P = self.T, self.P\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        RT_inv = 1.0/(R*T)\n        self._Poyntings = [trunc_exp(Vml*(P-Psat)*RT_inv) for Psat, Vml in zip(Psats, Vms_sat)]\n        return self._Poyntings\n\n\n    def dPoyntings_dT(self):\n        try:\n            return self._dPoyntings_dT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dT = [0.0]*self.N\n            return self._dPoyntings_dT\n\n        T, P = self.T, self.P\n\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n\n        x0 = 1.0/R\n        x1 = 1.0/T\n        RT_inv = x0*x1\n\n        self._dPoyntings_dT = dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = Psats[i]\n\n            x4 = P - x3\n            x5 = x1*x2*x4\n            dPoyntings_dTi = -RT_inv*(x2*dPsats_dT[i] - x4*dVms_sat_dT[i] + x5)*trunc_exp(x0*x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def dPoyntings_dT_at(self, T, P, Psats=None, Vms=None, dPsats_dT=None, dVms_sat_dT=None):\n        if not self.use_Poynting:\n            return [0.0]*self.N\n\n        if Psats is None:\n            Psats = self.Psats_at(T)\n\n        if dPsats_dT is None:\n            dPsats_dT = self.dPsats_dT_at(T, Psats)\n\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n\n        if dVms_sat_dT is None:\n            dVms_sat_dT = self.dVms_sat_dT_at(T)\n        x0 = 1.0/R\n        x1 = 1.0/T\n        dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x4 = P - Psats[i]\n            x5 = x1*x2*x4\n            dPoyntings_dTi = -x0*x1*(x2*dPsats_dT[i] - x4*dVms_sat_dT[i] + x5)*exp(x0*x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def d2Poyntings_dT2(self):\n        try:\n            return self._d2Poyntings_dT2\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dT2 = [0.0]*self.N\n            return self._d2Poyntings_dT2\n\n        T, P = self.T, self.P\n\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        d2Psats_dT2 = self.d2Psats_dT2()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n\n        x6 = 1.0/T\n        x7 = x6 + x6\n        x11 = 1.0/R\n        x12 = x11*x6\n        c0 = 2.0*x6*x6\n\n        self._d2Poyntings_dT2 = d2Poyntings_dT2 = []\n        \"\"\"\n        from sympy import *\n        R, T, P = symbols('R, T, P')\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\n        RT_inv = 1/(R*T)\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\n        cse(diff(Poy, T, 2), optimizations='basic')\n        \"\"\"\n        for i in range(self.N):\n            x0 = Vms[i]\n            x1 = Psats[i]\n            x2 = P - x1\n            x3 = x0*x2\n            x4 = dPsats_dT[i]\n            x5 = x0*x4\n            x8 = dVms_sat_dT[i]\n            x9 = x2*x8\n            x10 = x3*x6\n            x50 = (x10 + x5 - x9)\n            d2Poyntings_dT2i = (x12*(-x0*d2Psats_dT2[i] + x12*x50*x50\n                                    + x2*d2Vms_sat_dT2[i] - 2.0*x4*x8 + x5*x7\n                                    - x7*x9 + x3*c0)*exp(x10*x11))\n            d2Poyntings_dT2.append(d2Poyntings_dT2i)\n        return d2Poyntings_dT2\n\n    def dPoyntings_dP(self):\n        '''from sympy import *\n        R, T, P, zi = symbols('R, T, P, zi')\n        Vml = symbols('Vml', cls=Function)\n        cse(diff(exp(Vml(T)*(P - Psati(T))/(R*T)), P), optimizations='basic')\n        '''\n        try:\n            return self._dPoyntings_dP\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dP = [0.0]*self.N\n            return self._dPoyntings_dP\n        T, P = self.T, self.P\n        Psats = self.Psats()\n\n        Vms = self.Vms_sat()\n\n        self._dPoyntings_dP = dPoyntings_dPs = []\n        for i in range(self.N):\n            x0 = Vms[i]/(R*T)\n            dPoyntings_dPs.append(x0*exp(x0*(P - Psats[i])))\n        return dPoyntings_dPs\n\n    def d2Poyntings_dPdT(self):\n        '''\n        from sympy import *\n        R, T, P = symbols('R, T, P')\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\n        RT_inv = 1/(R*T)\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\n        Poyf = symbols('Poyf')\n        cse(diff(Poy, T, P).subs(Poy, Poyf), optimizations='basic')\n        '''\n        try:\n            return self._d2Poyntings_dPdT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dPdT = [0.0]*self.N\n            return self._d2Poyntings_dPdT\n\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms = self._Vms_sat\n        except AttributeError:\n            Vms = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._dVms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n\n        x0 = R_inv\n        x1 = 1.0/self.T\n        P = self.P\n        nRT_inv = -x0*x1\n        self._d2Poyntings_dPdT = d2Poyntings_dPdT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = x1*x2\n            x4 = dVms_sat_dT[i]\n            x5 = Psats[i]\n            x6 = P - x5\n            v = Poyntings[i]*nRT_inv*(x0*x3*(x2*dPsats_dT[i] + x3*x6 - x4*x6) + x3 - x4)\n            d2Poyntings_dPdT.append(v)\n        return d2Poyntings_dPdT\n\n\n    d2Poyntings_dTdP = d2Poyntings_dPdT\n\n    def phis_sat_at(self, T):\n        if not self.use_phis_sat:\n            return [1.0]*self.N\n        phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n    def phis_sat(self):\n        r'''Method to calculate and return the saturation fugacity coefficient\n        correction factors of the phase, [-].\n\n        These are calculated from the\n        provided pure-component equations of state. This term should only be\n        used with a consistent vapor-phase cubic equation of state.\n\n        Returns\n        -------\n        phis_sat : list[float]\n            Saturation fugacity coefficient correction factors, [-]\n\n        Notes\n        -----\n        .. warning::\n            This factor cannot be calculated when a compound is supercritical,\n            as there is no longer any vapor-liquid pure-component equilibrium\n            (by definition).\n\n        '''\n        try:\n            return self._phis_sat\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._phis_sat = [1.0]*self.N\n            return self._phis_sat\n\n        T = self.T\n        self._phis_sat = phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n\n\n\n    def dphis_sat_dT_at(self, T):\n        if not self.use_phis_sat:\n            return [0.0]*self.N\n        dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def dphis_sat_dT(self):\n        try:\n            return self._dphis_sat_dT\n        except AttributeError:\n            pass\n\n        if not self.use_phis_sat:\n            self._dphis_sat_dT = [0.0]*self.N\n            return self._dphis_sat_dT\n\n        T = self.T\n        self._dphis_sat_dT = dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def d2phis_sat_dT2(self):\n        # Numerically implemented\n        try:\n            return self._d2phis_sat_dT2\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._d2phis_sat_dT2 = [0.0]*self.N\n            return self._d2phis_sat_dT2\n\n        T = self.T\n        self._d2phis_sat_dT2 = d2phis_sat_dT2 = []\n        for i in self.eos_pure_instances:\n            try:\n                d2phis_sat_dT2.append(i.d2phi_sat_dT2(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR*i.Tc:\n                    d2phis_sat_dT2.append(0.0)\n                else:\n                    raise e\n        return d2phis_sat_dT2\n\n\n    def phis_at(self, T, P, zs, Psats=None, gammas=None, phis_sat=None, Poyntings=None):\n        P_inv = 1.0/P\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if gammas is None:\n            gammas = self.gammas_at(T, zs)\n        if phis_sat is None:\n            phis_sat = self.phis_sat_at(T)\n        if Poyntings is None:\n            Poyntings = self.Poyntings_at(T, P, Psats=Psats)\n        return [gammas[i]*Psats[i]*Poyntings[i]*phis_sat[i]*P_inv\n                for i in range(self.N)]\n\n    def phis(self):\n        r'''Method to calculate the fugacity coefficients of the\n        GibbsExcessLiquid phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\phi_i = \\frac{\\gamma_i P_{i}^{sat} \\phi_i^{sat} \\text{Poynting}_i}\n            {P}\n\n        Returns\n        -------\n        phis : list[float]\n            Fugacity coefficients of all components in the phase, [-]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1.\n        '''\n        try:\n            return self._phis\n        except AttributeError:\n            pass\n        P = self.P\n        try:\n            gammas = self._gammas\n        except AttributeError:\n            gammas = self.gammas()\n\n\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n\n        try:\n            phis_sat = self._phis_sat\n        except AttributeError:\n            phis_sat = self.phis_sat()\n\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n\n        P_inv = 1.0/P\n        self._phis = [gammas[i]*Psats[i]*Poyntings[i]*phis_sat[i]*P_inv\n                for i in range(self.N)]\n        return self._phis\n\n\n    def lnphis(self):\n        try:\n            return self._lnphis\n        except AttributeError:\n            pass\n        try:\n            self._lnphis = [log(i) for i in self.phis()]\n        except:\n            # Zero Psats - must compute them inline\n            P = self.P\n            try:\n                gammas = self._gammas\n            except AttributeError:\n                gammas = self.gammas()\n            try:\n                lnPsats = self._lnPsats\n            except AttributeError:\n                lnPsats = self.lnPsats()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n            P_inv = 1.0/P\n            self._lnphis = [log(gammas[i]*Poyntings[i]*phis_sat[i]*P_inv) + lnPsats[i]\n                    for i in range(self.N)]\n\n        return self._lnphis\n\n    lnphis_G_min = lnphis\n    lnphis_lowest_Gibbs = lnphis\n\n#    def fugacities(self, T, P, zs):\n#        # DO NOT EDIT _ CORRECT\n#        gammas = self.gammas(T, zs)\n#        Psats = self._Psats(T=T)\n#        if self.use_phis_sat:\n#            phis = self.phis(T=T, zs=zs)\n#        else:\n#            phis = [1.0]*self.N\n#\n#        if self.use_Poynting:\n#            Poyntings = self.Poyntings(T=T, P=P, Psats=Psats)\n#        else:\n#            Poyntings = [1.0]*self.N\n#        return [zs[i]*gammas[i]*Psats[i]*Poyntings[i]*phis[i]\n#                for i in range(self.N)]\n#\n#    def dphis_dxs(self):\n#        if\n    def dphis_dT(self):\n        try:\n            return self._dphis_dT\n        except AttributeError:\n            pass\n        P = self.P\n        Psats = self.Psats()\n        gammas = self.gammas()\n\n        if self.use_Poynting:\n            # Evidence suggests poynting derivatives are not worth calculating\n            dPoyntings_dT = self.dPoyntings_dT() #[0.0]*self.N\n            Poyntings = self.Poyntings()\n        else:\n            dPoyntings_dT = [0.0]*self.N\n            Poyntings = [1.0]*self.N\n\n        dPsats_dT = self.dPsats_dT()\n\n        dgammas_dT = self.GibbsExcessModel.dgammas_dT()\n\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT()\n            phis_sat = self.phis_sat()\n        else:\n            dphis_sat_dT = [0.0]*self.N\n            phis_sat = [1.0]*self.N\n\n#        print(gammas, phis_sat, Psats, Poyntings, dgammas_dT, dPoyntings_dT, dPsats_dT)\n        self._dphis_dT = dphis_dTl = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2*x3\n            x5 = x0*x1\n            v = (x0*x4*dphis_sat_dT[i] + x1*x4*dgammas_dT[i] + x2*x5*dPoyntings_dT[i] + x3*x5*dPsats_dT[i])/P\n            dphis_dTl.append(v)\n        return dphis_dTl\n\n    def dphis_dT_at(self, T, P, zs, phis_also=False):\n        Psats = self.Psats_at(T)\n        dPsats_dT = self.dPsats_dT_at(T, Psats)\n        Vms = self.Vms_sat_at(T)\n        dVms_sat_dT = self.dVms_sat_dT_at(T)\n\n        gammas = self.gammas_at(T, zs)\n        dgammas_dT = self.dgammas_dT_at(T, zs)\n\n        if self.use_Poynting:\n            Poyntings = self.Poyntings_at(T, P, Psats, Vms)\n            dPoyntings_dT = self.dPoyntings_dT_at(T, P, Psats=Psats, Vms=Vms, dPsats_dT=dPsats_dT, dVms_sat_dT=dVms_sat_dT)\n        else:\n            Poyntings = [1.0]*self.N\n            dPoyntings_dT = [0.0]*self.N\n\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT_at(T)\n            phis_sat = self.phis_sat_at(T)\n        else:\n            dphis_sat_dT = [0.0]*self.N\n            phis_sat = [1.0]*self.N\n\n\n        dphis_dT = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2*x3\n            x5 = x0*x1\n            v = (x0*x4*dphis_sat_dT[i] + x1*x4*dgammas_dT[i] + x2*x5*dPoyntings_dT[i] + x3*x5*dPsats_dT[i])/P\n            dphis_dT.append(v)\n        if phis_also:\n            P_inv = 1.0/P\n            phis = [gammas[i]*Psats[i]*Poyntings[i]*phis_sat[i]*P_inv for i in range(self.N)]\n            return dphis_dT, phis\n        return dphis_dT\n\n    def dlnphis_dT(self):\n        try:\n            return self._dlnphis_dT\n        except AttributeError:\n            pass\n        dphis_dT = self.dphis_dT()\n        phis = self.phis()\n        self._dlnphis_dT = [i/j for i, j in zip(dphis_dT, phis)]\n        return self._dlnphis_dT\n\n    def dlnphis_dP(self):\n        r'''Method to calculate the pressure derivative of log fugacity\n        coefficients of the phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\frac{\\partial \\ln \\phi_i}{\\partial P} =\n            \\frac{\\frac{\\partial \\text{Poynting}_i}{\\partial P}}\n            {\\text{Poynting}_i} - \\frac{1}{P}\n\n        Returns\n        -------\n        dlnphis_dP : list[float]\n            Pressure derivative of log fugacity coefficients of all components\n            in the phase, [1/Pa]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1. For\n        that case, :math:`\\frac{\\partial \\ln \\phi_i}{\\partial P}=\\frac{1}{P}`.\n        '''\n        try:\n            return self._dlnphis_dP\n        except AttributeError:\n            pass\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n\n        try:\n            dPoyntings_dP = self._dPoyntings_dP\n        except AttributeError:\n            dPoyntings_dP = self.dPoyntings_dP()\n\n        P_inv = 1.0/self.P\n\n        self._dlnphis_dP = [dPoyntings_dP[i]/Poyntings[i] - P_inv for i in range(self.N)]\n        return self._dlnphis_dP\n\n    def gammas_at(self, T, zs):\n        if self.composition_independent:\n            return [1.0]*self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).gammas()\n\n    def dgammas_dT_at(self, T, zs):\n        if self.composition_independent:\n            return [0.0]*self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).dgammas_dT()\n\n    def gammas(self):\n        r'''Method to calculate and return the activity coefficients of the\n        phase, [-]. This is a direct call to\n        :obj:`GibbsExcess.gammas <thermo.activity.GibbsExcess.gammas>`.\n\n        Returns\n        -------\n        gammas : list[float]\n            Activity coefficients, [-]\n        '''\n        try:\n            return self.GibbsExcessModel._gammas\n        except AttributeError:\n            return self.GibbsExcessModel.gammas()\n\n    def dgammas_dT(self):\n        r'''Method to calculate and return the temperature derivative of\n        activity coefficients of the phase, [-].\n\n        This is a direct call to\n        :obj:`GibbsExcess.dgammas_dT <thermo.activity.GibbsExcess.dgammas_dT>`.\n\n        Returns\n        -------\n        dgammas_dT : list[float]\n            First temperature derivative of the activity coefficients, [1/K]\n        '''\n        return self.GibbsExcessModel.dgammas_dT()\n\n    def H_old(self):\n#        try:\n#            return self._H\n#        except AttributeError:\n#            pass\n        # Untested\n        T = self.T\n        RT = R*T\n        P = self.P\n        zs, cmps = self.zs, range(self.N)\n        T_REF_IG = self.T_REF_IG\n        P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n\n        H = 0.0\n\n        if P_DEPENDENT_H_LIQ:\n            # Page 650  Chemical Thermodynamics for Process Simulation\n            # Confirmed with CoolProp via analytical integrals\n            # Not actually checked numerically until Hvap is implemented though\n            \"\"\"\n            from scipy.integrate import *\n            from CoolProp.CoolProp import PropsSI\n\n            fluid = 'decane'\n            T = 400\n            Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n            P2 = Psat*100\n            dP = P2 - Psat\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\n            Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\n            dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\n\n            def to_int(P):\n                Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\n                alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\n                return Vm -alpha*T*Vm\n            quad(to_int, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dH\n            \"\"\"\n\n            if self.use_IG_Cp:\n                try:\n                    Psats = self._Psats\n                except AttributeError:\n                    Psats = self.Psats()\n                try:\n                    dPsats_dT = self._dPsats_dT\n                except AttributeError:\n                    dPsats_dT = self.dPsats_dT()\n                try:\n                    Vms_sat = self._Vms_sat\n                except AttributeError:\n                    Vms_sat = self.Vms_sat()\n                try:\n                    dVms_sat_dT = self._Vms_sat_dT\n                except AttributeError:\n                    dVms_sat_dT = self.dVms_sat_dT()\n\n                failed_dPsat_dT = False\n                try:\n                    H = 0.0\n                    for i in cmps:\n                        dV_vap = R*T/Psats[i] - Vms_sat[i]\n    #                    print( R*T/Psats[i] , Vms_sat[i])\n                        # ratio of der to value might be easier?\n                        dS_vap = dPsats_dT[i]*dV_vap\n    #                    print(dPsats_dT[i]*dV_vap)\n                        Hvap = T*dS_vap\n                        H += zs[i]*(Cpig_integrals_pure[i] - Hvap)\n                except ZeroDivisionError:\n                    failed_dPsat_dT = True\n\n                if failed_dPsat_dT or isinf(H):\n                    # Handle the case where vapor pressure reaches zero - needs special implementations\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    H = 0.0\n                    for i in cmps:\n#                        dV_vap = R*T/Psats[i] - Vms_sat[i]\n#                        dS_vap = dPsats_dT[i]*dV_vap\n                        Hvap = T*dPsats_dT_over_Psats[i]*RT\n                        H += zs[i]*(Cpig_integrals_pure[i] - Hvap)\n\n                if self.use_Tait:\n                    dH_dP_integrals_Tait = self.dH_dP_integrals_Tait()\n                    for i in cmps:\n                        H += zs[i]*dH_dP_integrals_Tait[i]\n                elif self.use_Poynting:\n                    for i in cmps:\n                        # This bit is the differential with respect to pressure\n#                        dP = max(0.0, P - Psats[i]) # Breaks thermodynamic consistency\n                        dP = P - Psats[i]\n                        H += zs[i]*dP*(Vms_sat[i] - T*dVms_sat_dT[i])\n            else:\n                Psats = self.Psats()\n                Vms_sat = self.Vms_sat()\n                dVms_sat_dT = self.dVms_sat_dT()\n                dPsats_dT = self.dPsats_dT()\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Cpl_integrals_pure = self._Cpl_integrals_pure()\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                Vms_sat_T_ref = self.Vms_sat_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n\n                Hvaps = self.Hvaps()\n\n                H = 0.0\n                for i in range(self.N):\n                    H += zs[i]*(Cpl_integrals_pure[i] - Hvaps_T_ref[i])\n                    # If we can use the liquid heat capacity and prove its consistency\n\n                    # This bit is the differential with respect to pressure\n                    dP = P - Psats_T_ref[i]\n                    H += zs[i]*dP*(Vms_sat_T_ref[i] - T_REF_IG*dVms_sat_dT_T_ref[i])\n        else:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i]*(Cpig_integrals_pure[i] - Hvaps[i])\n        H += self.GibbsExcessModel.HE()\n#        self._H = H\n        return H\n    del H_old\n\n    def H(self):\n        r'''Method to calculate the enthalpy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}} \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}} \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i \\left[-RT^2\\left(\n            + \\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n             \\right)\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            H = H_{\\text{excess}} + \\sum_i z_i\\left[-H_{vap,i}\n            + \\int_{T,ref}^T C_{p,ig} dT \\right]\n\n        Returns\n        -------\n        H : float\n            Enthalpy of the phase, [J/(mol)]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._H\n        except AttributeError:\n            pass\n        H = 0.0\n        T = self.T\n        nRT2 = -R*T*T\n        zs, cmps = self.zs, range(self.N)\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n\n        if self.use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i]*(Cpig_integrals_pure[i] - Hvaps[i])\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            use_Poynting, use_phis_sat = self.use_Poynting, self.use_phis_sat\n\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    H += zs[i]*(nRT2*(dphis_sat_dT[i]/phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i])\n                                + Cpig_integrals_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    H += zs[i]*(nRT2*(dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i]) + Cpig_integrals_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    H += zs[i]*(nRT2*(dPsats_dT_over_Psats[i] + dphis_sat_dT[i]/phis_sat[i]) + Cpig_integrals_pure[i])\n            else:\n                for i in cmps:\n                    H += zs[i]*(nRT2*dPsats_dT_over_Psats[i] + Cpig_integrals_pure[i])\n\n        if not self.composition_independent:\n            H += self.GibbsExcessModel.HE()\n        self._H = H\n        return H\n\n    def S_old(self):\n#        try:\n#            return self._S\n#        except AttributeError:\n#            pass\n        # Untested\n        # Page 650  Chemical Thermodynamics for Process Simulation\n        '''\n        from scipy.integrate import *\n        from CoolProp.CoolProp import PropsSI\n\n        fluid = 'decane'\n        T = 400\n        Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n        P2 = Psat*100\n        dP = P2 - Psat\n        Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\n        Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\n        dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\n        dS = PropsSI('SMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('SMOLAR', 'T', T, 'Q', 0, fluid)\n        def to_int2(P):\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\n            alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\n            return -alpha*Vm\n        quad(to_int2, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dS\n        '''\n        S = 0.0\n        T, P, zs, cmps = self.T, self.P, self.zs, range(self.N)\n        log_zs = self.log_zs()\n        for i in cmps:\n            S -= zs[i]*log_zs[i]\n        S *= R\n        S_base = S\n\n        T_inv = 1.0/T\n        RT = R*T\n\n        P_REF_IG_INV = self.P_REF_IG_INV\n\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._Vms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n\n        if self.P_DEPENDENT_H_LIQ:\n            if self.use_IG_Cp:\n                failed_dPsat_dT = False\n                try:\n                    for i in range(self.N):\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dVsat = R*T/Psats[i] - Vms_sat[i]\n                        dSvap = dPsats_dT[i]*dVsat\n        #                dSvap = Hvaps[i]/T # Confirmed - this line breaks everything - do not use\n                        dSi -= dSvap\n        #                dSi = Cpig_integrals_over_T_pure[i] - Hvaps[i]*T_inv # Do the transition at the temperature of the liquid\n                        # Take each component to its reference state change - saturation pressure\n        #                dSi -= R*log(P*P_REF_IG_INV)\n                        dSi -= R*log(Psats[i]*P_REF_IG_INV)\n        #                dSi -= R*log(P/101325.0)\n                        # Only include the\n                        dP = P - Psats[i]\n    #                    dP = max(0.0, P - Psats[i])\n        #                if dP > 0.0:\n                        # I believe should include effect of pressure on all components, regardless of phase\n                        dSi -= dP*dVms_sat_dT[i]\n                        S += dSi*zs[i]\n                except (ZeroDivisionError, ValueError):\n                    # Handle the zero division on Psat or the log getting two small\n                    failed_dPsat_dT = True\n\n                if failed_dPsat_dT or isinf(S):\n                    S = S_base\n                    # Handle the case where vapor pressure reaches zero - needs special implementations\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    lnPsats = self.lnPsats()\n                    LOG_P_REF_IG = self.LOG_P_REF_IG\n                    for i in cmps:\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dSvap = RT*dPsats_dT_over_Psats[i]\n                        dSi -= dSvap\n                        dSi -= R*(lnPsats[i] - LOG_P_REF_IG)#   trunc_log(Psats[i]*P_REF_IG_INV)\n                        dSi -= P*dVms_sat_dT[i]\n                        S += dSi*zs[i]\n\n                if self.use_Tait:\n                    pass\n                elif self.use_Poynting:\n                    pass\n#                for i in cmps:\n\n            else:\n                # mine\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n                Cpl_integrals_over_T_pure = self._Cpl_integrals_over_T_pure()\n                T_REF_IG_INV = self.T_REF_IG_INV\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                # Vms_sat_T_ref = self.Vms_sat_T_ref()\n\n                for i in range(self.N):\n                    dSi = Cpl_integrals_over_T_pure[i]\n                    dSi -= Hvaps_T_ref[i]*T_REF_IG_INV\n                    # Take each component to its reference state change - saturation pressure\n                    dSi -= R*log(Psats_T_ref[i]*P_REF_IG_INV)\n                    # I believe should include effect of pressure on all components, regardless of phase\n\n\n                    dP = P - Psats_T_ref[i]\n                    dSi -= dP*dVms_sat_dT_T_ref[i]\n                    S += dSi*zs[i]\n#                else:\n#                    # COCO\n#                    Hvaps = self.Hvaps()\n#                    Psats_T_ref = self.Psats_T_ref()\n#                    _Cpl_integrals_over_T_pure = self._Cpl_integrals_over_T_pure()\n#                    T_REF_IG_INV = self.T_REF_IG_INV\n#\n#                    for i in range(self.N):\n#                        dSi = -_Cpl_integrals_over_T_pure[i]\n#                        dSi -= Hvaps[i]/T\n#                        # Take each component to its reference state change - saturation pressure\n#                        dSi -= R*log(Psats[i]*P_REF_IG_INV)\n#\n#                        dP = P - Psats[i]\n#                        # I believe should include effect of pressure on all components, regardless of phase\n#                        dSi -= dP*dVms_sat_dT[i]\n#                        S += dSi*zs[i]\n        else:\n            Hvaps = self.Hvaps()\n            for i in cmps:\n                Sg298_to_T = Cpig_integrals_over_T_pure[i]\n                Svap = -Hvaps[i]*T_inv # Do the transition at the temperature of the liquid\n                S += zs[i]*(Sg298_to_T + Svap - R*log(P*P_REF_IG_INV))\n#        self._S =\n        S = S + self.GibbsExcessModel.SE()\n        return S\n\n    def S(self):\n        r'''Method to calculate the entropy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + T\\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\text{Poynting}\\cdot\\phi_{\\text{sat},i}}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T \\frac{\\frac{\\partial \\phi_{\\text{sat},i}}{\\partial T}}{\\phi_{\\text{sat},i}}\n            + T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\phi_{\\text{sat},i}}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + T\\frac{\\frac{\\text{Poynting}}{\\partial T}}{\\text{Poynting}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{\\text{Poynting}}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\n            T\\frac{\\frac{\\partial P_{\\text{sat},i}}{\\partial T}}{P_{\\text{sat},i}}\n            + \\ln(P_{\\text{sat},i}) + \\ln\\left(\\frac{1}{P}\\right)\n            \\right) - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            S = S_{\\text{excess}} - R\\sum_i z_i\\ln z_i - R\\ln\\left(\\frac{P}{P_{ref}}\\right)\n            - \\sum_i z_i\\left[R\\left(\\ln P_{\\text{sat},i} + \\ln\\left(\\frac{1}{P}\\right)\\right)\n            + \\frac{H_{vap,i}}{T}\n            - \\int_{T,ref}^T \\frac{C_{p,ig,i}}{T} dT \\right]\n\n        Returns\n        -------\n        S : float\n            Entropy of the phase, [J/(mol*K)]\n\n        Notes\n        -----\n        '''\n        try:\n            return self._S\n        except AttributeError:\n            pass\n        T, P = self.T, self.P\n        P_inv = 1.0/P\n        zs, cmps = self.zs, range(self.N)\n\n        log_zs = self.log_zs()\n        S_comp = 0.0\n        for i in cmps:\n            S_comp -= zs[i]*log_zs[i]\n        S = S_comp - log(P*self.P_REF_IG_INV)\n        S *= R\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n\n        try:\n            lnPsats = self._lnPsats\n        except AttributeError:\n            lnPsats = self.lnPsats()\n\n        use_Poynting, use_phis_sat, use_Hvap_caloric = self.use_Poynting, self.use_phis_sat, self.use_Hvap_caloric\n\n        if use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            T_inv = 1.0/T\n            logP_inv = log(P_inv)\n            # Almost the same as no Poynting\n            for i in cmps:\n                S -= zs[i]*(R*(lnPsats[i] + logP_inv)\n                            - Cpig_integrals_over_T_pure[i] + Hvaps[i]*T_inv)\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    S -= zs[i]*(R*(T*(dphis_sat_dT[i]/phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i])\n                                + lnPsats[i] + log(Poyntings[i]*phis_sat[i]*P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    S -= zs[i]*(R*(T*(dPsats_dT_over_Psats[i] + dPoyntings_dT[i]/Poyntings[i])\n                                + lnPsats[i] + log(Poyntings[i]*P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    S -= zs[i]*(R*(T*(dphis_sat_dT[i]/phis_sat[i] + dPsats_dT_over_Psats[i])\n                                + lnPsats[i] + log(phis_sat[i]*P_inv)) - Cpig_integrals_over_T_pure[i])\n            else:\n                logP_inv = log(P_inv)\n                for i in cmps:\n                    S -= zs[i]*(R*(T*dPsats_dT_over_Psats[i] + lnPsats[i] + logP_inv)\n                                - Cpig_integrals_over_T_pure[i])\n\n        if not self.composition_independent:\n            S += self.GibbsExcessModel.SE()\n        self._S = S\n        return S\n\n    def Cp_old(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        # Needs testing\n        T, P, P_DEPENDENT_H_LIQ = self.T, self.P, self.P_DEPENDENT_H_LIQ\n        Cp, zs = 0.0, self.zs\n        Cpigs_pure = self.Cpigs_pure()\n        if P_DEPENDENT_H_LIQ:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            try:\n                dPsats_dT = self._dPsats_dT\n            except AttributeError:\n                dPsats_dT = self.dPsats_dT()\n            try:\n                d2Psats_dT2 = self._d2Psats_dT2\n            except AttributeError:\n                d2Psats_dT2 = self.d2Psats_dT2()\n            try:\n                Vms_sat = self._Vms_sat\n            except AttributeError:\n                Vms_sat = self.Vms_sat()\n            try:\n                dVms_sat_dT = self._Vms_sat_dT\n            except AttributeError:\n                dVms_sat_dT = self.dVms_sat_dT()\n            try:\n                d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n            except AttributeError:\n                d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n\n            failed_dPsat_dT = False\n            try:\n                for i in range(self.N):\n                    x0 = Psats[i]\n                    Psat_inv = 1.0/x0\n                    x1 = Vms_sat[i]\n                    x2 = dPsats_dT[i]\n                    x3 = R*Psat_inv\n                    x4 = T*x3\n                    x5 = -x1\n                    x6 = dVms_sat_dT[i]\n                    x7 = T*x2\n    #                print(#-T*(P - x0)*d2Vms_sat_dT2[i],\n    #                       - T*(x4 + x5)*d2Psats_dT2[i], T, x4, x5, d2Psats_dT2[i],\n                           #x2*(x1 - x4) + x2*(T*x6 + x5) - x7*(-R*x7*Psat_inv*Psat_inv + x3 - x6),\n                           #Cpigs_pure[i]\n    #                       )\n                    Cp += zs[i]*(-T*(P - x0)*d2Vms_sat_dT2[i] - T*(x4 + x5)*d2Psats_dT2[i]\n                    + x2*(x1 - x4) + x2*(T*x6 + x5) - x7*(-R*x7*Psat_inv*Psat_inv + x3 - x6) + Cpigs_pure[i])\n                    # The second derivative of volume is zero when extrapolating, which causes zero issues, discontinuous derivative\n                \"\"\"\n                from sympy import *\n                T, P, R, zi = symbols('T, P, R, zi')\n                Psat, Cpig_int, Vmsat = symbols('Psat, Cpig_int, Vmsat', cls=Function)\n                dVmsatdT = diff(Vmsat(T), T)\n                dPsatdT = diff(Psat(T), T)\n                dV_vap = R*T/Psat(T) - Vmsat(T)\n                dS_vap = dPsatdT*dV_vap\n                Hvap = T*dS_vap\n                H = zi*(Cpig_int(T) - Hvap)\n\n                dP = P - Psat(T)\n                H += zi*dP*(Vmsat(T) - T*dVmsatdT)\n\n                (cse(diff(H, T), optimizations='basic'))\n                \"\"\"\n            except (ZeroDivisionError, ValueError):\n                # Handle the zero division on Psat or the log getting two small\n                failed_dPsat_dT = True\n\n            if failed_dPsat_dT or isinf(Cp) or isnan(Cp):\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n                Cp = 0.0\n                for i in range(self.N):\n                    Cp += zs[i]*(Cpigs_pure[i] - P*T*d2Vms_sat_dT2[i] - R*T*T*d2lnPsats_dT2[i]\n                    - 2.0*R*T*dlnPsats_dT[i])\n                    \"\"\"\n                    from sympy import *\n                    T, P, R, zi = symbols('T, P, R, zi')\n                    lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\n                    dVmsatdT = diff(Vmsat(T), T)\n                    dPsatdT = diff(exp(lnPsat(T)), T)\n                    dV_vap = R*T/exp(lnPsat(T)) - Vmsat(T)\n                    dS_vap = dPsatdT*dV_vap\n                    Hvap = T*dS_vap\n                    H = zi*(Cpig_int(T) - Hvap)\n                    dP = P\n                    H += zi*dP*(Vmsat(T) - T*dVmsatdT)\n                    print(simplify(expand(diff(H, T)).subs(exp(lnPsat(T)), 0)/zi))\n                    \"\"\"\n#                Cp += zs[i]*(Cpigs_pure[i] - dHvaps_dT[i])\n#                Cp += zs[i]*(-T*(P - Psats[i])*d2Vms_sat_dT2[i] + (T*dVms_sat_dT[i] - Vms_sat[i])*dPsats_dT[i])\n\n        else:\n            dHvaps_dT = self.dHvaps_dT()\n            for i in range(self.N):\n                Cp += zs[i]*(Cpigs_pure[i] - dHvaps_dT[i])\n\n        Cp += self.GibbsExcessModel.CpE()\n        return Cp\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        T, zs, cmps = self.T, self.zs, range(self.N)\n        Cpigs_pure = self.Cpigs_pure()\n        use_Poynting, use_phis_sat = self.use_Poynting, self.use_phis_sat\n\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n\n        RT = R*T\n        RT2 = RT*T\n        RT2_2 = RT + RT\n\n        Cp = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                phi_inv = 1.0/phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0/phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        else:\n            for i in cmps:\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dPsats_dT_over_Psats[i]\n                Cp -= zs[i]*(RT2*a + RT2_2*b - Cpigs_pure[i])\n        if not self.composition_independent:\n            Cp += self.GibbsExcessModel.CpE()\n        self._Cp = Cp\n        return Cp\n\n    dH_dT = Cp\n\n    def dS_dT_old(self):\n        # Needs testing\n        T, P, P_DEPENDENT_H_LIQ = self.T, self.P, self.P_DEPENDENT_H_LIQ\n        RT = R*T\n        zs = self.zs\n        Cpigs_pure = self.Cpigs_pure()\n        dS_dT = 0.0\n        T_inv = 1.0/T\n        if P_DEPENDENT_H_LIQ:\n            d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n            dVms_sat_dT = self.dVms_sat_dT()\n            Vms_sat = self.Vms_sat()\n            Psats = self.Psats()\n            dPsats_dT = self.dPsats_dT()\n            d2Psats_dT2 = self.d2Psats_dT2()\n            failed_dPsat_dT = False\n            for Psat in Psats:\n                if Psat < 1e-40:\n                    failed_dPsat_dT = True\n            if not failed_dPsat_dT:\n                try:\n                    \"\"\"\n                    from sympy import *\n                    T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\n\n                    Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\n                    dVmsatdT = diff(Vmsat(T), T)\n                    dPsatdT = diff(Psat(T), T)\n\n                    S = 0\n                    dSi = Cpig_T_int(T)\n                    dVsat = R*T/Psat(T) - Vmsat(T)\n                    dSvap = dPsatdT*dVsat\n                    dSi -= dSvap\n                    dSi -= R*log(Psat(T)/P_REF_IG)\n                    dP = P - Psat(T)\n                    dSi -= dP*dVmsatdT\n                    S += dSi*zi\n                    # cse(diff(S, T), optimizations='basic')\n                    \"\"\"\n                    for i in range(self.N):\n                        x0 = Psats[i]\n                        x1 = dPsats_dT[i]\n                        x2 = R/x0\n                        x3 = Vms_sat[i]\n                        x4 = dVms_sat_dT[i]\n                        dS_dT -= zs[i]*(x1*x2 - x1*x4 - x1*(RT*x1/x0**2 - x2 + x4) + (P - x0)*d2Vms_sat_dT2[i]\n                        + (T*x2 - x3)*d2Psats_dT2[i] - Cpigs_pure[i]*T_inv)\n                except (ZeroDivisionError, ValueError):\n                    # Handle the zero division on Psat or the log getting two small\n                    failed_dPsat_dT = True\n\n            if failed_dPsat_dT:\n                # lnPsats = self.lnPsats()\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n#                P*Derivative(Vmsat(T), (T, 2))\n#                R*T*Derivative(lnPsat(T), (T, 2))\n#                 2*R*Derivative(lnPsat(T), T) + Derivative(Cpig_T_int(T), T)\n                \"\"\"\n                from sympy import *\n                T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\n\n                lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\n                # Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\n                dVmsatdT = diff(Vmsat(T), T)\n                dPsatdT = diff(exp(lnPsat(T)), T)\n\n                S = 0\n                dSi = Cpig_T_int(T)\n                dVsat = R*T/exp(lnPsat(T)) - Vmsat(T)\n                dSvap = dPsatdT*dVsat\n                dSi -= dSvap\n                # dSi -= R*log(Psat(T)/P_REF_IG)\n                dSi -= R*(lnPsat(T) - log(P_REF_IG))\n                dP = P - exp(lnPsat(T))\n                dSi -= dP*dVmsatdT\n                S += dSi*zi\n                # cse(diff(S, T), optimizations='basic')\n                print(simplify(expand(diff(S, T)).subs(exp(lnPsat(T)), 0)/zi))\n\n\n                \"\"\"\n                dS_dT = 0.0\n                for i in range(self.N):\n                    dS_dT -= zs[i]*(P*d2Vms_sat_dT2[i] + RT*d2lnPsats_dT2[i]\n                    + 2.0*R*dlnPsats_dT[i]- Cpigs_pure[i]*T_inv)\n\n        dS_dT += self.GibbsExcessModel.dSE_dT()\n        return dS_dT\n\n    def dS_dT(self):\n        try:\n            return self._dS_dT\n        except AttributeError:\n            pass\n        T, zs, cmps = self.T, self.zs, range(self.N)\n        use_Poynting, use_phis_sat = self.use_Poynting, self.use_phis_sat\n\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n        Cpigs_pure = self.Cpigs_pure()\n\n        T_inv = 1.0/T\n        RT = R*T\n        R_2 = R + R\n\n        dS_dT = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                phi_inv = 1.0/phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0/Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i]*Poy_inv\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i]\n                     + d2Poyntings_dT2[i]*Poy_inv - dPoy_ratio*dPoy_ratio)\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0/phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i]*phi_inv\n                a = (d2phis_sat_dT2[i]*phi_inv - dphi_ratio*dphi_ratio\n                     + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        else:\n            for i in cmps:\n                a = (d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i]*dPsats_dT_over_Psats[i])\n                b = dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i]*((RT*a + b*R_2) - Cpigs_pure[i]*T_inv)\n        if not self.composition_independent:\n            dS_dT += self.GibbsExcessModel.dSE_dT()\n        self._dS_dT = dS_dT\n        return dS_dT\n\n    def dH_dP(self):\n        try:\n            return self._dH_dP\n        except AttributeError:\n            pass\n        T = self.T\n        zs = self.zs\n        dH_dP = 0.0\n        if self.use_Poynting:\n            nRT2 = -R*T*T\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0/Poyntings[i]\n                dH_dP += nRT2*zs[i]*Poy_inv*(d2Poyntings_dPdT[i] - dPoyntings_dP[i]*dPoyntings_dT[i]*Poy_inv)\n\n#        if self.P_DEPENDENT_H_LIQ:\n#            if self.use_IG_Cp:\n#                Vms_sat = self.Vms_sat()\n#                dVms_sat_dT = self.dVms_sat_dT()\n#                Psats = self.Psats()\n#                for i in range(self.N):\n#                    if P > Psats[i]:\n#                        dH_dP += zs[i]*(-T*dVms_sat_dT[i] + Vms_sat[i])\n        self._dH_dP = dH_dP\n        return dH_dP\n\n\n    def dS_dP(self):\n        try:\n            return self._dS_dP\n        except AttributeError:\n            pass\n        T = self.T\n        P = self.P\n        P_inv = 1.0/P\n        zs = self.zs\n        if self.use_Poynting:\n            dS_dP = -R*P_inv\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0/Poyntings[i]\n                dS_dP -= zs[i]*R*Poy_inv*(dPoyntings_dP[i] - Poyntings[i]*P_inv\n                        +T*(d2Poyntings_dPdT[i] - dPoyntings_dP[i]*dPoyntings_dT[i]*Poy_inv))\n        else:\n            dS_dP = 0.0\n#        if self.P_DEPENDENT_H_LIQ:\n#            if self.use_IG_Cp:\n#                dVms_sat_dT = self.dVms_sat_dT()\n#                Psats = self.Psats()\n#                for i in range(self.N):\n#                    if P > Psats[i]:\n#                        dS_dP -= zs[i]*(dVms_sat_dT[i])\n        self._dS_dP = dS_dP\n        return dS_dP\n\n    def H_dep(self):\n        return self.H() - self.H_ideal_gas()\n\n    def S_dep(self):\n        return self.S() - self.S_ideal_gas()\n\n    def Cp_dep(self):\n        return self.Cp() - self.Cp_ideal_gas()\n\n    ### Volumetric properties\n    def V(self):\n        try:\n            return self._V\n        except AttributeError:\n            pass\n        zs = self.zs\n        Vms = self.Vms()\n        \"\"\"To make a fugacity-volume identity consistent, cannot use pressure\n        correction unless the Poynting factor is calculated with quadrature/\n        integration.\n        \"\"\"\n        V = 0.0\n        for i in range(self.N):\n            V += zs[i]*Vms[i]\n        self._V = V\n        return V\n\n    def dV_dT(self):\n        try:\n            return self._dV_dT\n        except AttributeError:\n            pass\n        zs = self.zs\n        dVms_sat_dT = self.dVms_sat_dT()\n        dV_dT = 0.0\n        for i in range(self.N):\n            dV_dT += zs[i]*dVms_sat_dT[i]\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def d2V_dT2(self):\n        try:\n            return self._d2V_dT2\n        except AttributeError:\n            pass\n        zs = self.zs\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n        d2V_dT2 = 0.0\n        for i in range(self.N):\n            d2V_dT2 += zs[i]*d2Vms_sat_dT2[i]\n        self._d2V_dT2 = d2V_dT2\n        return d2V_dT2\n\n    # Main needed volume derivatives\n    def dP_dV(self):\n        try:\n            return self._dP_dV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._dP_dV = self.INCOMPRESSIBLE_CONST #1.0/self.VolumeLiquidMixture.property_derivative_P(self.T, self.P, self.zs, order=1)\n\n        return self._dP_dV\n\n    def d2P_dV2(self):\n        try:\n            return self._d2P_dV2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dV2 = self.INCOMPRESSIBLE_CONST #self.d2V_dP2()/-(self.dP_dV())**-3\n        return self._d2P_dV2\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except AttributeError:\n            pass\n        self._dP_dT = self.dV_dT()/-self.dP_dV()\n        return self._dP_dT\n\n    def d2P_dTdV(self):\n        try:\n            return self._d2P_dTdV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dTdV = 0.0\n        else:\n            P = self.P\n            def dP_dV_for_diff(T):\n                return 1.0/self.VolumeLiquidMixture.property_derivative_P(T, P, self.zs, order=1)\n\n            self._d2P_dTdV = derivative(dP_dV_for_diff, self.T)\n        return self._d2P_dTdV\n\n    def d2P_dT2(self):\n        try:\n            return self._d2P_dT2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dT2 = -self.d2V_dT2()/self.INCOMPRESSIBLE_CONST\n        else:\n            P, zs = self.P, self.zs\n            def dP_dT_for_diff(T):\n                dV_dT = self.VolumeLiquidMixture.property_derivative_T(T, P, zs, order=1)\n                dP_dV = 1.0/self.VolumeLiquidMixture.property_derivative_P(T, P, zs, order=1)\n                dP_dT = dV_dT/-dP_dV\n                return dP_dT\n\n            self._d2P_dT2 = derivative(dP_dT_for_diff, self.T)\n        return self._d2P_dT2\n\n    # Volume derivatives which needed to be implemented for the main ones\n    def d2V_dP2(self):\n        try:\n            return self._d2V_dP2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2V_dP2 = 0.0\n        return self._d2V_dP2\n\n    def Tait_Bs(self):\n        try:\n            return self._Tait_Bs\n        except:\n            pass\n\n        self._Tait_Bs = evaluate_linear_fits(self._Tait_B_data, self.T)\n        return self._Tait_Bs\n\n    def dTait_B_dTs(self):\n        try:\n            return self._dTait_B_dTs\n        except:\n            pass\n\n        self._dTait_B_dTs = evaluate_linear_fits_d(self._Tait_B_data, self.T)\n        return self._dTait_B_dTs\n\n    def d2Tait_B_dT2s(self):\n        try:\n            return self._d2Tait_B_dT2s\n        except:\n            pass\n\n        self._d2Tait_B_dT2s = evaluate_linear_fits_d2(self._Tait_B_data, self.T)\n        return self._d2Tait_B_dT2s\n\n    def Tait_Cs(self):\n        try:\n            return self._Tait_Cs\n        except:\n            pass\n\n        self._Tait_Cs = evaluate_linear_fits(self._Tait_C_data, self.T)\n        return self._Tait_Cs\n\n    def dTait_C_dTs(self):\n        try:\n            return self._dTait_C_dTs\n        except:\n            pass\n\n        self._dTait_C_dTs = evaluate_linear_fits_d(self._Tait_C_data, self.T)\n        return self._dTait_C_dTs\n\n    def d2Tait_C_dT2s(self):\n        try:\n            return self._d2Tait_C_dT2s\n        except:\n            pass\n\n        self._d2Tait_C_dT2s = evaluate_linear_fits_d2(self._Tait_C_data, self.T)\n        return self._d2Tait_C_dT2s\n\n    def Tait_Vs(self):\n        Vms_sat = self.Vms_sat()\n        Psats = self.Psats()\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        P = self.P\n        return [Vms_sat[i]*(1.0  - Tait_Cs[i]*log((Tait_Bs[i] + P)/(Tait_Bs[i] + Psats[i]) ))\n                for i in range(self.N)]\n\n\n    def dH_dP_integrals_Tait(self):\n        try:\n            return self._dH_dP_integrals_Tait\n        except AttributeError:\n            pass\n        Psats = self.Psats()\n        Vms_sat = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        dPsats_dT = self.dPsats_dT()\n\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        dTait_C_dTs = self.dTait_C_dTs()\n        dTait_B_dTs = self.dTait_B_dTs()\n        T, P = self.T, self.P\n\n\n        self._dH_dP_integrals_Tait = dH_dP_integrals_Tait = []\n\n#        def to_int(P, i):\n#            l = self.to_TP_zs(T, P, zs)\n##            def to_diff(T):\n##                return self.to_TP_zs(T, P, zs).Tait_Vs()[i]\n##            dV_dT = derivative(to_diff, T, dx=1e-5*T, order=11)\n#\n#            x0 = l.Vms_sat()[i]\n#            x1 = l.Tait_Cs()[i]\n#            x2 = l.Tait_Bs()[i]\n#            x3 = P + x2\n#            x4 = l.Psats()[i]\n#            x5 = x3/(x2 + x4)\n#            x6 = log(x5)\n#            x7 = l.dTait_B_dTs()[i]\n#            dV_dT = (-x0*(x1*(-x5*(x7 +l.dPsats_dT()[i]) + x7)/x3\n#                                   + x6*l.dTait_C_dTs()[i])\n#                        - (x1*x6 - 1.0)*l.dVms_sat_dT()[i])\n#\n##            print(dV_dT, dV_dT2, dV_dT/dV_dT2, T, P)\n#\n#            V = l.Tait_Vs()[i]\n#            return V - T*dV_dT\n#        from scipy.integrate import quad\n#        _dH_dP_integrals_Tait = [quad(to_int, Psats[i], P, args=i)[0]\n#                                      for i in range(self.N)]\n##        return self._dH_dP_integrals_Tait\n#        print(_dH_dP_integrals_Tait)\n#        self._dH_dP_integrals_Tait2 = _dH_dP_integrals_Tait\n#        return self._dH_dP_integrals_Tait2\n\n#        dH_dP_integrals_Tait = []\n        for i in range(self.N):\n            # Very wrong according to numerical integration. Is it an issue with\n            # the translation to code, one of the derivatives, what was integrated,\n            # or sympy's integration?\n            x0 = Tait_Bs[i]\n            x1 = P + x0\n            x2 = Psats[i]\n            x3 = x0 + x2\n            x4 = 1.0/x3\n            x5 = Tait_Cs[i]\n            x6 = Vms_sat[i]\n            x7 = x5*x6\n            x8 = T*dVms_sat_dT[i]\n            x9 = x5*x8\n            x10 = T*dTait_C_dTs[i]\n            x11 = x0*x6\n            x12 = T*x7\n            x13 = -x0*x7 + x0*x9 + x10*x11 + x12*dTait_B_dTs[i]\n            x14 = x2*x6\n            x15 = x4*(x0*x8 + x10*x14 - x11 + x12*dPsats_dT[i] + x13 - x14 - x2*x7 + x2*x8 + x2*x9)\n            val = -P*x15 + P*(x10*x6 - x7 + x9)*log(x1*x4) + x13*log(x1) - x13*log(x3) + x15*x2\n            dH_dP_integrals_Tait.append(val)\n#        print(dH_dP_integrals_Tait, self._dH_dP_integrals_Tait2)\n        return dH_dP_integrals_Tait\n\n    def mu(self):\n        try:\n            return self._mu\n        except AttributeError:\n            pass\n        mu = self._mu = self.correlations.ViscosityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return mu\n\n    def k(self):\n        try:\n            return self._k\n        except AttributeError:\n            pass\n        self._k = k = self.correlations.ThermalConductivityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return k\n\n\nclass GibbsExcessSolid(GibbsExcessLiquid):\n    ideal_gas_basis = True\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    pure_references = ('HeatCapacityGases','SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\n\n\n    model_attributes = ('Hfs', 'Gfs', 'Sfs','GibbsExcessModel',\n                        'eos_pure_instances', 'use_Poynting', 'use_phis_sat',\n                        'use_eos_volume', 'henry_components',\n                        'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs',\n                         'Psat_extrpolation') + pure_references\n\n    def __init__(self, SublimationPressures, VolumeSolids=None,\n                 GibbsExcessModel=IdealSolution,\n                 eos_pure_instances=None,\n                 VolumeLiquidMixture=None,\n                 HeatCapacityGases=None,\n                 EnthalpySublimations=None,\n                 use_Poynting=False,\n                 use_phis_sat=False,\n                 Hfs=None, Gfs=None, Sfs=None,\n                 T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None,\n                 ):\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids,\n              HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations,\n              use_Poynting=use_Poynting,\n              Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)\n"
  },
  "GT_src_dict": {
    "thermo/interaction_parameters.py": {
      "InteractionParameterDB.has_ip_specific": {
        "code": "    def has_ip_specific(self, name, CASs, ip):\n        \"\"\"Check if a specific interaction parameter (IP) exists for a given set of CAS numbers in the specified data table. This method first constructs a key based on the CAS numbers, with consideration for whether the interaction parameters are symmetric. It then checks if the key is in the data table and if the specified parameter is present for that key. \n\nParameters\n----------\nname : str\n    The name of the data table to check, e.g., 'ChemSep PR'.\nCASs : Iterable[str]\n    A list or collection of CAS numbers for which the interaction parameter is being queried. The order of CAS numbers does not need to be sorted.\nip : str\n    The name of the interaction parameter to check for, e.g., 'kij'.\n\nReturns\n-------\npresent : bool\n    Returns `True` if the interaction parameter exists for the specified CAS numbers in the table; otherwise, returns `False`.\n\nThis method utilizes the `self.metadata` dictionary to check if the interaction parameters are symmetric using the 'symmetric' key. The `sorted_CAS_key` function from the `chemicals.identifiers` module is used to sort CAS numbers for symmetric parameters appropriately.\"\"\"\n        \"Check if a bip exists in a table.\\n\\n        Parameters\\n        ----------\\n        name : str\\n            Name of the data table, [-]\\n        CASs : Iterable[str]\\n            CAS numbers; they do not need to be sorted, [-]\\n        ip : str\\n            Name of the parameter to retrieve, [-]\\n\\n        Returns\\n        -------\\n        present : bool\\n            Whether or not the data is included in the table, [-]\\n\\n        Examples\\n        --------\\n        Check if nitrogen-ethane as a PR BIP:\\n\\n        >>> from thermo.interaction_parameters import IPDB\\n        >>> IPDB.has_ip_specific('ChemSep PR', ['7727-37-9', '74-84-0'], 'kij')\\n        True\\n        \"\n        if self.metadata[name]['symmetric']:\n            key = ' '.join(sorted_CAS_key(CASs))\n        else:\n            key = ' '.join(CASs)\n        table = self.tables[name]\n        if key not in table:\n            return False\n        return ip in table[key]",
        "docstring": "Check if a specific interaction parameter (IP) exists for a given set of CAS numbers in the specified data table. This method first constructs a key based on the CAS numbers, with consideration for whether the interaction parameters are symmetric. It then checks if the key is in the data table and if the specified parameter is present for that key. \n\nParameters\n----------\nname : str\n    The name of the data table to check, e.g., 'ChemSep PR'.\nCASs : Iterable[str]\n    A list or collection of CAS numbers for which the interaction parameter is being queried. The order of CAS numbers does not need to be sorted.\nip : str\n    The name of the interaction parameter to check for, e.g., 'kij'.\n\nReturns\n-------\npresent : bool\n    Returns `True` if the interaction parameter exists for the specified CAS numbers in the table; otherwise, returns `False`.\n\nThis method utilizes the `self.metadata` dictionary to check if the interaction parameters are symmetric using the 'symmetric' key. The `sorted_CAS_key` function from the `chemicals.identifiers` module is used to sort CAS numbers for symmetric parameters appropriately.",
        "signature": "def has_ip_specific(self, name, CASs, ip):",
        "type": "Method",
        "class_signature": "class InteractionParameterDB:"
      },
      "InteractionParameterDB.get_ip_specific": {
        "code": "    def get_ip_specific(self, name, CASs, ip):\n        \"\"\"Retrieve a specific interaction parameter from a designated database table. If the parameter is not found, this method returns a predefined 'missing' value as specified in the metadata.\n\nParameters\n----------\nname : str\n    The name of the interaction parameter table to look into.\nCASs : Iterable[str]\n    A collection of CAS numbers for the components involved, order does not matter.\nip : str\n    The specific interaction parameter to retrieve.\n\nReturns\n-------\nfloat\n    The value of the specified interaction parameter. If the parameter is not present, the default missing value from the table's metadata is returned.\n\nNotes\n-----\nThis function utilizes the `symmetric` property from the `metadata` dictionary to determine the appropriate key format. It uses the `sorted_CAS_key` from the `chemicals.utils` module to sort CAS numbers, ensuring consistency for symmetric parameters. If the specified key is not found, a `KeyError` is caught, and the missing value is retrieved from the metadata.\"\"\"\n        \"Get an interaction parameter from a table. If the specified\\n        parameter is missing, the default `missing` value as defined in\\n        the data file is returned instead.\\n\\n        Parameters\\n        ----------\\n        name : str\\n            Name of the data table, [-]\\n        CASs : Iterable[str]\\n            CAS numbers; they do not need to be sorted, [-]\\n        ip : str\\n            Name of the parameter to retrieve, [-]\\n\\n        Returns\\n        -------\\n        value : float\\n            Interaction parameter specified by `ip`, [-]\\n\\n        Examples\\n        --------\\n        Check if nitrogen-ethane as a PR BIP:\\n\\n        >>> from thermo.interaction_parameters import IPDB\\n        >>> IPDB.get_ip_specific('ChemSep PR', ['7727-37-9', '74-84-0'], 'kij')\\n        0.0533\\n        \"\n        if self.metadata[name]['symmetric']:\n            key = ' '.join(sorted_CAS_key(CASs))\n        else:\n            key = ' '.join(CASs)\n        try:\n            return self.tables[name][key][ip]\n        except KeyError:\n            return self.metadata[name]['missing'][ip]",
        "docstring": "Retrieve a specific interaction parameter from a designated database table. If the parameter is not found, this method returns a predefined 'missing' value as specified in the metadata.\n\nParameters\n----------\nname : str\n    The name of the interaction parameter table to look into.\nCASs : Iterable[str]\n    A collection of CAS numbers for the components involved, order does not matter.\nip : str\n    The specific interaction parameter to retrieve.\n\nReturns\n-------\nfloat\n    The value of the specified interaction parameter. If the parameter is not present, the default missing value from the table's metadata is returned.\n\nNotes\n-----\nThis function utilizes the `symmetric` property from the `metadata` dictionary to determine the appropriate key format. It uses the `sorted_CAS_key` from the `chemicals.utils` module to sort CAS numbers, ensuring consistency for symmetric parameters. If the specified key is not found, a `KeyError` is caught, and the missing value is retrieved from the metadata.",
        "signature": "def get_ip_specific(self, name, CASs, ip):",
        "type": "Method",
        "class_signature": "class InteractionParameterDB:"
      },
      "InteractionParameterDB.get_tables_with_type": {
        "code": "    def get_tables_with_type(self, ip_type):\n        \"\"\"Retrieve the names of interaction parameter tables that include a specified type of parameter.\n\nParameters\n----------\nip_type : str\n    A string representing the name of the parameter type to search for within the interaction parameter tables.\n\nReturns\n-------\nlist[str]\n    A list of table names (as strings) that contain the specified parameter type.\n\nThis method accesses the `metadata` attribute of the `InteractionParameterDB` class, which stores information about various interaction parameter datasets, including their types. It iterates through the metadata to find matching entries and compiles their names into a list, facilitating the lookup of relevant data tables.\"\"\"\n        \"Get a list of tables which have a type of a parameter.\\n\\n        Parameters\\n        ----------\\n        ip_type : str\\n            Name of the parameter type, [-]\\n\\n        Returns\\n        -------\\n        table_names : list[str]\\n            Interaction parameter tables including `ip`, [-]\\n\\n        Examples\\n        --------\\n        >>> from thermo.interaction_parameters import IPDB\\n        >>> IPDB.get_tables_with_type('PR kij')\\n        ['ChemSep PR']\\n        \"\n        tables = []\n        for key, d in self.metadata.items():\n            if d['type'] == ip_type:\n                tables.append(key)\n        return tables",
        "docstring": "Retrieve the names of interaction parameter tables that include a specified type of parameter.\n\nParameters\n----------\nip_type : str\n    A string representing the name of the parameter type to search for within the interaction parameter tables.\n\nReturns\n-------\nlist[str]\n    A list of table names (as strings) that contain the specified parameter type.\n\nThis method accesses the `metadata` attribute of the `InteractionParameterDB` class, which stores information about various interaction parameter datasets, including their types. It iterates through the metadata to find matching entries and compiles their names into a list, facilitating the lookup of relevant data tables.",
        "signature": "def get_tables_with_type(self, ip_type):",
        "type": "Method",
        "class_signature": "class InteractionParameterDB:"
      },
      "InteractionParameterDB.get_ip_automatic": {
        "code": "    def get_ip_automatic(self, CASs, ip_type, ip):\n        \"\"\"Retrieve the specified interaction parameter for a given set of CAS numbers from the first available table that contains the relevant data.\n\nParameters\n----------\nCASs : Iterable[str]\n    A collection of CAS numbers representing the components; the order of CAS numbers does not need to be sorted.\nip_type : str\n    The type of the interaction parameter to search for, such as 'PR kij'.\nip : str\n    The specific interaction parameter name to retrieve, for example 'kij'.\n\nReturns\n-------\nvalue : float\n    The interaction parameter value corresponding to the provided `ip`, or raises an error if not found.\n\nThis method utilizes the `get_tables_with_type` method to find the first interaction parameter table associated with the specified `ip_type`. It then retrieves the value using `get_ip_specific` by passing the identified table and the provided CAS numbers. The method is useful for dynamically retrieving interaction parameters without requiring explicit knowledge of all available tables.\"\"\"\n        \"Get an interaction parameter for the first table containing the\\n        value.\\n\\n        Parameters\\n        ----------\\n        CASs : Iterable[str]\\n            CAS numbers; they do not need to be sorted, [-]\\n        ip_type : str\\n            Name of the parameter type, [-]\\n        ip : str\\n            Name of the parameter to retrieve, [-]\\n\\n        Returns\\n        -------\\n        value : float\\n            Interaction parameter specified by `ip`, [-]\\n\\n        Examples\\n        --------\\n        >>> from thermo.interaction_parameters import IPDB\\n        >>> IPDB.get_ip_automatic(CASs=['7727-37-9', '74-84-0'], ip_type='PR kij', ip='kij')\\n        0.0533\\n        \"\n        table = self.get_tables_with_type(ip_type)[0]\n        return self.get_ip_specific(table, CASs, ip)",
        "docstring": "Retrieve the specified interaction parameter for a given set of CAS numbers from the first available table that contains the relevant data.\n\nParameters\n----------\nCASs : Iterable[str]\n    A collection of CAS numbers representing the components; the order of CAS numbers does not need to be sorted.\nip_type : str\n    The type of the interaction parameter to search for, such as 'PR kij'.\nip : str\n    The specific interaction parameter name to retrieve, for example 'kij'.\n\nReturns\n-------\nvalue : float\n    The interaction parameter value corresponding to the provided `ip`, or raises an error if not found.\n\nThis method utilizes the `get_tables_with_type` method to find the first interaction parameter table associated with the specified `ip_type`. It then retrieves the value using `get_ip_specific` by passing the identified table and the provided CAS numbers. The method is useful for dynamically retrieving interaction parameters without requiring explicit knowledge of all available tables.",
        "signature": "def get_ip_automatic(self, CASs, ip_type, ip):",
        "type": "Method",
        "class_signature": "class InteractionParameterDB:"
      },
      "InteractionParameterDB.get_ip_symmetric_matrix": {
        "code": "    def get_ip_symmetric_matrix(self, name, CASs, ip, T=298.15):\n        \"\"\"Get a symmetric matrix of interaction parameters from a specified database for given chemical components. The method populates a matrix where elements correspond to the specified interaction parameter between components, assuming that interaction parameters are symmetric (i.e., the value for component A with component B is equal to that for component B with component A).\n\nParameters\n----------\nname : str\n    Name of the interaction parameter data table to query.\nCASs : Iterable[str]\n    List of CAS numbers for the components; order does not matter.\nip : str\n    The specific interaction parameter to retrieve (e.g., 'kij').\nT : float, optional\n    Temperature in Kelvin for the system (default is 298.15 K).\n\nReturns\n-------\nvalues : list[list[float]]\n    A 2D list (matrix) where each element represents the interaction parameter specified by `ip` between the components as indexed by their respective positions in `CASs`.\n\nThis method utilizes other methods in the `InteractionParameterDB` class, particularly `get_ip_specific`, to fetch the interaction parameters from the database based on the specified component combinations, and is optimized for cases where the interaction parameters are symmetric.\"\"\"\n        \"Get a table of interaction parameters from a specified source\\n        for the specified parameters. This method assumes symmetric\\n        parameters for speed.\\n\\n        Parameters\\n        ----------\\n        name : str\\n            Name of the data table, [-]\\n        CASs : Iterable[str]\\n            CAS numbers; they do not need to be sorted, [-]\\n        ip : str\\n            Name of the parameter to retrieve, [-]\\n        T : float, optional\\n            Temperature of the system, [-]\\n\\n        Returns\\n        -------\\n        values : list[list[float]]\\n            Interaction parameters specified by `ip`, [-]\\n\\n        Examples\\n        --------\\n        >>> from thermo.interaction_parameters import IPDB\\n        >>> IPDB.get_ip_symmetric_matrix(name='ChemSep PR', CASs=['7727-37-9', '74-84-0', '74-98-6'], ip='kij')\\n        [[0.0, 0.0533, 0.0878], [0.0533, 0.0, 0.0011], [0.0878, 0.0011, 0.0]]\\n        \"\n        table = self.tables[name]\n        N = len(CASs)\n        values = [[None for i in range(N)] for j in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    i_ip = 0.0\n                elif values[j][i] is not None:\n                    continue\n                else:\n                    i_ip = self.get_ip_specific(name, [CASs[i], CASs[j]], ip)\n                values[i][j] = values[j][i] = i_ip\n        return values",
        "docstring": "Get a symmetric matrix of interaction parameters from a specified database for given chemical components. The method populates a matrix where elements correspond to the specified interaction parameter between components, assuming that interaction parameters are symmetric (i.e., the value for component A with component B is equal to that for component B with component A).\n\nParameters\n----------\nname : str\n    Name of the interaction parameter data table to query.\nCASs : Iterable[str]\n    List of CAS numbers for the components; order does not matter.\nip : str\n    The specific interaction parameter to retrieve (e.g., 'kij').\nT : float, optional\n    Temperature in Kelvin for the system (default is 298.15 K).\n\nReturns\n-------\nvalues : list[list[float]]\n    A 2D list (matrix) where each element represents the interaction parameter specified by `ip` between the components as indexed by their respective positions in `CASs`.\n\nThis method utilizes other methods in the `InteractionParameterDB` class, particularly `get_ip_specific`, to fetch the interaction parameters from the database based on the specified component combinations, and is optimized for cases where the interaction parameters are symmetric.",
        "signature": "def get_ip_symmetric_matrix(self, name, CASs, ip, T=298.15):",
        "type": "Method",
        "class_signature": "class InteractionParameterDB:"
      },
      "InteractionParameterDB.get_ip_asymmetric_matrix": {
        "code": "    def get_ip_asymmetric_matrix(self, name, CASs, ip, T=298.15):\n        \"\"\"Get a table of asymmetric interaction parameters for a specified source and parameter from the provided CAS numbers.\n\nParameters\n----------\nname : str\n    The name of the data table to query, which contains interaction parameters.\nCASs : Iterable[str]\n    A list of CAS numbers representing the components for which interaction parameters are to be retrieved. They do not need to be sorted.\nip : str\n    The specific interaction parameter to look up in the table.\nT : float, optional\n    The temperature of the system (default is 298.15 K), although it is not utilized directly in this method.\n\nReturns\n-------\nvalues : list[list[float]]\n    A 2D list containing the interaction parameters specified by `ip`. The diagonal entries are set to 0.0, indicating the self-interaction of components.\n\nNotes\n-----\nThis method interacts with the `get_ip_specific` method of the `InteractionParameterDB` class to obtain values for pairs of CASs. It constructs a symmetric matrix where `values[i][j]` is the interaction parameter between the components identified by `CASs[i]` and `CASs[j]`. The method relies on the structure of the interaction parameter database established within the `load_json` method, which loads data from JSON files into the `tables` attribute.\"\"\"\n        \"Get a table of interaction parameters from a specified source\\n        for the specified parameters.\\n\\n        Parameters\\n        ----------\\n        name : str\\n            Name of the data table, [-]\\n        CASs : Iterable[str]\\n            CAS numbers; they do not need to be sorted, [-]\\n        ip : str\\n            Name of the parameter to retrieve, [-]\\n        T : float, optional\\n            Temperature of the system, [-]\\n\\n        Returns\\n        -------\\n        values : list[list[float]]\\n            Interaction parameters specified by `ip`, [-]\\n\\n        Examples\\n        --------\\n        >>> from thermo.interaction_parameters import IPDB\\n        >>> IPDB.get_ip_symmetric_matrix(name='ChemSep NRTL', CASs=['64-17-5', '7732-18-5', '67-56-1'], ip='alphaij')\\n        [[0.0, 0.2937, 0.3009], [0.2937, 0.0, 0.2999], [0.3009, 0.2999, 0.0]]\\n        \"\n        table = self.tables[name]\n        N = len(CASs)\n        values = [[None for i in range(N)] for j in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    i_ip = 0.0\n                else:\n                    i_ip = self.get_ip_specific(name, [CASs[i], CASs[j]], ip)\n                values[i][j] = i_ip\n        return values",
        "docstring": "Get a table of asymmetric interaction parameters for a specified source and parameter from the provided CAS numbers.\n\nParameters\n----------\nname : str\n    The name of the data table to query, which contains interaction parameters.\nCASs : Iterable[str]\n    A list of CAS numbers representing the components for which interaction parameters are to be retrieved. They do not need to be sorted.\nip : str\n    The specific interaction parameter to look up in the table.\nT : float, optional\n    The temperature of the system (default is 298.15 K), although it is not utilized directly in this method.\n\nReturns\n-------\nvalues : list[list[float]]\n    A 2D list containing the interaction parameters specified by `ip`. The diagonal entries are set to 0.0, indicating the self-interaction of components.\n\nNotes\n-----\nThis method interacts with the `get_ip_specific` method of the `InteractionParameterDB` class to obtain values for pairs of CASs. It constructs a symmetric matrix where `values[i][j]` is the interaction parameter between the components identified by `CASs[i]` and `CASs[j]`. The method relies on the structure of the interaction parameter database established within the `load_json` method, which loads data from JSON files into the `tables` attribute.",
        "signature": "def get_ip_asymmetric_matrix(self, name, CASs, ip, T=298.15):",
        "type": "Method",
        "class_signature": "class InteractionParameterDB:"
      }
    },
    "thermo/phases/iapws_phase.py": {},
    "thermo/phases/gibbs_excess.py": {}
  },
  "dependency_dict": {
    "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_automatic": {},
    "thermo/interaction_parameters.py:InteractionParameterDB:get_tables_with_type": {},
    "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {},
    "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_symmetric_matrix": {},
    "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_asymmetric_matrix": {}
  },
  "PRD": "# PROJECT NAME: thermo-test_interaction_parameters\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 thermo/\n    \u251c\u2500\u2500 interaction_parameters.py\n    \u2502   \u251c\u2500\u2500 InteractionParameterDB.get_ip_asymmetric_matrix\n    \u2502   \u251c\u2500\u2500 InteractionParameterDB.get_ip_automatic\n    \u2502   \u251c\u2500\u2500 InteractionParameterDB.get_ip_specific\n    \u2502   \u251c\u2500\u2500 InteractionParameterDB.get_ip_symmetric_matrix\n    \u2502   \u251c\u2500\u2500 InteractionParameterDB.get_tables_with_type\n    \u2502   \u2514\u2500\u2500 InteractionParameterDB.has_ip_specific\n    \u2514\u2500\u2500 phases/\n        \u251c\u2500\u2500 gibbs_excess.py\n        \u2502   \u2514\u2500\u2500 GibbsExcessLiquid.GibbsExcessLiquid\n        \u2514\u2500\u2500 iapws_phase.py\n            \u2514\u2500\u2500 IAPWS95Liquid.IAPWS95Liquid\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThe module provides tools for managing, validating, and retrieving chemical interaction parameters within a process modeling framework. It enables users to access and manipulate interaction parameter databases, such as those used for thermodynamic models (e.g., Peng-Robinson, NRTL, UNIQUAC, and Henry's Law constants). The module supports querying specific interaction parameters for chemical species by their chemical identifiers (e.g., CAS numbers), retrieving symmetric and asymmetric parameter matrices, and validating the consistency and integrity of data tables. By automating these tasks, it streamlines the process of integrating accurate thermodynamic and transport property data into simulation workflows, reducing errors and improving efficiency for chemical engineers and developers working on process design and analysis.\n\n## FILE 1: thermo/interaction_parameters.py\n\n- CLASS METHOD: InteractionParameterDB.get_ip_automatic\n  - CLASS SIGNATURE: class InteractionParameterDB:\n  - SIGNATURE: def get_ip_automatic(self, CASs, ip_type, ip):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the specified interaction parameter for a given set of CAS numbers from the first available table that contains the relevant data.\n\nParameters\n----------\nCASs : Iterable[str]\n    A collection of CAS numbers representing the components; the order of CAS numbers does not need to be sorted.\nip_type : str\n    The type of the interaction parameter to search for, such as 'PR kij'.\nip : str\n    The specific interaction parameter name to retrieve, for example 'kij'.\n\nReturns\n-------\nvalue : float\n    The interaction parameter value corresponding to the provided `ip`, or raises an error if not found.\n\nThis method utilizes the `get_tables_with_type` method to find the first interaction parameter table associated with the specified `ip_type`. It then retrieves the value using `get_ip_specific` by passing the identified table and the provided CAS numbers. The method is useful for dynamically retrieving interaction parameters without requiring explicit knowledge of all available tables.\n\"\"\"\n```\n\n- CLASS METHOD: InteractionParameterDB.get_ip_asymmetric_matrix\n  - CLASS SIGNATURE: class InteractionParameterDB:\n  - SIGNATURE: def get_ip_asymmetric_matrix(self, name, CASs, ip, T=298.15):\n  - DOCSTRING: \n```python\n\"\"\"\nGet a table of asymmetric interaction parameters for a specified source and parameter from the provided CAS numbers.\n\nParameters\n----------\nname : str\n    The name of the data table to query, which contains interaction parameters.\nCASs : Iterable[str]\n    A list of CAS numbers representing the components for which interaction parameters are to be retrieved. They do not need to be sorted.\nip : str\n    The specific interaction parameter to look up in the table.\nT : float, optional\n    The temperature of the system (default is 298.15 K), although it is not utilized directly in this method.\n\nReturns\n-------\nvalues : list[list[float]]\n    A 2D list containing the interaction parameters specified by `ip`. The diagonal entries are set to 0.0, indicating the self-interaction of components.\n\nNotes\n-----\nThis method interacts with the `get_ip_specific` method of the `InteractionParameterDB` class to obtain values for pairs of CASs. It constructs a symmetric matrix where `values[i][j]` is the interaction parameter between the components identified by `CASs[i]` and `CASs[j]`. The method relies on the structure of the interaction parameter database established within the `load_json` method, which loads data from JSON files into the `tables` attribute.\n\"\"\"\n```\n\n- CLASS METHOD: InteractionParameterDB.get_tables_with_type\n  - CLASS SIGNATURE: class InteractionParameterDB:\n  - SIGNATURE: def get_tables_with_type(self, ip_type):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve the names of interaction parameter tables that include a specified type of parameter.\n\nParameters\n----------\nip_type : str\n    A string representing the name of the parameter type to search for within the interaction parameter tables.\n\nReturns\n-------\nlist[str]\n    A list of table names (as strings) that contain the specified parameter type.\n\nThis method accesses the `metadata` attribute of the `InteractionParameterDB` class, which stores information about various interaction parameter datasets, including their types. It iterates through the metadata to find matching entries and compiles their names into a list, facilitating the lookup of relevant data tables.\n\"\"\"\n```\n\n- CLASS METHOD: InteractionParameterDB.has_ip_specific\n  - CLASS SIGNATURE: class InteractionParameterDB:\n  - SIGNATURE: def has_ip_specific(self, name, CASs, ip):\n  - DOCSTRING: \n```python\n\"\"\"\nCheck if a specific interaction parameter (IP) exists for a given set of CAS numbers in the specified data table. This method first constructs a key based on the CAS numbers, with consideration for whether the interaction parameters are symmetric. It then checks if the key is in the data table and if the specified parameter is present for that key. \n\nParameters\n----------\nname : str\n    The name of the data table to check, e.g., 'ChemSep PR'.\nCASs : Iterable[str]\n    A list or collection of CAS numbers for which the interaction parameter is being queried. The order of CAS numbers does not need to be sorted.\nip : str\n    The name of the interaction parameter to check for, e.g., 'kij'.\n\nReturns\n-------\npresent : bool\n    Returns `True` if the interaction parameter exists for the specified CAS numbers in the table; otherwise, returns `False`.\n\nThis method utilizes the `self.metadata` dictionary to check if the interaction parameters are symmetric using the 'symmetric' key. The `sorted_CAS_key` function from the `chemicals.identifiers` module is used to sort CAS numbers for symmetric parameters appropriately.\n\"\"\"\n```\n\n- CLASS METHOD: InteractionParameterDB.get_ip_specific\n  - CLASS SIGNATURE: class InteractionParameterDB:\n  - SIGNATURE: def get_ip_specific(self, name, CASs, ip):\n  - DOCSTRING: \n```python\n\"\"\"\nRetrieve a specific interaction parameter from a designated database table. If the parameter is not found, this method returns a predefined 'missing' value as specified in the metadata.\n\nParameters\n----------\nname : str\n    The name of the interaction parameter table to look into.\nCASs : Iterable[str]\n    A collection of CAS numbers for the components involved, order does not matter.\nip : str\n    The specific interaction parameter to retrieve.\n\nReturns\n-------\nfloat\n    The value of the specified interaction parameter. If the parameter is not present, the default missing value from the table's metadata is returned.\n\nNotes\n-----\nThis function utilizes the `symmetric` property from the `metadata` dictionary to determine the appropriate key format. It uses the `sorted_CAS_key` from the `chemicals.utils` module to sort CAS numbers, ensuring consistency for symmetric parameters. If the specified key is not found, a `KeyError` is caught, and the missing value is retrieved from the metadata.\n\"\"\"\n```\n\n- CLASS METHOD: InteractionParameterDB.get_ip_symmetric_matrix\n  - CLASS SIGNATURE: class InteractionParameterDB:\n  - SIGNATURE: def get_ip_symmetric_matrix(self, name, CASs, ip, T=298.15):\n  - DOCSTRING: \n```python\n\"\"\"\nGet a symmetric matrix of interaction parameters from a specified database for given chemical components. The method populates a matrix where elements correspond to the specified interaction parameter between components, assuming that interaction parameters are symmetric (i.e., the value for component A with component B is equal to that for component B with component A).\n\nParameters\n----------\nname : str\n    Name of the interaction parameter data table to query.\nCASs : Iterable[str]\n    List of CAS numbers for the components; order does not matter.\nip : str\n    The specific interaction parameter to retrieve (e.g., 'kij').\nT : float, optional\n    Temperature in Kelvin for the system (default is 298.15 K).\n\nReturns\n-------\nvalues : list[list[float]]\n    A 2D list (matrix) where each element represents the interaction parameter specified by `ip` between the components as indexed by their respective positions in `CASs`.\n\nThis method utilizes other methods in the `InteractionParameterDB` class, particularly `get_ip_specific`, to fetch the interaction parameters from the database based on the specified component combinations, and is optimized for cases where the interaction parameters are symmetric.\n\"\"\"\n```\n\n## FILE 2: thermo/phases/iapws_phase.py\n\n## FILE 3: thermo/phases/gibbs_excess.py\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "thermo/interaction_parameters.py": "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2017, 2018, 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nThis module contains a small database of interaction parameters.\nOnly two data sets are currently included, both from ChemSep. If you would\nlike to add parameters to this project please make a referenced compilation of\nvalues and submit them on GitHub.\n\n\nFor reporting bugs, adding feature requests, or submitting pull requests,\nplease use the `GitHub issue tracker <https://github.com/CalebBell/thermo/>`_.\n\n.. contents:: :local:\n\n.. autoclass:: InteractionParameterDB\n    :members:\n\n.. autodata:: IPDB\n\n   Exmple database with NRTL and PR values from ChemSep. This is lazy-loaded,\n   access it as `thermo.interaction_parameters.IPDB`.\n\n.. autoclass:: ScalarParameterDB\n\nSPDB\n\n    Example scalar parameters for models. This is lazy-loaded,\n    access it as `thermo.interaction_parameters.SPDB`.\n\"\"\"\n__all__ = ['InteractionParameterDB', 'ScalarParameterDB']\nimport os\nfrom math import isnan\nfrom chemicals.identifiers import check_CAS, sorted_CAS_key\nfrom chemicals.utils import PY37, can_load_data\n\nclass InteractionParameterDB:\n    \"\"\"Basic database framework for interaction parameters.\n    \"\"\"\n\n    def __init__(self):\n        self.tables = {}\n        self.metadata = {}\n\n    def load_json(self, file, name):\n        \"\"\"Load a json file from disk containing interaction\n        coefficients.\n\n        The format for the file is as follows:\n\n        A `data` key containing a dictionary with a key:\n\n            * `CAS1 CAS2` : str\n               The CAS numbers of both components, sorted from small to high\n               as integers; they should have the '-' symbols still in them\n               and have a single space between them; if these are ternary or\n               higher parameters, follow the same format for the other CAS\n               numbers, [-]\n\n            * values : dict[str : various]\n                All of the values listed in the metadata element\n                `necessary keys`; they are None if missing.\n\n        A `metadata` key containing:\n\n            * `symmetric` : bool\n               Whether or not the interaction coefficients are missing.\n            * `source` : str\n               Where the data came from.\n            * `components` : int\n               The number of components each interaction parameter is for;\n               2 for binary, 3 for ternary, etc.\n            * `necessary keys` : list[str]\n               Which elements are required in the data.\n            * `P dependent` : bool\n               Whether or not the interaction parameters are pressure dependent.\n            * `missing` : dict[str : float]\n               Values which are missing are returned with these values\n            * `type` : One of 'PR kij', 'SRK kij', etc; used to group data but not\n               tied into anything else.\n            * `T dependent` : bool\n               Whether or not the data is T-dependent.\n\n        Parameters\n        ----------\n        file : str\n            Path to json file on disk which contains interaction coefficients, [-]\n        name : str\n            Name that the data read should be referred to by, [-]\n        \"\"\"\n        import json\n        f = open(file).read()\n        dat = json.loads(f)\n        self.tables[name] = dat['data']\n        self.metadata[name] = dat['metadata']\n\n    def validate_table(self, name):\n        \"\"\"Basic method which checks that all CAS numbers are valid, and that\n        all elements of the data have non-nan values.\n        Raises an exception if any of the data is missing or is a nan value.\n        \"\"\"\n        table = self.tables[name]\n        meta = self.metadata[name]\n        components = meta['components']\n        necessary_keys = meta['necessary keys']\n        for key in table:\n            CASs = key.split(' ')\n            assert len(CASs) == components\n            assert all((check_CAS(i) for i in CASs))\n            values = table[key]\n            for i in necessary_keys:\n                assert i in values\n                val = values[i]\n                assert val is not None\n                assert not isnan(val)\n\nclass ScalarParameterDB:\n    \"\"\"Basic database framework for scalar parameters of various thermodynamic\n    models. The following keys are used:\n\n    **Peng-Robinson**\n\n    :obj:`Twu Volume-translated Peng-Robinson <thermo.eos_mix.PRMIXTranslatedConsistent>`:\n    `TwuPRL`, `TwuPRM`, `TwuPRN`, `TwuPRc`\n\n    :obj:`Volume-translated Peng-Robinson <thermo.eos_mix.PRMIXTranslated>`:\n    `PRc`\n\n    :obj:`Peng-Robinson-Stryjek-Vera  <thermo.eos_mix.PRSVMIX>`:\n    `PRSVkappa1`\n\n    :obj:`Peng-Robinson-Stryjek-Vera 2  <thermo.eos_mix.PRSV2MIX>`:\n    `PRSV2kappa1`, `PRSV2kappa2`, `PRSV2kappa3`\n\n    **SRK**\n\n    :obj:`Twu Volume-translated Peng-Robinson <thermo.eos_mix.SRKMIXTranslatedConsistent>`:\n    `TwuSRKL`, `TwuSRKM`, `TwuSRKN`, `TwuSRKc`\n\n    :obj:`Volume-translated Peng-Robinson <thermo.eos_mix.SRKMIXTranslated>`:\n    `SRKc`\n\n    :obj:`Refinery Soave-Redlich-Kwong  <thermo.eos_mix.APISRKMIX>`:\n    `APISRKS1`, `APISRKS2`\n\n    :obj:`MSRK  <thermo.eos_mix.MSRKMIXTranslated>`:\n    `MSRKM`, `MSRKN`, `MSRKc`\n\n    :obj:`Predictive Soave-Redlich-Kwong <thermo.eos_mix.PSRK>`:\n    `MCSRKC1`, `MCSRKC2`, `MCSRKC3`\n\n\n    **Excess Gibbs Energy Models**\n\n    :obj:`Regular Solution <thermo.regular_solution.RegularSolution>`:\n    `RegularSolutionV`, `RegularSolutionSP`\n\n\n    \"\"\"\n\n    def __init__(self):\n        self.tables = {}\n        self.metadata = {}\n\n    def load_json(self, file, name):\n        import json\n        f = open(file).read()\n        dat = json.loads(f)\n        self.tables[name] = dat['data']\n        self.metadata[name] = dat['metadata']\n\n    def get_parameter_specific(self, name, CAS, parameter):\n        \"\"\"Get a parameter from a table. If the specified\n        parameter is missing, the default `missing` value as defined in\n        the data file is returned instead.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CAS : str\n            CAS number, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        value : float\n            Interaction parameter specified by `ip`, [-]\n\n        Examples\n        --------\n        Get the `L` Twu parameter for PR from Pi\u00f1a-Martinez (2021):\n\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_parameter_specific('PRTwu_PinaMartinez', '7727-37-9', 'TwuPRL')\n        0.1243\n        \"\"\"\n        try:\n            return self.tables[name][CAS][parameter]\n        except KeyError:\n            return self.metadata[name]['missing'][parameter]\n\n    def has_parameter_specific(self, name, CAS, parameter):\n        \"\"\"Check if a parameter exists in a table.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CAS : str\n            CAS number, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        present : bool\n            Whether or not the data is included in the table, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.has_parameter_specific('PRTwu_PinaMartinez', '7727-37-9', 'TwuPRL')\n        True\n        >>> SPDB.has_parameter_specific('PRTwu_PinaMartinez', '7439-89-6', 'TwuPRL')\n        False\n        \"\"\"\n        table = self.tables[name]\n        if CAS not in table:\n            return False\n        return parameter in table[CAS]\n\n    def get_tables_with_type(self, parameter):\n        \"\"\"Get a list of tables which have a parameter.\n\n        Parameters\n        ----------\n        parameter : str\n            Name of the parameter, [-]\n\n        Returns\n        -------\n        table_names : list[str]\n            Interaction parameter tables including `parameter`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_tables_with_type('TwuPRL')\n        ['PRTwu_PinaMartinez', 'PRTwu_ibell_2018']\n        \"\"\"\n        tables = []\n        for key, d in self.metadata.items():\n            if parameter in d['missing']:\n                tables.append(key)\n        return tables\n\n    def get_parameter_automatic(self, CAS, parameter):\n        \"\"\"Get an interaction parameter for the first table containing the\n        value.\n\n        Parameters\n        ----------\n        CAS : str\n            CAS number, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        value : float\n            Parameter value specified by `parameter`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_parameter_automatic('7727-37-9', parameter='TwuPRL')\n        0.1243\n        \"\"\"\n        table = self.get_tables_with_type(parameter)[0]\n        return self.get_parameter_specific(table, CAS, parameter)\n\n    def get_parameter_vector(self, name, CASs, parameter):\n        \"\"\"Get a list of parameters from a specified source\n        for the specified parameter.\n\n        Parameters\n        ----------\n        name : str\n            Name of the data table, [-]\n        CASs : Iterable[str]\n            CAS numbers; the returned values will be in this order, [-]\n        parameter : str\n            Name of the parameter to retrieve, [-]\n\n        Returns\n        -------\n        values : list[float]\n            Parameter specified by `parameter`, [-]\n\n        Examples\n        --------\n        >>> from thermo.interaction_parameters import SPDB\n        >>> SPDB.get_parameter_vector(name='PRTwu_PinaMartinez', CASs=['7727-37-9', '74-84-0', '74-98-6'], parameter='TwuPRL')\n        [0.1243, 0.3053, 0.7455]\n        >>> SPDB.get_parameter_vector(name='PRVolumeTranslation_PinaMartinez', CASs=['7727-37-9', '74-84-0', '74-98-6'], parameter='PRc')\n        [-3.643e-06, -3.675e-06, -3.735e-06]\n        \"\"\"\n        table = self.tables[name]\n        N = len(CASs)\n        values = [None] * N\n        for i in range(N):\n            values[i] = self.get_parameter_specific(name, CASs[i], parameter)\n        return values\n_loaded_interactions = False\n\ndef load_all_interaction_parameters():\n    global IPDB, _loaded_interactions\n    folder = os.path.join(os.path.dirname(__file__), 'Interaction Parameters')\n    chemsep_db_path = os.path.join(folder, 'ChemSep')\n    ip_files = {'ChemSep PR': os.path.join(chemsep_db_path, 'pr.json'), 'ChemSep NRTL': os.path.join(chemsep_db_path, 'nrtl.json'), 'ChemSep UNIQUAC': os.path.join(chemsep_db_path, 'uniquac.json'), 'ChemSep Wilson': os.path.join(chemsep_db_path, 'wilson.json'), 'ChemSep Henry': os.path.join(chemsep_db_path, 'henry.json'), 'Sander Const': os.path.join(folder, 'Sander_henry_const.json'), 'Sander T dep': os.path.join(folder, 'Sander_henry_T_dep.json'), 'PRTranslated Henry Best': os.path.join(folder, 'PRTranslated_best_henry_T_dep.json')}\n    IPDB = InteractionParameterDB()\n    for name, file in ip_files.items():\n        IPDB.load_json(file, name)\n    _loaded_interactions = True\n_loaded_scalars = False\n\ndef load_all_scalar_parameters():\n    global SPDB, _loaded_scalars\n    folder = os.path.join(os.path.dirname(__file__), 'Scalar Parameters')\n    sp_files = {'PRTwu_PinaMartinez': os.path.join(folder, 'PRTwu_PinaMartinez.json'), 'SRKTwu_PinaMartinez': os.path.join(folder, 'SRKTwu_PinaMartinez.json'), 'PRVolumeTranslation_PinaMartinez': os.path.join(folder, 'PRVolumeTranslation_PinaMartinez.json'), 'SRKVolumeTranslation_PinaMartinez': os.path.join(folder, 'SRKVolumeTranslation_PinaMartinez.json'), 'PRTwu_ibell_2018': os.path.join(folder, 'PRTwu_ibell_2018.json'), 'chemsep_regular_solution': os.path.join(folder, 'chemsep_regular_solution.json'), 'chemsep_PSRK_matthias_copeman': os.path.join(folder, 'chemsep_PSRK_matthias_copeman.json'), 'chemsep_APISRK': os.path.join(folder, 'chemsep_APISRK.json')}\n    SPDB = ScalarParameterDB()\n    for name, file in sp_files.items():\n        SPDB.load_json(file, name)\n    _loaded_scalars = True\nif PY37:\n\n    def __getattr__(name):\n        if name in ('IPDB',):\n            load_all_interaction_parameters()\n            return globals()[name]\n        if name in ('SPDB',):\n            load_all_scalar_parameters()\n            return globals()[name]\n        raise AttributeError(f'module {__name__} has no attribute {name}')\nelif can_load_data:\n    load_all_interaction_parameters()\n    load_all_scalar_parameters()",
    "thermo/phases/iapws_phase.py": "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n__all__ = ['IAPWS95', 'IAPWS95Gas', 'IAPWS95Liquid', 'IAPWS97', 'IAPWS06']\nfrom cmath import log as logc\nfrom math import exp\nfrom chemicals import iapws\nfrom chemicals.interface import sigma_IAPWS\nfrom chemicals.thermal_conductivity import k_IAPWS\nfrom chemicals.utils import Vm_to_rho, rho_to_Vm\nfrom chemicals.viscosity import mu_IAPWS\nfrom fluids.numerics import secant\nfrom thermo.phases.gibbs_eos import GibbsEOS\nfrom thermo.phases.helmholtz_eos import HelmholtzEOS\nfrom thermo.phases.phase import Phase\n\nclass IAPWS95(HelmholtzEOS):\n    model_name = 'iapws95'\n    _MW = iapws.iapws95_MW\n    Tc = iapws.iapws95_Tc\n    Pc = iapws.iapws95_Pc\n    rhoc_mass = iapws.iapws95_rhoc\n    rhoc_mass_inv = 1.0 / rhoc_mass\n    Hfs = [-241822.0]\n    Sfs = [-44.5]\n    Gfs = [-228554.325]\n    N = 1\n    rhoc_inv = rho_to_Vm(rhoc_mass, _MW)\n    rhoc = 1.0 / rhoc_inv\n    rho_red = rhoc\n    rho_red_inv = rhoc_inv\n    T_red = Tc\n    T_fixed_transport = 1.5 * T_red\n    _MW_kg = _MW * 0.001\n    R = _MW_kg * iapws.iapws95_R\n    R_inv = 1.0 / R\n    R2 = R * R\n    zs = [1.0]\n    cmps = [0]\n    T_MAX_FLASH = T_MAX_FIXED = 5000.0\n    T_MIN_FLASH = T_MIN_FIXED = 243.0\n    _d4Ar_ddelta2dtau2_func = staticmethod(iapws.iapws95_d4Ar_ddelta2dtau2)\n    _d3Ar_ddeltadtau2_func = staticmethod(iapws.iapws95_d3Ar_ddeltadtau2)\n    _d3Ar_ddelta2dtau_func = staticmethod(iapws.iapws95_d3Ar_ddelta2dtau)\n    _d2Ar_ddeltadtau_func = staticmethod(iapws.iapws95_d2Ar_ddeltadtau)\n    _d2Ar_dtau2_func = staticmethod(iapws.iapws95_d2Ar_dtau2)\n    _dAr_dtau_func = staticmethod(iapws.iapws95_dAr_dtau)\n    _d3Ar_ddelta3_func = staticmethod(iapws.iapws95_d3Ar_ddelta3)\n    _d2Ar_ddelta2_func = staticmethod(iapws.iapws95_d2Ar_ddelta2)\n    _dAr_ddelta_func = staticmethod(iapws.iapws95_dAr_ddelta)\n    _Ar_func = staticmethod(iapws.iapws95_Ar)\n\n    def __init__(self, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        self.tau = tau = self.Tc / T\n        self.delta = delta = rho_mass * self.rhoc_mass_inv\n        self.A0, self.dA0_dtau, self.d2A0_dtau2, self.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n\n    def to_TP_zs(self, T, P, zs):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.T = T\n        new.P = P\n        new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n        new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        new.tau = tau = new.Tc / T\n        new.delta = delta = rho_mass * new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None and P is not None:\n            new.T = T\n            new._rho_mass = rho_mass = iapws.iapws95_rho(T, P)\n            new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n            new.P = P\n        elif T is not None and V is not None:\n            new.T = T\n            new._rho_mass = rho_mass = 0.001 * self._MW / V\n            P = iapws.iapws95_P(T, rho_mass)\n            new._V = V\n            new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws95_T(P, rho_mass)\n            new._V = V\n            new.P = P\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        new.P = P\n        new.T = T\n        new.tau = tau = new.Tc / T\n        new.delta = delta = rho_mass * new.rhoc_mass_inv\n        new.A0, new.dA0_dtau, new.d2A0_dtau2, new.d3A0_dtau3 = iapws.iapws95_A0_tau_derivatives(tau, delta)\n        return new\n\n    def mu(self):\n        \"\"\"Calculate and return the viscosity of water according to the IAPWS.\n        For details, see :obj:`chemicals.viscosity.mu_IAPWS`.\n\n        Returns\n        -------\n        mu : float\n            Viscosity of water, [Pa*s]\n        \"\"\"\n        try:\n            return self._mu\n        except:\n            pass\n        self.__mu_k()\n        return self._mu\n\n    def k(self):\n        \"\"\"Calculate and return the thermal conductivity of water according to the IAPWS.\n        For details, see :obj:`chemicals.thermal_conductivity.k_IAPWS`.\n\n        Returns\n        -------\n        k : float\n            Thermal conductivity of water, [W/m/K]\n        \"\"\"\n        try:\n            return self._k\n        except:\n            pass\n        self.__mu_k()\n        return self._k\n\n    def __mu_k(self):\n        drho_mass_dP = self.drho_mass_dP()\n        drho_dP_Tr = self.to(T=self.T_fixed_transport, V=self._V, zs=self.zs).drho_mass_dP()\n        self._mu = mu_IAPWS(T=self.T, rho=self._rho_mass, drho_dP=drho_mass_dP, drho_dP_Tr=drho_dP_Tr)\n        self._k = k_IAPWS(T=self.T, rho=self._rho_mass, Cp=self.Cp_mass(), Cv=self.Cv_mass(), mu=self._mu, drho_dP=drho_mass_dP, drho_dP_Tr=drho_dP_Tr)\n\nclass IAPWS95Gas(IAPWS95):\n    is_gas = True\n    is_liquid = False\n    force_phase = 'g'\n\nclass IAPWS95Liquid(IAPWS95):\n    force_phase = 'l'\n    is_gas = False\n    is_liquid = True\n\n    def sigma(self):\n        try:\n            return self._sigma\n        except:\n            pass\n        self._sigma = sigma_IAPWS(self.T)\n        return self._sigma\n\nclass IAPWS97(Phase):\n    model_name = 'iapws97'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    R = 461.526\n    Tc = 647.096\n    Pc = 22064000.0\n    rhoc = 322.0\n    zs = [1.0]\n    cmps = [0]\n\n    def mu(self):\n        return mu_IAPWS(T=self.T, rho=self._rho_mass)\n\n    def k(self):\n        return k_IAPWS(T=self.T, rho=self._rho_mass)\n\n    def G(self):\n        try:\n            return self._G\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            G = iapws.iapws97_G_region1(tau, pi)\n        elif region == 2:\n            G = iapws.iapws97_Gr_region2(tau, pi) + iapws.iapws97_G0_region2(tau, pi)\n        elif region == 5:\n            G = iapws.iapws97_Gr_region5(tau, pi) + iapws.iapws97_G0_region5(tau, pi)\n        elif region == 4:\n            G = self.H() - self.T * self.S()\n        self._G = G\n        return G\n\n    def dG_dpi(self):\n        try:\n            return self._dG_dpi\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            dG_dpi = iapws.iapws97_dG_dpi_region1(tau, pi)\n        elif region == 2:\n            dG_dpi = 1.0 / pi + iapws.iapws97_dGr_dpi_region2(tau, pi)\n        elif region == 5:\n            dG_dpi = 1.0 / pi + iapws.iapws97_dGr_dpi_region5(tau, pi)\n        self._dG_dpi = dG_dpi\n        return dG_dpi\n\n    def d2G_d2pi(self):\n        try:\n            return self._d2G_d2pi\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            d2G_d2pi = iapws.iapws97_d2G_dpi2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2pi = -1.0 / (pi * pi) + iapws.iapws97_d2Gr_dpi2_region2(tau, pi)\n        elif region == 5:\n            d2G_d2pi = -1.0 / (pi * pi) + iapws.iapws97_d2Gr_dpi2_region5(tau, pi)\n        self._d2G_d2pi = d2G_d2pi\n        return d2G_d2pi\n\n    def dG_dtau(self):\n        try:\n            return self._dG_dtau\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            dG_dtau = iapws.iapws97_dG_dtau_region1(tau, pi)\n        elif region == 2:\n            dG_dtau = iapws.iapws97_dG0_dtau_region2(tau, pi) + iapws.iapws97_dGr_dtau_region2(tau, pi)\n        elif region == 5:\n            dG_dtau = iapws.iapws97_dG0_dtau_region5(tau, pi) + iapws.iapws97_dGr_dtau_region5(tau, pi)\n        self._dG_dtau = dG_dtau\n        return dG_dtau\n\n    def d2G_d2tau(self):\n        try:\n            return self._d2G_d2tau\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            d2G_d2tau = iapws.iapws97_d2G_dtau2_region1(tau, pi)\n        elif region == 2:\n            d2G_d2tau = iapws.iapws97_d2Gr_dtau2_region2(tau, pi) + iapws.iapws97_d2G0_dtau2_region2(tau, pi)\n        elif region == 5:\n            d2G_d2tau = iapws.iapws97_d2Gr_dtau2_region5(tau, pi) + iapws.iapws97_d2G0_dtau2_region5(tau, pi)\n        self._d2G_d2tau = d2G_d2tau\n        return d2G_d2tau\n\n    def d2G_dpidtau(self):\n        try:\n            return self._d2G_dpidtau\n        except:\n            pass\n        tau, pi, region = (self.tau, self.pi, self.region)\n        if region == 1:\n            d2G_dpidtau = iapws.iapws97_d2G_dpidtau_region1(tau, pi)\n        elif region == 2:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region2(tau, pi)\n        elif region == 5:\n            d2G_dpidtau = iapws.iapws97_d2Gr_dpidtau_region5(tau, pi)\n        self._d2G_dpidtau = d2G_dpidtau\n        return d2G_dpidtau\n\n    def A_region3(self):\n        try:\n            return self._A_region3\n        except:\n            pass\n        self._A_region3 = A_region3 = iapws.iapws97_A_region3_region3(self.tau, self.delta)\n        return A_region3\n\n    def dA_ddelta(self):\n        try:\n            return self._dA_ddelta\n        except:\n            pass\n        self._dA_ddelta = dA_ddelta = iapws.iapws97_dA_ddelta_region3(self.tau, self.delta)\n        return dA_ddelta\n\n    def d2A_d2delta(self):\n        try:\n            return self._d2A_d2delta\n        except:\n            pass\n        self._d2A_d2delta = d2A_d2delta = iapws.iapws97_d2A_d2delta_region3(self.tau, self.delta)\n        return d2A_d2delta\n\n    def dA_dtau(self):\n        try:\n            return self._dA_dtau\n        except:\n            pass\n        self._dA_dtau = dA_dtau = iapws.iapws97_dA_dtau_region3(self.tau, self.delta)\n        return dA_dtau\n\n    def d2A_d2tau(self):\n        try:\n            return self._d2A_d2tau\n        except:\n            pass\n        self._d2A_d2tau = d2A_d2tau = iapws.iapws97_d2A_d2tau_region3(self.tau, self.delta)\n        return d2A_d2tau\n\n    def d2A_ddeltadtau(self):\n        try:\n            return self._d2A_ddeltadtau\n        except:\n            pass\n        self._d2A_ddeltadtau = d2A_ddeltadtau = iapws.iapws97_d2A_ddeltadtau_region3(self.tau, self.delta)\n        return d2A_ddeltadtau\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P * 6.049606775559589e-08\n            self.tau = 1386.0 / T\n            self.Pref = 16530000.0\n            self.Tref = 1386.0\n        elif region == 2:\n            self.pi = P * 1e-06\n            self.tau = 540.0 / T\n            self.Pref = 1000000.0\n            self.Tref = 540.0\n        elif region == 3:\n            self.tau = self.Tc / T\n            self.Tref = self.Tc\n            self.delta = self._rho_mass * 0.003105590062111801\n            self.rhoref = 322.0\n        elif region == 5:\n            self.pi = P * 1e-06\n            self.tau = 1000.0 / T\n            self.Tref = 1000.0\n            self.Pref = 1000000.0\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        self._rho_mass = iapws.iapws97_rho(T, P)\n        self._V = rho_to_Vm(rho=self._rho_mass, MW=self._MW)\n        self.region = region = iapws.iapws97_identify_region_TP(T, P)\n        if region == 1:\n            self.pi = P * 6.049606775559589e-08\n            self.tau = 1386.0 / T\n        elif region == 2:\n            self.pi = P * 1e-06\n            self.tau = 540.0 / T\n        elif region == 3:\n            self.tau = self.Tc / T\n            self.delta = self._rho_mass * 0.003105590062111801\n        elif region == 5:\n            self.pi = P * 1e-06\n            self.tau = 1000.0 / T\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new._rho_mass = rho_mass = iapws.iapws97_rho(T, P)\n                new._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n                new.P = P\n            elif V is not None:\n                new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n                P = iapws.iapws97_P(T, rho_mass)\n                new.V = V\n                new.P = P\n        elif P is not None and V is not None:\n            new._rho_mass = rho_mass = Vm_to_rho(V, MW=self._MW)\n            T = new.T = iapws.iapws97_T(P, rho_mass)\n            new.V = V\n            new.P = P\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        new.region = region = iapws.iapws97_identify_region_TP(new.T, new.P)\n        if region == 1:\n            new.pi = P * 6.049606775559589e-08\n            new.tau = 1386.0 / T\n            new.Pref = 16530000.0\n            new.Tref = 1386.0\n        elif region == 2:\n            new.pi = P * 1e-06\n            new.tau = 540.0 / T\n            new.Pref = 1000000.0\n            new.Tref = 540.0\n        elif region == 3:\n            new.tau = new.Tc / T\n            new.Tref = new.Tc\n            new.delta = new._rho_mass * 0.003105590062111801\n            new.rhoref = 322.0\n        elif region == 5:\n            new.pi = P * 1e-06\n            new.tau = 1000.0 / T\n            new.Tref = 1000.0\n            new.Pref = 1000000.0\n        new.P = P\n        new.T = T\n        return new\n\n    def V(self):\n        return self._V\n\n    def U(self):\n        try:\n            return self._U\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            U = self.R * self.T(*self.tau * dG_dtau - self.pi * dG_dpi)\n        self._U = U\n        return U\n\n    def S(self):\n        try:\n            return self._S\n        except:\n            pass\n        if self.region != 3:\n            try:\n                G = self._G\n            except:\n                G = self.G()\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            S = self.R * (self.tau * dG_dtau - G)\n        self._S = S\n        return S\n\n    def H(self):\n        try:\n            return self._H\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dtau = self._dG_dtau\n            except:\n                dG_dtau = self.dG_dtau()\n            H = self.R * self.T * self.tau * dG_dtau\n        self._H = H\n        return H\n\n    def Cv(self):\n        try:\n            return self._Cv\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2tau = self._d2G_d2tau\n            except:\n                d2G_d2tau = self.d2G_d2tau()\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n            tau = self.tau\n            x0 = dG_dpi - tau * d2G_dpidtau\n            Cv = self.R * (-tau * tau * d2G_d2tau + x0 * x0 / d2G_d2pi)\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except:\n            pass\n        if self.region == 3:\n            tau, delta = (self.tau, self.delta)\n            try:\n                dA_ddelta = self._dA_ddelta\n            except:\n                dA_ddelta = self.dA_ddelta()\n            try:\n                d2A_ddeltadtau = self._d2A_ddeltadtau\n            except:\n                d2A_ddeltadtau = self.d2A_ddeltadtau()\n            try:\n                d2A_d2delta = self._d2A_d2delta\n            except:\n                d2A_d2delta = self.d2A_d2delta()\n            try:\n                d2A_d2tau = self._d2A_d2tau\n            except:\n                d2A_d2tau = self.d2A_d2tau()\n            x0 = delta * dA_ddelta - delta * tau * d2A_ddeltadtau\n            Cp = self.R * (-tau * tau * d2A_d2tau + x0 * x0 / (delta * (2.0 * dA_ddelta + delta * d2A_d2delta)))\n        else:\n            tau = self.tau\n            Cp = -self.R * tau * tau * self.d2G_d2tau()\n        Cp *= self._MW * 0.001\n        self._Cp = Cp\n        return Cp\n    dH_dT = dH_dT_P = Cp\n\n    def dV_dP(self):\n        \"\"\"\n        from sympy import *\n        R, T, MW, P, Pref, Tref = symbols('R, T, MW, P, Pref, Tref')\n        dG_dpif = symbols('dG_dpi', cls=Function)\n        pi = P/Pref\n        tau = Tref/T\n        dG_dpi = dG_dpif(tau, pi)\n        V = (R*T*pi*dG_dpi*MW)/(1000*P)\n        print(diff(V, P))\n\n        MW*R*T*Subs(Derivative(dG_dpi(Tref/T, _xi_2), _xi_2), _xi_2, P/Pref)/(1000*Pref**2)\n        \"\"\"\n        try:\n            return self._dV_dP\n        except:\n            pass\n        if self.region != 3:\n            try:\n                d2G_d2pi = self._d2G_d2pi\n            except:\n                d2G_d2pi = self.d2G_d2pi()\n            dV_dP = self._MW * self.R * self.T * d2G_d2pi / (1000.0 * self.Pref * self.Pref)\n        self._dV_dP = dV_dP\n        return dV_dP\n\n    def dV_dT(self):\n        try:\n            return self._dV_dT\n        except:\n            pass\n        if self.region != 3:\n            try:\n                dG_dpi = self._dG_dpi\n            except:\n                dG_dpi = self.dG_dpi()\n            try:\n                d2G_dpidtau = self._d2G_dpidtau\n            except:\n                d2G_dpidtau = self.d2G_dpidtau()\n            dV_dT = self._MW * self.R * dG_dpi / (1000 * self.Pref) - self._MW * self.R * self.Tref * d2G_dpidtau / (1000 * self.Pref * self.T)\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except:\n            pass\n        if self.region != 3:\n            dP_dT = -self.dV_dT() / self.dV_dP()\n        self._dP_dT = dP_dT\n        return dP_dT\n\n    def dP_dV(self):\n        return 1.0 / self.dV_dP()\n\nclass IAPWS06(GibbsEOS):\n    T_MAX_FLASH = T_MAX_FIXED = 273.16\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    model_name = 'iapws06'\n    model_attributes = ('model_name',)\n    _MW = 18.015268\n    zs = [1.0]\n    cmps = [0]\n    R06 = iapws.iapws95_R\n    R06_inv = 1.0 / R06\n    _MW_kg = _MW * 0.001\n    R = _MW_kg * iapws.iapws95_R\n    R_inv = 1.0 / R\n    R2 = R * R\n    Tt = 273.16\n    Tt_inv = 1.0 / Tt\n    p0 = 101325.0\n    pt = 611.657\n    pt_inv = 1.0 / pt\n    pi0 = p0 / pt\n    g0n = [-632020.233335886, 0.655022213658955, -1.89369929326131e-08, 3.39746123271053e-15, -5.56464869058991e-22]\n    g0n_rev = g0n[::-1]\n    s0 = -3327.33756492168\n    t1 = 0.0368017112855051 + 0.0510878114959572j\n    r1 = 44.7050716285388 + 65.6876847463481j\n    t2 = 0.337315741065416 + 0.335449415919309j\n    r2n = [-72.597457432922 - 78.100842711287j, -5.57107698030123e-05 + 4.64578634580806e-05j, 2.34801409215913e-11 - 2.85651142904972e-11j]\n    r2n_rev = r2n[::-1]\n    r2np_rev = [7.677551608692879e-14 - 9.340239477516712e-14j, -9.108171704568459e-08 + 7.595411065038183e-08j]\n    g0p_coeffs = [-3.6390648292032365e-24, 1.666356094695489e-17, -6.192030151739651e-11, 0.0010708979275295713]\n    g0pp_coeffs = [-1.7848556441943294e-26, 5.44866189611331e-20, -1.0123370045204503e-13]\n    r2pp = r2n[2] * 2.0 / (pt * pt)\n\n    def __init__(self, T=None, P=None, zs=None):\n        self.T = T\n        self.P = P\n        self._set_core()\n\n    def to_TP_zs(self, T, P, zs, other_eos=None):\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new._set_core()\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        if T is not None:\n            new.T = T\n            if P is not None:\n                new.P = P\n                new._set_core()\n            elif V is not None:\n\n                def V_err(P):\n                    new.P = P\n                    new._set_core()\n                    return new._V - V\n                P = secant(V_err, 100000.0, xtol=1e-12, bisection=True)\n                new.P = P\n                new._set_core()\n        elif P is not None and V is not None:\n            new.P = P\n\n            def V_err(T):\n                new.T = T\n                new._set_core()\n                return new._V - V\n            T = secant(V_err, 250.0, xtol=1e-12, bisection=True)\n            new.T = T\n            new._set_core()\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        new.P = P\n        new.T = T\n        return new\n\n    def _set_core(self):\n        T, P = (self.T, self.P)\n        self.tau = T * self.Tt_inv\n        self.pi = P * self.pt_inv\n        pi, tau = (self.pi, self.tau)\n        R06_inv = self.R06_inv\n        t1, t2, pi0 = (self.t1, self.t2, self.pi0)\n        s0, Tt, r1 = (self.s0, self.Tt, self.r1)\n        tau2 = tau * tau\n        v0 = pi - pi0\n        r2 = v0 * (v0 * (2.34801409215913e-11 - 2.85651142904972e-11j) + (-5.57107698030123e-05 + 4.64578634580806e-05j)) + (-72.597457432922 - 78.100842711287j)\n        r2p = v0 * (7.677551608692879e-14 - 9.340239477516712e-14j) + (-9.108171704568459e-08 + 7.595411065038183e-08j)\n        g0 = v0 * (v0 * (v0 * (-5.56464869058991e-22 * v0 + 3.39746123271053e-15) - 1.89369929326131e-08) + 0.655022213658955) - 632020.233335886\n        g0p = v0 * (v0 * (-3.6390648292032365e-24 * v0 + 1.666356094695489e-17) - 6.192030151739651e-11) + 0.0010708979275295713\n        g0pp = (-1.7848556441943294e-26 * v0 + 5.44866189611331e-20) * v0 - 1.0123370045204503e-13\n        log_t1_tau = logc(t1 + tau)\n        log_t1_n_tau = logc(t1 - tau)\n        log_t2_tau = logc(t2 + tau)\n        log_t2_n_tau = logc(t2 - tau)\n        log_t1 = logc(t1)\n        log_t2 = logc(t2)\n        t2_inv = 1.0 / t2\n        t1_inv = 1.0 / t1\n        tau_t2inv = tau * t2_inv\n        t2_log_t2 = t2 * log_t2\n        t2_log_t2_2 = t2_log_t2 + t2_log_t2\n        g_real_sum = (r1 * ((t1 - tau) * log_t1_n_tau + (t1 + tau) * log_t1_tau - 2.0 * t1 * log_t1 - tau2 * t1_inv) + r2 * ((t2 - tau) * log_t2_n_tau + (t2 + tau) * log_t2_tau - t2_log_t2_2 - tau2 * t2_inv)).real\n        g = g0 - s0 * Tt * tau + Tt * g_real_sum\n        g_T_real_sum = (r1 * (-log_t1_n_tau + log_t1_tau - 2.0 * tau * t1_inv) + r2 * (-log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_T = -s0 + g_T_real_sum\n        g_TT_real_sum = (r1 * (1.0 / (t1 - tau) + 1.0 / (t1 + tau) - t1_inv - t1_inv) + r2 * (1.0 / (t2 - tau) + 1.0 / (t2 + tau) - t2_inv - t2_inv)).real\n        g_TT = 0.0036608581051398447 * g_TT_real_sum\n        x0 = (t2 - tau) * log_t2_n_tau + (t2 + tau) * log_t2_tau - t2_log_t2_2 - tau2 * t2_inv\n        g_P_real_sum = (r2p * x0).real\n        g_P = g0p + Tt * g_P_real_sum\n        g_PP_real_sum = (self.r2pp * x0).real\n        g_PP = g0pp + Tt * g_PP_real_sum\n        g_TP_real_sum = (r2p * (-log_t2_n_tau + log_t2_tau - tau_t2inv - tau_t2inv)).real\n        g_TP = g_TP_real_sum\n        self._rho_mass = rho_mass = 1.0 / g_P\n        self._V = rho_to_Vm(rho=rho_mass, MW=self._MW)\n        fact = self._MW_kg\n        self._G = g * fact\n        self._dG_dT = g_T * fact\n        self._d2G_dT2 = g_TT * fact\n        self._dG_dP = g_P * fact\n        self._d2G_dP2 = g_PP * fact\n        self._d2G_dTdP = g_TP * fact\n\n    def G(self):\n        return self._G\n\n    def dG_dT(self):\n        return self._dG_dT\n\n    def d2G_dT2(self):\n        return self._d2G_dT2\n\n    def dG_dP(self):\n        return self._dG_dP\n\n    def d2G_dP2(self):\n        return self._d2G_dP2\n\n    def d2G_dTdP(self):\n        return self._d2G_dTdP\n    d2G_dPdT = d2G_dTdP\n\n    def P_sub(self):\n        return iapws.iapws11_Psub(self.T)\n\n    def vapor_fugacity_coefficient(self):\n        return 1.0\n\n    def fugacities(self):\n        P_sub = self.P_sub()\n        phi = self.vapor_fugacity_coefficient()\n        fugacity = phi * P_sub * exp(self.V() / (self.R * self.T) * (self.P - P_sub))\n        return [fugacity]",
    "thermo/phases/gibbs_excess.py": "\"\"\"Chemical Engineering Design Library (ChEDL). Utilities for process modeling.\nCopyright (C) 2019, 2020 Caleb Bell <Caleb.Andrew.Bell@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\"\"\"\n__all__ = ['GibbsExcessLiquid', 'GibbsExcessSolid']\nfrom math import isinf, isnan\nfrom chemicals.solubility import Henry_constants, d2Henry_constants_dT2, dHenry_constants_dT\nfrom chemicals.utils import phase_identification_parameter\nfrom fluids.constants import R, R_inv\nfrom fluids.numerics import derivative, evaluate_linear_fits, evaluate_linear_fits_d, evaluate_linear_fits_d2, exp, horner_and_der2, log, secant, trunc_exp\nfrom fluids.numerics import numpy as np\nfrom thermo.activity import IdealSolution\nfrom thermo.heat_capacity import HeatCapacityGas, HeatCapacityLiquid\nfrom thermo.nrtl import nrtl_d2taus_dT2 as d2ln_henries_dT2\nfrom thermo.nrtl import nrtl_dtaus_dT as dln_henries_dT\nfrom thermo.nrtl import nrtl_taus as ln_henries\nfrom thermo.phase_change import EnthalpySublimation, EnthalpyVaporization\nfrom thermo.phases.phase import Phase\nfrom thermo.utils import POLY_FIT, TRANSFORM_SECOND_DERIVATIVE_RATIO, TRANSFORM_SECOND_LOG_DERIVATIVE, TRANSFORM_DERIVATIVE_RATIO, TRANSFORM_LOG_DERIVATIVE, TRANSFORM_LOG\nfrom thermo.vapor_pressure import SublimationPressure, VaporPressure\nfrom thermo.volume import VolumeLiquid, VolumeSolid\ntry:\n    zeros, array = (np.zeros, np.array)\nexcept:\n    pass\n\nclass GibbsExcessLiquid(Phase):\n    \"\"\"Phase based on combining Raoult's law with a\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model, optionally\n    including saturation fugacity coefficient corrections (if the vapor phase\n    is a cubic equation of state) and Poynting correction factors (if more\n    accuracy is desired).\n\n    The equilibrium equation options (controlled by `equilibrium_basis`)\n    are as follows:\n\n    * 'Psat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat}}{P}`\n    * 'Poynting&PhiSat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat} \\\\text{Poynting}_i}{P}`\n    * 'Poynting': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat}\\\\text{Poynting}_i}{P}`\n    * 'PhiSat': :math:`\\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat}}{P}`\n\n    In all cases, the activity coefficient is derived from the\n    :obj:`GibbsExcess <thermo.activity.GibbsExcess>` model specified as\n    input; use the :obj:`IdealSolution <thermo.activity.IdealSolution>`\n    class as an input to set the activity coefficients to one.\n\n    The enthalpy `H` and entropy `S` (and other caloric properties `U`, `G`, `A`)\n    equation options are similar to the equilibrium ones. If the same option\n    is selected for `equilibrium_basis` and `caloric_basis`, the phase will be\n    `thermodynamically consistent`. This is recommended for many reasons.\n    The full 'Poynting&PhiSat' equations for `H` and `S` are as follows; see\n    :obj:`GibbsExcessLiquid.H` and :obj:`GibbsExcessLiquid.S` for all of the\n    other equations:\n\n    .. math::\n        H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n        \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n        + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n        + \\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}} \\\\right)\n        + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n    .. math::\n        S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n        - \\\\sum_i z_i\\\\left[R\\\\left(\n        T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n        + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n        + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\n        + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}\\\\cdot\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\n        \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n    An additional caloric mode is `Hvap`, which uses enthalpy of vaporization;\n    this mode can never be thermodynamically consistent, but is still widely\n    used.\n\n    .. math::\n        H = H_{\\\\text{excess}} + \\\\sum_i z_i\\\\left[-H_{vap,i}\n        + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n    .. math::\n        S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n        - \\\\sum_i z_i\\\\left[R\\\\left(\\\\ln P_{\\\\text{sat},i} + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\\\\right)\n        + \\\\frac{H_{vap,i}}{T}\n        - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n\n    .. warning::\n        Note that above the critical point, there is no definition for what vapor\n        pressure is. The vapor pressure also tends to reach zero at temperatures\n        in the 4-20 K range. These aspects mean extrapolation in the supercritical and\n        very low temperature region is critical to ensure the equations will still\n        converge. Extrapolation can be performed using either the equation\n        :math:`P^{\\\\text{sat}} = \\\\exp\\\\left(A - \\\\frac{B}{T}\\\\right)` or\n        :math:`P^{\\\\text{sat}} = \\\\exp\\\\left(A + \\\\frac{B}{T} + C\\\\cdot \\\\ln T\\\\right)` by\n        setting `Psat_extrpolation` to either 'AB' or 'ABC' respectively.\n        The extremely low temperature region's issue is solved by calculating the\n        logarithm of vapor pressures instead of the actual value. While floating\n        point values in Python (doubles) can reach a minimum value of around\n        1e-308, if only the logarithm of that number is computed no issues arise.\n        Both of these features only work when the vapor pressure correlations are\n        polynomials.\n\n    .. warning::\n        When using 'PhiSat' as an option, note that the factor cannot be\n        calculated when a compound is supercritical,\n        as there is no longer any vapor-liquid pure-component equilibrium\n        (by definition).\n\n    Parameters\n    ----------\n    VaporPressures : list[:obj:`thermo.vapor_pressure.VaporPressure`]\n        Objects holding vapor pressure data and methods, [-]\n    VolumeLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods; required for Poynting\n        factors and volumetric properties, [-]\n    HeatCapacityGases : list[:obj:`thermo.heat_capacity.HeatCapacityGas`], optional\n        Objects proiding pure-component heat capacity correlations; required\n        for caloric properties, [-]\n    GibbsExcessModel : :obj:`GibbsExcess <thermo.activity.GibbsExcess>`, optional\n        Configured instance for calculating activity coefficients and excess properties;\n        set to :obj:`IdealSolution <thermo.activity.IdealSolution>` if not provided, [-]\n    eos_pure_instances : list[:obj:`thermo.eos.GCEOS`], optional\n        Cubic equation of state object instances for each pure component, [-]\n    EnthalpyVaporizations : list[:obj:`thermo.phase_change.EnthalpyVaporization`], optional\n        Objects holding enthalpy of vaporization data and methods; used only\n        with the 'Hvap' optional, [-]\n    HeatCapacityLiquids : list[:obj:`thermo.heat_capacity.HeatCapacityLiquid`], optional\n        Objects holding liquid heat capacity data and methods; not used at\n        present, [-]\n    VolumeSupercriticalLiquids : list[:obj:`thermo.volume.VolumeLiquid`], optional\n        Objects holding liquid volume data and methods but that are used for\n        supercritical temperatures on a per-component basis only; required for\n        Poynting factors and volumetric properties at supercritical conditions;\n        `VolumeLiquids` is used if not provided, [-]\n    Hfs : list[float], optional\n        Molar ideal-gas standard heats of formation at 298.15 K and 1 atm,\n        [J/mol]\n    Gfs : list[float], optional\n        Molar ideal-gas standard Gibbs energies of formation at 298.15 K and\n        1 atm, [J/mol]\n    T : float, optional\n        Temperature, [K]\n    P : float, optional\n        Pressure, [Pa]\n    zs : list[float], optional\n        Mole fractions of each component, [-]\n    equilibrium_basis : str, optional\n        Which set of equilibrium equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', [-]\n    caloric_basis : str, optional\n        Which set of caloric equations to use when calculating fugacities\n        and related properties; valid options are 'Psat', 'Poynting&PhiSat',\n        'Poynting', 'PhiSat', 'Hvap' [-]\n    Psat_extrpolation : str, optional\n        One of 'AB' or 'ABC'; configures extrapolation for vapor pressure, [-]\n    henry_abcdef : tuple[list[list[float]], 6], optional\n        Contains the parameters used for henry's law constant, [-]\n    henry_as : list[list[float]], optional\n        `a` parameters used in calculating henry's law constant, [-]\n    henry_bs : list[list[float]], optional\n        `b` parameters used in calculating henry's law constant, [K]\n    henry_cs : list[list[float]], optional\n        `c` parameters used in calculating henry's law constant, [-]\n    henry_ds : list[list[float]], optional\n        `d` paraemeters used in calculating henry's law constant, [1/K]\n    henry_es : list[list[float]], optional\n        `e` parameters used in calculating henry's law constant, [K^2]\n    henry_fs : list[list[float]], optional\n        `f` parameters used in calculating henry's law constant, [1/K^2]\n    henry_mode : str\n        The setting for henry's law. 'solvents' to consider all\n        components set not to be henry's law components a solvent (if\n        any parameters are missing this will not make sense at all);\n        'solvents_with_parameters' to consider only the solvents with\n        parameters (vapor pressures will be used if a component has\n        no solvents whatsoever)\n\n    use_Hvap_caloric : bool, optional\n        If True, enthalpy and entropy will be calculated using ideal-gas\n        heat capacity and the heat of vaporization of the fluid only. This\n        forces enthalpy to be pressure-independent. This supersedes other\n        options which would otherwise impact these properties. The molar volume\n        of the fluid has no impact on enthalpy or entropy if this option is\n        True. This option is not thermodynamically consistent, but is still\n        often an assumption that is made.\n\n    \"\"\"\n    PIP_INCALCULABLE_VALUE = 2\n    force_phase = 'l'\n    phase = 'l'\n    is_gas = False\n    is_liquid = True\n    P_DEPENDENT_H_LIQ = True\n    PHI_SAT_IDEAL_TR = 0.1\n    _Psats_data = None\n    _Vms_sat_data = None\n    _Hvap_data = None\n    use_IG_Cp = True\n    ideal_gas_basis = True\n    supercritical_volumes = False\n    Cpls_poly_fit = False\n    _Cpls_data = None\n    _Tait_B_data = None\n    _Tait_C_data = None\n    pure_references = ('HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids', 'EnthalpyVaporizations')\n    pure_reference_types = (HeatCapacityGas, VolumeLiquid, VaporPressure, HeatCapacityLiquid, EnthalpyVaporization)\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_Tait', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'henry_mode', 'Psat_extrpolation') + pure_references\n    obj_references = ('GibbsExcessModel', 'eos_pure_instances', 'result', 'constants', 'correlations', 'HeatCapacityGases', 'VolumeLiquids', 'VaporPressures', 'HeatCapacityLiquids', 'EnthalpyVaporizations')\n    __slots__ = ('VaporPressures', 'Psats_poly_fit', 'Psat_extrpolation', 'N', 'HeatCapacityGases', 'Cpgs_poly_fit', '_Cpgs_data', 'HeatCapacityLiquids', 'use_eos_volume', 'VolumeLiquids', 'Vms_sat_poly_fit', 'VolumeSupercriticalLiquids', 'Vms_supercritical_poly_fit', 'incompressible', 'use_Tait', 'EnthalpyVaporizations', 'Hvap_poly_fit', 'GibbsExcessModel', 'eos_pure_instances', 'equilibrium_basis', 'caloric_basis', 'use_phis_sat', 'use_Poynting', 'use_phis_sat_caloric', 'use_Poynting_caloric', 'use_Hvap_caloric', 'has_henry_components', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'henry_mode', 'composition_independent', 'Hfs', 'Gfs', 'Sfs', 'model_id', 'T', 'P', 'zs', '_model_hash_ignore_phase', '_model_hash')\n\n    def __repr__(self):\n        \"\"\"Method to create a string representation of the phase object, with\n        the goal of making it easy to obtain standalone code which reproduces\n        the current state of the phase. This is extremely helpful in creating\n        new test cases.\n\n        Returns\n        -------\n        recreation : str\n            String which is valid Python and recreates the current state of\n            the object if ran, [-]\n\n        \"\"\"\n        pure_strs = ''\n        for k in self.pure_references:\n            v = getattr(self, k)\n            if v is not None:\n                try:\n                    s = '[' + ', '.join((str(o) for o in v)) + ']'\n                except:\n                    continue\n                pure_strs += f'{k}={s}, '\n        base = f'{self.__class__.__name__}(GibbsExcessModel={self.GibbsExcessModel},\\n               equilibrium_basis={self.equilibrium_basis}, caloric_basis={self.caloric_basis},\\n               eos_pure_instances={self.eos_pure_instances}, {pure_strs}'\n        for s in ('Hfs', 'Gfs', 'Sfs', 'T', 'P', 'zs'):\n            if hasattr(self, s) and getattr(self, s) is not None:\n                base += f'{s}={getattr(self, s)}, '\n        if base[-2:] == ', ':\n            base = base[:-2]\n        base += ')'\n        return base\n\n    def __init__(self, VaporPressures, VolumeLiquids=None, HeatCapacityGases=None, GibbsExcessModel=None, eos_pure_instances=None, EnthalpyVaporizations=None, HeatCapacityLiquids=None, VolumeSupercriticalLiquids=None, use_Hvap_caloric=False, use_Poynting=False, use_phis_sat=False, use_Tait=False, use_eos_volume=False, Hfs=None, Gfs=None, Sfs=None, henry_components=None, henry_abcdef=None, henry_as=None, henry_bs=None, henry_cs=None, henry_ds=None, henry_es=None, henry_fs=None, henry_mode='solvents_with_parameters', T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None, Psat_extrpolation='AB', equilibrium_basis=None, caloric_basis=None):\n        \"\"\"It is quite possible to introduce a PVT relation ship for liquid\n        density and remain thermodynamically consistent. However, must be\n        applied on a per-component basis! This class cannot have an\n        equation-of-state or VolumeLiquidMixture for a liquid MIXTURE!\n\n        (it might still be nice to generalize the handling; maybe even allow)\n        pure EOSs to be used too, and as a form/template for which functions to\n        use).\n\n        In conclusion, you have\n        1) The standard H/S model\n        2) The H/S model with all pressure correction happening at P\n        3) The inconsistent model which has no pressure dependence whatsover in H/S\n           This model is required due to its popularity, not its consistency (but still volume dependency)\n\n        All mixture volumetric properties have to be averages of the pure\n        components properties and derivatives. A Multiphase will be needed to\n        allow flashes with different properties from different phases.\n        \"\"\"\n        self.N = N = len(VaporPressures)\n        if zs is None:\n            zs = [1.0 / N] * N\n        if henry_components is None:\n            henry_components = [False] * self.N\n        self.has_henry_components = any(henry_components)\n        self.henry_components = henry_components\n        self.VaporPressures = VaporPressures\n        self.Psats_poly_fit = all((i.method == POLY_FIT for i in VaporPressures)) and (not self.has_henry_components) if VaporPressures is not None else False\n        self.Psat_extrpolation = Psat_extrpolation\n        if self.Psats_poly_fit:\n            Psats_data = [[i.poly_fit_Tmin for i in VaporPressures], [i.poly_fit_Tmin_slope for i in VaporPressures], [i.poly_fit_Tmin_value for i in VaporPressures], [i.poly_fit_Tmax for i in VaporPressures], [i.poly_fit_Tmax_slope for i in VaporPressures], [i.poly_fit_Tmax_value for i in VaporPressures], [i.poly_fit_coeffs for i in VaporPressures], [i.poly_fit_d_coeffs for i in VaporPressures], [i.poly_fit_d2_coeffs for i in VaporPressures], [i.DIPPR101_ABC for i in VaporPressures]]\n            if Psat_extrpolation == 'AB':\n                Psats_data.append([i.poly_fit_AB_high_ABC_compat + [0.0] for i in VaporPressures])\n            elif Psat_extrpolation == 'ABC':\n                Psats_data.append([i.DIPPR101_ABC_high for i in VaporPressures])\n            self._Psats_data = Psats_data\n        if self.vectorized:\n            zero_coeffs = zeros((N, N))\n        else:\n            zero_coeffs = [[0.0] * N for _ in range(N)]\n        self.HeatCapacityGases = HeatCapacityGases\n        self.Cpgs_poly_fit, self._Cpgs_data = self._setup_Cpigs(HeatCapacityGases)\n        self.HeatCapacityLiquids = HeatCapacityLiquids\n        if HeatCapacityLiquids is not None:\n            self.Cpls_poly_fit, self._Cpls_data = self._setup_Cpigs(HeatCapacityLiquids)\n            T_REF_IG = self.T_REF_IG\n            T_REF_IG_INV = 1.0 / T_REF_IG\n            self.Hvaps_T_ref = [obj(T_REF_IG) for obj in EnthalpyVaporizations]\n            self.dSvaps_T_ref = [T_REF_IG_INV * dH for dH in self.Hvaps_T_ref]\n        self.use_eos_volume = use_eos_volume\n        self.VolumeLiquids = VolumeLiquids\n        self.Vms_sat_poly_fit = not use_eos_volume and all((i.method == POLY_FIT for i in VolumeLiquids)) if VolumeLiquids is not None else False\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_data = [[i.poly_fit_Tmin for i in VolumeLiquids], [i.poly_fit_Tmin_slope for i in VolumeLiquids], [i.poly_fit_Tmin_value for i in VolumeLiquids], [i.poly_fit_Tmax for i in VolumeLiquids], [i.poly_fit_Tmax_slope for i in VolumeLiquids], [i.poly_fit_Tmax_value for i in VolumeLiquids], [i.poly_fit_coeffs for i in VolumeLiquids], [i.poly_fit_d_coeffs for i in VolumeLiquids], [i.poly_fit_d2_coeffs for i in VolumeLiquids], [i.poly_fit_Tmin_quadratic for i in VolumeLiquids]]\n        self.VolumeSupercriticalLiquids = VolumeSupercriticalLiquids\n        self.Vms_supercritical_poly_fit = all((i.method == POLY_FIT for i in VolumeSupercriticalLiquids)) if VolumeSupercriticalLiquids is not None else False\n        if self.Vms_supercritical_poly_fit:\n            self.Vms_supercritical_data = [[i.poly_fit_Tmin for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_slope for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_value for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax_slope for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmax_value for i in VolumeSupercriticalLiquids], [i.poly_fit_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_d_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_d2_coeffs for i in VolumeSupercriticalLiquids], [i.poly_fit_Tmin_quadratic for i in VolumeSupercriticalLiquids]]\n        self.incompressible = not use_Tait\n        self.use_Tait = use_Tait\n        if self.use_Tait:\n            Tait_B_data, Tait_C_data = ([[] for i in range(9)], [[] for i in range(9)])\n            for v in VolumeLiquids:\n                for d, store in zip(v.Tait_data(), [Tait_B_data, Tait_C_data]):\n                    for i in range(len(d)):\n                        store[i].append(d[i])\n            self._Tait_B_data = Tait_B_data\n            self._Tait_C_data = Tait_C_data\n        self.EnthalpyVaporizations = EnthalpyVaporizations\n        self.Hvap_poly_fit = all((i.method == POLY_FIT for i in EnthalpyVaporizations)) if EnthalpyVaporizations is not None else False\n        if self.Hvap_poly_fit:\n            self._Hvap_data = [[i.poly_fit_Tmin for i in EnthalpyVaporizations], [i.poly_fit_Tmax for i in EnthalpyVaporizations], [i.poly_fit_Tc for i in EnthalpyVaporizations], [1.0 / i.poly_fit_Tc for i in EnthalpyVaporizations], [i.poly_fit_coeffs for i in EnthalpyVaporizations]]\n        if GibbsExcessModel is None:\n            GibbsExcessModel = IdealSolution(T=T, xs=zs)\n        self.GibbsExcessModel = GibbsExcessModel\n        self.eos_pure_instances = eos_pure_instances\n        self.equilibrium_basis = equilibrium_basis\n        self.caloric_basis = caloric_basis\n        if equilibrium_basis is not None:\n            if equilibrium_basis == 'Poynting':\n                self.use_Poynting = True\n                self.use_phis_sat = False\n            elif equilibrium_basis == 'Poynting&PhiSat':\n                self.use_Poynting = True\n                self.use_phis_sat = True\n            elif equilibrium_basis == 'PhiSat':\n                self.use_phis_sat = True\n                self.use_Poynting = False\n            elif equilibrium_basis == 'Psat':\n                self.use_phis_sat = False\n                self.use_Poynting = False\n        else:\n            self.use_Poynting = use_Poynting\n            self.use_phis_sat = use_phis_sat\n        if caloric_basis is not None:\n            if caloric_basis == 'Poynting':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Poynting&PhiSat':\n                self.use_Poynting_caloric = True\n                self.use_phis_sat_caloric = True\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'PhiSat':\n                self.use_phis_sat_caloric = True\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Psat':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = False\n            elif caloric_basis == 'Hvap':\n                self.use_phis_sat_caloric = False\n                self.use_Poynting_caloric = False\n                self.use_Hvap_caloric = True\n        else:\n            self.use_Poynting_caloric = use_Poynting\n            self.use_phis_sat_caloric = use_phis_sat\n            self.use_Hvap_caloric = use_Hvap_caloric\n        if henry_mode not in ('solvents', 'solvents_with_parameters'):\n            raise ValueError(\"Henry's law model setting not recognized\")\n        self.henry_mode = henry_mode\n        multiple_henry_inputs = (henry_as, henry_bs, henry_cs, henry_ds, henry_es, henry_fs)\n        input_count_henry = (henry_abcdef is not None) + any((i is not None for i in multiple_henry_inputs))\n        if input_count_henry > 1:\n            raise ValueError('Input only one of henry_abcdef, or (henry_as...henry_fs)')\n        if henry_abcdef is not None:\n            if self.vectorized:\n                self.henry_as = array(henry_abcdef[:, :, 0], order='C', copy=True)\n                self.henry_bs = array(henry_abcdef[:, :, 1], order='C', copy=True)\n                self.henry_cs = array(henry_abcdef[:, :, 2], order='C', copy=True)\n                self.henry_ds = array(henry_abcdef[:, :, 3], order='C', copy=True)\n                self.henry_es = array(henry_abcdef[:, :, 4], order='C', copy=True)\n                self.henry_fs = array(henry_abcdef[:, :, 5], order='C', copy=True)\n            else:\n                self.henry_as = [[i[0] for i in l] for l in henry_abcdef]\n                self.henry_bs = [[i[1] for i in l] for l in henry_abcdef]\n                self.henry_cs = [[i[2] for i in l] for l in henry_abcdef]\n                self.henry_ds = [[i[3] for i in l] for l in henry_abcdef]\n                self.henry_es = [[i[4] for i in l] for l in henry_abcdef]\n                self.henry_fs = [[i[5] for i in l] for l in henry_abcdef]\n        else:\n            if henry_abcdef is None:\n                henry_abcdef = multiple_henry_inputs\n            henry_abcdef_len = 0 if henry_abcdef is None else len(henry_abcdef)\n            if not henry_abcdef_len or henry_abcdef[0] is None:\n                self.henry_as = zero_coeffs\n            else:\n                self.henry_as = henry_abcdef[0]\n            if not henry_abcdef_len or henry_abcdef[1] is None:\n                self.henry_bs = zero_coeffs\n            else:\n                self.henry_bs = henry_abcdef[1]\n            if not henry_abcdef_len or henry_abcdef[2] is None:\n                self.henry_cs = zero_coeffs\n            else:\n                self.henry_cs = henry_abcdef[2]\n            if not henry_abcdef_len or henry_abcdef[3] is None:\n                self.henry_ds = zero_coeffs\n            else:\n                self.henry_ds = henry_abcdef[3]\n            if not henry_abcdef_len or henry_abcdef[4] is None:\n                self.henry_es = zero_coeffs\n            else:\n                self.henry_es = henry_abcdef[4]\n            if not henry_abcdef_len or henry_abcdef[5] is None:\n                self.henry_fs = zero_coeffs\n            else:\n                self.henry_fs = henry_abcdef[5]\n        self.composition_independent = isinstance(GibbsExcessModel, IdealSolution) and (not self.has_henry_components)\n        self.Hfs = Hfs\n        self.Gfs = Gfs\n        self.Sfs = Sfs\n        self.model_id = 20000 + GibbsExcessModel.model_id\n        if T is not None and P is not None and (zs is not None):\n            self.T = T\n            self.P = P\n            self.zs = zs\n\n    def to_TP_zs(self, T, P, zs):\n        T_equal = hasattr(self, 'T') and T == self.T\n        new = self.__class__.__new__(self.__class__)\n        new.T = T\n        new.P = P\n        new.zs = zs\n        new.N = self.N\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n    def to(self, zs, T=None, P=None, V=None):\n        try:\n            T_equal = T == self.T\n        except:\n            T_equal = False\n        new = self.__class__.__new__(self.__class__)\n        new.zs = zs\n        new.N = self.N\n        if T is not None:\n            if P is not None:\n                new.T = T\n                new.P = P\n            elif V is not None:\n\n                def to_solve(P):\n                    return self.to_TP_zs(T, P, zs).V() - V\n                P = secant(to_solve, 0.0002, xtol=1e-08, ytol=1e-10)\n                new.P = P\n        elif P is not None and V is not None:\n\n            def to_solve(T):\n                return self.to_TP_zs(T, P, zs).V() - V\n            T = secant(to_solve, 300, xtol=1e-09, ytol=1e-05)\n            new.T = T\n        else:\n            raise ValueError('Two of T, P, or V are needed')\n        self.transfer_data(new, zs, T, T_equal)\n        return new\n\n    def transfer_data(self, new, zs, T, T_equal):\n        new.VaporPressures = self.VaporPressures\n        new.VolumeLiquids = self.VolumeLiquids\n        new.eos_pure_instances = self.eos_pure_instances\n        new.HeatCapacityGases = self.HeatCapacityGases\n        new.EnthalpyVaporizations = self.EnthalpyVaporizations\n        new.HeatCapacityLiquids = self.HeatCapacityLiquids\n        new.Psats_poly_fit = self.Psats_poly_fit\n        new._Psats_data = self._Psats_data\n        new.Psat_extrpolation = self.Psat_extrpolation\n        new.Cpgs_poly_fit = self.Cpgs_poly_fit\n        new._Cpgs_data = self._Cpgs_data\n        new.Cpls_poly_fit = self.Cpls_poly_fit\n        new._Cpls_data = self._Cpls_data\n        new.Vms_sat_poly_fit = self.Vms_sat_poly_fit\n        new._Vms_sat_data = self._Vms_sat_data\n        new._Hvap_data = self._Hvap_data\n        new.Hvap_poly_fit = self.Hvap_poly_fit\n        new.incompressible = self.incompressible\n        new.equilibrium_basis = self.equilibrium_basis\n        new.caloric_basis = self.caloric_basis\n        new.use_phis_sat = self.use_phis_sat\n        new.use_Poynting = self.use_Poynting\n        new.P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n        new.use_eos_volume = self.use_eos_volume\n        new.use_Hvap_caloric = self.use_Hvap_caloric\n        new.Hfs = self.Hfs\n        new.Gfs = self.Gfs\n        new.Sfs = self.Sfs\n        new.henry_as = self.henry_as\n        new.henry_bs = self.henry_bs\n        new.henry_cs = self.henry_cs\n        new.henry_ds = self.henry_ds\n        new.henry_es = self.henry_es\n        new.henry_fs = self.henry_fs\n        new.henry_components = self.henry_components\n        new.has_henry_components = self.has_henry_components\n        new.henry_mode = self.henry_mode\n        new.composition_independent = self.composition_independent\n        new.model_id = self.model_id\n        new.use_Tait = self.use_Tait\n        new._Tait_B_data = self._Tait_B_data\n        new._Tait_C_data = self._Tait_C_data\n        if T_equal and (self.composition_independent or self.zs is zs):\n            new.GibbsExcessModel = self.GibbsExcessModel\n        else:\n            new.GibbsExcessModel = self.GibbsExcessModel.to_T_xs(T=T, xs=zs)\n        try:\n            if T_equal:\n                if not self.has_henry_components:\n                    try:\n                        new._Psats = self._Psats\n                        new._dPsats_dT = self._dPsats_dT\n                        new._d2Psats_dT2 = self._d2Psats_dT2\n                    except:\n                        pass\n                    try:\n                        new._lnPsats = self._lnPsats\n                        new._dPsats_dT_over_Psats = self._dPsats_dT_over_Psats\n                    except:\n                        pass\n                else:\n                    try:\n                        new._lnHenry_matrix = self._lnHenry_matrix\n                        new._dlnHenry_matrix_dT = self._dlnHenry_matrix_dT\n                        new._d2lnHenry_matrix_dT2 = self._d2lnHenry_matrix_dT2\n                    except:\n                        pass\n                try:\n                    new._Vms_sat = self._Vms_sat\n                    new._Vms_sat_dT = self._Vms_sat_dT\n                    new._d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n                except:\n                    pass\n                try:\n                    new._Cpigs = self._Cpigs\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n                except:\n                    pass\n                try:\n                    new._Cpig_integrals_pure = self._Cpig_integrals_pure\n                except:\n                    pass\n        except:\n            pass\n        return new\n    supports_lnphis_args = False\n\n    def lnphis_args(self):\n        try:\n            return self._lnphis_args\n        except:\n            pass\n        lnPsats = self.lnPsats()\n        Poyntings = self.Poyntings()\n        phis_sat = self.phis_sat()\n        activity_args = self.GibbsExcessModel.gammas_args()\n        lnphis = zeros(self.N) if self.vectorized else [0.0] * self.N\n        self._lnphis_args = (self.model_id, self.T, self.P, self.N, lnPsats, Poyntings, phis_sat) + activity_args + (lnphis,)\n        return self._lnphis_args\n\n    def lnHenry_matrix(self):\n        \"\"\"Method to calculate and return the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        .. math::\n            \\\\ln \\\\text{H}_{i,j} = A_{ij}+\\\\frac{B_{ij}}{T}+C_{ij}\\\\ln T + D_{ij}T\n            + \\\\frac{E_{ij}}{T^2} + F_{ij}{T^2}\n\n        Returns\n        -------\n        lnHenry_matrix : list[list[float]]\n            Henry's law interaction parameters, [log(Pa)]\n\n        Notes\n        -----\n        Solvent/solvent and gas/gas values are all 0.\n        \"\"\"\n        try:\n            return self._lnHenry_matrix\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            lnHenry_matrix = zeros((N, N))\n        else:\n            lnHenry_matrix = [[0.0] * N for _ in range(N)]\n        lnHenry_matrix = ln_henries(self.T, N, self.henry_as, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, lnHenry_matrix)\n        self._lnHenry_matrix = lnHenry_matrix\n        return lnHenry_matrix\n\n    def dlnHenry_matrix_dT(self):\n        \"\"\"Method to calculate and return the first temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        dlnHenry_matrix_dT : list[list[float]]\n            First temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._dlnHenry_matrix_dT\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            dlnHenry_matrix_dT = zeros((N, N))\n        else:\n            dlnHenry_matrix_dT = [[0.0] * N for _ in range(N)]\n        dlnHenry_matrix_dT = dln_henries_dT(self.T, N, self.henry_bs, self.henry_cs, self.henry_ds, self.henry_es, self.henry_fs, dlnHenry_matrix_dT)\n        self._dlnHenry_matrix_dT = dlnHenry_matrix_dT\n        return dlnHenry_matrix_dT\n\n    def d2lnHenry_matrix_dT2(self):\n        \"\"\"Method to calculate and return the second temperature derivative\n        of the matrix of log Henry's law constants\n        as required by the traditional mixing rule, [-].\n\n        Returns\n        -------\n        d2lnHenry_matrix_dT2 : list[list[float]]\n            Second temperature derivative of Henry's law interaction\n            parameters, [log(Pa)/K]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._d2lnHenry_matrix_dT2\n        except:\n            pass\n        N = self.N\n        if self.vectorized:\n            d2lnHenry_matrix_dT2 = zeros((N, N))\n        else:\n            d2lnHenry_matrix_dT2 = [[0.0] * N for _ in range(N)]\n        d2lnHenry_matrix_dT2 = d2ln_henries_dT2(self.T, N, self.henry_bs, self.henry_cs, self.henry_es, self.henry_fs, d2lnHenry_matrix_dT2)\n        self._d2lnHenry_matrix_dT2 = d2lnHenry_matrix_dT2\n        return d2lnHenry_matrix_dT2\n\n    def Henry_constants(self):\n        zs, vectorized, N, henry_components, henry_mode = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        Hs = zeros(N) if vectorized else [0.0] * N\n        Henry_constants(lnHenry_matrix, zs, henry_components, solvents_with_parameters, Hs)\n        return Hs\n        dHenry_constants_dT\n\n    def dHenry_constants_dT(self):\n        zs, vectorized, N, henry_components, henry_mode = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        dHs = zeros(N) if vectorized else [0.0] * N\n        dHenry_constants_dT(lnHenry_matrix, dlnHenry_matrix_dT, zs, henry_components, solvents_with_parameters, dHs)\n        return dHs\n\n    def d2Henry_constants_dT2(self):\n        zs, vectorized, N, henry_components, henry_mode = (self.zs, self.vectorized, self.N, self.henry_components, self.henry_mode)\n        solvents_with_parameters = henry_mode == 'solvents_with_parameters'\n        lnHenry_matrix = self.lnHenry_matrix()\n        dlnHenry_matrix_dT = self.dlnHenry_matrix_dT()\n        d2lnHenry_matrix_dT2 = self.d2lnHenry_matrix_dT2()\n        d2Hs = zeros(N) if vectorized else [0.0] * N\n        d2Henry_constants_dT2(lnHenry_matrix, dlnHenry_matrix_dT, d2lnHenry_matrix_dT2, zs, henry_components, solvents_with_parameters, d2Hs)\n        return d2Hs\n\n    def Psats_T_ref(self):\n        try:\n            return self._Psats_T_ref\n        except AttributeError:\n            pass\n        VaporPressures, N = (self.VaporPressures, self.N)\n        T_REF_IG = self.T_REF_IG\n        if self.has_henry_components:\n            self._Psats_T_ref = self.to(T=T_REF_IG, P=self.P, zs=self.zs).Psats()\n        else:\n            self._Psats_T_ref = [VaporPressures[i](T_REF_IG) for i in range(N)]\n        return self._Psats_T_ref\n\n    def Psats_at(self, T):\n        if self.Psats_poly_fit:\n            return self._Psats_at_poly_fit(T, self._Psats_data, range(self.N))\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).Psats()\n        VaporPressures = self.VaporPressures\n        return [VaporPressures[i](T) for i in range(self.N)]\n\n    @staticmethod\n    def _Psats_at_poly_fit(T, Psats_data, cmps):\n        Psats = []\n        T_inv = 1.0 / T\n        logT = log(T)\n        Tmins, Tmaxes, coeffs = (Psats_data[0], Psats_data[3], Psats_data[6])\n        for i in cmps:\n            if T < Tmins[i]:\n                A, B, C = Psats_data[9][i]\n                Psat = A + B * T_inv + C * logT\n            elif T > Tmaxes[i]:\n                A, B, C = Psats_data[10][i]\n                Psat = A + B * T_inv + C * logT\n            else:\n                Psat = 0.0\n                for c in coeffs[i]:\n                    Psat = Psat * T + c\n            try:\n                Psats.append(exp(Psat))\n            except:\n                Psats.append(1.6549840276802644e+300)\n        return Psats\n\n    def Psats(self):\n        try:\n            return self._Psats\n        except AttributeError:\n            pass\n        N = self.N\n        T, cmps = (self.T, range(N))\n        if self.Psats_poly_fit:\n            self._Psats = Psats = self._Psats_at_poly_fit(T, self._Psats_data, cmps)\n        else:\n            self._Psats = Psats = []\n            for i in self.VaporPressures:\n                Psats.append(i.T_dependent_property(T))\n        if self.has_henry_components:\n            Hs, henry_components = (self.Henry_constants(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    Psats[i] = Hs[i]\n        return Psats\n\n    def PIP(self):\n        dP_dT = self.dP_dT()\n        if dP_dT == 0:\n            return self.PIP_INCALCULABLE_VALUE\n        return phase_identification_parameter(self.V(), self.dP_dT(), self.dP_dV(), self.d2P_dV2(), self.d2P_dTdV())\n\n    @staticmethod\n    def _dPsats_dT_at_poly_fit(T, Psats_data, cmps, Psats):\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        dPsats_dT = []\n        Tmins, Tmaxes, dcoeffs, coeffs_low, coeffs_high = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\n        for i in cmps:\n            if T < Tmins[i]:\n                dPsat_dT = Psats[i] * (-coeffs_low[i][1] * Tinv2 + coeffs_low[i][2] * T_inv)\n            elif T > Tmaxes[i]:\n                dPsat_dT = Psats[i] * (-coeffs_high[i][1] * Tinv2 + coeffs_high[i][2] * T_inv)\n            else:\n                dPsat_dT = 0.0\n                for c in dcoeffs[i]:\n                    dPsat_dT = dPsat_dT * T + c\n                dPsat_dT *= Psats[i]\n            dPsats_dT.append(dPsat_dT)\n        return dPsats_dT\n\n    def dPsats_dT_at(self, T, Psats=None):\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if self.Psats_poly_fit:\n            return self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(self.N), Psats)\n        if self.has_henry_components:\n            return self.to(T=T, P=self.P, zs=self.zs).dPsats_dT()\n        return [VaporPressure.T_dependent_property_derivative(T=T) for VaporPressure in self.VaporPressures]\n\n    def dPsats_dT(self):\n        try:\n            return self._dPsats_dTT_dependent_property_derivative\n        except:\n            pass\n        T, N = (self.T, self.N)\n        if self.Psats_poly_fit:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            self._dPsats_dT = dPsats_dT = self._dPsats_dT_at_poly_fit(T, self._Psats_data, range(N), Psats)\n            return dPsats_dT\n        self._dPsats_dT = dPsats_dT = [VaporPressure.T_dependent_property_derivative(T=T) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            dHs, henry_components = (self.dHenry_constants_dT(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    dPsats_dT[i] = dHs[i]\n        return dPsats_dT\n\n    def d2Psats_dT2(self):\n        try:\n            return self._d2Psats_dT2\n        except:\n            pass\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        T_inv2 = T_inv * T_inv\n        self._d2Psats_dT2 = d2Psats_dT2 = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = (Psats_data[0], Psats_data[3], Psats_data[8])\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    x0 = B * T_inv - C\n                    d2Psat_dT2 = Psats[i] * (2.0 * B * T_inv - C + x0 * x0) * T_inv2\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    x0 = B * T_inv - C\n                    d2Psat_dT2 = Psats[i] * (2.0 * B * T_inv - C + x0 * x0) * T_inv2\n                else:\n                    d2Psat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2Psat_dT2 = d2Psat_dT2 * T + c\n                    d2Psat_dT2 = dPsats_dT[i] * dPsats_dT[i] / Psats[i] + Psats[i] * d2Psat_dT2\n                d2Psats_dT2.append(d2Psat_dT2)\n            return d2Psats_dT2\n        self._d2Psats_dT2 = d2Psats_dT2 = [VaporPressure.T_dependent_property_derivative(T=T, order=2) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            d2Hs, henry_components = (self.d2Henry_constants_dT2(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psats_dT2[i] = d2Hs[i]\n        return d2Psats_dT2\n\n    def lnPsats(self):\n        try:\n            return self._lnPsats\n        except AttributeError:\n            pass\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        logT = log(T)\n        lnPsats = []\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, coeffs = (Psats_data[0], Psats_data[3], Psats_data[6])\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    Psat = A + B * T_inv + C * logT\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    Psat = A + B * T_inv + C * logT\n                else:\n                    Psat = 0.0\n                    for c in coeffs[i]:\n                        Psat = Psat * T + c\n                lnPsats.append(Psat)\n            self._lnPsats = lnPsats\n            return lnPsats\n        self._lnPsats = lnPsats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, henry_components = (self.Henry_constants(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    lnPsats[i] = log(Hs[i])\n        return lnPsats\n\n    def dlnPsats_dT(self):\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs = (Psats_data[0], Psats_data[3], Psats_data[7])\n            dlnPsats_dT = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    dPsat_dT = -B * Tinv2 + C * T_inv\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    dPsat_dT = -B * Tinv2 + C * T_inv\n                else:\n                    dPsat_dT = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT = dPsat_dT * T + c\n                dlnPsats_dT.append(dPsat_dT)\n            return dlnPsats_dT\n        dlnPsats_dT = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, henry_components = (self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    dlnPsats_dT[i] = dHs[i] / Hs[i]\n        return dlnPsats_dT\n\n    def d2lnPsats_dT2(self):\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        T_inv2 = T_inv * T_inv\n        if self.Psats_poly_fit:\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, d2coeffs = (Psats_data[0], Psats_data[3], Psats_data[8])\n            d2lnPsats_dT2 = []\n            for i in range(N):\n                if T < Tmins[i]:\n                    A, B, C = Psats_data[9][i]\n                    d2lnPsat_dT2 = (2.0 * B * T_inv - C) * T_inv2\n                elif T > Tmaxes[i]:\n                    A, B, C = Psats_data[10][i]\n                    d2lnPsat_dT2 = (2.0 * B * T_inv - C) * T_inv2\n                else:\n                    d2lnPsat_dT2 = 0.0\n                    for c in d2coeffs[i]:\n                        d2lnPsat_dT2 = d2lnPsat_dT2 * T + c\n                d2lnPsats_dT2.append(d2lnPsat_dT2)\n            return d2lnPsats_dT2\n        d2lnPsats_dT2 = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_LOG_DERIVATIVE) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHs, d2Hs, henry_components = (self.Henry_constants(), self.dHenry_constants_dT(), self.d2Henry_constants_dT2(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    d2lnPsats_dT2[i] = (d2Hs[i] - dHs[i] * dHs[i] / Hs[i]) / Hs[i]\n        return d2lnPsats_dT2\n\n    def dPsats_dT_over_Psats(self):\n        try:\n            return self._dPsats_dT_over_Psats\n        except AttributeError:\n            pass\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        if self.Psats_poly_fit:\n            dPsat_dT_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\n            for i in range(N):\n                if T < Tmins[i]:\n                    dPsat_dT_over_Psat = -low_coeffs[i][1] * Tinv2 + low_coeffs[i][2] * T_inv\n                elif T > Tmaxes[i]:\n                    dPsat_dT_over_Psat = -high_coeffs[i][1] * Tinv2 + high_coeffs[i][2] * T_inv\n                else:\n                    dPsat_dT_over_Psat = 0.0\n                    for c in dcoeffs[i]:\n                        dPsat_dT_over_Psat = dPsat_dT_over_Psat * T + c\n                dPsat_dT_over_Psats.append(dPsat_dT_over_Psat)\n            self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n            return dPsat_dT_over_Psats\n        dPsat_dT_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, dHenry_constants_dT, henry_components = (self.Henry_constants(), self.dHenry_constants_dT(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    dPsat_dT_over_Psats[i] = dHenry_constants_dT[i] / Hs[i]\n        self._dPsats_dT_over_Psats = dPsat_dT_over_Psats\n        return dPsat_dT_over_Psats\n\n    def d2Psats_dT2_over_Psats(self):\n        try:\n            return self._d2Psats_dT2_over_Psats\n        except AttributeError:\n            pass\n        T, N = (self.T, self.N)\n        T_inv = 1.0 / T\n        Tinv2 = T_inv * T_inv\n        Tinv4 = Tinv2 * Tinv2\n        c0 = (T + T) * Tinv4\n        if self.Psats_poly_fit:\n            d2Psat_dT2_over_Psats = []\n            Psats_data = self._Psats_data\n            Tmins, Tmaxes, dcoeffs, low_coeffs, high_coeffs = (Psats_data[0], Psats_data[3], Psats_data[7], Psats_data[9], Psats_data[10])\n            for i in range(N):\n                if T < Tmins[i]:\n                    B, C = (low_coeffs[i][1], low_coeffs[i][2])\n                    x0 = B - C * T\n                    d2Psat_dT2_over_Psat = c0 * B - C * Tinv2 + x0 * x0 * Tinv4\n                elif T > Tmaxes[i]:\n                    B, C = (high_coeffs[i][1], high_coeffs[i][2])\n                    x0 = B - C * T\n                    d2Psat_dT2_over_Psat = c0 * B - C * Tinv2 + x0 * x0 * Tinv4\n                else:\n                    dPsat_dT = 0.0\n                    d2Psat_dT2 = 0.0\n                    for a in dcoeffs[i]:\n                        d2Psat_dT2 = T * d2Psat_dT2 + dPsat_dT\n                        dPsat_dT = T * dPsat_dT + a\n                    d2Psat_dT2_over_Psat = dPsat_dT * dPsat_dT + d2Psat_dT2\n                d2Psat_dT2_over_Psats.append(d2Psat_dT2_over_Psat)\n            self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n            return d2Psat_dT2_over_Psats\n        d2Psat_dT2_over_Psats = [VaporPressure.T_dependent_property_transform(T, TRANSFORM_SECOND_DERIVATIVE_RATIO) for VaporPressure in self.VaporPressures]\n        if self.has_henry_components:\n            Hs, d2Henry_constants_dT2, henry_components = (self.Henry_constants(), self.d2Henry_constants_dT2(), self.henry_components)\n            for i in range(N):\n                if henry_components[i]:\n                    d2Psat_dT2_over_Psats[i] = d2Henry_constants_dT2[i] / Hs[i]\n        self._d2Psats_dT2_over_Psats = d2Psat_dT2_over_Psats\n        return d2Psat_dT2_over_Psats\n\n    @staticmethod\n    def _Vms_sat_at(T, Vms_sat_data, cmps):\n        Tmins, Tmaxes, coeffs, coeffs_Tmin = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[6], Vms_sat_data[9])\n        Vms_sat = []\n        for i in cmps:\n            if T < Tmins[i]:\n                Vm = 0.0\n                for c in coeffs_Tmin[i]:\n                    Vm = Vm * T + c\n            elif T > Tmaxes[i]:\n                Vm = (T - Tmaxes[i]) * Vms_sat_data[4][i] + Vms_sat_data[5][i]\n            else:\n                Vm = 0.0\n                for c in coeffs[i]:\n                    Vm = Vm * T + c\n            Vms_sat.append(Vm)\n        return Vms_sat\n\n    def Vms_sat_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n        VolumeLiquids = self.VolumeLiquids\n        return [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n\n    def Vms_sat(self):\n        try:\n            return self._Vms_sat\n        except AttributeError:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat = Vms_sat = self._Vms_sat_at(T, self._Vms_sat_data, range(self.N))\n            return Vms_sat\n        elif self.use_eos_volume:\n            Vms = []\n            eoss = self.eos_pure_instances\n            Psats = self.Psats()\n            for i, e in enumerate(eoss):\n                if T < e.Tc:\n                    Vms.append(e.V_l_sat(T))\n                else:\n                    e = e.to(T=T, P=Psats[i])\n                    try:\n                        Vms.append(e.V_l)\n                    except:\n                        Vms.append(e.V_g)\n            self._Vms_sat = Vms\n            return Vms\n        VolumeLiquids = self.VolumeLiquids\n        self._Vms_sat = [VolumeLiquids[i].T_dependent_property(T) for i in range(self.N)]\n        return self._Vms_sat\n\n    @staticmethod\n    def _dVms_sat_dT_at(T, Vms_sat_data, cmps):\n        Vms_sat_dT = []\n        Tmins, Tmaxes, dcoeffs = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[7])\n        for i in cmps:\n            if T < Tmins[i]:\n                dVm = horner_and_der2(Vms_sat_data[9][i], T)[1]\n            elif T > Tmaxes[i]:\n                dVm = Vms_sat_data[4][i]\n            else:\n                dVm = 0.0\n                for c in dcoeffs[i]:\n                    dVm = dVm * T + c\n            Vms_sat_dT.append(dVm)\n        return Vms_sat_dT\n\n    def dVms_sat_dT_at(self, T):\n        if self.Vms_sat_poly_fit:\n            return self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n        return [obj.T_dependent_property_derivative(T=T) for obj in self.VolumeLiquids]\n\n    def dVms_sat_dT(self):\n        try:\n            return self._Vms_sat_dT\n        except:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_dT = self._dVms_sat_dT_at(T, self._Vms_sat_data, range(self.N))\n            return self._Vms_sat_dT\n        VolumeLiquids = self.VolumeLiquids\n        self._Vms_sat_dT = Vms_sat_dT = [obj.T_dependent_property_derivative(T=T) for obj in VolumeLiquids]\n        return Vms_sat_dT\n\n    def d2Vms_sat_dT2(self):\n        try:\n            return self._d2Vms_sat_dT2\n        except:\n            pass\n        T = self.T\n        if self.Vms_sat_poly_fit:\n            d2Vms_sat_dT2 = self._d2Vms_sat_dT2 = []\n            Vms_sat_data = self._Vms_sat_data\n            Tmins, Tmaxes, d2coeffs = (Vms_sat_data[0], Vms_sat_data[3], Vms_sat_data[8])\n            for i in range(self.N):\n                d2Vm = 0.0\n                if Tmins[i] < T < Tmaxes[i]:\n                    for c in d2coeffs[i]:\n                        d2Vm = d2Vm * T + c\n                elif T < Tmins[i]:\n                    d2Vm = horner_and_der2(Vms_sat_data[9][i], T)[2]\n                d2Vms_sat_dT2.append(d2Vm)\n            return d2Vms_sat_dT2\n        VolumeLiquids = self.VolumeLiquids\n        self._d2Vms_sat_dT2 = [obj.T_dependent_property_derivative(T=T, order=2) for obj in VolumeLiquids]\n        return self._d2Vms_sat_dT2\n\n    def Vms_sat_T_ref(self):\n        try:\n            return self._Vms_sat_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._Vms_sat_T_ref = evaluate_linear_fits(self._Vms_sat_data, T_REF_IG)\n        else:\n            VolumeLiquids, cmps = (self.VolumeLiquids, range(self.N))\n            self._Vms_sat_T_ref = [VolumeLiquids[i].T_dependent_property(T_REF_IG) for i in cmps]\n        return self._Vms_sat_T_ref\n\n    def dVms_sat_dT_T_ref(self):\n        try:\n            return self._dVms_sat_dT_T_ref\n        except AttributeError:\n            pass\n        T_REF_IG = self.T_REF_IG\n        if self.Vms_sat_poly_fit:\n            self._dVms_sat_dT_T_ref = evaluate_linear_fits_d(self._Vms_sat_data, self.T)\n        else:\n            VolumeLiquids, cmps = (self.VolumeLiquids, range(self.N))\n            self._dVms_sat_dT_T_ref = [VolumeLiquids[i].T_dependent_property_derivative(T_REF_IG) for i in cmps]\n        return self._dVms_sat_dT_T_ref\n\n    def Vms(self):\n        return self.Vms_sat()\n\n    def dVms_dT(self):\n        return self.dVms_sat_dT()\n\n    def d2Vms_dT2(self):\n        return self.d2Vms_sat_dT2()\n\n    def dVms_dP(self):\n        return [0.0] * self.N\n\n    def d2Vms_dP2(self):\n        return [0.0] * self.N\n\n    def d2Vms_dPdT(self):\n        return [0.0] * self.N\n\n    def Hvaps(self):\n        try:\n            return self._Hvaps\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = (self.T, self.EnthalpyVaporizations, range(self.N))\n        self._Hvaps = Hvaps = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = (Hvap_data[2], Hvap_data[3], Hvap_data[4])\n            for i in cmps:\n                Hvap = 0.0\n                if T < Tcs[i]:\n                    x = log(1.0 - T * Tcs_inv[i])\n                    for c in coeffs[i]:\n                        Hvap = Hvap * x + c\n                Hvaps.append(Hvap)\n            return Hvaps\n        self._Hvaps = Hvaps = [EnthalpyVaporizations[i](T) for i in cmps]\n        for i in cmps:\n            if Hvaps[i] is None:\n                Hvaps[i] = 0.0\n        return Hvaps\n\n    def dHvaps_dT(self):\n        try:\n            return self._dHvaps_dT\n        except AttributeError:\n            pass\n        T, EnthalpyVaporizations, cmps = (self.T, self.EnthalpyVaporizations, range(self.N))\n        self._dHvaps_dT = dHvaps_dT = []\n        if self.Hvap_poly_fit:\n            Hvap_data = self._Hvap_data\n            Tcs, Tcs_inv, coeffs = (Hvap_data[2], Hvap_data[3], Hvap_data[4])\n            for i in cmps:\n                dHvap_dT = 0.0\n                if T < Tcs[i]:\n                    p = log((Tcs[i] - T) * Tcs_inv[i])\n                    x = 1.0\n                    a = 1.0\n                    for c in coeffs[i][-2::-1]:\n                        dHvap_dT += a * c * x\n                        x *= p\n                        a += 1.0\n                    dHvap_dT /= T - Tcs[i]\n                dHvaps_dT.append(dHvap_dT)\n            return dHvaps_dT\n        self._dHvaps_dT = dHvaps_dT = [EnthalpyVaporizations[i].T_dependent_property_derivative(T) for i in cmps]\n        for i in cmps:\n            if dHvaps_dT[i] is None:\n                dHvaps_dT[i] = 0.0\n        return dHvaps_dT\n\n    def Hvaps_T_ref(self):\n        try:\n            return self._Hvaps_T_ref\n        except AttributeError:\n            pass\n        EnthalpyVaporizations, cmps = (self.EnthalpyVaporizations, range(self.N))\n        T_REF_IG = self.T_REF_IG\n        self._Hvaps_T_ref = [EnthalpyVaporizations[i](T_REF_IG) for i in cmps]\n        return self._Hvaps_T_ref\n\n    def Poyntings_at(self, T, P, Psats=None, Vms=None):\n        if not self.use_Poynting:\n            return [1.0] * self.N\n        cmps = range(self.N)\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n        RT_inv = 1.0 / (R * T)\n        return [exp(Vms[i] * (P - Psats[i]) * RT_inv) for i in cmps]\n\n    def Poyntings(self):\n        \"\"\"Method to calculate and return the Poynting pressure correction\n        factors of the phase, [-].\n\n        .. math::\n            \\\\text{Poynting}_i = \\\\exp\\\\left(\\\\frac{V_{m,i}(P-P_{sat})}{RT}\\\\right)\n\n        Returns\n        -------\n        Poyntings : list[float]\n            Poynting pressure correction factors, [-]\n\n        Notes\n        -----\n        The above formula is correct for pressure-independent molar volumes.\n        When the volume does depend on pressure, the full expression is:\n\n        .. math::\n            \\\\text{Poynting} = \\\\exp\\\\left[\\\\frac{\\\\int_{P_i^{sat}}^P V_i^l dP}{RT}\\\\right]\n\n        When a specified model e.g. the Tait equation is used, an analytical\n        integral of this term is normally available.\n\n        \"\"\"\n        try:\n            return self._Poyntings\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._Poyntings = [1.0] * self.N\n            return self._Poyntings\n        T, P = (self.T, self.P)\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        RT_inv = 1.0 / (R * T)\n        self._Poyntings = [trunc_exp(Vml * (P - Psat) * RT_inv) for Psat, Vml in zip(Psats, Vms_sat)]\n        return self._Poyntings\n\n    def dPoyntings_dT(self):\n        try:\n            return self._dPoyntings_dT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dT = [0.0] * self.N\n            return self._dPoyntings_dT\n        T, P = (self.T, self.P)\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        x0 = 1.0 / R\n        x1 = 1.0 / T\n        RT_inv = x0 * x1\n        self._dPoyntings_dT = dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = Psats[i]\n            x4 = P - x3\n            x5 = x1 * x2 * x4\n            dPoyntings_dTi = -RT_inv * (x2 * dPsats_dT[i] - x4 * dVms_sat_dT[i] + x5) * trunc_exp(x0 * x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def dPoyntings_dT_at(self, T, P, Psats=None, Vms=None, dPsats_dT=None, dVms_sat_dT=None):\n        if not self.use_Poynting:\n            return [0.0] * self.N\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if dPsats_dT is None:\n            dPsats_dT = self.dPsats_dT_at(T, Psats)\n        if Vms is None:\n            Vms = self.Vms_sat_at(T)\n        if dVms_sat_dT is None:\n            dVms_sat_dT = self.dVms_sat_dT_at(T)\n        x0 = 1.0 / R\n        x1 = 1.0 / T\n        dPoyntings_dT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x4 = P - Psats[i]\n            x5 = x1 * x2 * x4\n            dPoyntings_dTi = -x0 * x1 * (x2 * dPsats_dT[i] - x4 * dVms_sat_dT[i] + x5) * exp(x0 * x5)\n            dPoyntings_dT.append(dPoyntings_dTi)\n        return dPoyntings_dT\n\n    def d2Poyntings_dT2(self):\n        try:\n            return self._d2Poyntings_dT2\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dT2 = [0.0] * self.N\n            return self._d2Poyntings_dT2\n        T, P = (self.T, self.P)\n        Psats = self.Psats()\n        dPsats_dT = self.dPsats_dT()\n        d2Psats_dT2 = self.d2Psats_dT2()\n        Vms = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n        x6 = 1.0 / T\n        x7 = x6 + x6\n        x11 = 1.0 / R\n        x12 = x11 * x6\n        c0 = 2.0 * x6 * x6\n        self._d2Poyntings_dT2 = d2Poyntings_dT2 = []\n        \"\\n        from sympy import *\\n        R, T, P = symbols('R, T, P')\\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\\n        RT_inv = 1/(R*T)\\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\\n        cse(diff(Poy, T, 2), optimizations='basic')\\n        \"\n        for i in range(self.N):\n            x0 = Vms[i]\n            x1 = Psats[i]\n            x2 = P - x1\n            x3 = x0 * x2\n            x4 = dPsats_dT[i]\n            x5 = x0 * x4\n            x8 = dVms_sat_dT[i]\n            x9 = x2 * x8\n            x10 = x3 * x6\n            x50 = x10 + x5 - x9\n            d2Poyntings_dT2i = x12 * (-x0 * d2Psats_dT2[i] + x12 * x50 * x50 + x2 * d2Vms_sat_dT2[i] - 2.0 * x4 * x8 + x5 * x7 - x7 * x9 + x3 * c0) * exp(x10 * x11)\n            d2Poyntings_dT2.append(d2Poyntings_dT2i)\n        return d2Poyntings_dT2\n\n    def dPoyntings_dP(self):\n        \"\"\"from sympy import *\n        R, T, P, zi = symbols('R, T, P, zi')\n        Vml = symbols('Vml', cls=Function)\n        cse(diff(exp(Vml(T)*(P - Psati(T))/(R*T)), P), optimizations='basic')\n        \"\"\"\n        try:\n            return self._dPoyntings_dP\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._dPoyntings_dP = [0.0] * self.N\n            return self._dPoyntings_dP\n        T, P = (self.T, self.P)\n        Psats = self.Psats()\n        Vms = self.Vms_sat()\n        self._dPoyntings_dP = dPoyntings_dPs = []\n        for i in range(self.N):\n            x0 = Vms[i] / (R * T)\n            dPoyntings_dPs.append(x0 * exp(x0 * (P - Psats[i])))\n        return dPoyntings_dPs\n\n    def d2Poyntings_dPdT(self):\n        \"\"\"\n        from sympy import *\n        R, T, P = symbols('R, T, P')\n        Vml, Psat = symbols('Vml, Psat', cls=Function)\n        RT_inv = 1/(R*T)\n        Poy = exp(Vml(T)*(P-Psat(T))*RT_inv)\n        Poyf = symbols('Poyf')\n        cse(diff(Poy, T, P).subs(Poy, Poyf), optimizations='basic')\n        \"\"\"\n        try:\n            return self._d2Poyntings_dPdT\n        except AttributeError:\n            pass\n        if not self.use_Poynting:\n            self._d2Poyntings_dPdT = [0.0] * self.N\n            return self._d2Poyntings_dPdT\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms = self._Vms_sat\n        except AttributeError:\n            Vms = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._dVms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n        x0 = R_inv\n        x1 = 1.0 / self.T\n        P = self.P\n        nRT_inv = -x0 * x1\n        self._d2Poyntings_dPdT = d2Poyntings_dPdT = []\n        for i in range(self.N):\n            x2 = Vms[i]\n            x3 = x1 * x2\n            x4 = dVms_sat_dT[i]\n            x5 = Psats[i]\n            x6 = P - x5\n            v = Poyntings[i] * nRT_inv * (x0 * x3 * (x2 * dPsats_dT[i] + x3 * x6 - x4 * x6) + x3 - x4)\n            d2Poyntings_dPdT.append(v)\n        return d2Poyntings_dPdT\n    d2Poyntings_dTdP = d2Poyntings_dPdT\n\n    def phis_sat_at(self, T):\n        if not self.use_phis_sat:\n            return [1.0] * self.N\n        phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n    def phis_sat(self):\n        \"\"\"Method to calculate and return the saturation fugacity coefficient\n        correction factors of the phase, [-].\n\n        These are calculated from the\n        provided pure-component equations of state. This term should only be\n        used with a consistent vapor-phase cubic equation of state.\n\n        Returns\n        -------\n        phis_sat : list[float]\n            Saturation fugacity coefficient correction factors, [-]\n\n        Notes\n        -----\n        .. warning::\n            This factor cannot be calculated when a compound is supercritical,\n            as there is no longer any vapor-liquid pure-component equilibrium\n            (by definition).\n\n        \"\"\"\n        try:\n            return self._phis_sat\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._phis_sat = [1.0] * self.N\n            return self._phis_sat\n        T = self.T\n        self._phis_sat = phis_sat = []\n        for i in self.eos_pure_instances:\n            try:\n                phis_sat.append(i.phi_sat(min(T, i.Tc), polish=True))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    phis_sat.append(1.0)\n                else:\n                    raise e\n        return phis_sat\n\n    def dphis_sat_dT_at(self, T):\n        if not self.use_phis_sat:\n            return [0.0] * self.N\n        dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def dphis_sat_dT(self):\n        try:\n            return self._dphis_sat_dT\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._dphis_sat_dT = [0.0] * self.N\n            return self._dphis_sat_dT\n        T = self.T\n        self._dphis_sat_dT = dphis_sat_dT = []\n        for i in self.eos_pure_instances:\n            try:\n                dphis_sat_dT.append(i.dphi_sat_dT(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    dphis_sat_dT.append(0.0)\n                else:\n                    raise e\n        return dphis_sat_dT\n\n    def d2phis_sat_dT2(self):\n        try:\n            return self._d2phis_sat_dT2\n        except AttributeError:\n            pass\n        if not self.use_phis_sat:\n            self._d2phis_sat_dT2 = [0.0] * self.N\n            return self._d2phis_sat_dT2\n        T = self.T\n        self._d2phis_sat_dT2 = d2phis_sat_dT2 = []\n        for i in self.eos_pure_instances:\n            try:\n                d2phis_sat_dT2.append(i.d2phi_sat_dT2(min(T, i.Tc)))\n            except Exception as e:\n                if T < self.PHI_SAT_IDEAL_TR * i.Tc:\n                    d2phis_sat_dT2.append(0.0)\n                else:\n                    raise e\n        return d2phis_sat_dT2\n\n    def phis_at(self, T, P, zs, Psats=None, gammas=None, phis_sat=None, Poyntings=None):\n        P_inv = 1.0 / P\n        if Psats is None:\n            Psats = self.Psats_at(T)\n        if gammas is None:\n            gammas = self.gammas_at(T, zs)\n        if phis_sat is None:\n            phis_sat = self.phis_sat_at(T)\n        if Poyntings is None:\n            Poyntings = self.Poyntings_at(T, P, Psats=Psats)\n        return [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\n\n    def phis(self):\n        \"\"\"Method to calculate the fugacity coefficients of the\n        GibbsExcessLiquid phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\\\phi_i = \\\\frac{\\\\gamma_i P_{i}^{sat} \\\\phi_i^{sat} \\\\text{Poynting}_i}\n            {P}\n\n        Returns\n        -------\n        phis : list[float]\n            Fugacity coefficients of all components in the phase, [-]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1.\n        \"\"\"\n        try:\n            return self._phis\n        except AttributeError:\n            pass\n        P = self.P\n        try:\n            gammas = self._gammas\n        except AttributeError:\n            gammas = self.gammas()\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            phis_sat = self._phis_sat\n        except AttributeError:\n            phis_sat = self.phis_sat()\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n        P_inv = 1.0 / P\n        self._phis = [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\n        return self._phis\n\n    def lnphis(self):\n        try:\n            return self._lnphis\n        except AttributeError:\n            pass\n        try:\n            self._lnphis = [log(i) for i in self.phis()]\n        except:\n            P = self.P\n            try:\n                gammas = self._gammas\n            except AttributeError:\n                gammas = self.gammas()\n            try:\n                lnPsats = self._lnPsats\n            except AttributeError:\n                lnPsats = self.lnPsats()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n            P_inv = 1.0 / P\n            self._lnphis = [log(gammas[i] * Poyntings[i] * phis_sat[i] * P_inv) + lnPsats[i] for i in range(self.N)]\n        return self._lnphis\n    lnphis_G_min = lnphis\n    lnphis_lowest_Gibbs = lnphis\n\n    def dphis_dT(self):\n        try:\n            return self._dphis_dT\n        except AttributeError:\n            pass\n        P = self.P\n        Psats = self.Psats()\n        gammas = self.gammas()\n        if self.use_Poynting:\n            dPoyntings_dT = self.dPoyntings_dT()\n            Poyntings = self.Poyntings()\n        else:\n            dPoyntings_dT = [0.0] * self.N\n            Poyntings = [1.0] * self.N\n        dPsats_dT = self.dPsats_dT()\n        dgammas_dT = self.GibbsExcessModel.dgammas_dT()\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT()\n            phis_sat = self.phis_sat()\n        else:\n            dphis_sat_dT = [0.0] * self.N\n            phis_sat = [1.0] * self.N\n        self._dphis_dT = dphis_dTl = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2 * x3\n            x5 = x0 * x1\n            v = (x0 * x4 * dphis_sat_dT[i] + x1 * x4 * dgammas_dT[i] + x2 * x5 * dPoyntings_dT[i] + x3 * x5 * dPsats_dT[i]) / P\n            dphis_dTl.append(v)\n        return dphis_dTl\n\n    def dphis_dT_at(self, T, P, zs, phis_also=False):\n        Psats = self.Psats_at(T)\n        dPsats_dT = self.dPsats_dT_at(T, Psats)\n        Vms = self.Vms_sat_at(T)\n        dVms_sat_dT = self.dVms_sat_dT_at(T)\n        gammas = self.gammas_at(T, zs)\n        dgammas_dT = self.dgammas_dT_at(T, zs)\n        if self.use_Poynting:\n            Poyntings = self.Poyntings_at(T, P, Psats, Vms)\n            dPoyntings_dT = self.dPoyntings_dT_at(T, P, Psats=Psats, Vms=Vms, dPsats_dT=dPsats_dT, dVms_sat_dT=dVms_sat_dT)\n        else:\n            Poyntings = [1.0] * self.N\n            dPoyntings_dT = [0.0] * self.N\n        if self.use_phis_sat:\n            dphis_sat_dT = self.dphis_sat_dT_at(T)\n            phis_sat = self.phis_sat_at(T)\n        else:\n            dphis_sat_dT = [0.0] * self.N\n            phis_sat = [1.0] * self.N\n        dphis_dT = []\n        for i in range(self.N):\n            x0 = gammas[i]\n            x1 = phis_sat[i]\n            x2 = Psats[i]\n            x3 = Poyntings[i]\n            x4 = x2 * x3\n            x5 = x0 * x1\n            v = (x0 * x4 * dphis_sat_dT[i] + x1 * x4 * dgammas_dT[i] + x2 * x5 * dPoyntings_dT[i] + x3 * x5 * dPsats_dT[i]) / P\n            dphis_dT.append(v)\n        if phis_also:\n            P_inv = 1.0 / P\n            phis = [gammas[i] * Psats[i] * Poyntings[i] * phis_sat[i] * P_inv for i in range(self.N)]\n            return (dphis_dT, phis)\n        return dphis_dT\n\n    def dlnphis_dT(self):\n        try:\n            return self._dlnphis_dT\n        except AttributeError:\n            pass\n        dphis_dT = self.dphis_dT()\n        phis = self.phis()\n        self._dlnphis_dT = [i / j for i, j in zip(dphis_dT, phis)]\n        return self._dlnphis_dT\n\n    def dlnphis_dP(self):\n        \"\"\"Method to calculate the pressure derivative of log fugacity\n        coefficients of the phase. Depending on the settings of the phase, can\n        include the effects of activity coefficients `gammas`, pressure\n        correction terms `Poyntings`, and pure component saturation fugacities\n        `phis_sat` as well as the pure component vapor pressures.\n\n        .. math::\n            \\\\frac{\\\\partial \\\\ln \\\\phi_i}{\\\\partial P} =\n            \\\\frac{\\\\frac{\\\\partial \\\\text{Poynting}_i}{\\\\partial P}}\n            {\\\\text{Poynting}_i} - \\\\frac{1}{P}\n\n        Returns\n        -------\n        dlnphis_dP : list[float]\n            Pressure derivative of log fugacity coefficients of all components\n            in the phase, [1/Pa]\n\n        Notes\n        -----\n        Poyntings, gammas, and pure component saturation phis default to 1. For\n        that case, :math:`\\\\frac{\\\\partial \\\\ln \\\\phi_i}{\\\\partial P}=\\\\frac{1}{P}`.\n        \"\"\"\n        try:\n            return self._dlnphis_dP\n        except AttributeError:\n            pass\n        try:\n            Poyntings = self._Poyntings\n        except AttributeError:\n            Poyntings = self.Poyntings()\n        try:\n            dPoyntings_dP = self._dPoyntings_dP\n        except AttributeError:\n            dPoyntings_dP = self.dPoyntings_dP()\n        P_inv = 1.0 / self.P\n        self._dlnphis_dP = [dPoyntings_dP[i] / Poyntings[i] - P_inv for i in range(self.N)]\n        return self._dlnphis_dP\n\n    def gammas_at(self, T, zs):\n        if self.composition_independent:\n            return [1.0] * self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).gammas()\n\n    def dgammas_dT_at(self, T, zs):\n        if self.composition_independent:\n            return [0.0] * self.N\n        return self.GibbsExcessModel.to_T_xs(T, zs).dgammas_dT()\n\n    def gammas(self):\n        \"\"\"Method to calculate and return the activity coefficients of the\n        phase, [-]. This is a direct call to\n        :obj:`GibbsExcess.gammas <thermo.activity.GibbsExcess.gammas>`.\n\n        Returns\n        -------\n        gammas : list[float]\n            Activity coefficients, [-]\n        \"\"\"\n        try:\n            return self.GibbsExcessModel._gammas\n        except AttributeError:\n            return self.GibbsExcessModel.gammas()\n\n    def dgammas_dT(self):\n        \"\"\"Method to calculate and return the temperature derivative of\n        activity coefficients of the phase, [-].\n\n        This is a direct call to\n        :obj:`GibbsExcess.dgammas_dT <thermo.activity.GibbsExcess.dgammas_dT>`.\n\n        Returns\n        -------\n        dgammas_dT : list[float]\n            First temperature derivative of the activity coefficients, [1/K]\n        \"\"\"\n        return self.GibbsExcessModel.dgammas_dT()\n\n    def H_old(self):\n        T = self.T\n        RT = R * T\n        P = self.P\n        zs, cmps = (self.zs, range(self.N))\n        T_REF_IG = self.T_REF_IG\n        P_DEPENDENT_H_LIQ = self.P_DEPENDENT_H_LIQ\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n        H = 0.0\n        if P_DEPENDENT_H_LIQ:\n            \"\\n            from scipy.integrate import *\\n            from CoolProp.CoolProp import PropsSI\\n\\n            fluid = 'decane'\\n            T = 400\\n            Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\\n            P2 = Psat*100\\n            dP = P2 - Psat\\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\\n            Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\\n            dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\\n\\n            def to_int(P):\\n                Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\\n                alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\\n                return Vm -alpha*T*Vm\\n            quad(to_int, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dH\\n            \"\n            if self.use_IG_Cp:\n                try:\n                    Psats = self._Psats\n                except AttributeError:\n                    Psats = self.Psats()\n                try:\n                    dPsats_dT = self._dPsats_dT\n                except AttributeError:\n                    dPsats_dT = self.dPsats_dT()\n                try:\n                    Vms_sat = self._Vms_sat\n                except AttributeError:\n                    Vms_sat = self.Vms_sat()\n                try:\n                    dVms_sat_dT = self._Vms_sat_dT\n                except AttributeError:\n                    dVms_sat_dT = self.dVms_sat_dT()\n                failed_dPsat_dT = False\n                try:\n                    H = 0.0\n                    for i in cmps:\n                        dV_vap = R * T / Psats[i] - Vms_sat[i]\n                        dS_vap = dPsats_dT[i] * dV_vap\n                        Hvap = T * dS_vap\n                        H += zs[i] * (Cpig_integrals_pure[i] - Hvap)\n                except ZeroDivisionError:\n                    failed_dPsat_dT = True\n                if failed_dPsat_dT or isinf(H):\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    H = 0.0\n                    for i in cmps:\n                        Hvap = T * dPsats_dT_over_Psats[i] * RT\n                        H += zs[i] * (Cpig_integrals_pure[i] - Hvap)\n                if self.use_Tait:\n                    dH_dP_integrals_Tait = self.dH_dP_integrals_Tait()\n                    for i in cmps:\n                        H += zs[i] * dH_dP_integrals_Tait[i]\n                elif self.use_Poynting:\n                    for i in cmps:\n                        dP = P - Psats[i]\n                        H += zs[i] * dP * (Vms_sat[i] - T * dVms_sat_dT[i])\n            else:\n                Psats = self.Psats()\n                Vms_sat = self.Vms_sat()\n                dVms_sat_dT = self.dVms_sat_dT()\n                dPsats_dT = self.dPsats_dT()\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Cpl_integrals_pure = self._Cpl_integrals_pure()\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                Vms_sat_T_ref = self.Vms_sat_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n                Hvaps = self.Hvaps()\n                H = 0.0\n                for i in range(self.N):\n                    H += zs[i] * (Cpl_integrals_pure[i] - Hvaps_T_ref[i])\n                    dP = P - Psats_T_ref[i]\n                    H += zs[i] * dP * (Vms_sat_T_ref[i] - T_REF_IG * dVms_sat_dT_T_ref[i])\n        else:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i] * (Cpig_integrals_pure[i] - Hvaps[i])\n        H += self.GibbsExcessModel.HE()\n        return H\n    del H_old\n\n    def H(self):\n        \"\"\"Method to calculate the enthalpy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}} \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}} \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i \\\\left[-RT^2\\\\left(\n            + \\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n             \\\\right)\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            H = H_{\\\\text{excess}} + \\\\sum_i z_i\\\\left[-H_{vap,i}\n            + \\\\int_{T,ref}^T C_{p,ig} dT \\\\right]\n\n        Returns\n        -------\n        H : float\n            Enthalpy of the phase, [J/(mol)]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._H\n        except AttributeError:\n            pass\n        H = 0.0\n        T = self.T\n        nRT2 = -R * T * T\n        zs, cmps = (self.zs, range(self.N))\n        try:\n            Cpig_integrals_pure = self._Cpig_integrals_pure\n        except AttributeError:\n            Cpig_integrals_pure = self.Cpig_integrals_pure()\n        if self.use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            for i in range(self.N):\n                H += zs[i] * (Cpig_integrals_pure[i] - Hvaps[i])\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            use_Poynting, use_phis_sat = (self.use_Poynting, self.use_phis_sat)\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + Cpig_integrals_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * (dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + Cpig_integrals_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * (dPsats_dT_over_Psats[i] + dphis_sat_dT[i] / phis_sat[i]) + Cpig_integrals_pure[i])\n            else:\n                for i in cmps:\n                    H += zs[i] * (nRT2 * dPsats_dT_over_Psats[i] + Cpig_integrals_pure[i])\n        if not self.composition_independent:\n            H += self.GibbsExcessModel.HE()\n        self._H = H\n        return H\n\n    def S_old(self):\n        \"\"\"\n        from scipy.integrate import *\n        from CoolProp.CoolProp import PropsSI\n\n        fluid = 'decane'\n        T = 400\n        Psat = PropsSI('P', 'T', T, 'Q', 0, fluid)\n        P2 = Psat*100\n        dP = P2 - Psat\n        Vm = 1/PropsSI('DMOLAR', 'T', T, 'Q', 0, fluid)\n        Vm2 = 1/PropsSI('DMOLAR', 'T', T, 'P', P2, fluid)\n        dH = PropsSI('HMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('HMOLAR', 'T', T, 'Q', 0, fluid)\n        dS = PropsSI('SMOLAR', 'T', T, 'P', P2, fluid) - PropsSI('SMOLAR', 'T', T, 'Q', 0, fluid)\n        def to_int2(P):\n            Vm = 1/PropsSI('DMOLAR', 'T', T, 'P', P, fluid)\n            alpha = PropsSI('ISOBARIC_EXPANSION_COEFFICIENT', 'T', T, 'P', P, fluid)\n            return -alpha*Vm\n        quad(to_int2, Psat, P2, epsabs=1.49e-14, epsrel=1.49e-14)[0]/dS\n        \"\"\"\n        S = 0.0\n        T, P, zs, cmps = (self.T, self.P, self.zs, range(self.N))\n        log_zs = self.log_zs()\n        for i in cmps:\n            S -= zs[i] * log_zs[i]\n        S *= R\n        S_base = S\n        T_inv = 1.0 / T\n        RT = R * T\n        P_REF_IG_INV = self.P_REF_IG_INV\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n        try:\n            Psats = self._Psats\n        except AttributeError:\n            Psats = self.Psats()\n        try:\n            dPsats_dT = self._dPsats_dT\n        except AttributeError:\n            dPsats_dT = self.dPsats_dT()\n        try:\n            Vms_sat = self._Vms_sat\n        except AttributeError:\n            Vms_sat = self.Vms_sat()\n        try:\n            dVms_sat_dT = self._Vms_sat_dT\n        except AttributeError:\n            dVms_sat_dT = self.dVms_sat_dT()\n        if self.P_DEPENDENT_H_LIQ:\n            if self.use_IG_Cp:\n                failed_dPsat_dT = False\n                try:\n                    for i in range(self.N):\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dVsat = R * T / Psats[i] - Vms_sat[i]\n                        dSvap = dPsats_dT[i] * dVsat\n                        dSi -= dSvap\n                        dSi -= R * log(Psats[i] * P_REF_IG_INV)\n                        dP = P - Psats[i]\n                        dSi -= dP * dVms_sat_dT[i]\n                        S += dSi * zs[i]\n                except (ZeroDivisionError, ValueError):\n                    failed_dPsat_dT = True\n                if failed_dPsat_dT or isinf(S):\n                    S = S_base\n                    dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n                    lnPsats = self.lnPsats()\n                    LOG_P_REF_IG = self.LOG_P_REF_IG\n                    for i in cmps:\n                        dSi = Cpig_integrals_over_T_pure[i]\n                        dSvap = RT * dPsats_dT_over_Psats[i]\n                        dSi -= dSvap\n                        dSi -= R * (lnPsats[i] - LOG_P_REF_IG)\n                        dSi -= P * dVms_sat_dT[i]\n                        S += dSi * zs[i]\n                if self.use_Tait:\n                    pass\n                elif self.use_Poynting:\n                    pass\n            else:\n                Hvaps_T_ref = self.Hvaps_T_ref()\n                Psats_T_ref = self.Psats_T_ref()\n                Cpl_integrals_over_T_pure = self._Cpl_integrals_over_T_pure()\n                T_REF_IG_INV = self.T_REF_IG_INV\n                dVms_sat_dT_T_ref = self.dVms_sat_dT_T_ref()\n                for i in range(self.N):\n                    dSi = Cpl_integrals_over_T_pure[i]\n                    dSi -= Hvaps_T_ref[i] * T_REF_IG_INV\n                    dSi -= R * log(Psats_T_ref[i] * P_REF_IG_INV)\n                    dP = P - Psats_T_ref[i]\n                    dSi -= dP * dVms_sat_dT_T_ref[i]\n                    S += dSi * zs[i]\n        else:\n            Hvaps = self.Hvaps()\n            for i in cmps:\n                Sg298_to_T = Cpig_integrals_over_T_pure[i]\n                Svap = -Hvaps[i] * T_inv\n                S += zs[i] * (Sg298_to_T + Svap - R * log(P * P_REF_IG_INV))\n        S = S + self.GibbsExcessModel.SE()\n        return S\n\n    def S(self):\n        \"\"\"Method to calculate the entropy of the\n        :obj:`GibbsExcessLiquid` phase. Depending on the settings of the phase, this can\n        include the effects of activity coefficients\n        :obj:`gammas <GibbsExcessLiquid.gammas>`, pressure correction terms\n        :obj:`Poyntings <GibbsExcessLiquid.Poyntings>`, and pure component\n        saturation fugacities :obj:`phis_sat <GibbsExcessLiquid.phis_sat>`\n        as well as the pure component vapor pressures.\n\n        When `caloric_basis` is 'Poynting&PhiSat':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}\\\\cdot\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'PhiSat':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T \\\\frac{\\\\frac{\\\\partial \\\\phi_{\\\\text{sat},i}}{\\\\partial T}}{\\\\phi_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\phi_{\\\\text{sat},i}}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'Poynting':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + T\\\\frac{\\\\frac{\\\\text{Poynting}}{\\\\partial T}}{\\\\text{Poynting}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{\\\\text{Poynting}}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'Psat':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\n            T\\\\frac{\\\\frac{\\\\partial P_{\\\\text{sat},i}}{\\\\partial T}}{P_{\\\\text{sat},i}}\n            + \\\\ln(P_{\\\\text{sat},i}) + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\n            \\\\right) - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        When `caloric_basis` is 'Hvap':\n\n        .. math::\n            S = S_{\\\\text{excess}} - R\\\\sum_i z_i\\\\ln z_i - R\\\\ln\\\\left(\\\\frac{P}{P_{ref}}\\\\right)\n            - \\\\sum_i z_i\\\\left[R\\\\left(\\\\ln P_{\\\\text{sat},i} + \\\\ln\\\\left(\\\\frac{1}{P}\\\\right)\\\\right)\n            + \\\\frac{H_{vap,i}}{T}\n            - \\\\int_{T,ref}^T \\\\frac{C_{p,ig,i}}{T} dT \\\\right]\n\n        Returns\n        -------\n        S : float\n            Entropy of the phase, [J/(mol*K)]\n\n        Notes\n        -----\n        \"\"\"\n        try:\n            return self._S\n        except AttributeError:\n            pass\n        T, P = (self.T, self.P)\n        P_inv = 1.0 / P\n        zs, cmps = (self.zs, range(self.N))\n        log_zs = self.log_zs()\n        S_comp = 0.0\n        for i in cmps:\n            S_comp -= zs[i] * log_zs[i]\n        S = S_comp - log(P * self.P_REF_IG_INV)\n        S *= R\n        try:\n            Cpig_integrals_over_T_pure = self._Cpig_integrals_over_T_pure\n        except AttributeError:\n            Cpig_integrals_over_T_pure = self.Cpig_integrals_over_T_pure()\n        try:\n            lnPsats = self._lnPsats\n        except AttributeError:\n            lnPsats = self.lnPsats()\n        use_Poynting, use_phis_sat, use_Hvap_caloric = (self.use_Poynting, self.use_phis_sat, self.use_Hvap_caloric)\n        if use_Hvap_caloric:\n            Hvaps = self.Hvaps()\n            T_inv = 1.0 / T\n            logP_inv = log(P_inv)\n            for i in cmps:\n                S -= zs[i] * (R * (lnPsats[i] + logP_inv) - Cpig_integrals_over_T_pure[i] + Hvaps[i] * T_inv)\n        else:\n            dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n            if use_Poynting:\n                try:\n                    Poyntings = self._Poyntings\n                except AttributeError:\n                    Poyntings = self.Poyntings()\n                try:\n                    dPoyntings_dT = self._dPoyntings_dT\n                except AttributeError:\n                    dPoyntings_dT = self.dPoyntings_dT()\n            if use_phis_sat:\n                try:\n                    dphis_sat_dT = self._dphis_sat_dT\n                except AttributeError:\n                    dphis_sat_dT = self.dphis_sat_dT()\n                try:\n                    phis_sat = self._phis_sat\n                except AttributeError:\n                    phis_sat = self.phis_sat()\n            if use_Poynting and use_phis_sat:\n                for i in cmps:\n                    S -= zs[i] * (R * (T * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + lnPsats[i] + log(Poyntings[i] * phis_sat[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_Poynting:\n                for i in cmps:\n                    S -= zs[i] * (R * (T * (dPsats_dT_over_Psats[i] + dPoyntings_dT[i] / Poyntings[i]) + lnPsats[i] + log(Poyntings[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\n            elif use_phis_sat:\n                for i in cmps:\n                    S -= zs[i] * (R * (T * (dphis_sat_dT[i] / phis_sat[i] + dPsats_dT_over_Psats[i]) + lnPsats[i] + log(phis_sat[i] * P_inv)) - Cpig_integrals_over_T_pure[i])\n            else:\n                logP_inv = log(P_inv)\n                for i in cmps:\n                    S -= zs[i] * (R * (T * dPsats_dT_over_Psats[i] + lnPsats[i] + logP_inv) - Cpig_integrals_over_T_pure[i])\n        if not self.composition_independent:\n            S += self.GibbsExcessModel.SE()\n        self._S = S\n        return S\n\n    def Cp_old(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        T, P, P_DEPENDENT_H_LIQ = (self.T, self.P, self.P_DEPENDENT_H_LIQ)\n        Cp, zs = (0.0, self.zs)\n        Cpigs_pure = self.Cpigs_pure()\n        if P_DEPENDENT_H_LIQ:\n            try:\n                Psats = self._Psats\n            except AttributeError:\n                Psats = self.Psats()\n            try:\n                dPsats_dT = self._dPsats_dT\n            except AttributeError:\n                dPsats_dT = self.dPsats_dT()\n            try:\n                d2Psats_dT2 = self._d2Psats_dT2\n            except AttributeError:\n                d2Psats_dT2 = self.d2Psats_dT2()\n            try:\n                Vms_sat = self._Vms_sat\n            except AttributeError:\n                Vms_sat = self.Vms_sat()\n            try:\n                dVms_sat_dT = self._Vms_sat_dT\n            except AttributeError:\n                dVms_sat_dT = self.dVms_sat_dT()\n            try:\n                d2Vms_sat_dT2 = self._d2Vms_sat_dT2\n            except AttributeError:\n                d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n            failed_dPsat_dT = False\n            try:\n                for i in range(self.N):\n                    x0 = Psats[i]\n                    Psat_inv = 1.0 / x0\n                    x1 = Vms_sat[i]\n                    x2 = dPsats_dT[i]\n                    x3 = R * Psat_inv\n                    x4 = T * x3\n                    x5 = -x1\n                    x6 = dVms_sat_dT[i]\n                    x7 = T * x2\n                    Cp += zs[i] * (-T * (P - x0) * d2Vms_sat_dT2[i] - T * (x4 + x5) * d2Psats_dT2[i] + x2 * (x1 - x4) + x2 * (T * x6 + x5) - x7 * (-R * x7 * Psat_inv * Psat_inv + x3 - x6) + Cpigs_pure[i])\n                \"\\n                from sympy import *\\n                T, P, R, zi = symbols('T, P, R, zi')\\n                Psat, Cpig_int, Vmsat = symbols('Psat, Cpig_int, Vmsat', cls=Function)\\n                dVmsatdT = diff(Vmsat(T), T)\\n                dPsatdT = diff(Psat(T), T)\\n                dV_vap = R*T/Psat(T) - Vmsat(T)\\n                dS_vap = dPsatdT*dV_vap\\n                Hvap = T*dS_vap\\n                H = zi*(Cpig_int(T) - Hvap)\\n\\n                dP = P - Psat(T)\\n                H += zi*dP*(Vmsat(T) - T*dVmsatdT)\\n\\n                (cse(diff(H, T), optimizations='basic'))\\n                \"\n            except (ZeroDivisionError, ValueError):\n                failed_dPsat_dT = True\n            if failed_dPsat_dT or isinf(Cp) or isnan(Cp):\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n                Cp = 0.0\n                for i in range(self.N):\n                    Cp += zs[i] * (Cpigs_pure[i] - P * T * d2Vms_sat_dT2[i] - R * T * T * d2lnPsats_dT2[i] - 2.0 * R * T * dlnPsats_dT[i])\n                    \"\\n                    from sympy import *\\n                    T, P, R, zi = symbols('T, P, R, zi')\\n                    lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\\n                    dVmsatdT = diff(Vmsat(T), T)\\n                    dPsatdT = diff(exp(lnPsat(T)), T)\\n                    dV_vap = R*T/exp(lnPsat(T)) - Vmsat(T)\\n                    dS_vap = dPsatdT*dV_vap\\n                    Hvap = T*dS_vap\\n                    H = zi*(Cpig_int(T) - Hvap)\\n                    dP = P\\n                    H += zi*dP*(Vmsat(T) - T*dVmsatdT)\\n                    print(simplify(expand(diff(H, T)).subs(exp(lnPsat(T)), 0)/zi))\\n                    \"\n        else:\n            dHvaps_dT = self.dHvaps_dT()\n            for i in range(self.N):\n                Cp += zs[i] * (Cpigs_pure[i] - dHvaps_dT[i])\n        Cp += self.GibbsExcessModel.CpE()\n        return Cp\n\n    def Cp(self):\n        try:\n            return self._Cp\n        except AttributeError:\n            pass\n        T, zs, cmps = (self.T, self.zs, range(self.N))\n        Cpigs_pure = self.Cpigs_pure()\n        use_Poynting, use_phis_sat = (self.use_Poynting, self.use_phis_sat)\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n        RT = R * T\n        RT2 = RT * T\n        RT2_2 = RT + RT\n        Cp = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                phi_inv = 1.0 / phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0 / phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        else:\n            for i in cmps:\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dPsats_dT_over_Psats[i]\n                Cp -= zs[i] * (RT2 * a + RT2_2 * b - Cpigs_pure[i])\n        if not self.composition_independent:\n            Cp += self.GibbsExcessModel.CpE()\n        self._Cp = Cp\n        return Cp\n    dH_dT = Cp\n\n    def dS_dT_old(self):\n        T, P, P_DEPENDENT_H_LIQ = (self.T, self.P, self.P_DEPENDENT_H_LIQ)\n        RT = R * T\n        zs = self.zs\n        Cpigs_pure = self.Cpigs_pure()\n        dS_dT = 0.0\n        T_inv = 1.0 / T\n        if P_DEPENDENT_H_LIQ:\n            d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n            dVms_sat_dT = self.dVms_sat_dT()\n            Vms_sat = self.Vms_sat()\n            Psats = self.Psats()\n            dPsats_dT = self.dPsats_dT()\n            d2Psats_dT2 = self.d2Psats_dT2()\n            failed_dPsat_dT = False\n            for Psat in Psats:\n                if Psat < 1e-40:\n                    failed_dPsat_dT = True\n            if not failed_dPsat_dT:\n                try:\n                    \"\\n                    from sympy import *\\n                    T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\\n\\n                    Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\\n                    dVmsatdT = diff(Vmsat(T), T)\\n                    dPsatdT = diff(Psat(T), T)\\n\\n                    S = 0\\n                    dSi = Cpig_T_int(T)\\n                    dVsat = R*T/Psat(T) - Vmsat(T)\\n                    dSvap = dPsatdT*dVsat\\n                    dSi -= dSvap\\n                    dSi -= R*log(Psat(T)/P_REF_IG)\\n                    dP = P - Psat(T)\\n                    dSi -= dP*dVmsatdT\\n                    S += dSi*zi\\n                    # cse(diff(S, T), optimizations='basic')\\n                    \"\n                    for i in range(self.N):\n                        x0 = Psats[i]\n                        x1 = dPsats_dT[i]\n                        x2 = R / x0\n                        x3 = Vms_sat[i]\n                        x4 = dVms_sat_dT[i]\n                        dS_dT -= zs[i] * (x1 * x2 - x1 * x4 - x1 * (RT * x1 / x0 ** 2 - x2 + x4) + (P - x0) * d2Vms_sat_dT2[i] + (T * x2 - x3) * d2Psats_dT2[i] - Cpigs_pure[i] * T_inv)\n                except (ZeroDivisionError, ValueError):\n                    failed_dPsat_dT = True\n            if failed_dPsat_dT:\n                dlnPsats_dT = self.dlnPsats_dT()\n                d2lnPsats_dT2 = self.d2lnPsats_dT2()\n                \"\\n                from sympy import *\\n                T, P, R, zi, P_REF_IG = symbols('T, P, R, zi, P_REF_IG')\\n\\n                lnPsat, Cpig_T_int, Vmsat = symbols('lnPsat, Cpig_T_int, Vmsat', cls=Function)\\n                # Psat, Cpig_T_int, Vmsat = symbols('Psat, Cpig_T_int, Vmsat', cls=Function)\\n                dVmsatdT = diff(Vmsat(T), T)\\n                dPsatdT = diff(exp(lnPsat(T)), T)\\n\\n                S = 0\\n                dSi = Cpig_T_int(T)\\n                dVsat = R*T/exp(lnPsat(T)) - Vmsat(T)\\n                dSvap = dPsatdT*dVsat\\n                dSi -= dSvap\\n                # dSi -= R*log(Psat(T)/P_REF_IG)\\n                dSi -= R*(lnPsat(T) - log(P_REF_IG))\\n                dP = P - exp(lnPsat(T))\\n                dSi -= dP*dVmsatdT\\n                S += dSi*zi\\n                # cse(diff(S, T), optimizations='basic')\\n                print(simplify(expand(diff(S, T)).subs(exp(lnPsat(T)), 0)/zi))\\n\\n\\n                \"\n                dS_dT = 0.0\n                for i in range(self.N):\n                    dS_dT -= zs[i] * (P * d2Vms_sat_dT2[i] + RT * d2lnPsats_dT2[i] + 2.0 * R * dlnPsats_dT[i] - Cpigs_pure[i] * T_inv)\n        dS_dT += self.GibbsExcessModel.dSE_dT()\n        return dS_dT\n\n    def dS_dT(self):\n        try:\n            return self._dS_dT\n        except AttributeError:\n            pass\n        T, zs, cmps = (self.T, self.zs, range(self.N))\n        use_Poynting, use_phis_sat = (self.use_Poynting, self.use_phis_sat)\n        if use_Poynting:\n            try:\n                d2Poyntings_dT2 = self._d2Poyntings_dT2\n            except AttributeError:\n                d2Poyntings_dT2 = self.d2Poyntings_dT2()\n            try:\n                dPoyntings_dT = self._dPoyntings_dT\n            except AttributeError:\n                dPoyntings_dT = self.dPoyntings_dT()\n            try:\n                Poyntings = self._Poyntings\n            except AttributeError:\n                Poyntings = self.Poyntings()\n        if use_phis_sat:\n            try:\n                d2phis_sat_dT2 = self._d2phis_sat_dT2\n            except AttributeError:\n                d2phis_sat_dT2 = self.d2phis_sat_dT2()\n            try:\n                dphis_sat_dT = self._dphis_sat_dT\n            except AttributeError:\n                dphis_sat_dT = self.dphis_sat_dT()\n            try:\n                phis_sat = self._phis_sat\n            except AttributeError:\n                phis_sat = self.phis_sat()\n        dPsats_dT_over_Psats = self.dPsats_dT_over_Psats()\n        d2Psats_dT2_over_Psats = self.d2Psats_dT2_over_Psats()\n        Cpigs_pure = self.Cpigs_pure()\n        T_inv = 1.0 / T\n        RT = R * T\n        R_2 = R + R\n        dS_dT = 0.0\n        if use_Poynting and use_phis_sat:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                phi_inv = 1.0 / phis_sat[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dphi_ratio + dPsats_dT_over_Psats[i] + dPoy_ratio\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        elif use_Poynting:\n            for i in cmps:\n                Poy_inv = 1.0 / Poyntings[i]\n                dPoy_ratio = dPoyntings_dT[i] * Poy_inv\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i] + d2Poyntings_dT2[i] * Poy_inv - dPoy_ratio * dPoy_ratio\n                b = dPsats_dT_over_Psats[i] + dPoy_ratio\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        elif use_phis_sat:\n            for i in cmps:\n                phi_inv = 1.0 / phis_sat[i]\n                dphi_ratio = dphis_sat_dT[i] * phi_inv\n                a = d2phis_sat_dT2[i] * phi_inv - dphi_ratio * dphi_ratio + d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dphi_ratio + dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        else:\n            for i in cmps:\n                a = d2Psats_dT2_over_Psats[i] - dPsats_dT_over_Psats[i] * dPsats_dT_over_Psats[i]\n                b = dPsats_dT_over_Psats[i]\n                dS_dT -= zs[i] * (RT * a + b * R_2 - Cpigs_pure[i] * T_inv)\n        if not self.composition_independent:\n            dS_dT += self.GibbsExcessModel.dSE_dT()\n        self._dS_dT = dS_dT\n        return dS_dT\n\n    def dH_dP(self):\n        try:\n            return self._dH_dP\n        except AttributeError:\n            pass\n        T = self.T\n        zs = self.zs\n        dH_dP = 0.0\n        if self.use_Poynting:\n            nRT2 = -R * T * T\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0 / Poyntings[i]\n                dH_dP += nRT2 * zs[i] * Poy_inv * (d2Poyntings_dPdT[i] - dPoyntings_dP[i] * dPoyntings_dT[i] * Poy_inv)\n        self._dH_dP = dH_dP\n        return dH_dP\n\n    def dS_dP(self):\n        try:\n            return self._dS_dP\n        except AttributeError:\n            pass\n        T = self.T\n        P = self.P\n        P_inv = 1.0 / P\n        zs = self.zs\n        if self.use_Poynting:\n            dS_dP = -R * P_inv\n            Poyntings = self.Poyntings()\n            dPoyntings_dP = self.dPoyntings_dP()\n            dPoyntings_dT = self.dPoyntings_dT()\n            d2Poyntings_dPdT = self.d2Poyntings_dPdT()\n            for i in range(self.N):\n                Poy_inv = 1.0 / Poyntings[i]\n                dS_dP -= zs[i] * R * Poy_inv * (dPoyntings_dP[i] - Poyntings[i] * P_inv + T * (d2Poyntings_dPdT[i] - dPoyntings_dP[i] * dPoyntings_dT[i] * Poy_inv))\n        else:\n            dS_dP = 0.0\n        self._dS_dP = dS_dP\n        return dS_dP\n\n    def H_dep(self):\n        return self.H() - self.H_ideal_gas()\n\n    def S_dep(self):\n        return self.S() - self.S_ideal_gas()\n\n    def Cp_dep(self):\n        return self.Cp() - self.Cp_ideal_gas()\n\n    def V(self):\n        try:\n            return self._V\n        except AttributeError:\n            pass\n        zs = self.zs\n        Vms = self.Vms()\n        'To make a fugacity-volume identity consistent, cannot use pressure\\n        correction unless the Poynting factor is calculated with quadrature/\\n        integration.\\n        '\n        V = 0.0\n        for i in range(self.N):\n            V += zs[i] * Vms[i]\n        self._V = V\n        return V\n\n    def dV_dT(self):\n        try:\n            return self._dV_dT\n        except AttributeError:\n            pass\n        zs = self.zs\n        dVms_sat_dT = self.dVms_sat_dT()\n        dV_dT = 0.0\n        for i in range(self.N):\n            dV_dT += zs[i] * dVms_sat_dT[i]\n        self._dV_dT = dV_dT\n        return dV_dT\n\n    def d2V_dT2(self):\n        try:\n            return self._d2V_dT2\n        except AttributeError:\n            pass\n        zs = self.zs\n        d2Vms_sat_dT2 = self.d2Vms_sat_dT2()\n        d2V_dT2 = 0.0\n        for i in range(self.N):\n            d2V_dT2 += zs[i] * d2Vms_sat_dT2[i]\n        self._d2V_dT2 = d2V_dT2\n        return d2V_dT2\n\n    def dP_dV(self):\n        try:\n            return self._dP_dV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._dP_dV = self.INCOMPRESSIBLE_CONST\n        return self._dP_dV\n\n    def d2P_dV2(self):\n        try:\n            return self._d2P_dV2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dV2 = self.INCOMPRESSIBLE_CONST\n        return self._d2P_dV2\n\n    def dP_dT(self):\n        try:\n            return self._dP_dT\n        except AttributeError:\n            pass\n        self._dP_dT = self.dV_dT() / -self.dP_dV()\n        return self._dP_dT\n\n    def d2P_dTdV(self):\n        try:\n            return self._d2P_dTdV\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dTdV = 0.0\n        else:\n            P = self.P\n\n            def dP_dV_for_diff(T):\n                return 1.0 / self.VolumeLiquidMixture.property_derivative_P(T, P, self.zs, order=1)\n            self._d2P_dTdV = derivative(dP_dV_for_diff, self.T)\n        return self._d2P_dTdV\n\n    def d2P_dT2(self):\n        try:\n            return self._d2P_dT2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2P_dT2 = -self.d2V_dT2() / self.INCOMPRESSIBLE_CONST\n        else:\n            P, zs = (self.P, self.zs)\n\n            def dP_dT_for_diff(T):\n                dV_dT = self.VolumeLiquidMixture.property_derivative_T(T, P, zs, order=1)\n                dP_dV = 1.0 / self.VolumeLiquidMixture.property_derivative_P(T, P, zs, order=1)\n                dP_dT = dV_dT / -dP_dV\n                return dP_dT\n            self._d2P_dT2 = derivative(dP_dT_for_diff, self.T)\n        return self._d2P_dT2\n\n    def d2V_dP2(self):\n        try:\n            return self._d2V_dP2\n        except AttributeError:\n            pass\n        if self.incompressible:\n            self._d2V_dP2 = 0.0\n        return self._d2V_dP2\n\n    def Tait_Bs(self):\n        try:\n            return self._Tait_Bs\n        except:\n            pass\n        self._Tait_Bs = evaluate_linear_fits(self._Tait_B_data, self.T)\n        return self._Tait_Bs\n\n    def dTait_B_dTs(self):\n        try:\n            return self._dTait_B_dTs\n        except:\n            pass\n        self._dTait_B_dTs = evaluate_linear_fits_d(self._Tait_B_data, self.T)\n        return self._dTait_B_dTs\n\n    def d2Tait_B_dT2s(self):\n        try:\n            return self._d2Tait_B_dT2s\n        except:\n            pass\n        self._d2Tait_B_dT2s = evaluate_linear_fits_d2(self._Tait_B_data, self.T)\n        return self._d2Tait_B_dT2s\n\n    def Tait_Cs(self):\n        try:\n            return self._Tait_Cs\n        except:\n            pass\n        self._Tait_Cs = evaluate_linear_fits(self._Tait_C_data, self.T)\n        return self._Tait_Cs\n\n    def dTait_C_dTs(self):\n        try:\n            return self._dTait_C_dTs\n        except:\n            pass\n        self._dTait_C_dTs = evaluate_linear_fits_d(self._Tait_C_data, self.T)\n        return self._dTait_C_dTs\n\n    def d2Tait_C_dT2s(self):\n        try:\n            return self._d2Tait_C_dT2s\n        except:\n            pass\n        self._d2Tait_C_dT2s = evaluate_linear_fits_d2(self._Tait_C_data, self.T)\n        return self._d2Tait_C_dT2s\n\n    def Tait_Vs(self):\n        Vms_sat = self.Vms_sat()\n        Psats = self.Psats()\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        P = self.P\n        return [Vms_sat[i] * (1.0 - Tait_Cs[i] * log((Tait_Bs[i] + P) / (Tait_Bs[i] + Psats[i]))) for i in range(self.N)]\n\n    def dH_dP_integrals_Tait(self):\n        try:\n            return self._dH_dP_integrals_Tait\n        except AttributeError:\n            pass\n        Psats = self.Psats()\n        Vms_sat = self.Vms_sat()\n        dVms_sat_dT = self.dVms_sat_dT()\n        dPsats_dT = self.dPsats_dT()\n        Tait_Bs = self.Tait_Bs()\n        Tait_Cs = self.Tait_Cs()\n        dTait_C_dTs = self.dTait_C_dTs()\n        dTait_B_dTs = self.dTait_B_dTs()\n        T, P = (self.T, self.P)\n        self._dH_dP_integrals_Tait = dH_dP_integrals_Tait = []\n        for i in range(self.N):\n            x0 = Tait_Bs[i]\n            x1 = P + x0\n            x2 = Psats[i]\n            x3 = x0 + x2\n            x4 = 1.0 / x3\n            x5 = Tait_Cs[i]\n            x6 = Vms_sat[i]\n            x7 = x5 * x6\n            x8 = T * dVms_sat_dT[i]\n            x9 = x5 * x8\n            x10 = T * dTait_C_dTs[i]\n            x11 = x0 * x6\n            x12 = T * x7\n            x13 = -x0 * x7 + x0 * x9 + x10 * x11 + x12 * dTait_B_dTs[i]\n            x14 = x2 * x6\n            x15 = x4 * (x0 * x8 + x10 * x14 - x11 + x12 * dPsats_dT[i] + x13 - x14 - x2 * x7 + x2 * x8 + x2 * x9)\n            val = -P * x15 + P * (x10 * x6 - x7 + x9) * log(x1 * x4) + x13 * log(x1) - x13 * log(x3) + x15 * x2\n            dH_dP_integrals_Tait.append(val)\n        return dH_dP_integrals_Tait\n\n    def mu(self):\n        try:\n            return self._mu\n        except AttributeError:\n            pass\n        mu = self._mu = self.correlations.ViscosityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return mu\n\n    def k(self):\n        try:\n            return self._k\n        except AttributeError:\n            pass\n        self._k = k = self.correlations.ThermalConductivityLiquidMixture.mixture_property(self.T, self.P, self.zs, self.ws())\n        return k\n\nclass GibbsExcessSolid(GibbsExcessLiquid):\n    ideal_gas_basis = True\n    force_phase = 's'\n    phase = 's'\n    is_gas = False\n    is_liquid = False\n    is_solid = True\n    pure_references = ('HeatCapacityGases', 'SublimationPressures', 'VolumeSolids', 'EnthalpySublimations')\n    pure_reference_types = (HeatCapacityGas, SublimationPressure, VolumeSolid, EnthalpySublimation)\n    model_attributes = ('Hfs', 'Gfs', 'Sfs', 'GibbsExcessModel', 'eos_pure_instances', 'use_Poynting', 'use_phis_sat', 'use_eos_volume', 'henry_components', 'henry_as', 'henry_bs', 'henry_cs', 'henry_ds', 'henry_es', 'henry_fs', 'Psat_extrpolation') + pure_references\n\n    def __init__(self, SublimationPressures, VolumeSolids=None, GibbsExcessModel=IdealSolution, eos_pure_instances=None, VolumeLiquidMixture=None, HeatCapacityGases=None, EnthalpySublimations=None, use_Poynting=False, use_phis_sat=False, Hfs=None, Gfs=None, Sfs=None, T=Phase.T_DEFAULT, P=Phase.P_DEFAULT, zs=None):\n        super().__init__(VaporPressures=SublimationPressures, VolumeLiquids=VolumeSolids, HeatCapacityGases=HeatCapacityGases, EnthalpyVaporizations=EnthalpySublimations, use_Poynting=use_Poynting, Hfs=Hfs, Gfs=Gfs, Sfs=Sfs, T=T, P=P, zs=zs)"
  },
  "call_tree": {
    "modified_testcases/test_interaction_parameters.py:test_basic_chemsep_PR": {
      "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {},
      "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_automatic": {
        "thermo/interaction_parameters.py:InteractionParameterDB:get_tables_with_type": {},
        "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {}
      },
      "thermo/interaction_parameters.py:InteractionParameterDB:has_ip_specific": {},
      "thermo/interaction_parameters.py:InteractionParameterDB:get_tables_with_type": {},
      "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_symmetric_matrix": {
        "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {}
      }
    },
    "modified_testcases/test_interaction_parameters.py:test_basic_chemsep_NRTL": {
      "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_asymmetric_matrix": {
        "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {}
      },
      "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_symmetric_matrix": {
        "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {}
      }
    },
    "modified_testcases/test_interaction_parameters.py:test_basic_chemsep_UNIQUAC": {
      "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_asymmetric_matrix": {
        "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {}
      }
    },
    "modified_testcases/test_interaction_parameters.py:test_henry_Rolf_Sander_2023": {
      "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_asymmetric_matrix": {
        "thermo/interaction_parameters.py:InteractionParameterDB:get_ip_specific": {}
      }
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/thermo-image/thermo/tests/test_flash_vl.py:test_issue106_Michelson_stability_test_log_zero": {
      "thermo/phases/gibbs_excess.py:GibbsExcessLiquid:GibbsExcessLiquid": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/thermo-image/thermo/tests/test_flash_iapws.py:test_iapws95_basic_flash": {
      "thermo/phases/iapws_phase.py:IAPWS95Liquid:IAPWS95Liquid": {}
    },
    "/mnt/sfs_turbo/yaxindu/MAC/PackageDataset/app/thermo-image/thermo/modified_testcases/test_flash_vl.py:test_issue106_Michelson_stability_test_log_zero": {
      "thermo/phases/gibbs_excess.py:GibbsExcessLiquid:GibbsExcessLiquid": {}
    }
  }
}