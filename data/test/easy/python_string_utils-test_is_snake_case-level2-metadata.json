{
  "dir_path": "/app/python_string_utils",
  "package_name": "python_string_utils",
  "sample_name": "python_string_utils-test_is_snake_case",
  "src_dir": "string_utils/",
  "test_dir": "tests/",
  "test_file": "tests/test_is_snake_case.py",
  "test_code": "from unittest import TestCase\n\nfrom string_utils import is_snake_case\n\n\nclass IsSnakeCaseTestCase(TestCase):\n    def test_return_false_for_non_string_objects(self):\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case(None))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case(False))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case(0))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case([]))\n\n        # noinspection PyTypeChecker\n        self.assertFalse(is_snake_case({'a': 1}))\n\n    def test_string_cannot_be_blank(self):\n        self.assertFalse(is_snake_case(''))\n        self.assertFalse(is_snake_case(' '))\n\n    def test_string_cannot_be_lowercase_letters_only(self):\n        self.assertFalse(is_snake_case('lowercaseonly'))\n\n    def test_string_cannot_be_camel_case(self):\n        self.assertFalse(is_snake_case('Banana'))\n\n    def test_string_cannot_be_all_uppercase(self):\n        self.assertFalse(is_snake_case('HELLO'))\n\n    def test_string_cannot_contain_only_underscores(self):\n        self.assertFalse(is_snake_case('_'))\n        self.assertFalse(is_snake_case('__'))\n        self.assertFalse(is_snake_case('___'))\n        self.assertFalse(is_snake_case('____________________'))\n\n    def test_string_cannot_contain_bad_signs(self):\n        self.assertFalse(is_snake_case('1_no_snake'))\n        self.assertFalse(is_snake_case('^_no_snake'))\n        self.assertFalse(is_snake_case('@_no_snake'))\n        self.assertFalse(is_snake_case('%_no_snake'))\n        self.assertFalse(is_snake_case('no_snake#'))\n        self.assertFalse(is_snake_case('no_!'))\n        self.assertFalse(is_snake_case('!no_'))\n        self.assertFalse(is_snake_case('.no_'))\n\n    def test_should_accept_valid_snake_strings(self):\n        self.assertTrue(is_snake_case('HELLO_WORLD'))\n        self.assertTrue(is_snake_case('Hello_World'))\n        self.assertTrue(is_snake_case('_hello_world'))\n        self.assertTrue(is_snake_case('hello_world_'))\n        self.assertTrue(is_snake_case('hello_world'))\n        self.assertTrue(is_snake_case('_hello_'))\n        self.assertTrue(is_snake_case('_hello__'))\n        self.assertTrue(is_snake_case('__hello_'))\n        self.assertTrue(is_snake_case('a_'))\n        self.assertTrue(is_snake_case('_b'))\n        self.assertTrue(is_snake_case('a_b_c_d_e'))\n        self.assertTrue(is_snake_case('snake_case_string'))\n        self.assertTrue(is_snake_case('snake_2'))\n        self.assertTrue(is_snake_case('a_snake_string_4_you'))\n\n    def test_should_consider_custom_separator(self):\n        s = 'snake-string-with-dashes'\n        self.assertFalse(is_snake_case(s))\n        self.assertTrue(is_snake_case(s, separator='-'))\n",
  "GT_file_code": {
    "string_utils/validation.py": "# -*- coding: utf-8 -*-\n\n# public api to export\n__all__ = [\n    'is_string',\n    'is_full_string',\n    'is_number',\n    'is_integer',\n    'is_decimal',\n    'is_url',\n    'is_email',\n    'is_credit_card',\n    'is_camel_case',\n    'is_snake_case',\n    'is_json',\n    'is_uuid',\n    'is_ip_v4',\n    'is_ip_v6',\n    'is_ip',\n    'is_isbn_10',\n    'is_isbn_13',\n    'is_isbn',\n    'is_palindrome',\n    'is_pangram',\n    'is_isogram',\n    'is_slug',\n    'contains_html',\n    'words_count',\n]\n\nimport json\nimport string\nfrom typing import Any, Optional, List\n\nfrom ._regex import *\nfrom .errors import InvalidInputError\n\n\n# PRIVATE API\n\n\nclass __ISBNChecker:\n    def __init__(self, input_string: str, normalize: bool = True):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n\n        self.input_string = input_string.replace('-', '') if normalize else input_string\n\n    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if (index % 2 == 0) else 3\n                    product += int(digit) * weight\n\n                return product % 10 == 0\n\n            except ValueError:\n                pass\n\n        return False\n\n    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n\n                return product % 11 == 0\n\n            except ValueError:\n                pass\n\n        return False\n\n\n# PUBLIC API\n\ndef is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)\n\n\ndef is_full_string(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is not empty (it must contains at least one non space character).\n\n    *Examples:*\n\n    >>> is_full_string(None) # returns false\n    >>> is_full_string('') # returns false\n    >>> is_full_string(' ') # returns false\n    >>> is_full_string('hello') # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if not empty, false otherwise.\n    \"\"\"\n    return is_string(input_string) and input_string.strip() != ''\n\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n\n    return NUMBER_RE.match(input_string) is not None\n\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string\n\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string\n\n\n# Full url example:\n# scheme://username:password@www.domain.com:8042/folder/subfolder/file.extension?param=value&param2=value2#hash\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    valid = URL_RE.match(input_string) is not None\n\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n\n    return valid\n\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    # first simple \"pre check\": it must be a non empty string with max len 320 and cannot start with a dot\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n\n    try:\n        # we expect 2 tokens, one before \"@\" and one after, otherwise we have an exception and the email is not valid\n        head, tail = input_string.split('@')\n\n        # head's size must be <= 64, tail <= 255, head must not start with a dot or contain multiple consecutive dots\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n\n        # removes escaped spaces, so that later on the test regex will accept the string\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n\n        return EMAIL_RE.match(head + '@' + tail) is not None\n\n    except ValueError:\n        # borderline case in which we have multiple \"@\" signs but the head part is correctly escaped\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            # replace \"@\" with \"a\" in the head\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n\n        return False\n\n\ndef is_credit_card(input_string: Any, card_type: str = None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError(\n                'Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys()))\n            )\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n\n    return False\n\n\ndef is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None\n\n\ndef is_snake_case(input_string: Any, separator: str = '_') -> bool:\n    \"\"\"\n    Checks if a string is formatted as \"snake case\".\n\n    A string is considered snake case when:\n\n    - it's composed only by lowercase/uppercase letters and digits\n    - it contains at least one underscore (or provided separator)\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_snake_case('foo_bar_baz') # returns true\n    >>> is_snake_case('foo') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :param separator: String to use as separator.\n    :type separator: str\n    :return: True for a snake case string, false otherwise.\n    \"\"\"\n    if is_full_string(input_string):\n        re_map = {\n            '_': SNAKE_CASE_TEST_RE,\n            '-': SNAKE_CASE_TEST_DASH_RE\n        }\n        re_template = r'([a-z]+\\d*{sign}[a-z\\d{sign}]*|{sign}+[a-z\\d]+[a-z\\d{sign}]*)'\n        r = re_map.get(\n            separator,\n            re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE)\n        )\n\n        return r.match(input_string) is not None\n\n    return False\n\n\ndef is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    return False\n\n\ndef is_uuid(input_string: Any, allow_hex: bool = False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    # string casting is used to allow UUID itself as input data type\n    s = str(input_string)\n\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n\n    return UUID_RE.match(s) is not None\n\n\ndef is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n\n    # checks that each entry in the ip is in the valid range (0 to 255)\n    for token in input_string.split('.'):\n        if not (0 <= int(token) <= 255):\n            return False\n\n    return True\n\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None\n\n\ndef is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    return is_ip_v6(input_string) or is_ip_v4(input_string)\n\n\ndef is_palindrome(input_string: Any, ignore_spaces: bool = False, ignore_case: bool = False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),\\\n    False otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    if ignore_spaces:\n        input_string = SPACES_RE.sub('', input_string)\n\n    string_len = len(input_string)\n\n    # Traverse the string one char at step, and for each step compares the\n    # \"head_char\" (the one on the left of the string) to the \"tail_char\" (the one on the right).\n    # In this way we avoid to manipulate the whole string in advance if not necessary and provide a faster\n    # algorithm which can scale very well for long strings.\n    for index in range(string_len):\n        head_char = input_string[index]\n        tail_char = input_string[string_len - index - 1]\n\n        if ignore_case:\n            head_char = head_char.lower()\n            tail_char = tail_char.lower()\n\n        if head_char != tail_char:\n            return False\n\n    return True\n\n\ndef is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))\n\n\ndef is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)\n\n\ndef is_slug(input_string: Any, separator: str = '-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n\n    rex = r'^([a-z\\d]+' + re.escape(separator) + r'*?)*[a-z\\d]$'\n\n    return re.match(rex, input_string) is not None\n\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return HTML_RE.search(input_string) is not None\n\n\ndef words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n\n    return len(WORDS_COUNT_RE.findall(input_string))\n\n\ndef is_isbn_10(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_10()\n\n\ndef is_isbn_13(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13()\n\n\ndef is_isbn(input_string: str, normalize: bool = True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()\n"
  },
  "GT_src_dict": {
    "string_utils/validation.py": {
      "is_full_string": {
        "code": "def is_full_string(input_string: Any) -> bool:\n    \"\"\"Checks if the given input is a non-empty string, meaning it must contain at least one character that is not a whitespace. This function leverages the `is_string` utility to ensure the input is indeed a string, along with applying a string method to remove leading and trailing spaces for the emptiness check.\n\nParameters:\n- input_string (Any): The input to be evaluated, which is expected to be a string.\n\nReturns:\n- bool: Returns True if the input is a string containing non-whitespace characters; otherwise, returns False.\n\nDependencies:\n- `is_string`: This function is used to verify if the input is a string.\"\"\"\n    \"\\n    Check if a string is not empty (it must contains at least one non space character).\\n\\n    *Examples:*\\n\\n    >>> is_full_string(None) # returns false\\n    >>> is_full_string('') # returns false\\n    >>> is_full_string(' ') # returns false\\n    >>> is_full_string('hello') # returns true\\n\\n    :param input_string: String to check.\\n    :type input_string: str\\n    :return: True if not empty, false otherwise.\\n    \"\n    return is_string(input_string) and input_string.strip() != ''",
        "docstring": "Checks if the given input is a non-empty string, meaning it must contain at least one character that is not a whitespace. This function leverages the `is_string` utility to ensure the input is indeed a string, along with applying a string method to remove leading and trailing spaces for the emptiness check.\n\nParameters:\n- input_string (Any): The input to be evaluated, which is expected to be a string.\n\nReturns:\n- bool: Returns True if the input is a string containing non-whitespace characters; otherwise, returns False.\n\nDependencies:\n- `is_string`: This function is used to verify if the input is a string.",
        "signature": "def is_full_string(input_string: Any) -> bool:",
        "type": "Function",
        "class_signature": null
      },
      "is_snake_case": {
        "code": "def is_snake_case(input_string: Any, separator: str='_') -> bool:\n    \"\"\"Checks if a given string is formatted as \"snake case\". A string is considered snake case if it consists solely of lowercase and uppercase letters and digits, includes at least one underscore (or a specified separator), and does not start with a number.\n\n:param input_string: The string to evaluate.\n:type input_string: str\n:param separator: The character used as a separator (default is '_').\n:type separator: str\n:return: True if the string follows snake case conventions, false otherwise.\n\nThe function relies on regex patterns defined by the constants `SNAKE_CASE_TEST_RE` and `SNAKE_CASE_TEST_DASH_RE`, which are used to match the structure of the input string based on the specified separator. These regex patterns must be imported from the module where they are defined.\"\"\"\n    '\\n    Checks if a string is formatted as \"snake case\".\\n\\n    A string is considered snake case when:\\n\\n    - it\\'s composed only by lowercase/uppercase letters and digits\\n    - it contains at least one underscore (or provided separator)\\n    - it does not start with a number\\n\\n    *Examples:*\\n\\n    >>> is_snake_case(\\'foo_bar_baz\\') # returns true\\n    >>> is_snake_case(\\'foo\\') # returns false\\n\\n    :param input_string: String to test.\\n    :type input_string: str\\n    :param separator: String to use as separator.\\n    :type separator: str\\n    :return: True for a snake case string, false otherwise.\\n    '\n    if is_full_string(input_string):\n        re_map = {'_': SNAKE_CASE_TEST_RE, '-': SNAKE_CASE_TEST_DASH_RE}\n        re_template = '([a-z]+\\\\d*{sign}[a-z\\\\d{sign}]*|{sign}+[a-z\\\\d]+[a-z\\\\d{sign}]*)'\n        r = re_map.get(separator, re.compile(re_template.format(sign=re.escape(separator)), re.IGNORECASE))\n        return r.match(input_string) is not None\n    return False",
        "docstring": "Checks if a given string is formatted as \"snake case\". A string is considered snake case if it consists solely of lowercase and uppercase letters and digits, includes at least one underscore (or a specified separator), and does not start with a number.\n\n:param input_string: The string to evaluate.\n:type input_string: str\n:param separator: The character used as a separator (default is '_').\n:type separator: str\n:return: True if the string follows snake case conventions, false otherwise.\n\nThe function relies on regex patterns defined by the constants `SNAKE_CASE_TEST_RE` and `SNAKE_CASE_TEST_DASH_RE`, which are used to match the structure of the input string based on the specified separator. These regex patterns must be imported from the module where they are defined.",
        "signature": "def is_snake_case(input_string: Any, separator: str='_') -> bool:",
        "type": "Function",
        "class_signature": null
      }
    }
  },
  "dependency_dict": {
    "string_utils/validation.py:is_snake_case": {},
    "string_utils/validation.py:is_full_string": {
      "string_utils/validation.py": {
        "is_string": {
          "code": "def is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)",
          "docstring": "Checks if an object is a string.\n\n*Example:*\n\n>>> is_string('foo') # returns true\n>>> is_string(b'foo') # returns false\n\n:param obj: Object to test.\n:return: True if string, false otherwise.",
          "signature": "def is_string(obj: Any) -> bool:",
          "type": "Function",
          "class_signature": null
        }
      }
    }
  },
  "PRD": "# PROJECT NAME: python_string_utils-test_is_snake_case\n\n# FOLDER STRUCTURE:\n```\n..\n\u2514\u2500\u2500 string_utils/\n    \u2514\u2500\u2500 validation.py\n        \u251c\u2500\u2500 is_full_string\n        \u2514\u2500\u2500 is_snake_case\n```\n\n# IMPLEMENTATION REQUIREMENTS:\n## MODULE DESCRIPTION:\nThis module is designed to validate whether given strings adhere to the snake_case naming convention, ensuring compliance with specific formatting rules for identifiers. It provides functionality to verify strings against snake_case criteria, such as appropriate use of underscores, lowercase letters, and the absence of invalid characters or whitespace, while also allowing customizable separators for alternative naming conventions. By standardizing checks for naming consistency, the module simplifies validation processes for developers, reduces errors in naming, and ensures adherence to coding style guidelines within a codebase or application.\n\n## FILE 1: string_utils/validation.py\n\n- FUNCTION NAME: is_snake_case\n  - SIGNATURE: def is_snake_case(input_string: Any, separator: str='_') -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if a given string is formatted as \"snake case\". A string is considered snake case if it consists solely of lowercase and uppercase letters and digits, includes at least one underscore (or a specified separator), and does not start with a number.\n\n:param input_string: The string to evaluate.\n:type input_string: str\n:param separator: The character used as a separator (default is '_').\n:type separator: str\n:return: True if the string follows snake case conventions, false otherwise.\n\nThe function relies on regex patterns defined by the constants `SNAKE_CASE_TEST_RE` and `SNAKE_CASE_TEST_DASH_RE`, which are used to match the structure of the input string based on the specified separator. These regex patterns must be imported from the module where they are defined.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - string_utils/validation.py:is_full_string\n\n- FUNCTION NAME: is_full_string\n  - SIGNATURE: def is_full_string(input_string: Any) -> bool:\n  - DOCSTRING: \n```python\n\"\"\"\nChecks if the given input is a non-empty string, meaning it must contain at least one character that is not a whitespace. This function leverages the `is_string` utility to ensure the input is indeed a string, along with applying a string method to remove leading and trailing spaces for the emptiness check.\n\nParameters:\n- input_string (Any): The input to be evaluated, which is expected to be a string.\n\nReturns:\n- bool: Returns True if the input is a string containing non-whitespace characters; otherwise, returns False.\n\nDependencies:\n- `is_string`: This function is used to verify if the input is a string.\n\"\"\"\n```\n  - DEPENDENCIES:\n    - string_utils/validation.py:is_snake_case\n    - string_utils/validation.py:is_string\n\n# TASK DESCRIPTION:\nIn this project, you need to implement the functions and methods listed above. The functions have been removed from the code but their docstrings remain.\nYour task is to:\n1. Read and understand the docstrings of each function/method\n2. Understand the dependencies and how they interact with the target functions\n3. Implement the functions/methods according to their docstrings and signatures\n4. Ensure your implementations work correctly with the rest of the codebase\n",
  "file_code": {
    "string_utils/validation.py": "__all__ = ['is_string', 'is_full_string', 'is_number', 'is_integer', 'is_decimal', 'is_url', 'is_email', 'is_credit_card', 'is_camel_case', 'is_snake_case', 'is_json', 'is_uuid', 'is_ip_v4', 'is_ip_v6', 'is_ip', 'is_isbn_10', 'is_isbn_13', 'is_isbn', 'is_palindrome', 'is_pangram', 'is_isogram', 'is_slug', 'contains_html', 'words_count']\nimport json\nimport string\nfrom typing import Any, Optional, List\nfrom ._regex import *\nfrom .errors import InvalidInputError\n\nclass __ISBNChecker:\n\n    def __init__(self, input_string: str, normalize: bool=True):\n        if not is_string(input_string):\n            raise InvalidInputError(input_string)\n        self.input_string = input_string.replace('-', '') if normalize else input_string\n\n    def is_isbn_13(self) -> bool:\n        if len(self.input_string) == 13:\n            product = 0\n            try:\n                for index, digit in enumerate(self.input_string):\n                    weight = 1 if index % 2 == 0 else 3\n                    product += int(digit) * weight\n                return product % 10 == 0\n            except ValueError:\n                pass\n        return False\n\n    def is_isbn_10(self) -> bool:\n        if len(self.input_string) == 10:\n            product = 0\n            try:\n                for index, digit in enumerate(self.input_string):\n                    product += int(digit) * (index + 1)\n                return product % 11 == 0\n            except ValueError:\n                pass\n        return False\n\ndef is_string(obj: Any) -> bool:\n    \"\"\"\n    Checks if an object is a string.\n\n    *Example:*\n\n    >>> is_string('foo') # returns true\n    >>> is_string(b'foo') # returns false\n\n    :param obj: Object to test.\n    :return: True if string, false otherwise.\n    \"\"\"\n    return isinstance(obj, str)\n\ndef is_number(input_string: str) -> bool:\n    \"\"\"\n    Checks if a string is a valid number.\n\n    The number can be a signed (eg: +1, -2, -3.3) or unsigned (eg: 1, 2, 3.3) integer or double\n    or use the \"scientific notation\" (eg: 1e5).\n\n    *Examples:*\n\n    >>> is_number('42') # returns true\n    >>> is_number('19.99') # returns true\n    >>> is_number('-9.12') # returns true\n    >>> is_number('1e3') # returns true\n    >>> is_number('1 2 3') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if the string represents a number, false otherwise\n    \"\"\"\n    if not isinstance(input_string, str):\n        raise InvalidInputError(input_string)\n    return NUMBER_RE.match(input_string) is not None\n\ndef is_integer(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents an integer or not.\n\n    An integer may be signed or unsigned or use a \"scientific notation\".\n\n    *Examples:*\n\n    >>> is_integer('42') # returns true\n    >>> is_integer('42.0') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' not in input_string\n\ndef is_decimal(input_string: str) -> bool:\n    \"\"\"\n    Checks whether the given string represents a decimal or not.\n\n    A decimal may be signed or unsigned or use a \"scientific notation\".\n\n    >>> is_decimal('42.0') # returns true\n    >>> is_decimal('42') # returns false\n\n    :param input_string: String to check\n    :type input_string: str\n    :return: True if integer, false otherwise\n    \"\"\"\n    return is_number(input_string) and '.' in input_string\n\ndef is_url(input_string: Any, allowed_schemes: Optional[List[str]]=None) -> bool:\n    \"\"\"\n    Check if a string is a valid url.\n\n    *Examples:*\n\n    >>> is_url('http://www.mysite.com') # returns true\n    >>> is_url('https://mysite.com') # returns true\n    >>> is_url('.mysite.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allowed_schemes: List of valid schemes ('http', 'https', 'ftp'...). Default to None (any scheme is valid).\n    :type allowed_schemes: Optional[List[str]]\n    :return: True if url, false otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    valid = URL_RE.match(input_string) is not None\n    if allowed_schemes:\n        return valid and any([input_string.startswith(s) for s in allowed_schemes])\n    return valid\n\ndef is_email(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid email.\n\n    Reference: https://tools.ietf.org/html/rfc3696#section-3\n\n    *Examples:*\n\n    >>> is_email('my.email@the-provider.com') # returns true\n    >>> is_email('@gmail.com') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if email, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or len(input_string) > 320 or input_string.startswith('.'):\n        return False\n    try:\n        head, tail = input_string.split('@')\n        if len(head) > 64 or len(tail) > 255 or head.endswith('.') or ('..' in head):\n            return False\n        head = head.replace('\\\\ ', '')\n        if head.startswith('\"') and head.endswith('\"'):\n            head = head.replace(' ', '')[1:-1]\n        return EMAIL_RE.match(head + '@' + tail) is not None\n    except ValueError:\n        if ESCAPED_AT_SIGN.search(input_string) is not None:\n            return is_email(ESCAPED_AT_SIGN.sub('a', input_string))\n        return False\n\ndef is_credit_card(input_string: Any, card_type: str=None) -> bool:\n    \"\"\"\n    Checks if a string is a valid credit card number.\n    If card type is provided then it checks against that specific type only,\n    otherwise any known credit card number will be accepted.\n\n    Supported card types are the following:\n\n    - VISA\n    - MASTERCARD\n    - AMERICAN_EXPRESS\n    - DINERS_CLUB\n    - DISCOVER\n    - JCB\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param card_type: Card type. Default to None (any card).\n    :type card_type: str\n\n    :return: True if credit card, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    if card_type:\n        if card_type not in CREDIT_CARDS:\n            raise KeyError('Invalid card type \"{}\". Valid types are: {}'.format(card_type, ', '.join(CREDIT_CARDS.keys())))\n        return CREDIT_CARDS[card_type].match(input_string) is not None\n    for c in CREDIT_CARDS:\n        if CREDIT_CARDS[c].match(input_string) is not None:\n            return True\n    return False\n\ndef is_camel_case(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is formatted as camel case.\n\n    A string is considered camel case when:\n\n    - it's composed only by letters ([a-zA-Z]) and optionally numbers ([0-9])\n    - it contains both lowercase and uppercase letters\n    - it does not start with a number\n\n    *Examples:*\n\n    >>> is_camel_case('MyString') # returns true\n    >>> is_camel_case('mystring') # returns false\n\n    :param input_string: String to test.\n    :type input_string: str\n    :return: True for a camel case string, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and CAMEL_CASE_TEST_RE.match(input_string) is not None\n\ndef is_json(input_string: Any) -> bool:\n    \"\"\"\n    Check if a string is a valid json.\n\n    *Examples:*\n\n    >>> is_json('{\"name\": \"Peter\"}') # returns true\n    >>> is_json('[1, 2, 3]') # returns true\n    >>> is_json('{nope}') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if json, false otherwise\n    \"\"\"\n    if is_full_string(input_string) and JSON_WRAPPER_RE.match(input_string) is not None:\n        try:\n            return isinstance(json.loads(input_string), (dict, list))\n        except (TypeError, ValueError, OverflowError):\n            pass\n    return False\n\ndef is_uuid(input_string: Any, allow_hex: bool=False) -> bool:\n    \"\"\"\n    Check if a string is a valid UUID.\n\n    *Example:*\n\n    >>> is_uuid('6f8aa2f9-686c-4ac3-8766-5712354a04cf') # returns true\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf') # returns false\n    >>> is_uuid('6f8aa2f9686c4ac387665712354a04cf', allow_hex=True) # returns true\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param allow_hex: True to allow UUID hex representation as valid, false otherwise (default)\n    :type allow_hex: bool\n    :return: True if UUID, false otherwise\n    \"\"\"\n    s = str(input_string)\n    if allow_hex:\n        return UUID_HEX_OK_RE.match(s) is not None\n    return UUID_RE.match(s) is not None\n\ndef is_ip_v4(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v4.\n\n    *Examples:*\n\n    >>> is_ip_v4('255.200.100.75') # returns true\n    >>> is_ip_v4('nope') # returns false (not an ip)\n    >>> is_ip_v4('255.200.100.999') # returns false (999 is out of range)\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip v4, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string) or SHALLOW_IP_V4_RE.match(input_string) is None:\n        return False\n    for token in input_string.split('.'):\n        if not 0 <= int(token) <= 255:\n            return False\n    return True\n\ndef is_ip_v6(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip v6.\n\n    *Examples:*\n\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip_v6('2001:db8:85a3:0000:0000:8a2e:370:?') # returns false (invalid \"?\")\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if a v6 ip, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and IP_V6_RE.match(input_string) is not None\n\ndef is_ip(input_string: Any) -> bool:\n    \"\"\"\n    Checks if a string is a valid ip (either v4 or v6).\n\n    *Examples:*\n\n    >>> is_ip('255.200.100.75') # returns true\n    >>> is_ip('2001:db8:85a3:0000:0000:8a2e:370:7334') # returns true\n    >>> is_ip('1.2.3') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if an ip, false otherwise.\n    \"\"\"\n    return is_ip_v6(input_string) or is_ip_v4(input_string)\n\ndef is_palindrome(input_string: Any, ignore_spaces: bool=False, ignore_case: bool=False) -> bool:\n    \"\"\"\n    Checks if the string is a palindrome (https://en.wikipedia.org/wiki/Palindrome).\n\n    *Examples:*\n\n    >>> is_palindrome('LOL') # returns true\n    >>> is_palindrome('Lol') # returns false\n    >>> is_palindrome('Lol', ignore_case=True) # returns true\n    >>> is_palindrome('ROTFL') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param ignore_spaces: False if white spaces matter (default), true otherwise.\n    :type ignore_spaces: bool\n    :param ignore_case: False if char case matters (default), true otherwise.\n    :type ignore_case: bool\n    :return: True if the string is a palindrome (like \"otto\", or \"i topi non avevano nipoti\" if strict=False),    False otherwise\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    if ignore_spaces:\n        input_string = SPACES_RE.sub('', input_string)\n    string_len = len(input_string)\n    for index in range(string_len):\n        head_char = input_string[index]\n        tail_char = input_string[string_len - index - 1]\n        if ignore_case:\n            head_char = head_char.lower()\n            tail_char = tail_char.lower()\n        if head_char != tail_char:\n            return False\n    return True\n\ndef is_pangram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is a pangram (https://en.wikipedia.org/wiki/Pangram).\n\n    *Examples:*\n\n    >>> is_pangram('The quick brown fox jumps over the lazy dog') # returns true\n    >>> is_pangram('hello world') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if the string is a pangram, False otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    return set(SPACES_RE.sub('', input_string)).issuperset(set(string.ascii_lowercase))\n\ndef is_isogram(input_string: Any) -> bool:\n    \"\"\"\n    Checks if the string is an isogram (https://en.wikipedia.org/wiki/Isogram).\n\n    *Examples:*\n\n    >>> is_isogram('dermatoglyphics') # returns true\n    >>> is_isogram('hello') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: True if isogram, false otherwise.\n    \"\"\"\n    return is_full_string(input_string) and len(set(input_string)) == len(input_string)\n\ndef is_slug(input_string: Any, separator: str='-') -> bool:\n    \"\"\"\n    Checks if a given string is a slug (as created by `slugify()`).\n\n    *Examples:*\n\n    >>> is_slug('my-blog-post-title') # returns true\n    >>> is_slug('My blog post title') # returns false\n\n    :param input_string: String to check.\n    :type input_string: str\n    :param separator: Join sign used by the slug.\n    :type separator: str\n    :return: True if slug, false otherwise.\n    \"\"\"\n    if not is_full_string(input_string):\n        return False\n    rex = '^([a-z\\\\d]+' + re.escape(separator) + '*?)*[a-z\\\\d]$'\n    return re.match(rex, input_string) is not None\n\ndef contains_html(input_string: str) -> bool:\n    \"\"\"\n    Checks if the given string contains HTML/XML tags.\n\n    By design, this function matches ANY type of tag, so don't expect to use it\n    as an HTML validator, its goal is to detect \"malicious\" or undesired tags in the text.\n\n    *Examples:*\n\n    >>> contains_html('my string is <strong>bold</strong>') # returns true\n    >>> contains_html('my string is not bold') # returns false\n\n    :param input_string: Text to check\n    :type input_string: str\n    :return: True if string contains html, false otherwise.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n    return HTML_RE.search(input_string) is not None\n\ndef words_count(input_string: str) -> int:\n    \"\"\"\n    Returns the number of words contained into the given string.\n\n    This method is smart, it does consider only sequence of one or more letter and/or numbers\n    as \"words\", so a string like this: \"! @ # % ... []\" will return zero!\n    Moreover it is aware of punctuation, so the count for a string like \"one,two,three.stop\"\n    will be 4 not 1 (even if there are no spaces in the string).\n\n    *Examples:*\n\n    >>> words_count('hello world') # returns 2\n    >>> words_count('one,two,three.stop') # returns 4\n\n    :param input_string: String to check.\n    :type input_string: str\n    :return: Number of words.\n    \"\"\"\n    if not is_string(input_string):\n        raise InvalidInputError(input_string)\n    return len(WORDS_COUNT_RE.findall(input_string))\n\ndef is_isbn_10(input_string: str, normalize: bool=True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 10 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_10('1506715214') # returns true\n    >>> is_isbn_10('150-6715214') # returns true\n    >>> is_isbn_10('150-6715214', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 10, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_10()\n\ndef is_isbn_13(input_string: str, normalize: bool=True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN 13 (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn_13('9780312498580') # returns true\n    >>> is_isbn_13('978-0312498580') # returns true\n    >>> is_isbn_13('978-0312498580', normalize=False) # returns false\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN 13, false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13()\n\ndef is_isbn(input_string: str, normalize: bool=True) -> bool:\n    \"\"\"\n    Checks if the given string represents a valid ISBN (International Standard Book Number).\n    By default hyphens in the string are ignored, so digits can be separated in different ways, by calling this\n    function with `normalize=False` only digit-only strings will pass the validation.\n\n    *Examples:*\n\n    >>> is_isbn('9780312498580') # returns true\n    >>> is_isbn('1506715214') # returns true\n\n    :param input_string: String to check.\n    :param normalize: True to ignore hyphens (\"-\") in the string (default), false otherwise.\n    :return: True if valid ISBN (10 or 13), false otherwise.\n    \"\"\"\n    checker = __ISBNChecker(input_string, normalize)\n    return checker.is_isbn_13() or checker.is_isbn_10()"
  },
  "call_tree": {
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_return_false_for_non_string_objects": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_should_accept_valid_snake_strings": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_should_consider_custom_separator": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_string_cannot_be_all_uppercase": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_string_cannot_be_blank": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_string_cannot_be_camel_case": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_string_cannot_be_lowercase_letters_only": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_string_cannot_contain_bad_signs": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    },
    "tests/test_is_snake_case.py:IsSnakeCaseTestCase:test_string_cannot_contain_only_underscores": {
      "string_utils/validation.py:is_snake_case": {
        "string_utils/validation.py:is_full_string": {
          "string_utils/validation.py:is_string": {}
        }
      }
    }
  }
}